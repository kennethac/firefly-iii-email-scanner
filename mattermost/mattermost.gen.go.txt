// Package mattermost provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package mattermost

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ChannelBookmarkType.
const (
	ChannelBookmarkTypeFile ChannelBookmarkType = "file"
	ChannelBookmarkTypeLink ChannelBookmarkType = "link"
)

// Defines values for ChannelBookmarkWithFileInfoType.
const (
	ChannelBookmarkWithFileInfoTypeFile ChannelBookmarkWithFileInfoType = "file"
	ChannelBookmarkWithFileInfoTypeLink ChannelBookmarkWithFileInfoType = "link"
)

// Defines values for ChecklistItemState.
const (
	ChecklistItemStateClosed     ChecklistItemState = "closed"
	ChecklistItemStateEmpty      ChecklistItemState = ""
	ChecklistItemStateInProgress ChecklistItemState = "in_progress"
)

// Defines values for PluginStatusState.
const (
	FailedToStart       PluginStatusState = FailedToStart
	FailedToStayRunning PluginStatusState = FailedToStayRunning
	NotRunning          PluginStatusState = NotRunning
	Running             PluginStatusState = Running
	Starting            PluginStatusState = Starting
	Stopping            PluginStatusState = Stopping
)

// Defines values for PostMetadataEmbedsType.
const (
	PostMetadataEmbedsTypeImage             PostMetadataEmbedsType = "image"
	PostMetadataEmbedsTypeLink              PostMetadataEmbedsType = "link"
	PostMetadataEmbedsTypeMessageAttachment PostMetadataEmbedsType = "message_attachment"
	PostMetadataEmbedsTypeOpengraph         PostMetadataEmbedsType = "opengraph"
)

// Defines values for SidebarCategoryType.
const (
	SidebarCategoryTypeChannels       SidebarCategoryType = "channels"
	SidebarCategoryTypeCustom         SidebarCategoryType = "custom"
	SidebarCategoryTypeDirectMessages SidebarCategoryType = "direct_messages"
	SidebarCategoryTypeFavorites      SidebarCategoryType = "favorites"
)

// Defines values for SidebarCategoryWithChannelsType.
const (
	SidebarCategoryWithChannelsTypeChannels       SidebarCategoryWithChannelsType = "channels"
	SidebarCategoryWithChannelsTypeCustom         SidebarCategoryWithChannelsType = "custom"
	SidebarCategoryWithChannelsTypeDirectMessages SidebarCategoryWithChannelsType = "direct_messages"
	SidebarCategoryWithChannelsTypeFavorites      SidebarCategoryWithChannelsType = "favorites"
)

// Defines values for UploadSessionType.
const (
	Attachment UploadSessionType = "attachment"
	Import     UploadSessionType = "import"
)

// Defines values for CreateChannelBookmarkJSONBodyType.
const (
	CreateChannelBookmarkJSONBodyTypeFile CreateChannelBookmarkJSONBodyType = "file"
	CreateChannelBookmarkJSONBodyTypeLink CreateChannelBookmarkJSONBodyType = "link"
)

// Defines values for UpdateChannelBookmarkJSONBodyType.
const (
	File UpdateChannelBookmarkJSONBodyType = "file"
	Link UpdateChannelBookmarkJSONBodyType = "link"
)

// Defines values for GetPlaybooksParamsSort.
const (
	Stages GetPlaybooksParamsSort = "stages"
	Steps  GetPlaybooksParamsSort = "steps"
	Title  GetPlaybooksParamsSort = "title"
)

// Defines values for GetPlaybooksParamsDirection.
const (
	GetPlaybooksParamsDirectionAsc  GetPlaybooksParamsDirection = "asc"
	GetPlaybooksParamsDirectionDesc GetPlaybooksParamsDirection = "desc"
)

// Defines values for ListPlaybookRunsParamsSort.
const (
	ListPlaybookRunsParamsSortCreateAt    ListPlaybookRunsParamsSort = "create_at"
	ListPlaybookRunsParamsSortEndAt       ListPlaybookRunsParamsSort = "end_at"
	ListPlaybookRunsParamsSortId          ListPlaybookRunsParamsSort = "id"
	ListPlaybookRunsParamsSortIsActive    ListPlaybookRunsParamsSort = "is_active"
	ListPlaybookRunsParamsSortName        ListPlaybookRunsParamsSort = "name"
	ListPlaybookRunsParamsSortOwnerUserId ListPlaybookRunsParamsSort = "owner_user_id"
	ListPlaybookRunsParamsSortTeamId      ListPlaybookRunsParamsSort = "team_id"
)

// Defines values for ListPlaybookRunsParamsDirection.
const (
	ListPlaybookRunsParamsDirectionAsc  ListPlaybookRunsParamsDirection = "asc"
	ListPlaybookRunsParamsDirectionDesc ListPlaybookRunsParamsDirection = "desc"
)

// Defines values for ListPlaybookRunsParamsStatuses.
const (
	ListPlaybookRunsParamsStatusesFinished   ListPlaybookRunsParamsStatuses = "Finished"
	ListPlaybookRunsParamsStatusesInProgress ListPlaybookRunsParamsStatuses = "InProgress"
)

// Defines values for GetChannelsParamsSort.
const (
	GetChannelsParamsSortCreateAt    GetChannelsParamsSort = "create_at"
	GetChannelsParamsSortEndAt       GetChannelsParamsSort = "end_at"
	GetChannelsParamsSortId          GetChannelsParamsSort = "id"
	GetChannelsParamsSortName        GetChannelsParamsSort = "name"
	GetChannelsParamsSortOwnerUserId GetChannelsParamsSort = "owner_user_id"
	GetChannelsParamsSortTeamId      GetChannelsParamsSort = "team_id"
)

// Defines values for GetChannelsParamsDirection.
const (
	Asc  GetChannelsParamsDirection = "asc"
	Desc GetChannelsParamsDirection = "desc"
)

// Defines values for GetChannelsParamsStatus.
const (
	GetChannelsParamsStatusAll        GetChannelsParamsStatus = "all"
	GetChannelsParamsStatusFinished   GetChannelsParamsStatus = "Finished"
	GetChannelsParamsStatusInProgress GetChannelsParamsStatus = "InProgress"
)

// Defines values for AddChecklistItemJSONBodyState.
const (
	AddChecklistItemJSONBodyStateClosed     AddChecklistItemJSONBodyState = "closed"
	AddChecklistItemJSONBodyStateEmpty      AddChecklistItemJSONBodyState = ""
	AddChecklistItemJSONBodyStateInProgress AddChecklistItemJSONBodyState = "in_progress"
)

// Defines values for ItemSetStateJSONBodyNewState.
const (
	Closed     ItemSetStateJSONBodyNewState = "closed"
	Empty      ItemSetStateJSONBodyNewState = ""
	InProgress ItemSetStateJSONBodyNewState = "in_progress"
)

// AddOn defines model for AddOn.
type AddOn struct {
	DisplayName  *string `json:"display_name,omitempty"`
	Id           *string `json:"id,omitempty"`
	Name         *string `json:"name,omitempty"`
	PricePerSeat *string `json:"price_per_seat,omitempty"`
}

// Address defines model for Address.
type Address struct {
	City       *string `json:"city,omitempty"`
	Country    *string `json:"country,omitempty"`
	Line1      *string `json:"line1,omitempty"`
	Line2      *string `json:"line2,omitempty"`
	PostalCode *string `json:"postal_code,omitempty"`
	State      *string `json:"state,omitempty"`
}

// AllowedIPRange defines model for AllowedIPRange.
type AllowedIPRange struct {
	// CIDRBlock An IP address range in CIDR notation
	CIDRBlock *string `json:"CIDRBlock,omitempty"`

	// Description A description for the CIDRBlock
	Description *string `json:"Description,omitempty"`
}

// AppError defines model for AppError.
type AppError struct {
	Id         *string `json:"id,omitempty"`
	Message    *string `json:"message,omitempty"`
	RequestId  *string `json:"request_id,omitempty"`
	StatusCode *int    `json:"status_code,omitempty"`
}

// Audit defines model for Audit.
type Audit struct {
	Action *string `json:"action,omitempty"`

	// CreateAt The time in milliseconds a audit was created
	CreateAt  *int    `json:"create_at,omitempty"`
	ExtraInfo *string `json:"extra_info,omitempty"`
	Id        *string `json:"id,omitempty"`
	IpAddress *string `json:"ip_address,omitempty"`
	SessionId *string `json:"session_id,omitempty"`
	UserId    *string `json:"user_id,omitempty"`
}

// AutocompleteSuggestion defines model for AutocompleteSuggestion.
type AutocompleteSuggestion struct {
	// Complete Completed suggestion
	Complete *string `json:"Complete,omitempty"`

	// Description Description of the suggested command
	Description *string `json:"Description,omitempty"`

	// Hint Hint about suggested input
	Hint *string `json:"Hint,omitempty"`

	// IconData Base64 encoded svg image
	IconData *string `json:"IconData,omitempty"`

	// Suggestion Predicted text user might want to input
	Suggestion *string `json:"Suggestion,omitempty"`
}

// BoardsLimits defines model for BoardsLimits.
type BoardsLimits struct {
	Cards *int `json:"cards"`
	Views *int `json:"views"`
}

// Bot A bot account
type Bot struct {
	// CreateAt The time in milliseconds a bot was created
	CreateAt *int `json:"create_at,omitempty"`

	// DeleteAt The time in milliseconds a bot was deleted
	DeleteAt    *int    `json:"delete_at,omitempty"`
	Description *string `json:"description,omitempty"`
	DisplayName *string `json:"display_name,omitempty"`

	// OwnerId The user id of the user that currently owns this bot.
	OwnerId *string `json:"owner_id,omitempty"`

	// UpdateAt The time in milliseconds a bot was last updated
	UpdateAt *int `json:"update_at,omitempty"`

	// UserId The user id of the associated user entry.
	UserId   *string `json:"user_id,omitempty"`
	Username *string `json:"username,omitempty"`
}

// Channel defines model for Channel.
type Channel struct {
	// CreateAt The time in milliseconds a channel was created
	CreateAt  *int    `json:"create_at,omitempty"`
	CreatorId *string `json:"creator_id,omitempty"`

	// DeleteAt The time in milliseconds a channel was deleted
	DeleteAt    *int    `json:"delete_at,omitempty"`
	DisplayName *string `json:"display_name,omitempty"`

	// ExtraUpdateAt Deprecated in Mattermost 5.0 release
	ExtraUpdateAt *int    `json:"extra_update_at,omitempty"`
	Header        *string `json:"header,omitempty"`
	Id            *string `json:"id,omitempty"`

	// LastPostAt The time in milliseconds of the last post of a channel
	LastPostAt    *int    `json:"last_post_at,omitempty"`
	Name          *string `json:"name,omitempty"`
	Purpose       *string `json:"purpose,omitempty"`
	TeamId        *string `json:"team_id,omitempty"`
	TotalMsgCount *int    `json:"total_msg_count,omitempty"`
	Type          *string `json:"type,omitempty"`

	// UpdateAt The time in milliseconds a channel was last updated
	UpdateAt *int `json:"update_at,omitempty"`
}

// ChannelBookmark defines model for ChannelBookmark.
type ChannelBookmark struct {
	ChannelId *string `json:"channel_id,omitempty"`

	// CreateAt The time in milliseconds a channel bookmark was created
	CreateAt *int `json:"create_at,omitempty"`

	// DeleteAt The time in milliseconds a channel bookmark was deleted
	DeleteAt    *int    `json:"delete_at,omitempty"`
	DisplayName *string `json:"display_name,omitempty"`
	Emoji       *string `json:"emoji,omitempty"`

	// FileId The ID of the file associated with the channel bookmark
	FileId *string `json:"file_id,omitempty"`
	Id     *string `json:"id,omitempty"`

	// ImageUrl The URL of the image associated with the channel bookmark
	ImageUrl *string `json:"image_url,omitempty"`

	// LinkUrl The URL associated with the channel bookmark
	LinkUrl *string `json:"link_url,omitempty"`

	// OriginalId The ID of the original channel bookmark
	OriginalId *string `json:"original_id,omitempty"`

	// OwnerId The ID of the user that the channel bookmark belongs to
	OwnerId *string `json:"owner_id,omitempty"`

	// ParentId The ID of the parent channel bookmark
	ParentId *string `json:"parent_id,omitempty"`

	// SortOrder The order of the channel bookmark
	SortOrder *int                 `json:"sort_order,omitempty"`
	Type      *ChannelBookmarkType `json:"type,omitempty"`

	// UpdateAt The time in milliseconds a channel bookmark was last updated
	UpdateAt *int `json:"update_at,omitempty"`
}

// ChannelBookmarkType defines model for ChannelBookmark.Type.
type ChannelBookmarkType string

// ChannelBookmarkWithFileInfo defines model for ChannelBookmarkWithFileInfo.
type ChannelBookmarkWithFileInfo struct {
	ChannelId *string `json:"channel_id,omitempty"`

	// CreateAt The time in milliseconds a channel bookmark was created
	CreateAt *int `json:"create_at,omitempty"`

	// DeleteAt The time in milliseconds a channel bookmark was deleted
	DeleteAt    *int      `json:"delete_at,omitempty"`
	DisplayName *string   `json:"display_name,omitempty"`
	Emoji       *string   `json:"emoji,omitempty"`
	File        *FileInfo `json:"file,omitempty"`

	// FileId The ID of the file associated with the channel bookmark
	FileId *string `json:"file_id,omitempty"`
	Id     *string `json:"id,omitempty"`

	// ImageUrl The URL of the image associated with the channel bookmark
	ImageUrl *string `json:"image_url,omitempty"`

	// LinkUrl The URL associated with the channel bookmark
	LinkUrl *string `json:"link_url,omitempty"`

	// OriginalId The ID of the original channel bookmark
	OriginalId *string `json:"original_id,omitempty"`

	// OwnerId The ID of the user that the channel bookmark belongs to
	OwnerId *string `json:"owner_id,omitempty"`

	// ParentId The ID of the parent channel bookmark
	ParentId *string `json:"parent_id,omitempty"`

	// SortOrder The order of the channel bookmark
	SortOrder *int                             `json:"sort_order,omitempty"`
	Type      *ChannelBookmarkWithFileInfoType `json:"type,omitempty"`

	// UpdateAt The time in milliseconds a channel bookmark was last updated
	UpdateAt *int `json:"update_at,omitempty"`
}

// ChannelBookmarkWithFileInfoType defines model for ChannelBookmarkWithFileInfo.Type.
type ChannelBookmarkWithFileInfoType string

// ChannelListWithTeamData defines model for ChannelListWithTeamData.
type ChannelListWithTeamData = []ChannelWithTeamData

// ChannelMember defines model for ChannelMember.
type ChannelMember struct {
	ChannelId *string `json:"channel_id,omitempty"`

	// LastUpdateAt The time in milliseconds the channel member was last updated
	LastUpdateAt *int `json:"last_update_at,omitempty"`

	// LastViewedAt The time in milliseconds the channel was last viewed by the user
	LastViewedAt *int                `json:"last_viewed_at,omitempty"`
	MentionCount *int                `json:"mention_count,omitempty"`
	MsgCount     *int                `json:"msg_count,omitempty"`
	NotifyProps  *ChannelNotifyProps `json:"notify_props,omitempty"`
	Roles        *string             `json:"roles,omitempty"`
	UserId       *string             `json:"user_id,omitempty"`
}

// ChannelMemberWithTeamData defines model for ChannelMemberWithTeamData.
type ChannelMemberWithTeamData struct {
	ChannelId *string `json:"channel_id,omitempty"`

	// LastUpdateAt The time in milliseconds the channel member was last updated
	LastUpdateAt *int `json:"last_update_at,omitempty"`

	// LastViewedAt The time in milliseconds the channel was last viewed by the user
	LastViewedAt *int                `json:"last_viewed_at,omitempty"`
	MentionCount *int                `json:"mention_count,omitempty"`
	MsgCount     *int                `json:"msg_count,omitempty"`
	NotifyProps  *ChannelNotifyProps `json:"notify_props,omitempty"`
	Roles        *string             `json:"roles,omitempty"`

	// TeamDisplayName The display name of the team to which this channel belongs.
	TeamDisplayName *string `json:"team_display_name,omitempty"`

	// TeamName The name of the team to which this channel belongs.
	TeamName *string `json:"team_name,omitempty"`

	// TeamUpdateAt The time at which the team to which this channel belongs was last updated.
	TeamUpdateAt *int    `json:"team_update_at,omitempty"`
	UserId       *string `json:"user_id,omitempty"`
}

// ChannelModeratedRole defines model for ChannelModeratedRole.
type ChannelModeratedRole struct {
	Enabled *bool `json:"enabled,omitempty"`
	Value   *bool `json:"value,omitempty"`
}

// ChannelModeratedRoles defines model for ChannelModeratedRoles.
type ChannelModeratedRoles struct {
	Guests  *ChannelModeratedRole `json:"guests,omitempty"`
	Members *ChannelModeratedRole `json:"members,omitempty"`
}

// ChannelModeratedRolesPatch defines model for ChannelModeratedRolesPatch.
type ChannelModeratedRolesPatch struct {
	Guests  *bool `json:"guests,omitempty"`
	Members *bool `json:"members,omitempty"`
}

// ChannelModeration defines model for ChannelModeration.
type ChannelModeration struct {
	Name  *string                `json:"name,omitempty"`
	Roles *ChannelModeratedRoles `json:"roles,omitempty"`
}

// ChannelModerationPatch defines model for ChannelModerationPatch.
type ChannelModerationPatch struct {
	Name  *string                     `json:"name,omitempty"`
	Roles *ChannelModeratedRolesPatch `json:"roles,omitempty"`
}

// ChannelNotifyProps defines model for ChannelNotifyProps.
type ChannelNotifyProps struct {
	// Desktop Set to "all" to receive desktop notifications for all activity, "mention" for mentions and direct messages only, "none" to disable, or "default" to use the global user notification setting.
	Desktop *string `json:"desktop,omitempty"`

	// Email Set to "true" to enable email notifications, "false" to disable, or "default" to use the global user notification setting.
	Email *string `json:"email,omitempty"`

	// MarkUnread Set to "all" to mark the channel unread for any new message, "mention" to mark unread for new mentions only. Defaults to "all".
	MarkUnread *string `json:"mark_unread,omitempty"`

	// Push Set to "all" to receive push notifications for all activity, "mention" for mentions and direct messages only, "none" to disable, or "default" to use the global user notification setting.
	Push *string `json:"push,omitempty"`
}

// ChannelStats defines model for ChannelStats.
type ChannelStats struct {
	ChannelId   *string `json:"channel_id,omitempty"`
	MemberCount *int    `json:"member_count,omitempty"`
}

// ChannelUnread defines model for ChannelUnread.
type ChannelUnread struct {
	ChannelId    *string `json:"channel_id,omitempty"`
	MentionCount *int    `json:"mention_count,omitempty"`
	MsgCount     *int    `json:"msg_count,omitempty"`
	TeamId       *string `json:"team_id,omitempty"`
}

// ChannelUnreadAt defines model for ChannelUnreadAt.
type ChannelUnreadAt struct {
	// ChannelId The ID of the channel the user has access to..
	ChannelId *string `json:"channel_id,omitempty"`

	// LastViewedAt time in milliseconds when the user last viewed the channel.
	LastViewedAt *int `json:"last_viewed_at,omitempty"`

	// MentionCount No. of mentions the user has within the unread posts of the channel.
	MentionCount *int `json:"mention_count,omitempty"`

	// MsgCount No. of messages the user has already read.
	MsgCount *int `json:"msg_count,omitempty"`

	// TeamId The ID of the team the channel belongs to.
	TeamId *string `json:"team_id,omitempty"`
}

// ChannelWithTeamData defines model for ChannelWithTeamData.
type ChannelWithTeamData struct {
	// CreateAt The time in milliseconds a channel was created
	CreateAt  *int    `json:"create_at,omitempty"`
	CreatorId *string `json:"creator_id,omitempty"`

	// DeleteAt The time in milliseconds a channel was deleted
	DeleteAt    *int    `json:"delete_at,omitempty"`
	DisplayName *string `json:"display_name,omitempty"`

	// ExtraUpdateAt Deprecated in Mattermost 5.0 release
	ExtraUpdateAt *int    `json:"extra_update_at,omitempty"`
	Header        *string `json:"header,omitempty"`
	Id            *string `json:"id,omitempty"`

	// LastPostAt The time in milliseconds of the last post of a channel
	LastPostAt *int    `json:"last_post_at,omitempty"`
	Name       *string `json:"name,omitempty"`

	// PolicyId The data retention policy to which this team has been assigned. If no such policy exists, or the caller does not have the `sysconsole_read_compliance_data_retention` permission, this field will be null.
	PolicyId *string `json:"policy_id,omitempty"`
	Purpose  *string `json:"purpose,omitempty"`

	// TeamDisplayName The display name of the team to which this channel belongs.
	TeamDisplayName *string `json:"team_display_name,omitempty"`
	TeamId          *string `json:"team_id,omitempty"`

	// TeamName The name of the team to which this channel belongs.
	TeamName *string `json:"team_name,omitempty"`

	// TeamUpdateAt The time at which the team to which this channel belongs was last updated.
	TeamUpdateAt  *int    `json:"team_update_at,omitempty"`
	TotalMsgCount *int    `json:"total_msg_count,omitempty"`
	Type          *string `json:"type,omitempty"`

	// UpdateAt The time in milliseconds a channel was last updated
	UpdateAt *int `json:"update_at,omitempty"`
}

// Checklist defines model for Checklist.
type Checklist struct {
	// Id A unique, 26 characters long, alphanumeric identifier for the checklist.
	Id *string `json:"id,omitempty"`

	// Items The list of tasks to do.
	Items *[]ChecklistItem `json:"items,omitempty"`

	// Title The title of the checklist.
	Title *string `json:"title,omitempty"`
}

// ChecklistItem defines model for ChecklistItem.
type ChecklistItem struct {
	// AssigneeId The identifier of the user that has been assigned to complete this item. If the item has no assignee, this is an empty string.
	AssigneeId *string `json:"assignee_id,omitempty"`

	// AssigneeModified The timestamp for the latest modification of the item's assignee, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the item never got an assignee.
	AssigneeModified *int `json:"assignee_modified,omitempty"`

	// Command The slash command associated with this item. If the item has no slash command associated, this is an empty string
	Command *string `json:"command,omitempty"`

	// CommandLastRun The timestamp for the latest execution of the item's command, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the command was never executed.
	CommandLastRun *int `json:"command_last_run,omitempty"`

	// Description A detailed description of the checklist item, formatted with Markdown.
	Description *string `json:"description,omitempty"`

	// Id A unique, 26 characters long, alphanumeric identifier for the checklist item.
	Id *string `json:"id,omitempty"`

	// State The state of the checklist item. An empty string means that the item is not done.
	State *ChecklistItemState `json:"state,omitempty"`

	// StateModified The timestamp for the latest modification of the item's state, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the item was never modified.
	StateModified *int `json:"state_modified,omitempty"`

	// Title The title of the checklist item.
	Title *string `json:"title,omitempty"`
}

// ChecklistItemState The state of the checklist item. An empty string means that the item is not done.
type ChecklistItemState string

// CloudCustomer defines model for CloudCustomer.
type CloudCustomer struct {
	BillingAddress   *Address       `json:"billing_address,omitempty"`
	CompanyAddress   *Address       `json:"company_address,omitempty"`
	ContactFirstName *string        `json:"contact_first_name,omitempty"`
	ContactLastName  *string        `json:"contact_last_name,omitempty"`
	CreateAt         *int           `json:"create_at,omitempty"`
	CreatorId        *string        `json:"creator_id,omitempty"`
	Email            *string        `json:"email,omitempty"`
	Id               *string        `json:"id,omitempty"`
	Name             *string        `json:"name,omitempty"`
	NumEmployees     *string        `json:"num_employees,omitempty"`
	PaymentMethod    *PaymentMethod `json:"payment_method,omitempty"`
}

// ClusterInfo defines model for ClusterInfo.
type ClusterInfo = []interface{}

// Command defines model for Command.
type Command struct {
	// AutoComplete Use auto complete for this command
	AutoComplete *bool `json:"auto_complete,omitempty"`

	// AutoCompleteDesc The description for this command shown when selecting the command
	AutoCompleteDesc *string `json:"auto_complete_desc,omitempty"`

	// AutoCompleteHint The hint for this command
	AutoCompleteHint *string `json:"auto_complete_hint,omitempty"`

	// CreateAt The time in milliseconds the command was created
	CreateAt *int `json:"create_at,omitempty"`

	// CreatorId The user id for the commands creator
	CreatorId *string `json:"creator_id,omitempty"`

	// DeleteAt The time in milliseconds the command was deleted, 0 if never deleted
	DeleteAt *int `json:"delete_at,omitempty"`

	// Description Description for this command
	Description *string `json:"description,omitempty"`

	// DisplayName Display name for the command
	DisplayName *string `json:"display_name,omitempty"`

	// IconUrl The url to find the icon for this users avatar
	IconUrl *string `json:"icon_url,omitempty"`

	// Id The ID of the slash command
	Id *string `json:"id,omitempty"`

	// Method Is the trigger done with HTTP Get ('G') or HTTP Post ('P')
	Method *string `json:"method,omitempty"`

	// TeamId The team id for which this command is configured
	TeamId *string `json:"team_id,omitempty"`

	// Token The token which is used to verify the source of the payload
	Token *string `json:"token,omitempty"`

	// Trigger The string that triggers this command
	Trigger *string `json:"trigger,omitempty"`

	// UpdateAt The time in milliseconds the command was last updated
	UpdateAt *int `json:"update_at,omitempty"`

	// Url The URL that is triggered
	Url *string `json:"url,omitempty"`

	// Username What is the username for the response post
	Username *string `json:"username,omitempty"`
}

// CommandResponse defines model for CommandResponse.
type CommandResponse struct {
	Attachments  *[]SlackAttachment `json:"Attachments,omitempty"`
	GotoLocation *string            `json:"GotoLocation,omitempty"`
	IconURL      *string            `json:"IconURL,omitempty"`

	// ResponseType The response type either in_channel or ephemeral
	ResponseType *string `json:"ResponseType,omitempty"`
	Text         *string `json:"Text,omitempty"`
	Username     *string `json:"Username,omitempty"`
}

// Compliance defines model for Compliance.
type Compliance struct {
	Count    *int    `json:"count,omitempty"`
	CreateAt *int    `json:"create_at,omitempty"`
	Desc     *string `json:"desc,omitempty"`
	Emails   *string `json:"emails,omitempty"`
	EndAt    *int    `json:"end_at,omitempty"`
	Id       *string `json:"id,omitempty"`
	Keywords *string `json:"keywords,omitempty"`
	StartAt  *int    `json:"start_at,omitempty"`
	Status   *string `json:"status,omitempty"`
	Type     *string `json:"type,omitempty"`
	UserId   *string `json:"user_id,omitempty"`
}

// Config defines model for Config.
type Config struct {
	AnalyticsSettings *struct {
		MaxUsersForStatistics *int `json:"MaxUsersForStatistics,omitempty"`
	} `json:"AnalyticsSettings,omitempty"`
	ClusterSettings *struct {
		Enable                 *bool     `json:"Enable,omitempty"`
		InterNodeListenAddress *string   `json:"InterNodeListenAddress,omitempty"`
		InterNodeUrls          *[]string `json:"InterNodeUrls,omitempty"`
	} `json:"ClusterSettings,omitempty"`
	ComplianceSettings *struct {
		Directory   *string `json:"Directory,omitempty"`
		Enable      *bool   `json:"Enable,omitempty"`
		EnableDaily *bool   `json:"EnableDaily,omitempty"`
	} `json:"ComplianceSettings,omitempty"`
	EmailSettings *struct {
		ConnectionSecurity       *string `json:"ConnectionSecurity,omitempty"`
		EmailBatchingBufferSize  *int    `json:"EmailBatchingBufferSize,omitempty"`
		EmailBatchingInterval    *int    `json:"EmailBatchingInterval,omitempty"`
		EnableEmailBatching      *bool   `json:"EnableEmailBatching,omitempty"`
		EnableSignInWithEmail    *bool   `json:"EnableSignInWithEmail,omitempty"`
		EnableSignInWithUsername *bool   `json:"EnableSignInWithUsername,omitempty"`
		EnableSignUpWithEmail    *bool   `json:"EnableSignUpWithEmail,omitempty"`
		FeedbackEmail            *string `json:"FeedbackEmail,omitempty"`
		FeedbackName             *string `json:"FeedbackName,omitempty"`
		FeedbackOrganization     *string `json:"FeedbackOrganization,omitempty"`
		InviteSalt               *string `json:"InviteSalt,omitempty"`
		PasswordResetSalt        *string `json:"PasswordResetSalt,omitempty"`
		PushNotificationContents *string `json:"PushNotificationContents,omitempty"`
		PushNotificationServer   *string `json:"PushNotificationServer,omitempty"`
		RequireEmailVerification *bool   `json:"RequireEmailVerification,omitempty"`
		SMTPPassword             *string `json:"SMTPPassword,omitempty"`
		SMTPPort                 *string `json:"SMTPPort,omitempty"`
		SMTPServer               *string `json:"SMTPServer,omitempty"`
		SMTPUsername             *string `json:"SMTPUsername,omitempty"`
		SendEmailNotifications   *bool   `json:"SendEmailNotifications,omitempty"`
		SendPushNotifications    *bool   `json:"SendPushNotifications,omitempty"`
	} `json:"EmailSettings,omitempty"`
	FileSettings *struct {
		AmazonS3AccessKeyId     *string `json:"AmazonS3AccessKeyId,omitempty"`
		AmazonS3Bucket          *string `json:"AmazonS3Bucket,omitempty"`
		AmazonS3Endpoint        *string `json:"AmazonS3Endpoint,omitempty"`
		AmazonS3Region          *string `json:"AmazonS3Region,omitempty"`
		AmazonS3SSL             *bool   `json:"AmazonS3SSL,omitempty"`
		AmazonS3SecretAccessKey *string `json:"AmazonS3SecretAccessKey,omitempty"`
		AmazonS3StorageClass    *string `json:"AmazonS3StorageClass,omitempty"`
		Directory               *string `json:"Directory,omitempty"`
		DriverName              *string `json:"DriverName,omitempty"`
		EnablePublicLink        *bool   `json:"EnablePublicLink,omitempty"`
		InitialFont             *string `json:"InitialFont,omitempty"`
		MaxFileSize             *int    `json:"MaxFileSize,omitempty"`
		PreviewHeight           *int    `json:"PreviewHeight,omitempty"`
		PreviewWidth            *int    `json:"PreviewWidth,omitempty"`
		ProfileHeight           *int    `json:"ProfileHeight,omitempty"`
		ProfileWidth            *int    `json:"ProfileWidth,omitempty"`
		PublicLinkSalt          *string `json:"PublicLinkSalt,omitempty"`
		ThumbnailHeight         *int    `json:"ThumbnailHeight,omitempty"`
		ThumbnailWidth          *int    `json:"ThumbnailWidth,omitempty"`
	} `json:"FileSettings,omitempty"`
	GitLabSettings *struct {
		AuthEndpoint    *string `json:"AuthEndpoint,omitempty"`
		Enable          *bool   `json:"Enable,omitempty"`
		Id              *string `json:"Id,omitempty"`
		Scope           *string `json:"Scope,omitempty"`
		Secret          *string `json:"Secret,omitempty"`
		TokenEndpoint   *string `json:"TokenEndpoint,omitempty"`
		UserApiEndpoint *string `json:"UserApiEndpoint,omitempty"`
	} `json:"GitLabSettings,omitempty"`
	GoogleSettings *struct {
		AuthEndpoint    *string `json:"AuthEndpoint,omitempty"`
		Enable          *bool   `json:"Enable,omitempty"`
		Id              *string `json:"Id,omitempty"`
		Scope           *string `json:"Scope,omitempty"`
		Secret          *string `json:"Secret,omitempty"`
		TokenEndpoint   *string `json:"TokenEndpoint,omitempty"`
		UserApiEndpoint *string `json:"UserApiEndpoint,omitempty"`
	} `json:"GoogleSettings,omitempty"`
	LdapSettings *struct {
		BaseDN                      *string `json:"BaseDN,omitempty"`
		BindPassword                *string `json:"BindPassword,omitempty"`
		BindUsername                *string `json:"BindUsername,omitempty"`
		ConnectionSecurity          *string `json:"ConnectionSecurity,omitempty"`
		EmailAttribute              *string `json:"EmailAttribute,omitempty"`
		Enable                      *bool   `json:"Enable,omitempty"`
		FirstNameAttribute          *string `json:"FirstNameAttribute,omitempty"`
		IdAttribute                 *string `json:"IdAttribute,omitempty"`
		LastNameAttribute           *string `json:"LastNameAttribute,omitempty"`
		LdapPort                    *int    `json:"LdapPort,omitempty"`
		LdapServer                  *string `json:"LdapServer,omitempty"`
		LoginFieldName              *string `json:"LoginFieldName,omitempty"`
		MaxPageSize                 *int    `json:"MaxPageSize,omitempty"`
		NicknameAttribute           *string `json:"NicknameAttribute,omitempty"`
		PositionAttribute           *string `json:"PositionAttribute,omitempty"`
		QueryTimeout                *int    `json:"QueryTimeout,omitempty"`
		SkipCertificateVerification *bool   `json:"SkipCertificateVerification,omitempty"`
		SyncIntervalMinutes         *int    `json:"SyncIntervalMinutes,omitempty"`
		UserFilter                  *string `json:"UserFilter,omitempty"`
		UsernameAttribute           *string `json:"UsernameAttribute,omitempty"`
	} `json:"LdapSettings,omitempty"`
	LocalizationSettings *struct {
		AvailableLocales    *string `json:"AvailableLocales,omitempty"`
		DefaultClientLocale *string `json:"DefaultClientLocale,omitempty"`
		DefaultServerLocale *string `json:"DefaultServerLocale,omitempty"`
	} `json:"LocalizationSettings,omitempty"`
	LogSettings *struct {
		ConsoleLevel           *string `json:"ConsoleLevel,omitempty"`
		EnableConsole          *bool   `json:"EnableConsole,omitempty"`
		EnableDiagnostics      *bool   `json:"EnableDiagnostics,omitempty"`
		EnableFile             *bool   `json:"EnableFile,omitempty"`
		EnableWebhookDebugging *bool   `json:"EnableWebhookDebugging,omitempty"`
		FileLevel              *string `json:"FileLevel,omitempty"`
		FileLocation           *string `json:"FileLocation,omitempty"`
	} `json:"LogSettings,omitempty"`
	MetricsSettings *struct {
		BlockProfileRate *int    `json:"BlockProfileRate,omitempty"`
		Enable           *bool   `json:"Enable,omitempty"`
		ListenAddress    *string `json:"ListenAddress,omitempty"`
	} `json:"MetricsSettings,omitempty"`
	NativeAppSettings *struct {
		AndroidAppDownloadLink *string `json:"AndroidAppDownloadLink,omitempty"`
		AppDownloadLink        *string `json:"AppDownloadLink,omitempty"`
		IosAppDownloadLink     *string `json:"IosAppDownloadLink,omitempty"`
	} `json:"NativeAppSettings,omitempty"`
	Office365Settings *struct {
		AuthEndpoint    *string `json:"AuthEndpoint,omitempty"`
		Enable          *bool   `json:"Enable,omitempty"`
		Id              *string `json:"Id,omitempty"`
		Scope           *string `json:"Scope,omitempty"`
		Secret          *string `json:"Secret,omitempty"`
		TokenEndpoint   *string `json:"TokenEndpoint,omitempty"`
		UserApiEndpoint *string `json:"UserApiEndpoint,omitempty"`
	} `json:"Office365Settings,omitempty"`
	PasswordSettings *struct {
		Lowercase     *bool `json:"Lowercase,omitempty"`
		MinimumLength *int  `json:"MinimumLength,omitempty"`
		Number        *bool `json:"Number,omitempty"`
		Symbol        *bool `json:"Symbol,omitempty"`
		Uppercase     *bool `json:"Uppercase,omitempty"`
	} `json:"PasswordSettings,omitempty"`
	PrivacySettings *struct {
		ShowEmailAddress *bool `json:"ShowEmailAddress,omitempty"`
		ShowFullName     *bool `json:"ShowFullName,omitempty"`
	} `json:"PrivacySettings,omitempty"`
	RateLimitSettings *struct {
		Enable           *bool   `json:"Enable,omitempty"`
		MaxBurst         *int    `json:"MaxBurst,omitempty"`
		MemoryStoreSize  *int    `json:"MemoryStoreSize,omitempty"`
		PerSec           *int    `json:"PerSec,omitempty"`
		VaryByHeader     *string `json:"VaryByHeader,omitempty"`
		VaryByRemoteAddr *bool   `json:"VaryByRemoteAddr,omitempty"`
	} `json:"RateLimitSettings,omitempty"`
	SamlSettings *struct {
		AssertionConsumerServiceURL *string `json:"AssertionConsumerServiceURL,omitempty"`
		EmailAttribute              *string `json:"EmailAttribute,omitempty"`
		Enable                      *bool   `json:"Enable,omitempty"`
		Encrypt                     *bool   `json:"Encrypt,omitempty"`
		FirstNameAttribute          *string `json:"FirstNameAttribute,omitempty"`
		IdpCertificateFile          *string `json:"IdpCertificateFile,omitempty"`
		IdpDescriptorUrl            *string `json:"IdpDescriptorUrl,omitempty"`
		IdpUrl                      *string `json:"IdpUrl,omitempty"`
		LastNameAttribute           *string `json:"LastNameAttribute,omitempty"`
		LocaleAttribute             *string `json:"LocaleAttribute,omitempty"`
		LoginButtonText             *string `json:"LoginButtonText,omitempty"`
		NicknameAttribute           *string `json:"NicknameAttribute,omitempty"`
		PositionAttribute           *string `json:"PositionAttribute,omitempty"`
		PrivateKeyFile              *string `json:"PrivateKeyFile,omitempty"`
		PublicCertificateFile       *string `json:"PublicCertificateFile,omitempty"`
		UsernameAttribute           *string `json:"UsernameAttribute,omitempty"`
		Verify                      *bool   `json:"Verify,omitempty"`
	} `json:"SamlSettings,omitempty"`
	ServiceSettings *struct {
		AllowCorsFrom                     *string `json:"AllowCorsFrom,omitempty"`
		ConnectionSecurity                *string `json:"ConnectionSecurity,omitempty"`
		EnableCommands                    *bool   `json:"EnableCommands,omitempty"`
		EnableCustomEmoji                 *bool   `json:"EnableCustomEmoji,omitempty"`
		EnableDeveloper                   *bool   `json:"EnableDeveloper,omitempty"`
		EnableIncomingWebhooks            *bool   `json:"EnableIncomingWebhooks,omitempty"`
		EnableInsecureOutgoingConnections *bool   `json:"EnableInsecureOutgoingConnections,omitempty"`
		EnableMultifactorAuthentication   *bool   `json:"EnableMultifactorAuthentication,omitempty"`
		EnableOAuthServiceProvider        *bool   `json:"EnableOAuthServiceProvider,omitempty"`
		EnableOnlyAdminIntegrations       *bool   `json:"EnableOnlyAdminIntegrations,omitempty"`
		EnableOutgoingWebhooks            *bool   `json:"EnableOutgoingWebhooks,omitempty"`
		EnablePostIconOverride            *bool   `json:"EnablePostIconOverride,omitempty"`
		EnablePostUsernameOverride        *bool   `json:"EnablePostUsernameOverride,omitempty"`
		EnableSecurityFixAlert            *bool   `json:"EnableSecurityFixAlert,omitempty"`
		EnableTesting                     *bool   `json:"EnableTesting,omitempty"`
		EnforceMultifactorAuthentication  *bool   `json:"EnforceMultifactorAuthentication,omitempty"`
		Forward80To443                    *bool   `json:"Forward80To443,omitempty"`
		GoogleDeveloperKey                *string `json:"GoogleDeveloperKey,omitempty"`
		LetsEncryptCertificateCacheFile   *string `json:"LetsEncryptCertificateCacheFile,omitempty"`
		ListenAddress                     *string `json:"ListenAddress,omitempty"`
		MaximumLoginAttempts              *int    `json:"MaximumLoginAttempts,omitempty"`
		ReadTimeout                       *int    `json:"ReadTimeout,omitempty"`
		RestrictCustomEmojiCreation       *string `json:"RestrictCustomEmojiCreation,omitempty"`
		SegmentDeveloperKey               *string `json:"SegmentDeveloperKey,omitempty"`
		SessionCacheInMinutes             *int    `json:"SessionCacheInMinutes,omitempty"`
		SessionLengthMobileInDays         *int    `json:"SessionLengthMobileInDays,omitempty"`
		SessionLengthSSOInDays            *int    `json:"SessionLengthSSOInDays,omitempty"`
		SessionLengthWebInDays            *int    `json:"SessionLengthWebInDays,omitempty"`
		SiteURL                           *string `json:"SiteURL,omitempty"`
		TLSCertFile                       *string `json:"TLSCertFile,omitempty"`
		TLSKeyFile                        *string `json:"TLSKeyFile,omitempty"`
		UseLetsEncrypt                    *bool   `json:"UseLetsEncrypt,omitempty"`
		WebserverMode                     *string `json:"WebserverMode,omitempty"`
		WebsocketPort                     *int    `json:"WebsocketPort,omitempty"`
		WebsocketSecurePort               *int    `json:"WebsocketSecurePort,omitempty"`
		WriteTimeout                      *int    `json:"WriteTimeout,omitempty"`
	} `json:"ServiceSettings,omitempty"`
	SqlSettings *struct {
		AtRestEncryptKey   *string   `json:"AtRestEncryptKey,omitempty"`
		DataSource         *string   `json:"DataSource,omitempty"`
		DataSourceReplicas *[]string `json:"DataSourceReplicas,omitempty"`
		DriverName         *string   `json:"DriverName,omitempty"`
		MaxIdleConns       *int      `json:"MaxIdleConns,omitempty"`
		MaxOpenConns       *int      `json:"MaxOpenConns,omitempty"`
		Trace              *bool     `json:"Trace,omitempty"`
	} `json:"SqlSettings,omitempty"`
	SupportSettings *struct {
		AboutLink          *string `json:"AboutLink,omitempty"`
		HelpLink           *string `json:"HelpLink,omitempty"`
		PrivacyPolicyLink  *string `json:"PrivacyPolicyLink,omitempty"`
		ReportAProblemLink *string `json:"ReportAProblemLink,omitempty"`
		SupportEmail       *string `json:"SupportEmail,omitempty"`
		TermsOfServiceLink *string `json:"TermsOfServiceLink,omitempty"`
	} `json:"SupportSettings,omitempty"`
	TeamSettings *struct {
		CustomBrandText                  *string `json:"CustomBrandText,omitempty"`
		CustomDescriptionText            *string `json:"CustomDescriptionText,omitempty"`
		EnableCustomBrand                *bool   `json:"EnableCustomBrand,omitempty"`
		EnableOpenServer                 *bool   `json:"EnableOpenServer,omitempty"`
		EnableTeamCreation               *bool   `json:"EnableTeamCreation,omitempty"`
		EnableUserCreation               *bool   `json:"EnableUserCreation,omitempty"`
		MaxChannelsPerTeam               *int    `json:"MaxChannelsPerTeam,omitempty"`
		MaxNotificationsPerChannel       *int    `json:"MaxNotificationsPerChannel,omitempty"`
		MaxUsersPerTeam                  *int    `json:"MaxUsersPerTeam,omitempty"`
		RestrictCreationToDomains        *string `json:"RestrictCreationToDomains,omitempty"`
		RestrictDirectMessage            *string `json:"RestrictDirectMessage,omitempty"`
		RestrictPrivateChannelCreation   *string `json:"RestrictPrivateChannelCreation,omitempty"`
		RestrictPrivateChannelDeletion   *string `json:"RestrictPrivateChannelDeletion,omitempty"`
		RestrictPrivateChannelManagement *string `json:"RestrictPrivateChannelManagement,omitempty"`
		RestrictPublicChannelCreation    *string `json:"RestrictPublicChannelCreation,omitempty"`
		RestrictPublicChannelDeletion    *string `json:"RestrictPublicChannelDeletion,omitempty"`
		RestrictPublicChannelManagement  *string `json:"RestrictPublicChannelManagement,omitempty"`
		RestrictTeamInvite               *string `json:"RestrictTeamInvite,omitempty"`
		SiteName                         *string `json:"SiteName,omitempty"`
		UserStatusAwayTimeout            *int    `json:"UserStatusAwayTimeout,omitempty"`
	} `json:"TeamSettings,omitempty"`
}

// DataRetentionPolicy defines model for DataRetentionPolicy.
type DataRetentionPolicy struct {
	// DisplayName The display name for this retention policy.
	DisplayName *string `json:"display_name,omitempty"`

	// Id The ID of this retention policy.
	Id *string `json:"id,omitempty"`

	// PostDuration The number of days a message will be retained before being deleted by this policy. If this value is less than 0, the policy has infinite retention (i.e. messages are never deleted).
	PostDuration *int `json:"post_duration,omitempty"`
}

// DataRetentionPolicyCreate defines model for DataRetentionPolicyCreate.
type DataRetentionPolicyCreate = DataRetentionPolicyWithTeamAndChannelIds

// DataRetentionPolicyForChannel defines model for DataRetentionPolicyForChannel.
type DataRetentionPolicyForChannel struct {
	// ChannelId The channel ID.
	ChannelId *string `json:"channel_id,omitempty"`

	// PostDuration The number of days a message will be retained before being deleted by this policy.
	PostDuration *int `json:"post_duration,omitempty"`
}

// DataRetentionPolicyForTeam defines model for DataRetentionPolicyForTeam.
type DataRetentionPolicyForTeam struct {
	// PostDuration The number of days a message will be retained before being deleted by this policy.
	PostDuration *int `json:"post_duration,omitempty"`

	// TeamId The team ID.
	TeamId *string `json:"team_id,omitempty"`
}

// DataRetentionPolicyWithTeamAndChannelCounts defines model for DataRetentionPolicyWithTeamAndChannelCounts.
type DataRetentionPolicyWithTeamAndChannelCounts struct {
	// ChannelCount The number of channels to which this policy is applied.
	ChannelCount *int `json:"channel_count,omitempty"`

	// DisplayName The display name for this retention policy.
	DisplayName *string `json:"display_name,omitempty"`

	// Id The ID of this retention policy.
	Id *string `json:"id,omitempty"`

	// PostDuration The number of days a message will be retained before being deleted by this policy. If this value is less than 0, the policy has infinite retention (i.e. messages are never deleted).
	PostDuration *int `json:"post_duration,omitempty"`

	// TeamCount The number of teams to which this policy is applied.
	TeamCount *int `json:"team_count,omitempty"`
}

// DataRetentionPolicyWithTeamAndChannelIds defines model for DataRetentionPolicyWithTeamAndChannelIds.
type DataRetentionPolicyWithTeamAndChannelIds struct {
	// ChannelIds The IDs of the channels to which this policy should be applied.
	ChannelIds *[]string `json:"channel_ids,omitempty"`

	// DisplayName The display name for this retention policy.
	DisplayName *string `json:"display_name,omitempty"`

	// PostDuration The number of days a message will be retained before being deleted by this policy. If this value is less than 0, the policy has infinite retention (i.e. messages are never deleted).
	PostDuration *int `json:"post_duration,omitempty"`

	// TeamIds The IDs of the teams to which this policy should be applied.
	TeamIds *[]string `json:"team_ids,omitempty"`
}

// DataRetentionPolicyWithoutId defines model for DataRetentionPolicyWithoutId.
type DataRetentionPolicyWithoutId struct {
	// DisplayName The display name for this retention policy.
	DisplayName *string `json:"display_name,omitempty"`

	// PostDuration The number of days a message will be retained before being deleted by this policy. If this value is less than 0, the policy has infinite retention (i.e. messages are never deleted).
	PostDuration *int `json:"post_duration,omitempty"`
}

// Emoji defines model for Emoji.
type Emoji struct {
	// CreateAt The time in milliseconds the emoji was made
	CreateAt *int `json:"create_at,omitempty"`

	// CreatorId The ID of the user that made the emoji
	CreatorId *string `json:"creator_id,omitempty"`

	// DeleteAt The time in milliseconds the emoji was deleted
	DeleteAt *int `json:"delete_at,omitempty"`

	// Id The ID of the emoji
	Id *string `json:"id,omitempty"`

	// Name The name of the emoji
	Name *string `json:"name,omitempty"`

	// UpdateAt The time in milliseconds the emoji was last updated
	UpdateAt *int `json:"update_at,omitempty"`
}

// EnvironmentConfig defines model for EnvironmentConfig.
type EnvironmentConfig struct {
	AnalyticsSettings *struct {
		MaxUsersForStatistics *bool `json:"MaxUsersForStatistics,omitempty"`
	} `json:"AnalyticsSettings,omitempty"`
	ClusterSettings *struct {
		Enable                 *bool `json:"Enable,omitempty"`
		InterNodeListenAddress *bool `json:"InterNodeListenAddress,omitempty"`
		InterNodeUrls          *bool `json:"InterNodeUrls,omitempty"`
	} `json:"ClusterSettings,omitempty"`
	ComplianceSettings *struct {
		Directory   *bool `json:"Directory,omitempty"`
		Enable      *bool `json:"Enable,omitempty"`
		EnableDaily *bool `json:"EnableDaily,omitempty"`
	} `json:"ComplianceSettings,omitempty"`
	EmailSettings *struct {
		ConnectionSecurity       *bool `json:"ConnectionSecurity,omitempty"`
		EmailBatchingBufferSize  *bool `json:"EmailBatchingBufferSize,omitempty"`
		EmailBatchingInterval    *bool `json:"EmailBatchingInterval,omitempty"`
		EnableEmailBatching      *bool `json:"EnableEmailBatching,omitempty"`
		EnableSignInWithEmail    *bool `json:"EnableSignInWithEmail,omitempty"`
		EnableSignInWithUsername *bool `json:"EnableSignInWithUsername,omitempty"`
		EnableSignUpWithEmail    *bool `json:"EnableSignUpWithEmail,omitempty"`
		FeedbackEmail            *bool `json:"FeedbackEmail,omitempty"`
		FeedbackName             *bool `json:"FeedbackName,omitempty"`
		FeedbackOrganization     *bool `json:"FeedbackOrganization,omitempty"`
		InviteSalt               *bool `json:"InviteSalt,omitempty"`
		PasswordResetSalt        *bool `json:"PasswordResetSalt,omitempty"`
		PushNotificationContents *bool `json:"PushNotificationContents,omitempty"`
		PushNotificationServer   *bool `json:"PushNotificationServer,omitempty"`
		RequireEmailVerification *bool `json:"RequireEmailVerification,omitempty"`
		SMTPPassword             *bool `json:"SMTPPassword,omitempty"`
		SMTPPort                 *bool `json:"SMTPPort,omitempty"`
		SMTPServer               *bool `json:"SMTPServer,omitempty"`
		SMTPUsername             *bool `json:"SMTPUsername,omitempty"`
		SendEmailNotifications   *bool `json:"SendEmailNotifications,omitempty"`
		SendPushNotifications    *bool `json:"SendPushNotifications,omitempty"`
	} `json:"EmailSettings,omitempty"`
	FileSettings *struct {
		AmazonS3AccessKeyId     *bool   `json:"AmazonS3AccessKeyId,omitempty"`
		AmazonS3Bucket          *bool   `json:"AmazonS3Bucket,omitempty"`
		AmazonS3Endpoint        *bool   `json:"AmazonS3Endpoint,omitempty"`
		AmazonS3Region          *bool   `json:"AmazonS3Region,omitempty"`
		AmazonS3SSL             *bool   `json:"AmazonS3SSL,omitempty"`
		AmazonS3SecretAccessKey *bool   `json:"AmazonS3SecretAccessKey,omitempty"`
		AmazonS3StorageClass    *string `json:"AmazonS3StorageClass,omitempty"`
		Directory               *bool   `json:"Directory,omitempty"`
		DriverName              *bool   `json:"DriverName,omitempty"`
		EnablePublicLink        *bool   `json:"EnablePublicLink,omitempty"`
		InitialFont             *bool   `json:"InitialFont,omitempty"`
		MaxFileSize             *bool   `json:"MaxFileSize,omitempty"`
		PreviewHeight           *bool   `json:"PreviewHeight,omitempty"`
		PreviewWidth            *bool   `json:"PreviewWidth,omitempty"`
		ProfileHeight           *bool   `json:"ProfileHeight,omitempty"`
		ProfileWidth            *bool   `json:"ProfileWidth,omitempty"`
		PublicLinkSalt          *bool   `json:"PublicLinkSalt,omitempty"`
		ThumbnailHeight         *bool   `json:"ThumbnailHeight,omitempty"`
		ThumbnailWidth          *bool   `json:"ThumbnailWidth,omitempty"`
	} `json:"FileSettings,omitempty"`
	GitLabSettings *struct {
		AuthEndpoint    *bool `json:"AuthEndpoint,omitempty"`
		Enable          *bool `json:"Enable,omitempty"`
		Id              *bool `json:"Id,omitempty"`
		Scope           *bool `json:"Scope,omitempty"`
		Secret          *bool `json:"Secret,omitempty"`
		TokenEndpoint   *bool `json:"TokenEndpoint,omitempty"`
		UserApiEndpoint *bool `json:"UserApiEndpoint,omitempty"`
	} `json:"GitLabSettings,omitempty"`
	GoogleSettings *struct {
		AuthEndpoint    *bool `json:"AuthEndpoint,omitempty"`
		Enable          *bool `json:"Enable,omitempty"`
		Id              *bool `json:"Id,omitempty"`
		Scope           *bool `json:"Scope,omitempty"`
		Secret          *bool `json:"Secret,omitempty"`
		TokenEndpoint   *bool `json:"TokenEndpoint,omitempty"`
		UserApiEndpoint *bool `json:"UserApiEndpoint,omitempty"`
	} `json:"GoogleSettings,omitempty"`
	LdapSettings *struct {
		BaseDN                      *bool `json:"BaseDN,omitempty"`
		BindPassword                *bool `json:"BindPassword,omitempty"`
		BindUsername                *bool `json:"BindUsername,omitempty"`
		ConnectionSecurity          *bool `json:"ConnectionSecurity,omitempty"`
		EmailAttribute              *bool `json:"EmailAttribute,omitempty"`
		Enable                      *bool `json:"Enable,omitempty"`
		FirstNameAttribute          *bool `json:"FirstNameAttribute,omitempty"`
		IdAttribute                 *bool `json:"IdAttribute,omitempty"`
		LastNameAttribute           *bool `json:"LastNameAttribute,omitempty"`
		LdapPort                    *bool `json:"LdapPort,omitempty"`
		LdapServer                  *bool `json:"LdapServer,omitempty"`
		LoginFieldName              *bool `json:"LoginFieldName,omitempty"`
		MaxPageSize                 *bool `json:"MaxPageSize,omitempty"`
		NicknameAttribute           *bool `json:"NicknameAttribute,omitempty"`
		PositionAttribute           *bool `json:"PositionAttribute,omitempty"`
		QueryTimeout                *bool `json:"QueryTimeout,omitempty"`
		SkipCertificateVerification *bool `json:"SkipCertificateVerification,omitempty"`
		SyncIntervalMinutes         *bool `json:"SyncIntervalMinutes,omitempty"`
		UserFilter                  *bool `json:"UserFilter,omitempty"`
		UsernameAttribute           *bool `json:"UsernameAttribute,omitempty"`
	} `json:"LdapSettings,omitempty"`
	LocalizationSettings *struct {
		AvailableLocales    *bool `json:"AvailableLocales,omitempty"`
		DefaultClientLocale *bool `json:"DefaultClientLocale,omitempty"`
		DefaultServerLocale *bool `json:"DefaultServerLocale,omitempty"`
	} `json:"LocalizationSettings,omitempty"`
	LogSettings *struct {
		ConsoleLevel           *bool `json:"ConsoleLevel,omitempty"`
		EnableConsole          *bool `json:"EnableConsole,omitempty"`
		EnableDiagnostics      *bool `json:"EnableDiagnostics,omitempty"`
		EnableFile             *bool `json:"EnableFile,omitempty"`
		EnableWebhookDebugging *bool `json:"EnableWebhookDebugging,omitempty"`
		FileLevel              *bool `json:"FileLevel,omitempty"`
		FileLocation           *bool `json:"FileLocation,omitempty"`
	} `json:"LogSettings,omitempty"`
	MetricsSettings *struct {
		BlockProfileRate *bool `json:"BlockProfileRate,omitempty"`
		Enable           *bool `json:"Enable,omitempty"`
		ListenAddress    *bool `json:"ListenAddress,omitempty"`
	} `json:"MetricsSettings,omitempty"`
	NativeAppSettings *struct {
		AndroidAppDownloadLink *bool `json:"AndroidAppDownloadLink,omitempty"`
		AppDownloadLink        *bool `json:"AppDownloadLink,omitempty"`
		IosAppDownloadLink     *bool `json:"IosAppDownloadLink,omitempty"`
	} `json:"NativeAppSettings,omitempty"`
	Office365Settings *struct {
		AuthEndpoint    *bool `json:"AuthEndpoint,omitempty"`
		Enable          *bool `json:"Enable,omitempty"`
		Id              *bool `json:"Id,omitempty"`
		Scope           *bool `json:"Scope,omitempty"`
		Secret          *bool `json:"Secret,omitempty"`
		TokenEndpoint   *bool `json:"TokenEndpoint,omitempty"`
		UserApiEndpoint *bool `json:"UserApiEndpoint,omitempty"`
	} `json:"Office365Settings,omitempty"`
	PasswordSettings *struct {
		Lowercase     *bool `json:"Lowercase,omitempty"`
		MinimumLength *bool `json:"MinimumLength,omitempty"`
		Number        *bool `json:"Number,omitempty"`
		Symbol        *bool `json:"Symbol,omitempty"`
		Uppercase     *bool `json:"Uppercase,omitempty"`
	} `json:"PasswordSettings,omitempty"`
	PrivacySettings *struct {
		ShowEmailAddress *bool `json:"ShowEmailAddress,omitempty"`
		ShowFullName     *bool `json:"ShowFullName,omitempty"`
	} `json:"PrivacySettings,omitempty"`
	RateLimitSettings *struct {
		Enable           *bool `json:"Enable,omitempty"`
		MaxBurst         *bool `json:"MaxBurst,omitempty"`
		MemoryStoreSize  *bool `json:"MemoryStoreSize,omitempty"`
		PerSec           *bool `json:"PerSec,omitempty"`
		VaryByHeader     *bool `json:"VaryByHeader,omitempty"`
		VaryByRemoteAddr *bool `json:"VaryByRemoteAddr,omitempty"`
	} `json:"RateLimitSettings,omitempty"`
	SamlSettings *struct {
		AssertionConsumerServiceURL *bool `json:"AssertionConsumerServiceURL,omitempty"`
		EmailAttribute              *bool `json:"EmailAttribute,omitempty"`
		Enable                      *bool `json:"Enable,omitempty"`
		Encrypt                     *bool `json:"Encrypt,omitempty"`
		FirstNameAttribute          *bool `json:"FirstNameAttribute,omitempty"`
		IdpCertificateFile          *bool `json:"IdpCertificateFile,omitempty"`
		IdpDescriptorUrl            *bool `json:"IdpDescriptorUrl,omitempty"`
		IdpUrl                      *bool `json:"IdpUrl,omitempty"`
		LastNameAttribute           *bool `json:"LastNameAttribute,omitempty"`
		LocaleAttribute             *bool `json:"LocaleAttribute,omitempty"`
		LoginButtonText             *bool `json:"LoginButtonText,omitempty"`
		NicknameAttribute           *bool `json:"NicknameAttribute,omitempty"`
		PositionAttribute           *bool `json:"PositionAttribute,omitempty"`
		PrivateKeyFile              *bool `json:"PrivateKeyFile,omitempty"`
		PublicCertificateFile       *bool `json:"PublicCertificateFile,omitempty"`
		UsernameAttribute           *bool `json:"UsernameAttribute,omitempty"`
		Verify                      *bool `json:"Verify,omitempty"`
	} `json:"SamlSettings,omitempty"`
	ServiceSettings *struct {
		AllowCorsFrom                     *bool `json:"AllowCorsFrom,omitempty"`
		ConnectionSecurity                *bool `json:"ConnectionSecurity,omitempty"`
		EnableCommands                    *bool `json:"EnableCommands,omitempty"`
		EnableCustomEmoji                 *bool `json:"EnableCustomEmoji,omitempty"`
		EnableDeveloper                   *bool `json:"EnableDeveloper,omitempty"`
		EnableIncomingWebhooks            *bool `json:"EnableIncomingWebhooks,omitempty"`
		EnableInsecureOutgoingConnections *bool `json:"EnableInsecureOutgoingConnections,omitempty"`
		EnableMultifactorAuthentication   *bool `json:"EnableMultifactorAuthentication,omitempty"`
		EnableOAuthServiceProvider        *bool `json:"EnableOAuthServiceProvider,omitempty"`
		EnableOnlyAdminIntegrations       *bool `json:"EnableOnlyAdminIntegrations,omitempty"`
		EnableOutgoingWebhooks            *bool `json:"EnableOutgoingWebhooks,omitempty"`
		EnablePostIconOverride            *bool `json:"EnablePostIconOverride,omitempty"`
		EnablePostUsernameOverride        *bool `json:"EnablePostUsernameOverride,omitempty"`
		EnableSecurityFixAlert            *bool `json:"EnableSecurityFixAlert,omitempty"`
		EnableTesting                     *bool `json:"EnableTesting,omitempty"`
		EnforceMultifactorAuthentication  *bool `json:"EnforceMultifactorAuthentication,omitempty"`
		Forward80To443                    *bool `json:"Forward80To443,omitempty"`
		GoogleDeveloperKey                *bool `json:"GoogleDeveloperKey,omitempty"`
		LetsEncryptCertificateCacheFile   *bool `json:"LetsEncryptCertificateCacheFile,omitempty"`
		ListenAddress                     *bool `json:"ListenAddress,omitempty"`
		MaximumLoginAttempts              *bool `json:"MaximumLoginAttempts,omitempty"`
		ReadTimeout                       *bool `json:"ReadTimeout,omitempty"`
		RestrictCustomEmojiCreation       *bool `json:"RestrictCustomEmojiCreation,omitempty"`
		SegmentDeveloperKey               *bool `json:"SegmentDeveloperKey,omitempty"`
		SessionCacheInMinutes             *bool `json:"SessionCacheInMinutes,omitempty"`
		SessionLengthMobileInDays         *bool `json:"SessionLengthMobileInDays,omitempty"`
		SessionLengthSSOInDays            *bool `json:"SessionLengthSSOInDays,omitempty"`
		SessionLengthWebInDays            *bool `json:"SessionLengthWebInDays,omitempty"`
		SiteURL                           *bool `json:"SiteURL,omitempty"`
		TLSCertFile                       *bool `json:"TLSCertFile,omitempty"`
		TLSKeyFile                        *bool `json:"TLSKeyFile,omitempty"`
		UseLetsEncrypt                    *bool `json:"UseLetsEncrypt,omitempty"`
		WebserverMode                     *bool `json:"WebserverMode,omitempty"`
		WebsocketPort                     *bool `json:"WebsocketPort,omitempty"`
		WebsocketSecurePort               *bool `json:"WebsocketSecurePort,omitempty"`
		WriteTimeout                      *bool `json:"WriteTimeout,omitempty"`
	} `json:"ServiceSettings,omitempty"`
	SqlSettings *struct {
		AtRestEncryptKey   *bool `json:"AtRestEncryptKey,omitempty"`
		DataSource         *bool `json:"DataSource,omitempty"`
		DataSourceReplicas *bool `json:"DataSourceReplicas,omitempty"`
		DriverName         *bool `json:"DriverName,omitempty"`
		MaxIdleConns       *bool `json:"MaxIdleConns,omitempty"`
		MaxOpenConns       *bool `json:"MaxOpenConns,omitempty"`
		Trace              *bool `json:"Trace,omitempty"`
	} `json:"SqlSettings,omitempty"`
	SupportSettings *struct {
		AboutLink          *bool `json:"AboutLink,omitempty"`
		HelpLink           *bool `json:"HelpLink,omitempty"`
		PrivacyPolicyLink  *bool `json:"PrivacyPolicyLink,omitempty"`
		ReportAProblemLink *bool `json:"ReportAProblemLink,omitempty"`
		SupportEmail       *bool `json:"SupportEmail,omitempty"`
		TermsOfServiceLink *bool `json:"TermsOfServiceLink,omitempty"`
	} `json:"SupportSettings,omitempty"`
	TeamSettings *struct {
		CustomBrandText                  *bool `json:"CustomBrandText,omitempty"`
		CustomDescriptionText            *bool `json:"CustomDescriptionText,omitempty"`
		EnableCustomBrand                *bool `json:"EnableCustomBrand,omitempty"`
		EnableOpenServer                 *bool `json:"EnableOpenServer,omitempty"`
		EnableTeamCreation               *bool `json:"EnableTeamCreation,omitempty"`
		EnableUserCreation               *bool `json:"EnableUserCreation,omitempty"`
		MaxChannelsPerTeam               *bool `json:"MaxChannelsPerTeam,omitempty"`
		MaxNotificationsPerChannel       *bool `json:"MaxNotificationsPerChannel,omitempty"`
		MaxUsersPerTeam                  *bool `json:"MaxUsersPerTeam,omitempty"`
		RestrictCreationToDomains        *bool `json:"RestrictCreationToDomains,omitempty"`
		RestrictDirectMessage            *bool `json:"RestrictDirectMessage,omitempty"`
		RestrictPrivateChannelCreation   *bool `json:"RestrictPrivateChannelCreation,omitempty"`
		RestrictPrivateChannelDeletion   *bool `json:"RestrictPrivateChannelDeletion,omitempty"`
		RestrictPrivateChannelManagement *bool `json:"RestrictPrivateChannelManagement,omitempty"`
		RestrictPublicChannelCreation    *bool `json:"RestrictPublicChannelCreation,omitempty"`
		RestrictPublicChannelDeletion    *bool `json:"RestrictPublicChannelDeletion,omitempty"`
		RestrictPublicChannelManagement  *bool `json:"RestrictPublicChannelManagement,omitempty"`
		RestrictTeamInvite               *bool `json:"RestrictTeamInvite,omitempty"`
		SiteName                         *bool `json:"SiteName,omitempty"`
		UserStatusAwayTimeout            *bool `json:"UserStatusAwayTimeout,omitempty"`
	} `json:"TeamSettings,omitempty"`
}

// Error defines model for Error.
type Error struct {
	// Details Further details on where and why this error happened.
	Details string `json:"details"`

	// Error A message with the error description.
	Error string `json:"error"`
}

// FileInfo defines model for FileInfo.
type FileInfo struct {
	// CreateAt The time in milliseconds a file was created
	CreateAt *int `json:"create_at,omitempty"`

	// DeleteAt The time in milliseconds a file was deleted
	DeleteAt *int `json:"delete_at,omitempty"`

	// Extension The extension at the end of the file name
	Extension *string `json:"extension,omitempty"`

	// HasPreviewImage If this file is an image, whether or not it has a preview-sized version
	HasPreviewImage *bool `json:"has_preview_image,omitempty"`

	// Height If this file is an image, the height of the file
	Height *int `json:"height,omitempty"`

	// Id The unique identifier for this file
	Id *string `json:"id,omitempty"`

	// MimeType The MIME type of the file
	MimeType *string `json:"mime_type,omitempty"`

	// Name The name of the file
	Name *string `json:"name,omitempty"`

	// PostId If this file is attached to a post, the ID of that post
	PostId *string `json:"post_id,omitempty"`

	// Size The size of the file in bytes
	Size *int `json:"size,omitempty"`

	// UpdateAt The time in milliseconds a file was last updated
	UpdateAt *int `json:"update_at,omitempty"`

	// UserId The ID of the user that uploaded this file
	UserId *string `json:"user_id,omitempty"`

	// Width If this file is an image, the width of the file
	Width *int `json:"width,omitempty"`
}

// FileInfoList defines model for FileInfoList.
type FileInfoList struct {
	FileInfos *map[string]FileInfo `json:"file_infos,omitempty"`

	// NextFileId The ID of next file info. Not omitted when empty or not relevant.
	NextFileId *string   `json:"next_file_id,omitempty"`
	Order      *[]string `json:"order,omitempty"`

	// PrevFileId The ID of previous file info. Not omitted when empty or not relevant.
	PrevFileId *string `json:"prev_file_id,omitempty"`
}

// FilesLimits defines model for FilesLimits.
type FilesLimits struct {
	TotalStorage *int `json:"total_storage"`
}

// GlobalDataRetentionPolicy defines model for GlobalDataRetentionPolicy.
type GlobalDataRetentionPolicy struct {
	// FileDeletionEnabled Indicates whether data retention policy deletion of file attachments is enabled globally.
	FileDeletionEnabled *bool `json:"file_deletion_enabled,omitempty"`

	// FileRetentionCutoff The current server timestamp before which files should be deleted.
	FileRetentionCutoff *int `json:"file_retention_cutoff,omitempty"`

	// MessageDeletionEnabled Indicates whether data retention policy deletion of messages is enabled globally.
	MessageDeletionEnabled *bool `json:"message_deletion_enabled,omitempty"`

	// MessageRetentionCutoff The current server timestamp before which messages should be deleted.
	MessageRetentionCutoff *int `json:"message_retention_cutoff,omitempty"`
}

// Group defines model for Group.
type Group struct {
	CreateAt     *int    `json:"create_at,omitempty"`
	DeleteAt     *int    `json:"delete_at,omitempty"`
	Description  *string `json:"description,omitempty"`
	DisplayName  *string `json:"display_name,omitempty"`
	HasSyncables *bool   `json:"has_syncables,omitempty"`
	Id           *string `json:"id,omitempty"`
	Name         *string `json:"name,omitempty"`
	RemoteId     *string `json:"remote_id,omitempty"`
	Source       *string `json:"source,omitempty"`
	UpdateAt     *int    `json:"update_at,omitempty"`
}

// GroupMember defines model for GroupMember.
type GroupMember struct {
	CreateAt *int    `json:"create_at,omitempty"`
	DeleteAt *int    `json:"delete_at,omitempty"`
	GroupId  *string `json:"group_id,omitempty"`
	UserId   *string `json:"user_id,omitempty"`
}

// GroupSyncableChannel defines model for GroupSyncableChannel.
type GroupSyncableChannel struct {
	AutoAdd   *bool   `json:"auto_add,omitempty"`
	ChannelId *string `json:"channel_id,omitempty"`
	CreateAt  *int    `json:"create_at,omitempty"`
	DeleteAt  *int    `json:"delete_at,omitempty"`
	GroupId   *string `json:"group_id,omitempty"`
	UpdateAt  *int    `json:"update_at,omitempty"`
}

// GroupSyncableChannels defines model for GroupSyncableChannels.
type GroupSyncableChannels struct {
	AutoAdd            *bool   `json:"auto_add,omitempty"`
	ChannelDisplayName *string `json:"channel_display_name,omitempty"`
	ChannelId          *string `json:"channel_id,omitempty"`
	ChannelType        *string `json:"channel_type,omitempty"`
	CreateAt           *int    `json:"create_at,omitempty"`
	DeleteAt           *int    `json:"delete_at,omitempty"`
	GroupId            *string `json:"group_id,omitempty"`
	TeamDisplayName    *string `json:"team_display_name,omitempty"`
	TeamId             *string `json:"team_id,omitempty"`
	TeamType           *string `json:"team_type,omitempty"`
	UpdateAt           *int    `json:"update_at,omitempty"`
}

// GroupSyncableTeam defines model for GroupSyncableTeam.
type GroupSyncableTeam struct {
	AutoAdd  *bool   `json:"auto_add,omitempty"`
	CreateAt *int    `json:"create_at,omitempty"`
	DeleteAt *int    `json:"delete_at,omitempty"`
	GroupId  *string `json:"group_id,omitempty"`
	TeamId   *string `json:"team_id,omitempty"`
	UpdateAt *int    `json:"update_at,omitempty"`
}

// GroupSyncableTeams defines model for GroupSyncableTeams.
type GroupSyncableTeams struct {
	AutoAdd         *bool   `json:"auto_add,omitempty"`
	CreateAt        *int    `json:"create_at,omitempty"`
	DeleteAt        *int    `json:"delete_at,omitempty"`
	GroupId         *string `json:"group_id,omitempty"`
	TeamDisplayName *string `json:"team_display_name,omitempty"`
	TeamId          *string `json:"team_id,omitempty"`
	TeamType        *string `json:"team_type,omitempty"`
	UpdateAt        *int    `json:"update_at,omitempty"`
}

// GroupWithSchemeAdmin group augmented with scheme admin information
type GroupWithSchemeAdmin struct {
	Group       *Group `json:"group,omitempty"`
	SchemeAdmin *bool  `json:"scheme_admin,omitempty"`
}

// GroupsAssociatedToChannels a map of channel id(s) to the set of groups that constrain the corresponding channel in a team
type GroupsAssociatedToChannels map[string][]GroupWithSchemeAdmin

// IncomingWebhook defines model for IncomingWebhook.
type IncomingWebhook struct {
	// ChannelId The ID of a public channel or private group that receives the webhook payloads
	ChannelId *string `json:"channel_id,omitempty"`

	// CreateAt The time in milliseconds a incoming webhook was created
	CreateAt *int `json:"create_at,omitempty"`

	// DeleteAt The time in milliseconds a incoming webhook was deleted
	DeleteAt *int `json:"delete_at,omitempty"`

	// Description The description for this incoming webhook
	Description *string `json:"description,omitempty"`

	// DisplayName The display name for this incoming webhook
	DisplayName *string `json:"display_name,omitempty"`

	// Id The unique identifier for this incoming webhook
	Id *string `json:"id,omitempty"`

	// UpdateAt The time in milliseconds a incoming webhook was last updated
	UpdateAt *int `json:"update_at,omitempty"`
}

// Installation defines model for Installation.
type Installation struct {
	AllowedIpRanges *AllowedIPRange `json:"allowed_ip_ranges,omitempty"`

	// Id A unique identifier
	Id *string `json:"id,omitempty"`

	// State The current state of the installation
	State *string `json:"state,omitempty"`
}

// IntegrationsLimits defines model for IntegrationsLimits.
type IntegrationsLimits struct {
	Enabled *int `json:"enabled"`
}

// IntegrityCheckResult an object with the result of the integrity check.
type IntegrityCheckResult struct {
	// Data an object containing the results of a relational integrity check.
	Data *RelationalIntegrityCheckData `json:"data,omitempty"`

	// Err a string value set in case of error.
	Err *string `json:"err,omitempty"`
}

// Invoice defines model for Invoice.
type Invoice struct {
	CreateAt       *int               `json:"create_at,omitempty"`
	Id             *string            `json:"id,omitempty"`
	Item           *[]InvoiceLineItem `json:"item,omitempty"`
	Number         *string            `json:"number,omitempty"`
	PeriodEnd      *int               `json:"period_end,omitempty"`
	PeriodStart    *int               `json:"period_start,omitempty"`
	Status         *string            `json:"status,omitempty"`
	SubscriptionId *string            `json:"subscription_id,omitempty"`
	Tax            *int               `json:"tax,omitempty"`
	Total          *int               `json:"total,omitempty"`
}

// InvoiceLineItem defines model for InvoiceLineItem.
type InvoiceLineItem struct {
	Description  *string   `json:"description,omitempty"`
	Metadata     *[]string `json:"metadata,omitempty"`
	PriceId      *string   `json:"price_id,omitempty"`
	PricePerUnit *int      `json:"price_per_unit,omitempty"`
	Quantity     *int      `json:"quantity,omitempty"`
	Total        *int      `json:"total,omitempty"`
}

// Job defines model for Job.
type Job struct {
	// CreateAt The time at which the job was created
	CreateAt *int `json:"create_at,omitempty"`

	// Data A freeform data field containing additional information about the job
	Data *map[string]interface{} `json:"data,omitempty"`

	// Id The unique id of the job
	Id *string `json:"id,omitempty"`

	// LastActivityAt The last time at which the job had activity
	LastActivityAt *int `json:"last_activity_at,omitempty"`

	// Progress The progress (as a percentage) of the job
	Progress *int `json:"progress,omitempty"`

	// StartAt The time at which the job was started
	StartAt *int `json:"start_at,omitempty"`

	// Status The status of the job
	Status *string `json:"status,omitempty"`

	// Type The type of job
	Type *string `json:"type,omitempty"`
}

// KnownUsers defines model for KnownUsers.
type KnownUsers = []interface{}

// LDAPGroup A LDAP group
type LDAPGroup struct {
	HasSyncables      *bool   `json:"has_syncables,omitempty"`
	MattermostGroupId *string `json:"mattermost_group_id,omitempty"`
	Name              *string `json:"name,omitempty"`
	PrimaryKey        *string `json:"primary_key,omitempty"`
}

// LDAPGroupsPaged A paged list of LDAP groups
type LDAPGroupsPaged struct {
	// Count Total number of groups
	Count  *float32     `json:"count,omitempty"`
	Groups *[]LDAPGroup `json:"groups,omitempty"`
}

// LicenseRenewalLink defines model for LicenseRenewalLink.
type LicenseRenewalLink struct {
	// RenewalLink License renewal link
	RenewalLink *string `json:"renewal_link,omitempty"`
}

// MarketplacePlugin defines model for MarketplacePlugin.
type MarketplacePlugin struct {
	// DownloadUrl URL to download the plugin.
	DownloadUrl *string `json:"download_url,omitempty"`

	// HomepageUrl URL that leads to the homepage of the plugin.
	HomepageUrl *string `json:"homepage_url,omitempty"`

	// IconData Base64 encoding of a plugin icon SVG.
	IconData *string `json:"icon_data,omitempty"`

	// InstalledVersion Version number of the already installed plugin, if any.
	InstalledVersion *string `json:"installed_version,omitempty"`

	// Labels A list of the plugin labels.
	Labels   *[]string       `json:"labels,omitempty"`
	Manifest *PluginManifest `json:"manifest,omitempty"`

	// ReleaseNotesUrl URL that leads to the release notes of the plugin.
	ReleaseNotesUrl *string `json:"release_notes_url,omitempty"`

	// Signature Base64 encoded signature of the plugin.
	Signature *string `json:"signature,omitempty"`
}

// MessagesLimits defines model for MessagesLimits.
type MessagesLimits struct {
	History *int `json:"history"`
}

// Notice defines model for Notice.
type Notice struct {
	// Action Optional action to perform on action button click. (defaults to closing the notice)
	Action *string `json:"action,omitempty"`

	// ActionParam Optional action parameter.
	// Example: {"action": "url", actionParam: "/console/some-page"}
	ActionParam *string `json:"actionParam,omitempty"`

	// ActionText Optional override for the action button text (defaults to OK)
	ActionText *string `json:"actionText,omitempty"`

	// Description Notice content. Use {{Mattermost}} instead of plain text to support white-labeling. Text supports Markdown.
	Description *string `json:"description,omitempty"`

	// Id Notice ID
	Id *string `json:"id,omitempty"`

	// Image URL of image to display
	Image *string `json:"image,omitempty"`

	// SysAdminOnly Does this notice apply only to sysadmins
	SysAdminOnly *bool `json:"sysAdminOnly,omitempty"`

	// TeamAdminOnly Does this notice apply only to team admins
	TeamAdminOnly *bool `json:"teamAdminOnly,omitempty"`

	// Title Notice title. Use {{Mattermost}} instead of plain text to support white-labeling. Text supports Markdown.
	Title *string `json:"title,omitempty"`
}

// OAuthApp defines model for OAuthApp.
type OAuthApp struct {
	// CallbackUrls A list of callback URLs for the appliation
	CallbackUrls *[]string `json:"callback_urls,omitempty"`

	// ClientSecret The client secret of the application
	ClientSecret *string `json:"client_secret,omitempty"`

	// CreateAt The time of registration for the application
	CreateAt *int `json:"create_at,omitempty"`

	// Description A short description of the application
	Description *string `json:"description,omitempty"`

	// Homepage A link to the website of the application
	Homepage *string `json:"homepage,omitempty"`

	// IconUrl A URL to an icon to display with the application
	IconUrl *string `json:"icon_url,omitempty"`

	// Id The client id of the application
	Id *string `json:"id,omitempty"`

	// IsTrusted Set this to `true` to skip asking users for permission
	IsTrusted *bool `json:"is_trusted,omitempty"`

	// Name The name of the client application
	Name *string `json:"name,omitempty"`

	// UpdateAt The last time of update for the application
	UpdateAt *int `json:"update_at,omitempty"`
}

// OrderedSidebarCategories List of user's categories with their channels
type OrderedSidebarCategories struct {
	Categories *[]SidebarCategoryWithChannels `json:"categories,omitempty"`
	Order      *[]string                      `json:"order,omitempty"`
}

// OrphanedRecord an object containing information about an orphaned record.
type OrphanedRecord struct {
	// ChildId the id of the child relation (table) entry.
	ChildId *string `json:"child_id,omitempty"`

	// ParentId the id of the parent relation (table) entry.
	ParentId *string `json:"parent_id,omitempty"`
}

// OutgoingOAuthConnectionGetItem defines model for OutgoingOAuthConnectionGetItem.
type OutgoingOAuthConnectionGetItem struct {
	// Audiences The audiences of the outgoing OAuth connection.
	Audiences *string `json:"audiences,omitempty"`

	// CreateAt The time in milliseconds the outgoing OAuth connection was created.
	CreateAt *int `json:"create_at,omitempty"`

	// GrantType The grant type of the outgoing OAuth connection.
	GrantType *string `json:"grant_type,omitempty"`

	// Id The unique identifier for the outgoing OAuth connection.
	Id *string `json:"id,omitempty"`

	// Name The name of the outgoing OAuth connection.
	Name *string `json:"name,omitempty"`

	// UpdateAt The time in milliseconds the outgoing OAuth connection was last updated.
	UpdateAt *int `json:"update_at,omitempty"`
}

// OutgoingOAuthConnectionPostItem defines model for OutgoingOAuthConnectionPostItem.
type OutgoingOAuthConnectionPostItem struct {
	// Audiences The audiences of the outgoing OAuth connection.
	Audiences *string `json:"audiences,omitempty"`

	// ClientId The client ID of the outgoing OAuth connection.
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret The client secret of the outgoing OAuth connection.
	ClientSecret *string `json:"client_secret,omitempty"`

	// CredentialsPassword The password of the credentials of the outgoing OAuth connection.
	CredentialsPassword *string `json:"credentials_password,omitempty"`

	// CredentialsUsername The username of the credentials of the outgoing OAuth connection.
	CredentialsUsername *string `json:"credentials_username,omitempty"`

	// GrantType The grant type of the outgoing OAuth connection.
	GrantType *string `json:"grant_type,omitempty"`

	// Name The name of the outgoing OAuth connection.
	Name *string `json:"name,omitempty"`

	// OauthTokenUrl The OAuth token URL of the outgoing OAuth connection.
	OauthTokenUrl *string `json:"oauth_token_url,omitempty"`
}

// OutgoingWebhook defines model for OutgoingWebhook.
type OutgoingWebhook struct {
	// CallbackUrls The URLs to POST the payloads to when the webhook is triggered
	CallbackUrls *[]string `json:"callback_urls,omitempty"`

	// ChannelId The ID of a public channel that the webhook watchs
	ChannelId *string `json:"channel_id,omitempty"`

	// ContentType The format to POST the data in, either `application/json` or `application/x-www-form-urlencoded`
	ContentType *string `json:"content_type,omitempty"`

	// CreateAt The time in milliseconds a outgoing webhook was created
	CreateAt *int `json:"create_at,omitempty"`

	// CreatorId The Id of the user who created the webhook
	CreatorId *string `json:"creator_id,omitempty"`

	// DeleteAt The time in milliseconds a outgoing webhook was deleted
	DeleteAt *int `json:"delete_at,omitempty"`

	// Description The description for this outgoing webhook
	Description *string `json:"description,omitempty"`

	// DisplayName The display name for this outgoing webhook
	DisplayName *string `json:"display_name,omitempty"`

	// Id The unique identifier for this outgoing webhook
	Id *string `json:"id,omitempty"`

	// TeamId The ID of the team that the webhook watchs
	TeamId *string `json:"team_id,omitempty"`

	// TriggerWhen When to trigger the webhook, `0` when a trigger word is present at all and `1` if the message starts with a trigger word
	TriggerWhen *int `json:"trigger_when,omitempty"`

	// TriggerWords List of words for the webhook to trigger on
	TriggerWords *[]string `json:"trigger_words,omitempty"`

	// UpdateAt The time in milliseconds a outgoing webhook was last updated
	UpdateAt *int `json:"update_at,omitempty"`
}

// OwnerInfo defines model for OwnerInfo.
type OwnerInfo struct {
	// UserId A unique, 26 characters long, alphanumeric identifier for the owner.
	UserId string `json:"user_id"`

	// Username Owner's username.
	Username string `json:"username"`
}

// PaymentMethod defines model for PaymentMethod.
type PaymentMethod struct {
	CardBrand *string `json:"card_brand,omitempty"`
	ExpMonth  *int    `json:"exp_month,omitempty"`
	ExpYear   *int    `json:"exp_year,omitempty"`
	LastFour  *int    `json:"last_four,omitempty"`
	Name      *string `json:"name,omitempty"`
	Type      *string `json:"type,omitempty"`
}

// PaymentSetupIntent defines model for PaymentSetupIntent.
type PaymentSetupIntent struct {
	ClientSecret *string `json:"client_secret,omitempty"`
	Id           *string `json:"id,omitempty"`
}

// Playbook defines model for Playbook.
type Playbook struct {
	// Checklists The stages defined in this playbook.
	Checklists *[]Checklist `json:"checklists,omitempty"`

	// CreateAt The playbook creation timestamp, formatted as the number of milliseconds since the Unix epoch.
	CreateAt *int `json:"create_at,omitempty"`

	// CreatePublicPlaybookRun A boolean indicating whether the playbook runs created from this playbook should be public or private.
	CreatePublicPlaybookRun *bool `json:"create_public_playbook_run,omitempty"`

	// DeleteAt The playbook deletion timestamp, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the playbook is not deleted.
	DeleteAt *int `json:"delete_at,omitempty"`

	// Description The description of the playbook.
	Description *string `json:"description,omitempty"`

	// Id A unique, 26 characters long, alphanumeric identifier for the playbook.
	Id *string `json:"id,omitempty"`

	// MemberIds The identifiers of all the users that are members of this playbook.
	MemberIds *[]string `json:"member_ids,omitempty"`

	// NumStages The number of stages defined in this playbook.
	NumStages *int `json:"num_stages,omitempty"`

	// NumSteps The total number of steps from all the stages defined in this playbook.
	NumSteps *int `json:"num_steps,omitempty"`

	// TeamId The identifier of the team where the playbook is in.
	TeamId *string `json:"team_id,omitempty"`

	// Title The title of the playbook.
	Title *string `json:"title,omitempty"`
}

// PlaybookAutofollows defines model for PlaybookAutofollows.
type PlaybookAutofollows struct {
	// Items The user IDs of who marked this playbook to auto-follow.
	Items *[]string `json:"items,omitempty"`

	// TotalCount The total number of users who marked this playbook to auto-follow runs.
	TotalCount *int32 `json:"total_count,omitempty"`
}

// PlaybookList defines model for PlaybookList.
type PlaybookList struct {
	// HasMore A boolean describing whether there are more pages after the currently returned.
	HasMore *bool `json:"has_more,omitempty"`

	// Items The playbooks in this page.
	Items *[]Playbook `json:"items,omitempty"`

	// PageCount The total number of pages. This depends on the total number of playbooks in the database and the per_page parameter sent with the request.
	PageCount *int32 `json:"page_count,omitempty"`

	// TotalCount The total number of playbooks in the list, regardless of the paging.
	TotalCount *int32 `json:"total_count,omitempty"`
}

// PlaybookRun defines model for PlaybookRun.
type PlaybookRun struct {
	// ActiveStage Zero-based index of the currently active stage.
	ActiveStage *int32 `json:"active_stage,omitempty"`

	// ActiveStageTitle The title of the currently active stage.
	ActiveStageTitle *string `json:"active_stage_title,omitempty"`

	// ChannelId The identifier of the playbook run's channel.
	ChannelId  *string      `json:"channel_id,omitempty"`
	Checklists *[]Checklist `json:"checklists,omitempty"`

	// CreateAt The playbook run creation timestamp, formatted as the number of milliseconds since the Unix epoch.
	CreateAt *int `json:"create_at,omitempty"`

	// DeleteAt The playbook run deletion timestamp, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the playbook run is not deleted.
	DeleteAt *int `json:"delete_at,omitempty"`

	// Description The description of the playbook run.
	Description *string `json:"description,omitempty"`

	// EndAt The playbook run finish timestamp, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the playbook run is not finished.
	EndAt *int `json:"end_at,omitempty"`

	// Id A unique, 26 characters long, alphanumeric identifier for the playbook run.
	Id *string `json:"id,omitempty"`

	// IsActive True if the playbook run is ongoing; false if the playbook run is ended.
	IsActive *bool `json:"is_active,omitempty"`

	// Name The name of the playbook run.
	Name *string `json:"name,omitempty"`

	// OwnerUserId The identifier of the user that is commanding the playbook run.
	OwnerUserId *string `json:"owner_user_id,omitempty"`

	// PlaybookId The identifier of the playbook with from which this playbook run was created.
	PlaybookId *string `json:"playbook_id,omitempty"`

	// PostId If the playbook run was created from a post, this field contains the identifier of such post. If not, this field is empty.
	PostId *string `json:"post_id,omitempty"`

	// TeamId The identifier of the team where the playbook run's channel is in.
	TeamId *string `json:"team_id,omitempty"`
}

// PlaybookRunList defines model for PlaybookRunList.
type PlaybookRunList struct {
	// HasMore A boolean describing whether there are more pages after the currently returned.
	HasMore *bool `json:"has_more,omitempty"`

	// Items The playbook runs in this page.
	Items *[]PlaybookRun `json:"items,omitempty"`

	// PageCount The total number of pages. This depends on the total number of playbook runs in the database and the per_page parameter sent with the request.
	PageCount *int32 `json:"page_count,omitempty"`

	// TotalCount The total number of playbook runs in the list, regardless of the paging.
	TotalCount *int32 `json:"total_count,omitempty"`
}

// PlaybookRunMetadata defines model for PlaybookRunMetadata.
type PlaybookRunMetadata struct {
	// ChannelDisplayName Display name of the channel associated to the playbook run.
	ChannelDisplayName *string `json:"channel_display_name,omitempty"`

	// ChannelName Name of the channel associated to the playbook run.
	ChannelName *string `json:"channel_name,omitempty"`

	// NumMembers Number of users that have been members of the playbook run at any point.
	NumMembers *int `json:"num_members,omitempty"`

	// TeamName Name of the team the playbook run is in.
	TeamName *string `json:"team_name,omitempty"`

	// TotalPosts Number of posts in the channel associated to the playbook run.
	TotalPosts *int `json:"total_posts,omitempty"`
}

// PluginManifest defines model for PluginManifest.
type PluginManifest struct {
	// Backend Deprecated in Mattermost 5.2 release.
	Backend *struct {
		// Executable Path to the executable binary.
		Executable *string `json:"executable,omitempty"`
	} `json:"backend,omitempty"`

	// Description Description of what the plugin is and does.
	Description *string `json:"description,omitempty"`

	// Id Globally unique identifier that represents the plugin.
	Id *string `json:"id,omitempty"`

	// MinServerVersion The minimum Mattermost server version required for the plugin.
	//
	// Available as server version 5.6.
	MinServerVersion *string `json:"min_server_version,omitempty"`

	// Name Name of the plugin.
	Name   *string `json:"name,omitempty"`
	Server *struct {
		// Executable Path to the executable binary.
		Executable *string `json:"executable,omitempty"`

		// Executables Paths to executable binaries, specifying multiple entry points for different platforms when bundled together in a single plugin.
		Executables *struct {
			DarwinAmd64  *string `json:"darwin-amd64,omitempty"`
			LinuxAmd64   *string `json:"linux-amd64,omitempty"`
			WindowsAmd64 *string `json:"windows-amd64,omitempty"`
		} `json:"executables,omitempty"`
	} `json:"server,omitempty"`

	// SettingsSchema Settings schema used to define the System Console UI for the plugin.
	SettingsSchema *map[string]interface{} `json:"settings_schema,omitempty"`

	// Version Version number of the plugin.
	Version *string `json:"version,omitempty"`
	Webapp  *struct {
		// BundlePath Path to the webapp JavaScript bundle.
		BundlePath *string `json:"bundle_path,omitempty"`
	} `json:"webapp,omitempty"`
}

// PluginManifestWebapp defines model for PluginManifestWebapp.
type PluginManifestWebapp struct {
	// Id Globally unique identifier that represents the plugin.
	Id *string `json:"id,omitempty"`

	// Version Version number of the plugin.
	Version *string `json:"version,omitempty"`
	Webapp  *struct {
		// BundlePath Path to the webapp JavaScript bundle.
		BundlePath *string `json:"bundle_path,omitempty"`
	} `json:"webapp,omitempty"`
}

// PluginStatus defines model for PluginStatus.
type PluginStatus struct {
	// ClusterId ID of the cluster in which plugin is running
	ClusterId *string `json:"cluster_id,omitempty"`

	// Description Description of what the plugin is and does.
	Description *string `json:"description,omitempty"`

	// Name Name of the plugin.
	Name *string `json:"name,omitempty"`

	// PluginId Globally unique identifier that represents the plugin.
	PluginId *string `json:"plugin_id,omitempty"`

	// PluginPath Path to the plugin on the server
	PluginPath *string `json:"plugin_path,omitempty"`

	// State State of the plugin
	State *PluginStatusState `json:"state,omitempty"`

	// Version Version number of the plugin.
	Version *string `json:"version,omitempty"`
}

// PluginStatusState State of the plugin
type PluginStatusState float32

// Post defines model for Post.
type Post struct {
	ChannelId *string `json:"channel_id,omitempty"`

	// CreateAt The time in milliseconds a post was created
	CreateAt *int `json:"create_at,omitempty"`

	// DeleteAt The time in milliseconds a post was deleted
	DeleteAt *int      `json:"delete_at,omitempty"`
	EditAt   *int      `json:"edit_at,omitempty"`
	FileIds  *[]string `json:"file_ids,omitempty"`
	Hashtag  *string   `json:"hashtag,omitempty"`
	Id       *string   `json:"id,omitempty"`
	Message  *string   `json:"message,omitempty"`

	// Metadata Additional information used to display a post.
	Metadata      *PostMetadata           `json:"metadata,omitempty"`
	OriginalId    *string                 `json:"original_id,omitempty"`
	PendingPostId *string                 `json:"pending_post_id,omitempty"`
	Props         *map[string]interface{} `json:"props,omitempty"`
	RootId        *string                 `json:"root_id,omitempty"`
	Type          *string                 `json:"type,omitempty"`

	// UpdateAt The time in milliseconds a post was last updated
	UpdateAt *int    `json:"update_at,omitempty"`
	UserId   *string `json:"user_id,omitempty"`
}

// PostAcknowledgement defines model for PostAcknowledgement.
type PostAcknowledgement struct {
	// AcknowledgedAt The time in milliseconds in which this acknowledgement was made.
	AcknowledgedAt *int `json:"acknowledged_at,omitempty"`

	// PostId The ID of the post to which this acknowledgement was made.
	PostId *string `json:"post_id,omitempty"`

	// UserId The ID of the user that made this acknowledgement.
	UserId *string `json:"user_id,omitempty"`
}

// PostIdToReactionsMap defines model for PostIdToReactionsMap.
type PostIdToReactionsMap map[string][]Reaction

// PostList defines model for PostList.
type PostList struct {
	// HasNext Whether there are more items after this page.
	HasNext *bool `json:"has_next,omitempty"`

	// NextPostId The ID of next post. Not omitted when empty or not relevant.
	NextPostId *string          `json:"next_post_id,omitempty"`
	Order      *[]string        `json:"order,omitempty"`
	Posts      *map[string]Post `json:"posts,omitempty"`

	// PrevPostId The ID of previous post. Not omitted when empty or not relevant.
	PrevPostId *string `json:"prev_post_id,omitempty"`
}

// PostListWithSearchMatches defines model for PostListWithSearchMatches.
type PostListWithSearchMatches struct {
	// Matches A mapping of post IDs to a list of matched terms within the post. This field will only be populated on servers running version 5.1 or greater with Elasticsearch enabled.
	Matches *map[string][]string `json:"matches,omitempty"`
	Order   *[]string            `json:"order,omitempty"`
	Posts   *map[string]Post     `json:"posts,omitempty"`
}

// PostMetadata Additional information used to display a post.
type PostMetadata struct {
	// Acknowledgements Any acknowledgements made to this point.
	Acknowledgements *[]PostAcknowledgement `json:"acknowledgements,omitempty"`

	// Embeds Information about content embedded in the post including OpenGraph previews, image link previews, and message attachments. This field will be null if the post does not contain embedded content.
	Embeds *[]struct {
		// Data Any additional information about the embedded content. Only used at this time to store OpenGraph metadata.
		// This field will be null for non-OpenGraph embeds.
		Data *map[string]interface{} `json:"data,omitempty"`

		// Type The type of content that is embedded in this point.
		Type *PostMetadataEmbedsType `json:"type,omitempty"`

		// Url The URL of the embedded content, if one exists.
		Url *string `json:"url,omitempty"`
	} `json:"embeds,omitempty"`

	// Emojis The custom emojis that appear in this point or have been used in reactions to this post. This field will be null if the post does not contain custom emojis.
	Emojis *[]Emoji `json:"emojis,omitempty"`

	// Files The FileInfo objects for any files attached to the post. This field will be null if the post does not have any file attachments.
	Files *[]FileInfo `json:"files,omitempty"`

	// Images An object mapping the URL of an external image to an object containing the dimensions of that image. This field will be null if the post or its embedded content does not reference any external images.
	Images *map[string]interface{} `json:"images,omitempty"`

	// Priority Post priority set for this post. This field will be null if no priority metadata has been set.
	Priority *struct {
		// Priority The priority label of a post, could be either empty, important, or urgent.
		Priority *string `json:"priority,omitempty"`

		// RequestedAck Whether the post author has requested for acknowledgements or not.
		RequestedAck *bool `json:"requested_ack,omitempty"`
	} `json:"priority,omitempty"`

	// Reactions Any reactions made to this point. This field will be null if no reactions have been made to this post.
	Reactions *[]Reaction `json:"reactions,omitempty"`
}

// PostMetadataEmbedsType The type of content that is embedded in this point.
type PostMetadataEmbedsType string

// PostsUsage defines model for PostsUsage.
type PostsUsage struct {
	// Count Total no. of posts
	Count *float32 `json:"count,omitempty"`
}

// Preference defines model for Preference.
type Preference struct {
	Category *string `json:"category,omitempty"`
	Name     *string `json:"name,omitempty"`

	// UserId The ID of the user that owns this preference
	UserId *string `json:"user_id,omitempty"`
	Value  *string `json:"value,omitempty"`
}

// Product defines model for Product.
type Product struct {
	AddOns       *[]AddOn `json:"add_ons,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Id           *string  `json:"id,omitempty"`
	Name         *string  `json:"name,omitempty"`
	PricePerSeat *string  `json:"price_per_seat,omitempty"`
}

// ProductLimits defines model for ProductLimits.
type ProductLimits struct {
	Boards       *BoardsLimits       `json:"boards,omitempty"`
	Files        *FilesLimits        `json:"files,omitempty"`
	Integrations *IntegrationsLimits `json:"integrations,omitempty"`
	Messages     *MessagesLimits     `json:"messages,omitempty"`
	Teams        *TeamsLimits        `json:"teams,omitempty"`
}

// PushNotification defines model for PushNotification.
type PushNotification struct {
	AckId            *string  `json:"ack_id,omitempty"`
	Badge            *float32 `json:"badge,omitempty"`
	Category         *string  `json:"category,omitempty"`
	ChannelId        *string  `json:"channel_id,omitempty"`
	ChannelName      *string  `json:"channel_name,omitempty"`
	ContAva          *float32 `json:"cont_ava,omitempty"`
	DeviceId         *string  `json:"device_id,omitempty"`
	FromWebhook      *string  `json:"from_webhook,omitempty"`
	IsIdLoaded       *bool    `json:"is_id_loaded,omitempty"`
	Message          *string  `json:"message,omitempty"`
	OverrideIconUrl  *string  `json:"override_icon_url,omitempty"`
	OverrideUsername *string  `json:"override_username,omitempty"`
	Platform         *string  `json:"platform,omitempty"`
	PostId           *string  `json:"post_id,omitempty"`
	RootId           *string  `json:"root_id,omitempty"`
	SenderId         *string  `json:"sender_id,omitempty"`
	SenderName       *string  `json:"sender_name,omitempty"`
	ServerId         *string  `json:"server_id,omitempty"`
	Sound            *string  `json:"sound,omitempty"`
	TeamId           *string  `json:"team_id,omitempty"`
	Type             *string  `json:"type,omitempty"`
	Version          *string  `json:"version,omitempty"`
}

// Reaction defines model for Reaction.
type Reaction struct {
	// CreateAt The time in milliseconds this reaction was made
	CreateAt *int `json:"create_at,omitempty"`

	// EmojiName The name of the emoji that was used for this reaction
	EmojiName *string `json:"emoji_name,omitempty"`

	// PostId The ID of the post to which this reaction was made
	PostId *string `json:"post_id,omitempty"`

	// UserId The ID of the user that made this reaction
	UserId *string `json:"user_id,omitempty"`
}

// RelationalIntegrityCheckData an object containing the results of a relational integrity check.
type RelationalIntegrityCheckData struct {
	// ChildIdAttr the name of the attribute (column) containing the child id.
	ChildIdAttr *string `json:"child_id_attr,omitempty"`

	// ChildName the name of the child relation (table).
	ChildName *string `json:"child_name,omitempty"`

	// ParentIdAttr the name of the attribute (column) containing the parent id.
	ParentIdAttr *string `json:"parent_id_attr,omitempty"`

	// ParentName the name of the parent relation (table).
	ParentName *string `json:"parent_name,omitempty"`

	// Records the list of orphaned records found.
	Records *[]OrphanedRecord `json:"records,omitempty"`
}

// RemoteCluster defines model for RemoteCluster.
type RemoteCluster struct {
	// CreateAt Time in milliseconds that the remote cluster was created
	CreateAt  *int    `json:"create_at,omitempty"`
	CreatorId *string `json:"creator_id,omitempty"`

	// DefaultTeamId The team where channels from invites are created
	DefaultTeamId *string `json:"default_team_id,omitempty"`

	// DeleteAt Time in milliseconds that the remote cluster record was deleted
	DeleteAt    *int    `json:"delete_at,omitempty"`
	DisplayName *string `json:"display_name,omitempty"`

	// LastPingAt Time in milliseconds when the last ping to the remote cluster was run
	LastPingAt *int    `json:"last_ping_at,omitempty"`
	Name       *string `json:"name,omitempty"`

	// Options A bitmask with a set of option flags
	Options      *int    `json:"options,omitempty"`
	PluginId     *string `json:"plugin_id,omitempty"`
	RemoteId     *string `json:"remote_id,omitempty"`
	RemoteTeamId *string `json:"remote_team_id,omitempty"`
	RemoteToken  *string `json:"remote_token,omitempty"`

	// SiteUrl URL of the remote cluster
	SiteUrl *string `json:"site_url,omitempty"`
	Token   *string `json:"token,omitempty"`
	Topics  *string `json:"topics,omitempty"`
}

// RemoteClusterInfo defines model for RemoteClusterInfo.
type RemoteClusterInfo struct {
	// CreateAt The time in milliseconds a remote cluster was created
	CreateAt *int `json:"create_at,omitempty"`

	// DisplayName The display name for the remote cluster
	DisplayName *string `json:"display_name,omitempty"`

	// LastPingAt The time in milliseconds a remote cluster was last pinged successfully
	LastPingAt *int `json:"last_ping_at,omitempty"`
}

// RetentionPolicyForChannelList defines model for RetentionPolicyForChannelList.
type RetentionPolicyForChannelList struct {
	// Policies The list of channel policies.
	Policies *[]DataRetentionPolicyForChannel `json:"policies,omitempty"`

	// TotalCount The total number of channel policies.
	TotalCount *int `json:"total_count,omitempty"`
}

// RetentionPolicyForTeamList defines model for RetentionPolicyForTeamList.
type RetentionPolicyForTeamList struct {
	// Policies The list of team policies.
	Policies *[]DataRetentionPolicyForTeam `json:"policies,omitempty"`

	// TotalCount The total number of team policies.
	TotalCount *int `json:"total_count,omitempty"`
}

// Role defines model for Role.
type Role struct {
	// Description A human readable description of the role.
	Description *string `json:"description,omitempty"`

	// DisplayName The human readable name for the role.
	DisplayName *string `json:"display_name,omitempty"`

	// Id The unique identifier of the role.
	Id *string `json:"id,omitempty"`

	// Name The unique name of the role, used when assigning roles to users/groups in contexts.
	Name *string `json:"name,omitempty"`

	// Permissions A list of the unique names of the permissions this role grants.
	Permissions *[]string `json:"permissions,omitempty"`

	// SchemeManaged indicates if this role is managed by a scheme (true), or is a custom stand-alone role (false).
	SchemeManaged *bool `json:"scheme_managed,omitempty"`
}

// SamlCertificateStatus defines model for SamlCertificateStatus.
type SamlCertificateStatus struct {
	// IdpCertificateFile Status is good when `true`
	IdpCertificateFile *bool `json:"idp_certificate_file,omitempty"`

	// PrivateKeyFile Status is good when `true`
	PrivateKeyFile *bool `json:"private_key_file,omitempty"`

	// PublicCertificateFile Status is good when `true`
	PublicCertificateFile *bool `json:"public_certificate_file,omitempty"`
}

// ScheduledPost defines model for ScheduledPost.
type ScheduledPost struct {
	ChannelId *string `json:"channel_id,omitempty"`

	// CreateAt The time in milliseconds a scheduled post was created
	CreateAt *int `json:"create_at,omitempty"`

	// ErrorCode Explains the error behind why a scheduled post could not have been sent
	ErrorCode *string   `json:"error_code,omitempty"`
	FileIds   *[]string `json:"file_ids,omitempty"`
	Id        *string   `json:"id,omitempty"`
	Message   *string   `json:"message,omitempty"`

	// Metadata Additional information used to display a post.
	Metadata *PostMetadata `json:"metadata,omitempty"`

	// ProcessedAt The time in milliseconds a scheduled post was processed at
	ProcessedAt *int                    `json:"processed_at,omitempty"`
	Props       *map[string]interface{} `json:"props,omitempty"`
	RootId      *string                 `json:"root_id,omitempty"`

	// ScheduledAt The time in milliseconds a scheduled post is scheduled to be sent at
	ScheduledAt *int `json:"scheduled_at,omitempty"`

	// UpdateAt The time in milliseconds a scheduled post was last updated
	UpdateAt *int    `json:"update_at,omitempty"`
	UserId   *string `json:"user_id,omitempty"`
}

// Scheme defines model for Scheme.
type Scheme struct {
	// CreateAt The time at which the scheme was created.
	CreateAt *int `json:"create_at,omitempty"`

	// DefaultChannelAdminRole The id of the default channel admin role for this scheme.
	DefaultChannelAdminRole *string `json:"default_channel_admin_role,omitempty"`

	// DefaultChannelUserRole The id of the default channel user role for this scheme.
	DefaultChannelUserRole *string `json:"default_channel_user_role,omitempty"`

	// DefaultTeamAdminRole The id of the default team admin role for this scheme.
	DefaultTeamAdminRole *string `json:"default_team_admin_role,omitempty"`

	// DefaultTeamUserRole The id of the default team user role for this scheme.
	DefaultTeamUserRole *string `json:"default_team_user_role,omitempty"`

	// DeleteAt The time at which the scheme was deleted.
	DeleteAt *int `json:"delete_at,omitempty"`

	// Description A human readable description of the scheme.
	Description *string `json:"description,omitempty"`

	// Id The unique identifier of the scheme.
	Id *string `json:"id,omitempty"`

	// Name The human readable name for the scheme.
	Name *string `json:"name,omitempty"`

	// Scope The scope to which this scheme can be applied, either "team" or "channel".
	Scope *string `json:"scope,omitempty"`

	// UpdateAt The time at which the scheme was last updated.
	UpdateAt *int `json:"update_at,omitempty"`
}

// ServerLimits defines model for ServerLimits.
type ServerLimits struct {
	// ActiveUserCount The number of active users in the server
	ActiveUserCount *int `json:"activeUserCount,omitempty"`

	// MaxUsersLimit The maximum number of users allowed on server
	MaxUsersLimit *int `json:"maxUsersLimit,omitempty"`
}

// ServerBusy defines model for Server_Busy.
type ServerBusy struct {
	// Busy True if the server is marked as busy (under high load)
	Busy *bool `json:"busy,omitempty"`

	// Expires timestamp - number of seconds since Jan 1, 1970 UTC.
	Expires *int `json:"expires,omitempty"`
}

// Session defines model for Session.
type Session struct {
	// CreateAt The time in milliseconds a session was created
	CreateAt *int    `json:"create_at,omitempty"`
	DeviceId *string `json:"device_id,omitempty"`

	// ExpiresAt The time in milliseconds a session will expire
	ExpiresAt *int    `json:"expires_at,omitempty"`
	Id        *string `json:"id,omitempty"`
	IsOauth   *bool   `json:"is_oauth,omitempty"`

	// LastActivityAt The time in milliseconds of the last activity of a session
	LastActivityAt *int                    `json:"last_activity_at,omitempty"`
	Props          *map[string]interface{} `json:"props,omitempty"`
	Roles          *string                 `json:"roles,omitempty"`
	TeamMembers    *[]TeamMember           `json:"team_members,omitempty"`
	Token          *string                 `json:"token,omitempty"`
	UserId         *string                 `json:"user_id,omitempty"`
}

// SharedChannel defines model for SharedChannel.
type SharedChannel struct {
	// CreateAt Time in milliseconds that the channel was shared
	CreateAt *int `json:"create_at,omitempty"`

	// CreatorId Id of the user that shared the channel
	CreatorId *string `json:"creator_id,omitempty"`

	// DisplayName Channel display name as it appears locally
	DisplayName *string `json:"display_name,omitempty"`
	Header      *string `json:"header,omitempty"`

	// Home Is this the home cluster for the shared channel
	Home *bool `json:"home,omitempty"`

	// Id Channel id of the shared channel
	Id *string `json:"id,omitempty"`

	// Name Channel name as it is shared (may be different than original channel name)
	Name    *string `json:"name,omitempty"`
	Purpose *string `json:"purpose,omitempty"`

	// Readonly Is this shared channel shared as read only
	Readonly *bool `json:"readonly,omitempty"`

	// RemoteId Id of the remote cluster where the shared channel is homed
	RemoteId *string `json:"remote_id,omitempty"`
	TeamId   *string `json:"team_id,omitempty"`

	// UpdateAt Time in milliseconds that the shared channel record was last updated
	UpdateAt *int `json:"update_at,omitempty"`
}

// SharedChannelRemote defines model for SharedChannelRemote.
type SharedChannelRemote struct {
	// ChannelId The id of the channel
	ChannelId *string `json:"channel_id,omitempty"`

	// CreateAt Time in milliseconds that the remote was invited to the channel
	CreateAt *int `json:"create_at,omitempty"`

	// CreatorId Id of the user that invited the remote to share the channel
	CreatorId *string `json:"creator_id,omitempty"`

	// DeleteAt Time in milliseconds that the shared chanenl remote record was deleted
	DeleteAt *int `json:"delete_at,omitempty"`

	// Id The id of the shared channel remote
	Id *string `json:"id,omitempty"`

	// IsInviteAccepted Indicates if the invite has been accepted by the remote
	IsInviteAccepted *bool `json:"is_invite_accepted,omitempty"`

	// IsInviteConfirmed Indicates if the invite has been confirmed by the remote
	IsInviteConfirmed *bool `json:"is_invite_confirmed,omitempty"`

	// LastPostCreateAt Time in milliseconds of the last post in the channel that was synchronized with the remote create_at
	LastPostCreateAt *string `json:"last_post_create_at,omitempty"`
	LastPostCreateId *string `json:"last_post_create_id,omitempty"`

	// LastPostId Id of the last post in the channel that was synchronized with the remote
	LastPostId *string `json:"last_post_id,omitempty"`

	// LastPostUpdateAt Time in milliseconds of the last post in the channel that was synchronized with the remote update_at
	LastPostUpdateAt *int `json:"last_post_update_at,omitempty"`

	// RemoteId Id of the remote cluster that the channel is shared with
	RemoteId *string `json:"remote_id,omitempty"`

	// UpdateAt Time in milliseconds that the shared channel remote record was last updated
	UpdateAt *int `json:"update_at,omitempty"`
}

// SidebarCategory User's sidebar category
type SidebarCategory struct {
	DisplayName *string              `json:"display_name,omitempty"`
	Id          *string              `json:"id,omitempty"`
	TeamId      *string              `json:"team_id,omitempty"`
	Type        *SidebarCategoryType `json:"type,omitempty"`
	UserId      *string              `json:"user_id,omitempty"`
}

// SidebarCategoryType defines model for SidebarCategory.Type.
type SidebarCategoryType string

// SidebarCategoryWithChannels User's sidebar category with it's channels
type SidebarCategoryWithChannels struct {
	ChannelIds  *[]string                        `json:"channel_ids,omitempty"`
	DisplayName *string                          `json:"display_name,omitempty"`
	Id          *string                          `json:"id,omitempty"`
	TeamId      *string                          `json:"team_id,omitempty"`
	Type        *SidebarCategoryWithChannelsType `json:"type,omitempty"`
	UserId      *string                          `json:"user_id,omitempty"`
}

// SidebarCategoryWithChannelsType defines model for SidebarCategoryWithChannels.Type.
type SidebarCategoryWithChannelsType string

// SlackAttachment defines model for SlackAttachment.
type SlackAttachment struct {
	AuthorIcon *string                 `json:"AuthorIcon,omitempty"`
	AuthorLink *string                 `json:"AuthorLink,omitempty"`
	AuthorName *string                 `json:"AuthorName,omitempty"`
	Color      *string                 `json:"Color,omitempty"`
	Fallback   *string                 `json:"Fallback,omitempty"`
	Fields     *[]SlackAttachmentField `json:"Fields,omitempty"`
	Footer     *string                 `json:"Footer,omitempty"`
	FooterIcon *string                 `json:"FooterIcon,omitempty"`
	Id         *string                 `json:"Id,omitempty"`
	ImageURL   *string                 `json:"ImageURL,omitempty"`
	Pretext    *string                 `json:"Pretext,omitempty"`
	Text       *string                 `json:"Text,omitempty"`
	ThumbURL   *string                 `json:"ThumbURL,omitempty"`

	// Timestamp The timestamp of the slack attachment, either type of string or integer
	Timestamp *string `json:"Timestamp,omitempty"`
	Title     *string `json:"Title,omitempty"`
	TitleLink *string `json:"TitleLink,omitempty"`
}

// SlackAttachmentField defines model for SlackAttachmentField.
type SlackAttachmentField struct {
	Short *bool   `json:"Short,omitempty"`
	Title *string `json:"Title,omitempty"`

	// Value The value of the attachment, set as string but capable with golang interface
	Value *string `json:"Value,omitempty"`
}

// Status defines model for Status.
type Status struct {
	LastActivityAt *int    `json:"last_activity_at,omitempty"`
	Manual         *bool   `json:"manual,omitempty"`
	Status         *string `json:"status,omitempty"`
	UserId         *string `json:"user_id,omitempty"`
}

// StatusOK defines model for StatusOK.
type StatusOK struct {
	// Status Will contain "ok" if the request was successful and there was nothing else to return
	Status *string `json:"status,omitempty"`
}

// StorageUsage defines model for StorageUsage.
type StorageUsage struct {
	// Bytes Total file storage usage for the instance in bytes rounded down to the most significant digit
	Bytes *float32 `json:"bytes,omitempty"`
}

// Subscription defines model for Subscription.
type Subscription struct {
	AddOns     *[]string `json:"add_ons,omitempty"`
	CreateAt   *int      `json:"create_at,omitempty"`
	CustomerId *string   `json:"customer_id,omitempty"`
	Dns        *string   `json:"dns,omitempty"`
	EndAt      *int      `json:"end_at,omitempty"`
	Id         *string   `json:"id,omitempty"`
	ProductId  *string   `json:"product_id,omitempty"`
	Seats      *int      `json:"seats,omitempty"`
	StartAt    *int      `json:"start_at,omitempty"`
}

// System defines model for System.
type System struct {
	// Name System property name
	Name *string `json:"name,omitempty"`

	// Value System property value
	Value *string `json:"value,omitempty"`
}

// SystemStatusResponse defines model for SystemStatusResponse.
type SystemStatusResponse struct {
	// AndroidLatestVersion Latest Android version supported
	AndroidLatestVersion *string `json:"AndroidLatestVersion,omitempty"`

	// AndroidMinVersion Minimum Android version supported
	AndroidMinVersion *string `json:"AndroidMinVersion,omitempty"`

	// CanReceiveNotifications Whether the device id provided can receive notifications ("true", "false" or "unknown"). Included when device_id parameter set.
	CanReceiveNotifications *string `json:"CanReceiveNotifications,omitempty"`

	// DesktopLatestVersion Latest desktop version supported
	DesktopLatestVersion *string `json:"DesktopLatestVersion,omitempty"`

	// DesktopMinVersion Minimum desktop version supported
	DesktopMinVersion *string `json:"DesktopMinVersion,omitempty"`

	// IosLatestVersion Latest iOS version supported
	IosLatestVersion *string `json:"IosLatestVersion,omitempty"`

	// IosMinVersion Minimum iOS version supported
	IosMinVersion *string `json:"IosMinVersion,omitempty"`

	// DatabaseStatus Status of database ("OK" or "UNHEALTHY"). Included when get_server_status parameter set.
	DatabaseStatus *string `json:"database_status,omitempty"`

	// FilestoreStatus Status of filestore ("OK" or "UNHEALTHY"). Included when get_server_status parameter set.
	FilestoreStatus *string `json:"filestore_status,omitempty"`

	// Status Status of server ("OK" or "UNHEALTHY"). Included when get_server_status parameter set.
	Status *string `json:"status,omitempty"`
}

// Team defines model for Team.
type Team struct {
	AllowOpenInvite *bool   `json:"allow_open_invite,omitempty"`
	AllowedDomains  *string `json:"allowed_domains,omitempty"`

	// CreateAt The time in milliseconds a team was created
	CreateAt *int `json:"create_at,omitempty"`

	// DeleteAt The time in milliseconds a team was deleted
	DeleteAt    *int    `json:"delete_at,omitempty"`
	Description *string `json:"description,omitempty"`
	DisplayName *string `json:"display_name,omitempty"`
	Email       *string `json:"email,omitempty"`
	Id          *string `json:"id,omitempty"`
	InviteId    *string `json:"invite_id,omitempty"`
	Name        *string `json:"name,omitempty"`

	// PolicyId The data retention policy to which this team has been assigned. If no such policy exists, or the caller does not have the `sysconsole_read_compliance_data_retention` permission, this field will be null.
	PolicyId *string `json:"policy_id,omitempty"`
	Type     *string `json:"type,omitempty"`

	// UpdateAt The time in milliseconds a team was last updated
	UpdateAt *int `json:"update_at,omitempty"`
}

// TeamExists defines model for TeamExists.
type TeamExists struct {
	Exists *bool `json:"exists,omitempty"`
}

// TeamMember defines model for TeamMember.
type TeamMember struct {
	// DeleteAt The time in milliseconds that this team member was deleted.
	DeleteAt *int `json:"delete_at,omitempty"`

	// ExplicitRoles The list of roles explicitly assigned to this team member, as a space separated list of role names. This list does *not* include any roles granted implicitly through permissions schemes.
	ExplicitRoles *string `json:"explicit_roles,omitempty"`

	// Roles The complete list of roles assigned to this team member, as a space-separated list of role names, including any roles granted implicitly through permissions schemes.
	Roles *string `json:"roles,omitempty"`

	// SchemeAdmin Whether this team member holds the default admin role defined by the team's permissions scheme.
	SchemeAdmin *bool `json:"scheme_admin,omitempty"`

	// SchemeUser Whether this team member holds the default user role defined by the team's permissions scheme.
	SchemeUser *bool `json:"scheme_user,omitempty"`

	// TeamId The ID of the team this member belongs to.
	TeamId *string `json:"team_id,omitempty"`

	// UserId The ID of the user this member relates to.
	UserId *string `json:"user_id,omitempty"`
}

// TeamStats defines model for TeamStats.
type TeamStats struct {
	ActiveMemberCount *int    `json:"active_member_count,omitempty"`
	TeamId            *string `json:"team_id,omitempty"`
	TotalMemberCount  *int    `json:"total_member_count,omitempty"`
}

// TeamUnread defines model for TeamUnread.
type TeamUnread struct {
	MentionCount *int    `json:"mention_count,omitempty"`
	MsgCount     *int    `json:"msg_count,omitempty"`
	TeamId       *string `json:"team_id,omitempty"`
}

// TeamsLimits defines model for TeamsLimits.
type TeamsLimits struct {
	Active *int `json:"active"`
}

// TermsOfService defines model for TermsOfService.
type TermsOfService struct {
	// CreateAt The time at which the terms of service was created.
	CreateAt *int `json:"create_at,omitempty"`

	// Id The unique identifier of the terms of service.
	Id *string `json:"id,omitempty"`

	// Text The text of terms of service. Supports Markdown.
	Text *string `json:"text,omitempty"`

	// UserId The unique identifier of the user who created these terms of service.
	UserId *string `json:"user_id,omitempty"`
}

// Timezone defines model for Timezone.
type Timezone struct {
	// AutomaticTimezone This value is set automatically when the "useAutomaticTimezone" is set to "true".
	AutomaticTimezone *string `json:"automaticTimezone,omitempty"`

	// ManualTimezone Value when setting manually the timezone, i.e. "Europe/Berlin".
	ManualTimezone *string `json:"manualTimezone,omitempty"`

	// UseAutomaticTimezone Set to "true" to use the browser/system timezone, "false" to set manually. Defaults to "true".
	UseAutomaticTimezone *bool `json:"useAutomaticTimezone,omitempty"`
}

// TriggerIdReturn defines model for TriggerIdReturn.
type TriggerIdReturn struct {
	// TriggerId The trigger_id returned by the slash command.
	TriggerId string `json:"trigger_id"`
}

// UpdateChannelBookmarkResponse defines model for UpdateChannelBookmarkResponse.
type UpdateChannelBookmarkResponse struct {
	Deleted *ChannelBookmarkWithFileInfo `json:"deleted,omitempty"`
	Updated *ChannelBookmarkWithFileInfo `json:"updated,omitempty"`
}

// UploadSession an object containing information used to keep track of a file upload.
type UploadSession struct {
	// ChannelId The ID of the channel to upload to.
	ChannelId *string `json:"channel_id,omitempty"`

	// CreateAt The time the upload was created in milliseconds.
	CreateAt *int `json:"create_at,omitempty"`

	// FileOffset The amount of data uploaded in bytes.
	FileOffset *int `json:"file_offset,omitempty"`

	// FileSize The size of the file to upload in bytes.
	FileSize *int `json:"file_size,omitempty"`

	// Filename The name of the file to upload.
	Filename *string `json:"filename,omitempty"`

	// Id The unique identifier for the upload.
	Id *string `json:"id,omitempty"`

	// Type The type of the upload.
	Type *UploadSessionType `json:"type,omitempty"`

	// UserId The ID of the user performing the upload.
	UserId *string `json:"user_id,omitempty"`
}

// UploadSessionType The type of the upload.
type UploadSessionType string

// User defines model for User.
type User struct {
	AuthService *string `json:"auth_service,omitempty"`

	// CreateAt The time in milliseconds a user was created
	CreateAt *int `json:"create_at,omitempty"`

	// DeleteAt The time in milliseconds a user was deleted
	DeleteAt           *int                    `json:"delete_at,omitempty"`
	Email              *string                 `json:"email,omitempty"`
	EmailVerified      *bool                   `json:"email_verified,omitempty"`
	FailedAttempts     *int                    `json:"failed_attempts,omitempty"`
	FirstName          *string                 `json:"first_name,omitempty"`
	Id                 *string                 `json:"id,omitempty"`
	LastName           *string                 `json:"last_name,omitempty"`
	LastPasswordUpdate *int                    `json:"last_password_update,omitempty"`
	LastPictureUpdate  *int                    `json:"last_picture_update,omitempty"`
	Locale             *string                 `json:"locale,omitempty"`
	MfaActive          *bool                   `json:"mfa_active,omitempty"`
	Nickname           *string                 `json:"nickname,omitempty"`
	NotifyProps        *UserNotifyProps        `json:"notify_props,omitempty"`
	Props              *map[string]interface{} `json:"props,omitempty"`
	Roles              *string                 `json:"roles,omitempty"`

	// TermsOfServiceCreateAt The time in milliseconds the user accepted the terms of service
	TermsOfServiceCreateAt *int `json:"terms_of_service_create_at,omitempty"`

	// TermsOfServiceId ID of accepted terms of service, if any. This field is not present if empty.
	TermsOfServiceId *string   `json:"terms_of_service_id,omitempty"`
	Timezone         *Timezone `json:"timezone,omitempty"`

	// UpdateAt The time in milliseconds a user was last updated
	UpdateAt *int    `json:"update_at,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserAccessToken defines model for UserAccessToken.
type UserAccessToken struct {
	// Description A description of the token usage
	Description *string `json:"description,omitempty"`

	// Id Unique identifier for the token
	Id *string `json:"id,omitempty"`

	// Token The token used for authentication
	Token *string `json:"token,omitempty"`

	// UserId The user the token authenticates for
	UserId *string `json:"user_id,omitempty"`
}

// UserAccessTokenSanitized defines model for UserAccessTokenSanitized.
type UserAccessTokenSanitized struct {
	// Description A description of the token usage
	Description *string `json:"description,omitempty"`

	// Id Unique identifier for the token
	Id *string `json:"id,omitempty"`

	// IsActive Indicates whether the token is active
	IsActive *bool `json:"is_active,omitempty"`

	// UserId The user the token authenticates for
	UserId *string `json:"user_id,omitempty"`
}

// UserAuthData defines model for UserAuthData.
type UserAuthData struct {
	// AuthData Service-specific authentication data
	AuthData string `json:"auth_data"`

	// AuthService The authentication service such as "email", "gitlab", or "ldap"
	AuthService string `json:"auth_service"`
}

// UserAutocomplete defines model for UserAutocomplete.
type UserAutocomplete struct {
	// OutOfChannel A special case list of users returned when autocompleting in a specific channel. Omitted when empty or not relevant
	OutOfChannel *[]User `json:"out_of_channel,omitempty"`

	// Users A list of users that are the main result of the query
	Users *[]User `json:"users,omitempty"`
}

// UserNotifyProps defines model for UserNotifyProps.
type UserNotifyProps struct {
	// Channel Set to "true" to enable channel-wide notifications (@channel, @all, etc.), "false" to disable. Defaults to "true".
	Channel *string `json:"channel,omitempty"`

	// Desktop Set to "all" to receive desktop notifications for all activity, "mention" for mentions and direct messages only, and "none" to disable. Defaults to "all".
	Desktop *string `json:"desktop,omitempty"`

	// DesktopSound Set to "true" to enable sound on desktop notifications, "false" to disable. Defaults to "true".
	DesktopSound *string `json:"desktop_sound,omitempty"`

	// Email Set to "true" to enable email notifications, "false" to disable. Defaults to "true".
	Email *string `json:"email,omitempty"`

	// FirstName Set to "true" to enable mentions for first name. Defaults to "true" if a first name is set, "false" otherwise.
	FirstName *string `json:"first_name,omitempty"`

	// MentionKeys A comma-separated list of words to count as mentions. Defaults to username and @username.
	MentionKeys *string `json:"mention_keys,omitempty"`

	// Push Set to "all" to receive push notifications for all activity, "mention" for mentions and direct messages only, and "none" to disable. Defaults to "mention".
	Push *string `json:"push,omitempty"`
}

// UserReport defines model for UserReport.
type UserReport struct {
	AuthData    *string `json:"auth_data,omitempty"`
	AuthService *string `json:"auth_service,omitempty"`

	// CreateAt The time in milliseconds a user was created
	CreateAt *int `json:"create_at,omitempty"`

	// DaysActive Total number of days a user posted within the given date range
	DaysActive *int `json:"days_active,omitempty"`

	// DeleteAt The time in milliseconds a user was deleted
	DeleteAt            *int    `json:"delete_at,omitempty"`
	DisableWelcomeEmail *bool   `json:"disable_welcome_email,omitempty"`
	Email               *string `json:"email,omitempty"`
	FirstName           *string `json:"first_name,omitempty"`
	Id                  *string `json:"id,omitempty"`

	// LastLogin Last time the user was logged in
	LastLogin *int    `json:"last_login,omitempty"`
	LastName  *string `json:"last_name,omitempty"`

	// LastPostDate Last time the user made a post within the given date range
	LastPostDate *int `json:"last_post_date,omitempty"`

	// LastStatusAt Last time the user's status was updated
	LastStatusAt *int      `json:"last_status_at,omitempty"`
	Locale       *string   `json:"locale,omitempty"`
	Nickname     *string   `json:"nickname,omitempty"`
	Position     *string   `json:"position,omitempty"`
	Roles        *string   `json:"roles,omitempty"`
	Timezone     *Timezone `json:"timezone,omitempty"`

	// TotalPosts Total number of posts made by a user within the given date range
	TotalPosts *int `json:"total_posts,omitempty"`

	// UpdateAt The time in milliseconds a user was last updated
	UpdateAt *int    `json:"update_at,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserTermsOfService defines model for UserTermsOfService.
type UserTermsOfService struct {
	// CreateAt The time in milliseconds that this action was performed.
	CreateAt *int `json:"create_at,omitempty"`

	// TermsOfServiceId The unique identifier of the terms of service the action was performed on.
	TermsOfServiceId *string `json:"terms_of_service_id,omitempty"`

	// UserId The unique identifier of the user who performed this terms of service action.
	UserId *string `json:"user_id,omitempty"`
}

// UserThread a thread that user is following
type UserThread struct {
	// Id ID of the post that is this thread's root
	Id *string `json:"id,omitempty"`

	// LastReplyAt timestamp of the last post to this thread
	LastReplyAt *int `json:"last_reply_at,omitempty"`

	// LastViewedAt timestamp of the last time the user viewed this thread
	LastViewedAt *int `json:"last_viewed_at,omitempty"`

	// Participants list of users participating in this thread. only includes IDs unless 'extended' was set to 'true'
	Participants *[]Post `json:"participants,omitempty"`
	Post         *Post   `json:"post,omitempty"`

	// ReplyCount number of replies in this thread
	ReplyCount *int `json:"reply_count,omitempty"`
}

// UserThreads defines model for UserThreads.
type UserThreads struct {
	// Threads Array of threads
	Threads *[]UserThread `json:"threads,omitempty"`

	// Total Total number of threads (used for paging)
	Total *int `json:"total,omitempty"`
}

// UsersStats defines model for UsersStats.
type UsersStats struct {
	TotalUsersCount *int `json:"total_users_count,omitempty"`
}

// WebhookOnCreationPayload defines model for WebhookOnCreationPayload.
type WebhookOnCreationPayload struct {
	// ActiveStage Zero-based index of the currently active stage.
	ActiveStage *int32 `json:"active_stage,omitempty"`

	// ActiveStageTitle The title of the currently active stage.
	ActiveStageTitle *string `json:"active_stage_title,omitempty"`

	// ChannelId The identifier of the playbook run's channel.
	ChannelId *string `json:"channel_id,omitempty"`

	// ChannelUrl Absolute URL to the playbook run's channel.
	ChannelUrl *string      `json:"channel_url,omitempty"`
	Checklists *[]Checklist `json:"checklists,omitempty"`

	// CreateAt The playbook run creation timestamp, formatted as the number of milliseconds since the Unix epoch.
	CreateAt *int `json:"create_at,omitempty"`

	// DeleteAt The playbook run deletion timestamp, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the playbook run is not deleted.
	DeleteAt *int `json:"delete_at,omitempty"`

	// Description The description of the playbook run.
	Description *string `json:"description,omitempty"`

	// DetailsUrl Absolute URL to the playbook run's details.
	DetailsUrl *string `json:"details_url,omitempty"`

	// EndAt The playbook run finish timestamp, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the playbook run is not finished.
	EndAt *int `json:"end_at,omitempty"`

	// Id A unique, 26 characters long, alphanumeric identifier for the playbook run.
	Id *string `json:"id,omitempty"`

	// IsActive True if the playbook run is ongoing; false if the playbook run is ended.
	IsActive *bool `json:"is_active,omitempty"`

	// Name The name of the playbook run.
	Name *string `json:"name,omitempty"`

	// OwnerUserId The identifier of the user that is commanding the playbook run.
	OwnerUserId *string `json:"owner_user_id,omitempty"`

	// PlaybookId The identifier of the playbook with from which this playbook run was created.
	PlaybookId *string `json:"playbook_id,omitempty"`

	// PostId If the playbook run was created from a post, this field contains the identifier of such post. If not, this field is empty.
	PostId *string `json:"post_id,omitempty"`

	// TeamId The identifier of the team where the playbook run's channel is in.
	TeamId *string `json:"team_id,omitempty"`
}

// WebhookOnStatusUpdatePayload defines model for WebhookOnStatusUpdatePayload.
type WebhookOnStatusUpdatePayload struct {
	// ActiveStage Zero-based index of the currently active stage.
	ActiveStage *int32 `json:"active_stage,omitempty"`

	// ActiveStageTitle The title of the currently active stage.
	ActiveStageTitle *string `json:"active_stage_title,omitempty"`

	// ChannelId The identifier of the playbook run's channel.
	ChannelId *string `json:"channel_id,omitempty"`

	// ChannelUrl Absolute URL to the playbook run's channel.
	ChannelUrl *string      `json:"channel_url,omitempty"`
	Checklists *[]Checklist `json:"checklists,omitempty"`

	// CreateAt The playbook run creation timestamp, formatted as the number of milliseconds since the Unix epoch.
	CreateAt *int `json:"create_at,omitempty"`

	// DeleteAt The playbook run deletion timestamp, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the playbook run is not deleted.
	DeleteAt *int `json:"delete_at,omitempty"`

	// Description The description of the playbook run.
	Description *string `json:"description,omitempty"`

	// DetailsUrl Absolute URL to the playbook run's details.
	DetailsUrl *string `json:"details_url,omitempty"`

	// EndAt The playbook run finish timestamp, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the playbook run is not finished.
	EndAt *int `json:"end_at,omitempty"`

	// Id A unique, 26 characters long, alphanumeric identifier for the playbook run.
	Id *string `json:"id,omitempty"`

	// IsActive True if the playbook run is ongoing; false if the playbook run is ended.
	IsActive *bool `json:"is_active,omitempty"`

	// Name The name of the playbook run.
	Name *string `json:"name,omitempty"`

	// OwnerUserId The identifier of the user that is commanding the playbook run.
	OwnerUserId *string `json:"owner_user_id,omitempty"`

	// PlaybookId The identifier of the playbook with from which this playbook run was created.
	PlaybookId *string `json:"playbook_id,omitempty"`

	// PostId If the playbook run was created from a post, this field contains the identifier of such post. If not, this field is empty.
	PostId *string `json:"post_id,omitempty"`

	// TeamId The identifier of the team where the playbook run's channel is in.
	TeamId *string `json:"team_id,omitempty"`
}

// N400 defines model for 400.
type N400 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N500 defines model for 500.
type N500 = Error

// BadGateway defines model for BadGateway.
type BadGateway = AppError

// BadRequest defines model for BadRequest.
type BadRequest = AppError

// Forbidden defines model for Forbidden.
type Forbidden = AppError

// InternalServerError defines model for InternalServerError.
type InternalServerError = AppError

// NotFound defines model for NotFound.
type NotFound = AppError

// NotImplemented defines model for NotImplemented.
type NotImplemented = AppError

// TooLarge defines model for TooLarge.
type TooLarge = AppError

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = AppError

// Unauthorized defines model for Unauthorized.
type Unauthorized = AppError

// OpenInteractiveDialogJSONBody defines parameters for OpenInteractiveDialog.
type OpenInteractiveDialogJSONBody struct {
	// Dialog Post object to create
	Dialog struct {
		// CallbackId Set an ID that will be included when the dialog is submitted
		CallbackId *string `json:"callback_id,omitempty"`

		// Elements Input elements, see https://docs.mattermost.com/developer/interactive-dialogs.html#elements
		Elements []map[string]interface{} `json:"elements"`

		// IntroductionText Markdown formatted introductory paragraph
		IntroductionText *string `json:"introduction_text,omitempty"`

		// NotifyOnCancel Set true to receive payloads when user cancels a dialog
		NotifyOnCancel *bool `json:"notify_on_cancel,omitempty"`

		// State Set some state to be echoed back with the dialog submission
		State *string `json:"state,omitempty"`

		// SubmitLabel Label on the submit button
		SubmitLabel *string `json:"submit_label,omitempty"`

		// Title Title of the dialog
		Title string `json:"title"`
	} `json:"dialog"`

	// TriggerId Trigger ID provided by other action
	TriggerId string `json:"trigger_id"`

	// Url The URL to send the submitted dialog payload to
	Url string `json:"url"`
}

// SubmitInteractiveDialogJSONBody defines parameters for SubmitInteractiveDialog.
type SubmitInteractiveDialogJSONBody struct {
	// CallbackId Callback ID sent when the dialog was opened
	CallbackId *string `json:"callback_id,omitempty"`

	// Cancelled Set to true if the dialog was cancelled
	Cancelled *bool `json:"cancelled,omitempty"`

	// ChannelId Channel ID the user submitted the dialog from
	ChannelId string `json:"channel_id"`

	// State State sent when the dialog was opened
	State *string `json:"state,omitempty"`

	// Submission String map where keys are element names and values are the element input values
	Submission map[string]interface{} `json:"submission"`

	// TeamId Team ID the user submitted the dialog from
	TeamId string `json:"team_id"`

	// Url The URL to send the submitted dialog payload to
	Url string `json:"url"`
}

// GetAnalyticsOldParams defines parameters for GetAnalyticsOld.
type GetAnalyticsOldParams struct {
	// Name Possible values are "standard", "bot_post_counts_day", "post_counts_day", "user_counts_with_posts_day" or "extra_counts"
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// TeamId The team ID to filter the data by
	TeamId *string `form:"team_id,omitempty" json:"team_id,omitempty"`
}

// GetAuditsParams defines parameters for GetAudits.
type GetAuditsParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of audits per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetBotsParams defines parameters for GetBots.
type GetBotsParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of users per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// IncludeDeleted If deleted bots should be returned.
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`

	// OnlyOrphaned When true, only orphaned bots will be returned. A bot is considered orphaned if its owner has been deactivated.
	OnlyOrphaned *bool `form:"only_orphaned,omitempty" json:"only_orphaned,omitempty"`
}

// CreateBotJSONBody defines parameters for CreateBot.
type CreateBotJSONBody struct {
	Description *string `json:"description,omitempty"`
	DisplayName *string `json:"display_name,omitempty"`
	Username    string  `json:"username"`
}

// GetBotParams defines parameters for GetBot.
type GetBotParams struct {
	// IncludeDeleted If deleted bots should be returned.
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`
}

// PatchBotJSONBody defines parameters for PatchBot.
type PatchBotJSONBody struct {
	Description *string `json:"description,omitempty"`
	DisplayName *string `json:"display_name,omitempty"`
	Username    string  `json:"username"`
}

// ConvertBotToUserJSONBody defines parameters for ConvertBotToUser.
type ConvertBotToUserJSONBody struct {
	Email       *string                 `json:"email,omitempty"`
	FirstName   *string                 `json:"first_name,omitempty"`
	LastName    *string                 `json:"last_name,omitempty"`
	Locale      *string                 `json:"locale,omitempty"`
	Nickname    *string                 `json:"nickname,omitempty"`
	NotifyProps *UserNotifyProps        `json:"notify_props,omitempty"`
	Password    *string                 `json:"password,omitempty"`
	Position    *string                 `json:"position,omitempty"`
	Props       *map[string]interface{} `json:"props,omitempty"`
	Username    *string                 `json:"username,omitempty"`
}

// ConvertBotToUserParams defines parameters for ConvertBotToUser.
type ConvertBotToUserParams struct {
	// SetSystemAdmin Whether to give the user the system admin role.
	SetSystemAdmin *bool `form:"set_system_admin,omitempty" json:"set_system_admin,omitempty"`
}

// SetBotIconImageMultipartBody defines parameters for SetBotIconImage.
type SetBotIconImageMultipartBody struct {
	// Image SVG icon image to be uploaded
	Image openapi_types.File `json:"image"`
}

// UploadBrandImageMultipartBody defines parameters for UploadBrandImage.
type UploadBrandImageMultipartBody struct {
	// Image The image to be uploaded
	Image openapi_types.File `json:"image"`
}

// GetAllChannelsParams defines parameters for GetAllChannels.
type GetAllChannelsParams struct {
	// NotAssociatedToGroup A group id to exclude channels that are associated with that group via GroupChannel records. This can also be left blank with `not_associated_to_group=`.
	NotAssociatedToGroup *string `form:"not_associated_to_group,omitempty" json:"not_associated_to_group,omitempty"`

	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of channels per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// ExcludeDefaultChannels Whether to exclude default channels (ex Town Square, Off-Topic) from the results.
	ExcludeDefaultChannels *bool `form:"exclude_default_channels,omitempty" json:"exclude_default_channels,omitempty"`

	// IncludeDeleted Include channels that have been archived. This correlates to the `DeleteAt` flag being set in the database.
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`

	// IncludeTotalCount Appends a total count of returned channels inside the response object - ex: `{ "channels": [], "total_count" : 0 }`.
	IncludeTotalCount *bool `form:"include_total_count,omitempty" json:"include_total_count,omitempty"`

	// ExcludePolicyConstrained If set to true, channels which are part of a data retention policy will be excluded. The `sysconsole_read_compliance` permission is required to use this parameter.
	// __Minimum server version__: 5.35
	ExcludePolicyConstrained *bool `form:"exclude_policy_constrained,omitempty" json:"exclude_policy_constrained,omitempty"`
}

// CreateChannelJSONBody defines parameters for CreateChannel.
type CreateChannelJSONBody struct {
	// DisplayName The non-unique UI name for the channel
	DisplayName string `json:"display_name"`

	// Header Markdown-formatted text to display in the header of the channel
	Header *string `json:"header,omitempty"`

	// Name The unique handle for the channel, will be present in the channel URL
	Name string `json:"name"`

	// Purpose A short description of the purpose of the channel
	Purpose *string `json:"purpose,omitempty"`

	// TeamId The team ID of the team to create the channel on
	TeamId string `json:"team_id"`

	// Type 'O' for a public channel, 'P' for a private channel
	Type string `json:"type"`
}

// CreateDirectChannelJSONBody defines parameters for CreateDirectChannel.
type CreateDirectChannelJSONBody = []string

// CreateGroupChannelJSONBody defines parameters for CreateGroupChannel.
type CreateGroupChannelJSONBody = []string

// SearchGroupChannelsJSONBody defines parameters for SearchGroupChannels.
type SearchGroupChannelsJSONBody struct {
	// Term The search term to match against the members' usernames of the group channels
	Term string `json:"term"`
}

// ViewChannelJSONBody defines parameters for ViewChannel.
type ViewChannelJSONBody struct {
	// ChannelId The channel ID that is being viewed. Use a blank string to indicate that all channels have lost focus.
	ChannelId string `json:"channel_id"`

	// PrevChannelId The channel ID of the previous channel, used when switching channels. Providing this ID will cause push notifications to clear on the channel being switched to.
	PrevChannelId *string `json:"prev_channel_id,omitempty"`
}

// SearchAllChannelsJSONBody defines parameters for SearchAllChannels.
type SearchAllChannelsJSONBody struct {
	// Deleted Filters results to only return deleted / archived channels
	//
	// __Minimum server version__: 5.26
	Deleted *bool `json:"deleted,omitempty"`

	// ExcludeDefaultChannels Exclude default channels from the results by setting this parameter to true.
	ExcludeDefaultChannels *bool `json:"exclude_default_channels,omitempty"`

	// ExcludeGroupConstrained Filters results to exclude channels constrained to a group
	//
	// __Minimum server version__: 5.26
	ExcludeGroupConstrained *bool `json:"exclude_group_constrained,omitempty"`

	// ExcludePolicyConstrained If set to true, only channels which do not have a granular retention policy assigned to them will be returned. The `sysconsole_read_compliance_data_retention` permission is required to use this parameter.
	// __Minimum server version__: 5.35
	ExcludePolicyConstrained *bool `json:"exclude_policy_constrained,omitempty"`

	// ExcludeRemote If set to true, only returns channels that are local to this server.
	// __Minimum server version__: 10.2
	ExcludeRemote *bool `json:"exclude_remote,omitempty"`

	// GroupConstrained Filters results to only return channels constrained to a group
	//
	// __Minimum server version__: 5.26
	GroupConstrained *bool `json:"group_constrained,omitempty"`

	// IncludeSearchById If set to true, returns channels where given search 'term' matches channel ID.
	// __Minimum server version__: 5.35
	IncludeSearchById *bool `json:"include_search_by_id,omitempty"`

	// NotAssociatedToGroup A group id to exclude channels that are associated to that group via GroupChannel records.
	NotAssociatedToGroup *string `json:"not_associated_to_group,omitempty"`

	// Page The page number to return, if paginated. If this parameter is not present with the `per_page` parameter then the results will be returned un-paged.
	Page *string `json:"page,omitempty"`

	// PerPage The number of entries to return per page, if paginated. If this parameter is not present with the `page` parameter then the results will be returned un-paged.
	PerPage *string `json:"per_page,omitempty"`

	// Private Filters results to only return Private channels, can be used in conjunction with `public` to return both `private` and `public` channels
	//
	// __Minimum server version__: 5.26
	Private *bool `json:"private,omitempty"`

	// Public Filters results to only return Public / Open channels, can be used in conjunction with `private` to return both `public` and `private` channels
	//
	// __Minimum server version__: 5.26
	Public *bool `json:"public,omitempty"`

	// TeamIds Filters results to channels belonging to the given team ids
	//
	// __Minimum server version__: 5.26
	TeamIds *[]string `json:"team_ids,omitempty"`

	// Term The string to search in the channel name, display name, and purpose.
	Term string `json:"term"`
}

// SearchAllChannelsParams defines parameters for SearchAllChannels.
type SearchAllChannelsParams struct {
	// SystemConsole Is the request from system_console. If this is set to true, it filters channels by the logged in user.
	SystemConsole *bool `form:"system_console,omitempty" json:"system_console,omitempty"`
}

// UpdateChannelJSONBody defines parameters for UpdateChannel.
type UpdateChannelJSONBody struct {
	// DisplayName The non-unique UI name for the channel
	DisplayName *string `json:"display_name,omitempty"`

	// Header Markdown-formatted text to display in the header of the channel
	Header *string `json:"header,omitempty"`

	// Id The channel's id, not updatable
	Id string `json:"id"`

	// Name The unique handle for the channel, will be present in the channel URL
	Name *string `json:"name,omitempty"`

	// Purpose A short description of the purpose of the channel
	Purpose *string `json:"purpose,omitempty"`
}

// ListChannelBookmarksForChannelParams defines parameters for ListChannelBookmarksForChannel.
type ListChannelBookmarksForChannelParams struct {
	// BookmarksSince Timestamp to filter the bookmarks with. If set, the
	// endpoint returns bookmarks that have been added, updated
	// or deleted since its value
	BookmarksSince *float32 `form:"bookmarks_since,omitempty" json:"bookmarks_since,omitempty"`
}

// CreateChannelBookmarkJSONBody defines parameters for CreateChannelBookmark.
type CreateChannelBookmarkJSONBody struct {
	// DisplayName The name of the channel bookmark
	DisplayName string `json:"display_name"`

	// Emoji The emoji of the channel bookmark
	Emoji *string `json:"emoji,omitempty"`

	// FileId The ID of the file associated with the channel bookmark. Required for bookmarks of type 'file'
	FileId *string `json:"file_id,omitempty"`

	// ImageUrl The URL of the image associated with the channel bookmark. Optional, only applies for bookmarks of type 'link'
	ImageUrl *string `json:"image_url,omitempty"`

	// LinkUrl The URL associated with the channel bookmark. Required for bookmarks of type 'link'
	LinkUrl *string `json:"link_url,omitempty"`

	// Type * `link` for channel bookmarks that reference a link. `link_url` is requied
	// * `file` for channel bookmarks that reference a file. `file_id` is required
	Type CreateChannelBookmarkJSONBodyType `json:"type"`
}

// CreateChannelBookmarkJSONBodyType defines parameters for CreateChannelBookmark.
type CreateChannelBookmarkJSONBodyType string

// UpdateChannelBookmarkJSONBody defines parameters for UpdateChannelBookmark.
type UpdateChannelBookmarkJSONBody struct {
	// DisplayName The name of the channel bookmark
	DisplayName *string `json:"display_name,omitempty"`

	// Emoji The emoji of the channel bookmark
	Emoji *string `json:"emoji,omitempty"`

	// FileId The ID of the file associated with the channel bookmark. Required for bookmarks of type 'file'
	FileId *string `json:"file_id,omitempty"`

	// ImageUrl The URL of the image associated with the channel bookmark
	ImageUrl *string `json:"image_url,omitempty"`

	// LinkUrl The URL associated with the channel bookmark. Required for type bookmarks of type 'link'
	LinkUrl *string `json:"link_url,omitempty"`

	// SortOrder The order of the channel bookmark
	SortOrder *int `json:"sort_order,omitempty"`

	// Type * `link` for channel bookmarks that reference a link. `link_url` is requied
	// * `file` for channel bookmarks that reference a file. `file_id` is required
	Type *UpdateChannelBookmarkJSONBodyType `json:"type,omitempty"`
}

// UpdateChannelBookmarkJSONBodyType defines parameters for UpdateChannelBookmark.
type UpdateChannelBookmarkJSONBodyType string

// UpdateChannelBookmarkSortOrderJSONBody defines parameters for UpdateChannelBookmarkSortOrder.
type UpdateChannelBookmarkSortOrderJSONBody = float32

// GetGroupsByChannelParams defines parameters for GetGroupsByChannel.
type GetGroupsByChannelParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of groups per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// FilterAllowReference Boolean which filters the group entries with the `allow_reference` attribute set.
	FilterAllowReference *bool `form:"filter_allow_reference,omitempty" json:"filter_allow_reference,omitempty"`
}

// GetChannelMemberCountsByGroupParams defines parameters for GetChannelMemberCountsByGroup.
type GetChannelMemberCountsByGroupParams struct {
	// IncludeTimezones Defines if member timezone counts should be returned or not
	IncludeTimezones *bool `form:"include_timezones,omitempty" json:"include_timezones,omitempty"`
}

// GetChannelMembersParams defines parameters for GetChannelMembers.
type GetChannelMembersParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of members per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// AddChannelMemberJSONBody defines parameters for AddChannelMember.
type AddChannelMemberJSONBody struct {
	// PostRootId The ID of root post where link to add channel member originates
	PostRootId *string `json:"post_root_id,omitempty"`

	// UserId The ID of user to add into the channel, for backwards compatibility.
	UserId *string `json:"user_id,omitempty"`

	// UserIds The IDs of users to add into the channel, required if 'user_id' doess not exist.
	UserIds *[]string `json:"user_ids,omitempty"`
}

// GetChannelMembersByIdsJSONBody defines parameters for GetChannelMembersByIds.
type GetChannelMembersByIdsJSONBody = []string

// UpdateChannelRolesJSONBody defines parameters for UpdateChannelRoles.
type UpdateChannelRolesJSONBody struct {
	Roles string `json:"roles"`
}

// UpdateChannelMemberSchemeRolesJSONBody defines parameters for UpdateChannelMemberSchemeRoles.
type UpdateChannelMemberSchemeRolesJSONBody struct {
	SchemeAdmin bool `json:"scheme_admin"`
	SchemeUser  bool `json:"scheme_user"`
}

// ChannelMembersMinusGroupMembersParams defines parameters for ChannelMembersMinusGroupMembers.
type ChannelMembersMinusGroupMembersParams struct {
	// GroupIds A comma-separated list of group ids.
	GroupIds string `form:"group_ids" json:"group_ids"`

	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of users per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// MoveChannelJSONBody defines parameters for MoveChannel.
type MoveChannelJSONBody struct {
	// Force Remove members those are not member of target team before moving the channel.
	Force  *bool  `json:"force,omitempty"`
	TeamId string `json:"team_id"`
}

// PatchChannelJSONBody defines parameters for PatchChannel.
type PatchChannelJSONBody struct {
	// DisplayName The non-unique UI name for the channel
	DisplayName *string `json:"display_name,omitempty"`

	// Header Markdown-formatted text to display in the header of the channel
	Header *string `json:"header,omitempty"`

	// Name The unique handle for the channel, will be present in the channel URL
	Name *string `json:"name,omitempty"`

	// Purpose A short description of the purpose of the channel
	Purpose *string `json:"purpose,omitempty"`
}

// GetPostsForChannelParams defines parameters for GetPostsForChannel.
type GetPostsForChannelParams struct {
	// Page The page to select
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of posts per page
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Since Provide a non-zero value in Unix time milliseconds to select posts modified after that time
	Since *int `form:"since,omitempty" json:"since,omitempty"`

	// Before A post id to select the posts that came before this one
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// After A post id to select the posts that came after this one
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// IncludeDeleted Whether to include deleted posts or not. Must have system admin permissions.
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`
}

// UpdateChannelPrivacyJSONBody defines parameters for UpdateChannelPrivacy.
type UpdateChannelPrivacyJSONBody struct {
	// Privacy Channel privacy setting: 'O' for a public channel, 'P' for a private channel
	Privacy string `json:"privacy"`
}

// UpdateChannelSchemeJSONBody defines parameters for UpdateChannelScheme.
type UpdateChannelSchemeJSONBody struct {
	// SchemeId The ID of the scheme.
	SchemeId string `json:"scheme_id"`
}

// SubmitPerformanceReportJSONBody defines parameters for SubmitPerformanceReport.
type SubmitPerformanceReportJSONBody struct {
	// ClientId Not currently used
	ClientId *string `json:"client_id,omitempty"`

	// Counters An array of counter metrics to be reported
	Counters *[]struct {
		// Labels Labels to be applied to this metric when recorded by the metrics backend
		Labels *[]string `json:"labels,omitempty"`

		// Metric The name of the counter
		Metric string `json:"metric"`

		// Timestamp The time that the counter was incremented
		Timestamp *int `json:"timestamp,omitempty"`

		// Value The value to increment the counter by
		Value float64 `json:"value"`
	} `json:"counters,omitempty"`

	// End The time in milliseconds of the last metric in this report
	End int `json:"end"`

	// Histograms An array of histogram measurements to be reported
	Histograms *[]struct {
		// Labels Labels to be applied to this metric when recorded by the metrics backend
		Labels *[]string `json:"labels,omitempty"`

		// Metric The name of the measurement
		Metric string `json:"metric"`

		// Timestamp The time that the measurement was taken
		Timestamp *int `json:"timestamp,omitempty"`

		// Value The value of the measurement
		Value float64 `json:"value"`
	} `json:"histograms,omitempty"`

	// Labels Labels to be applied to all metrics when recorded by the metrics backend
	Labels *[]string `json:"labels,omitempty"`

	// Start The time in milliseconds of the first metric in this report
	Start int `json:"start"`

	// Version An identifier for the schema of the data being submitted which currently must be "0.1.0"
	Version string `json:"version"`
}

// UpdateCloudCustomerJSONBody defines parameters for UpdateCloudCustomer.
type UpdateCloudCustomerJSONBody struct {
	ContactFirstName *string `json:"contact_first_name,omitempty"`
	ContactLastName  *string `json:"contact_last_name,omitempty"`
	Email            *string `json:"email,omitempty"`
	Name             *string `json:"name,omitempty"`
	NumEmployees     *string `json:"num_employees,omitempty"`
}

// ConfirmCustomerPaymentMultipartBody defines parameters for ConfirmCustomerPayment.
type ConfirmCustomerPaymentMultipartBody struct {
	StripeSetupIntentId *string `json:"stripe_setup_intent_id,omitempty"`
}

// ListCommandsParams defines parameters for ListCommands.
type ListCommandsParams struct {
	// TeamId The team id.
	TeamId *string `form:"team_id,omitempty" json:"team_id,omitempty"`

	// CustomOnly To get only the custom commands. If set to false will get the custom
	// if the user have access plus the system commands, otherwise just the system commands.
	CustomOnly *bool `form:"custom_only,omitempty" json:"custom_only,omitempty"`
}

// CreateCommandJSONBody defines parameters for CreateCommand.
type CreateCommandJSONBody struct {
	// Method `'P'` for post request, `'G'` for get request
	Method string `json:"method"`

	// TeamId Team ID to where the command should be created
	TeamId string `json:"team_id"`

	// Trigger Activation word to trigger the command
	Trigger string `json:"trigger"`

	// Url The URL that the command will make the request
	Url string `json:"url"`
}

// ExecuteCommandJSONBody defines parameters for ExecuteCommand.
type ExecuteCommandJSONBody struct {
	// ChannelId Channel Id where the command will execute
	ChannelId string `json:"channel_id"`

	// Command The slash command to execute, including parameters. Eg, `'/echo bounces around the room'`
	Command string `json:"command"`
}

// MoveCommandJSONBody defines parameters for MoveCommand.
type MoveCommandJSONBody struct {
	// TeamId Destination teamId
	TeamId *string `json:"team_id,omitempty"`
}

// GetComplianceReportsParams defines parameters for GetComplianceReports.
type GetComplianceReportsParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of reports per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetConfigParams defines parameters for GetConfig.
type GetConfigParams struct {
	// RemoveMasked Remove masked values from the exported configuration.
	//
	// __Minimum server version__: 10.4.0
	RemoveMasked *bool `form:"remove_masked,omitempty" json:"remove_masked,omitempty"`

	// RemoveDefaults Remove default values from the exported configuration.
	//
	// __Minimum server version__: 10.4.0
	RemoveDefaults *string `form:"remove_defaults,omitempty" json:"remove_defaults,omitempty"`
}

// GetClientConfigParams defines parameters for GetClientConfig.
type GetClientConfigParams struct {
	// Format Must be `old`, other formats not implemented yet
	Format string `form:"format" json:"format"`
}

// GetDataRetentionPoliciesParams defines parameters for GetDataRetentionPolicies.
type GetDataRetentionPoliciesParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of policies per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// RemoveChannelsFromRetentionPolicyJSONBody defines parameters for RemoveChannelsFromRetentionPolicy.
type RemoveChannelsFromRetentionPolicyJSONBody = []string

// GetChannelsForRetentionPolicyParams defines parameters for GetChannelsForRetentionPolicy.
type GetChannelsForRetentionPolicyParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of channels per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// AddChannelsToRetentionPolicyJSONBody defines parameters for AddChannelsToRetentionPolicy.
type AddChannelsToRetentionPolicyJSONBody = []string

// SearchChannelsForRetentionPolicyJSONBody defines parameters for SearchChannelsForRetentionPolicy.
type SearchChannelsForRetentionPolicyJSONBody struct {
	// Deleted Filters results to only return deleted / archived channels
	Deleted *bool `json:"deleted,omitempty"`

	// Private Filters results to only return Private channels, can be used in conjunction with `public` to return both `private` and `public` channels
	Private *bool `json:"private,omitempty"`

	// Public Filters results to only return Public / Open channels, can be used in conjunction with `private` to return both `public` and `private` channels
	Public *bool `json:"public,omitempty"`

	// TeamIds Filters results to channels belonging to the given team ids
	TeamIds *[]string `json:"team_ids,omitempty"`

	// Term The string to search in the channel name, display name, and purpose.
	Term *string `json:"term,omitempty"`
}

// RemoveTeamsFromRetentionPolicyJSONBody defines parameters for RemoveTeamsFromRetentionPolicy.
type RemoveTeamsFromRetentionPolicyJSONBody = []string

// GetTeamsForRetentionPolicyParams defines parameters for GetTeamsForRetentionPolicy.
type GetTeamsForRetentionPolicyParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of teams per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// AddTeamsToRetentionPolicyJSONBody defines parameters for AddTeamsToRetentionPolicy.
type AddTeamsToRetentionPolicyJSONBody = []string

// SearchTeamsForRetentionPolicyJSONBody defines parameters for SearchTeamsForRetentionPolicy.
type SearchTeamsForRetentionPolicyJSONBody struct {
	// Term The search term to match against the name or display name of teams
	Term *string `json:"term,omitempty"`
}

// GetEmojiListParams defines parameters for GetEmojiList.
type GetEmojiListParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of emojis per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Sort Either blank for no sorting or "name" to sort by emoji names. Minimum server version for sorting is 4.7.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// CreateEmojiMultipartBody defines parameters for CreateEmoji.
type CreateEmojiMultipartBody struct {
	// Emoji A JSON object containing a `name` field with the name of the emoji and a `creator_id` field with the id of the authenticated user.
	Emoji string `json:"emoji"`

	// Image A file to be uploaded
	Image openapi_types.File `json:"image"`
}

// AutocompleteEmojiParams defines parameters for AutocompleteEmoji.
type AutocompleteEmojiParams struct {
	// Name The emoji name to search.
	Name string `form:"name" json:"name"`
}

// GetEmojisByNamesJSONBody defines parameters for GetEmojisByNames.
type GetEmojisByNamesJSONBody = []string

// SearchEmojiJSONBody defines parameters for SearchEmoji.
type SearchEmojiJSONBody struct {
	// PrefixOnly Set to only search for names starting with the search term.
	PrefixOnly *string `json:"prefix_only,omitempty"`

	// Term The term to match against the emoji name.
	Term string `json:"term"`
}

// UploadFileMultipartBody defines parameters for UploadFile.
type UploadFileMultipartBody struct {
	// ChannelId The ID of the channel that this file will be uploaded to
	ChannelId *string `json:"channel_id,omitempty"`

	// ClientIds A unique identifier for the file that will be returned in the response
	ClientIds *string `json:"client_ids,omitempty"`

	// Files A file to be uploaded
	Files *openapi_types.File `json:"files,omitempty"`
}

// UploadFileParams defines parameters for UploadFile.
type UploadFileParams struct {
	// ChannelId The ID of the channel that this file will be uploaded to
	ChannelId *string `form:"channel_id,omitempty" json:"channel_id,omitempty"`

	// Filename The name of the file to be uploaded
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// SearchFilesMultipartBody defines parameters for SearchFiles.
type SearchFilesMultipartBody struct {
	// IncludeDeletedChannels Set to true if deleted channels should be included in the search. (archived channels)
	IncludeDeletedChannels *bool `json:"include_deleted_channels,omitempty"`

	// IsOrSearch Set to true if an Or search should be performed vs an And search.
	IsOrSearch bool `json:"is_or_search"`

	// Page The page to select. (Only works with Elasticsearch)
	Page *int `json:"page,omitempty"`

	// PerPage The number of posts per page. (Only works with Elasticsearch)
	PerPage *int `json:"per_page,omitempty"`

	// Terms The search terms as entered by the user. To search for files from a user include `from:someusername`, using a user's username. To search in a specific channel include `in:somechannel`, using the channel name (not the display name). To search for specific extensions include `ext:extension`.
	Terms string `json:"terms"`

	// TimeZoneOffset Offset from UTC of user timezone for date searches.
	TimeZoneOffset *int `json:"time_zone_offset,omitempty"`
}

// GetGroupsParams defines parameters for GetGroups.
type GetGroupsParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of groups per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Q String to pattern match the `name` and `display_name` field. Will return all groups whose `name` and `display_name` field match any of the text.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// IncludeMemberCount Boolean which adds the `member_count` attribute to each group JSON object
	IncludeMemberCount *bool `form:"include_member_count,omitempty" json:"include_member_count,omitempty"`

	// NotAssociatedToTeam Team GUID which is used to return all the groups not associated to this team
	NotAssociatedToTeam string `form:"not_associated_to_team" json:"not_associated_to_team"`

	// NotAssociatedToChannel Group GUID which is used to return all the groups not associated to this channel
	NotAssociatedToChannel string `form:"not_associated_to_channel" json:"not_associated_to_channel"`

	// Since Only return groups that have been modified since the given Unix timestamp (in milliseconds). All modified groups, including deleted and created groups, will be returned.
	// __Minimum server version__: 5.24
	Since *int `form:"since,omitempty" json:"since,omitempty"`

	// FilterAllowReference Boolean which filters the group entries with the `allow_reference` attribute set.
	FilterAllowReference *bool `form:"filter_allow_reference,omitempty" json:"filter_allow_reference,omitempty"`
}

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody struct {
	// Group Group object to create.
	Group struct {
		// AllowReference Must be true
		AllowReference bool `json:"allow_reference"`

		// DisplayName The display name of the group which can include spaces.
		DisplayName string `json:"display_name"`

		// Name The unique group name used for at-mentioning.
		Name string `json:"name"`

		// Source Must be `custom`
		Source string `json:"source"`
	} `json:"group"`

	// UserIds The user ids of the group members to add.
	UserIds []string `json:"user_ids"`
}

// PatchGroupSyncableForChannelJSONBody defines parameters for PatchGroupSyncableForChannel.
type PatchGroupSyncableForChannelJSONBody struct {
	AutoAdd *bool `json:"auto_add,omitempty"`
}

// DeleteGroupMembersJSONBody defines parameters for DeleteGroupMembers.
type DeleteGroupMembersJSONBody struct {
	UserIds *[]string `json:"user_ids,omitempty"`
}

// GetGroupUsersParams defines parameters for GetGroupUsers.
type GetGroupUsersParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of groups per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// AddGroupMembersJSONBody defines parameters for AddGroupMembers.
type AddGroupMembersJSONBody struct {
	UserIds *[]string `json:"user_ids,omitempty"`
}

// PatchGroupJSONBody defines parameters for PatchGroup.
type PatchGroupJSONBody struct {
	Description *string `json:"description,omitempty"`
	DisplayName *string `json:"display_name,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// PatchGroupSyncableForTeamJSONBody defines parameters for PatchGroupSyncableForTeam.
type PatchGroupSyncableForTeamJSONBody struct {
	AutoAdd *bool `json:"auto_add,omitempty"`
}

// GetIncomingWebhooksParams defines parameters for GetIncomingWebhooks.
type GetIncomingWebhooksParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of hooks per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// TeamId The ID of the team to get hooks for.
	TeamId *string `form:"team_id,omitempty" json:"team_id,omitempty"`

	// IncludeTotalCount Appends a total count of returned hooks inside the response object - ex: `{ "incoming_webhooks": [], "total_count": 0 }`.
	IncludeTotalCount *bool `form:"include_total_count,omitempty" json:"include_total_count,omitempty"`
}

// CreateIncomingWebhookJSONBody defines parameters for CreateIncomingWebhook.
type CreateIncomingWebhookJSONBody struct {
	// ChannelId The ID of a public channel or private group that receives the webhook payloads.
	ChannelId string `json:"channel_id"`

	// Description The description for this incoming webhook
	Description *string `json:"description,omitempty"`

	// DisplayName The display name for this incoming webhook
	DisplayName *string `json:"display_name,omitempty"`

	// IconUrl The profile picture this incoming webhook will use when posting.
	IconUrl *string `json:"icon_url,omitempty"`

	// UserId The ID of the owner of the webhook if different than the requester. Required for [local mode](https://docs.mattermost.com/administration/mmctl-cli-tool.html#local-mode).
	UserId *string `json:"user_id,omitempty"`

	// Username The username this incoming webhook will post as.
	Username *string `json:"username,omitempty"`
}

// UpdateIncomingWebhookJSONBody defines parameters for UpdateIncomingWebhook.
type UpdateIncomingWebhookJSONBody struct {
	// ChannelId The ID of a public channel or private group that receives the webhook payloads.
	ChannelId string `json:"channel_id"`

	// Description The description for this incoming webhook
	Description string `json:"description"`

	// DisplayName The display name for this incoming webhook
	DisplayName string `json:"display_name"`

	// IconUrl The profile picture this incoming webhook will use when posting.
	IconUrl *string `json:"icon_url,omitempty"`

	// Id Incoming webhook GUID
	Id string `json:"id"`

	// Username The username this incoming webhook will post as.
	Username *string `json:"username,omitempty"`
}

// GetOutgoingWebhooksParams defines parameters for GetOutgoingWebhooks.
type GetOutgoingWebhooksParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of hooks per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// TeamId The ID of the team to get hooks for.
	TeamId *string `form:"team_id,omitempty" json:"team_id,omitempty"`

	// ChannelId The ID of the channel to get hooks for.
	ChannelId *string `form:"channel_id,omitempty" json:"channel_id,omitempty"`
}

// CreateOutgoingWebhookJSONBody defines parameters for CreateOutgoingWebhook.
type CreateOutgoingWebhookJSONBody struct {
	// CallbackUrls The URLs to POST the payloads to when the webhook is triggered
	CallbackUrls []string `json:"callback_urls"`

	// ChannelId The ID of a public channel that the webhook watchs
	ChannelId *string `json:"channel_id,omitempty"`

	// ContentType The format to POST the data in, either `application/json` or `application/x-www-form-urlencoded`
	ContentType *string `json:"content_type,omitempty"`

	// CreatorId The ID of the owner of the webhook if different than the requester. Required in [local mode](https://docs.mattermost.com/administration/mmctl-cli-tool.html#local-mode).
	CreatorId *string `json:"creator_id,omitempty"`

	// Description The description for this outgoing webhook
	Description *string `json:"description,omitempty"`

	// DisplayName The display name for this outgoing webhook
	DisplayName string `json:"display_name"`

	// TeamId The ID of the team that the webhook watchs
	TeamId string `json:"team_id"`

	// TriggerWhen When to trigger the webhook, `0` when a trigger word is present at all and `1` if the message starts with a trigger word
	TriggerWhen *int `json:"trigger_when,omitempty"`

	// TriggerWords List of words for the webhook to trigger on
	TriggerWords []string `json:"trigger_words"`
}

// UpdateOutgoingWebhookJSONBody defines parameters for UpdateOutgoingWebhook.
type UpdateOutgoingWebhookJSONBody struct {
	// ChannelId The ID of a public channel or private group that receives the webhook payloads.
	ChannelId string `json:"channel_id"`

	// Description The description for this incoming webhook
	Description string `json:"description"`

	// DisplayName The display name for this incoming webhook
	DisplayName string `json:"display_name"`

	// Id Outgoing webhook GUID
	Id string `json:"id"`
}

// ApplyIPFiltersJSONBody defines parameters for ApplyIPFilters.
type ApplyIPFiltersJSONBody = []AllowedIPRange

// GetJobsParams defines parameters for GetJobs.
type GetJobsParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of jobs per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// JobType The type of jobs to fetch.
	JobType *string `form:"job_type,omitempty" json:"job_type,omitempty"`

	// Status The status of jobs to fetch.
	Status *string `form:"status,omitempty" json:"status,omitempty"`
}

// CreateJobJSONBody defines parameters for CreateJob.
type CreateJobJSONBody struct {
	// Data An object containing any additional data required for this job type
	Data *map[string]interface{} `json:"data,omitempty"`

	// Type The type of job to create
	Type string `json:"type"`
}

// GetJobsByTypeParams defines parameters for GetJobsByType.
type GetJobsByTypeParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of jobs per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// UpdateJobStatusJSONBody defines parameters for UpdateJobStatus.
type UpdateJobStatusJSONBody struct {
	// Force Set this to true to bypass status restrictions
	Force *bool `json:"force,omitempty"`

	// Status The status you want to set
	Status string `json:"status"`
}

// UploadLdapPrivateCertificateMultipartBody defines parameters for UploadLdapPrivateCertificate.
type UploadLdapPrivateCertificateMultipartBody struct {
	// Certificate The private key file
	Certificate openapi_types.File `json:"certificate"`
}

// UploadLdapPublicCertificateMultipartBody defines parameters for UploadLdapPublicCertificate.
type UploadLdapPublicCertificateMultipartBody struct {
	// Certificate The public certificate file
	Certificate openapi_types.File `json:"certificate"`
}

// GetLdapGroupsParams defines parameters for GetLdapGroups.
type GetLdapGroupsParams struct {
	// Q Search term
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of users per page. per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// MigrateIdLdapJSONBody defines parameters for MigrateIdLdap.
type MigrateIdLdapJSONBody struct {
	// ToAttribute New IdAttribute value
	ToAttribute string `json:"toAttribute"`
}

// UploadLicenseFileMultipartBody defines parameters for UploadLicenseFile.
type UploadLicenseFileMultipartBody struct {
	// License The license to be uploaded
	License openapi_types.File `json:"license"`
}

// GetClientLicenseParams defines parameters for GetClientLicense.
type GetClientLicenseParams struct {
	// Format Must be `old`, other formats not implemented yet
	Format string `form:"format" json:"format"`
}

// GetLogsParams defines parameters for GetLogs.
type GetLogsParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// LogsPerPage The number of logs per page. There is a maximum limit of 10000 logs per page.
	LogsPerPage *string `form:"logs_per_page,omitempty" json:"logs_per_page,omitempty"`
}

// PostLogJSONBody defines parameters for PostLog.
type PostLogJSONBody struct {
	// Level The error level, ERROR or DEBUG
	Level string `json:"level"`

	// Message Message to send to the server logs
	Message string `json:"message"`
}

// GetOAuthAppsParams defines parameters for GetOAuthApps.
type GetOAuthAppsParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of apps per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// CreateOAuthAppJSONBody defines parameters for CreateOAuthApp.
type CreateOAuthAppJSONBody struct {
	// CallbackUrls A list of callback URLs for the appliation
	CallbackUrls []string `json:"callback_urls"`

	// Description A short description of the application
	Description string `json:"description"`

	// Homepage A link to the website of the application
	Homepage string `json:"homepage"`

	// IconUrl A URL to an icon to display with the application
	IconUrl *string `json:"icon_url,omitempty"`

	// IsTrusted Set this to `true` to skip asking users for permission
	IsTrusted *bool `json:"is_trusted,omitempty"`

	// Name The name of the client application
	Name string `json:"name"`
}

// UpdateOAuthAppJSONBody defines parameters for UpdateOAuthApp.
type UpdateOAuthAppJSONBody struct {
	// CallbackUrls A list of callback URLs for the appliation
	CallbackUrls []string `json:"callback_urls"`

	// Description A short description of the application
	Description string `json:"description"`

	// Homepage A link to the website of the application
	Homepage string `json:"homepage"`

	// IconUrl A URL to an icon to display with the application
	IconUrl *string `json:"icon_url,omitempty"`

	// Id The id of the client application
	Id string `json:"id"`

	// IsTrusted Set this to `true` to skip asking users for permission. It will be set to false if value is not provided.
	IsTrusted *bool `json:"is_trusted,omitempty"`

	// Name The name of the client application
	Name string `json:"name"`
}

// ListOutgoingOAuthConnectionsParams defines parameters for ListOutgoingOAuthConnections.
type ListOutgoingOAuthConnectionsParams struct {
	// TeamId Current Team ID in integrations backstage
	TeamId string `form:"team_id" json:"team_id"`
}

// CreateOutgoingOAuthConnectionParams defines parameters for CreateOutgoingOAuthConnection.
type CreateOutgoingOAuthConnectionParams struct {
	// TeamId Current Team ID in integrations backstage
	TeamId string `form:"team_id" json:"team_id"`
}

// ValidateOutgoingOAuthConnectionParams defines parameters for ValidateOutgoingOAuthConnection.
type ValidateOutgoingOAuthConnectionParams struct {
	// TeamId Current Team ID in integrations backstage
	TeamId string `form:"team_id" json:"team_id"`
}

// GetAncillaryPermissionsPostJSONBody defines parameters for GetAncillaryPermissionsPost.
type GetAncillaryPermissionsPostJSONBody = []string

// UploadPluginMultipartBody defines parameters for UploadPlugin.
type UploadPluginMultipartBody struct {
	// Force Set to 'true' to overwrite a previously installed plugin with the same ID, if any
	Force *string `json:"force,omitempty"`

	// Plugin The plugin image to be uploaded
	Plugin openapi_types.File `json:"plugin"`
}

// InstallPluginFromUrlParams defines parameters for InstallPluginFromUrl.
type InstallPluginFromUrlParams struct {
	// PluginDownloadUrl URL used to download the plugin
	PluginDownloadUrl string `form:"plugin_download_url" json:"plugin_download_url"`

	// Force Set to 'true' to overwrite a previously installed plugin with the same ID, if any
	Force *string `form:"force,omitempty" json:"force,omitempty"`
}

// GetMarketplacePluginsParams defines parameters for GetMarketplacePlugins.
type GetMarketplacePluginsParams struct {
	// Page Page number to be fetched. (not yet implemented)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of item per page. (not yet implemented)
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Filter Set to filter plugins by ID, name, or description.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// ServerVersion Set to filter minimum plugin server version. (not yet implemented)
	ServerVersion *string `form:"server_version,omitempty" json:"server_version,omitempty"`

	// LocalOnly Set true to only retrieve local plugins.
	LocalOnly *bool `form:"local_only,omitempty" json:"local_only,omitempty"`
}

// InstallMarketplacePluginJSONBody defines parameters for InstallMarketplacePlugin.
type InstallMarketplacePluginJSONBody struct {
	// Id The ID of the plugin to install.
	Id string `json:"id"`

	// Version The version of the plugin to install.
	Version string `json:"version"`
}

// CreatePostJSONBody defines parameters for CreatePost.
type CreatePostJSONBody struct {
	// ChannelId The channel ID to post in
	ChannelId string `json:"channel_id"`

	// FileIds A list of file IDs to associate with the post. Note that posts are limited to 5 files maximum. Please use additional posts for more files.
	FileIds *[]string `json:"file_ids,omitempty"`

	// Message The message contents, can be formatted with Markdown
	Message string `json:"message"`

	// Metadata A JSON object to add post metadata, e.g the post's priority
	Metadata *struct {
		// Priority An object containing the post's priority properties
		Priority *struct {
			// Priority The priority label of the post, could empty, important, or urgent
			Priority *string `json:"priority,omitempty"`

			// RequestedAck Set to true to request for acknowledgements
			RequestedAck *bool `json:"requested_ack,omitempty"`
		} `json:"priority,omitempty"`
	} `json:"metadata,omitempty"`

	// Props A general JSON property bag to attach to the post
	Props *map[string]interface{} `json:"props,omitempty"`

	// RootId The post ID to comment on
	RootId *string `json:"root_id,omitempty"`
}

// CreatePostParams defines parameters for CreatePost.
type CreatePostParams struct {
	// SetOnline Whether to set the user status as online or not.
	SetOnline *bool `form:"set_online,omitempty" json:"set_online,omitempty"`
}

// CreatePostEphemeralJSONBody defines parameters for CreatePostEphemeral.
type CreatePostEphemeralJSONBody struct {
	// Post Post object to create
	Post struct {
		// ChannelId The channel ID to post in
		ChannelId string `json:"channel_id"`

		// Message The message contents, can be formatted with Markdown
		Message string `json:"message"`
	} `json:"post"`

	// UserId The target user id for the ephemeral post
	UserId string `json:"user_id"`
}

// GetPostsByIdsJSONBody defines parameters for GetPostsByIds.
type GetPostsByIdsJSONBody = []string

// GetBulkReactionsJSONBody defines parameters for GetBulkReactions.
type GetBulkReactionsJSONBody = []string

// CreateScheduledPostJSONBody defines parameters for CreateScheduledPost.
type CreateScheduledPostJSONBody struct {
	// ChannelId The channel ID to post in
	ChannelId string `json:"channel_id"`

	// FileIds A list of file IDs to associate with the post. Note that posts are limited to 5 files maximum. Please use additional posts for more files.
	FileIds *[]interface{} `json:"file_ids,omitempty"`

	// Message The message contents, can be formatted with Markdown
	Message string `json:"message"`

	// Props A general JSON property bag to attach to the post
	Props *map[string]interface{} `json:"props,omitempty"`

	// RootId The post ID to comment on
	RootId *string `json:"root_id,omitempty"`

	// ScheduledAt UNIX timestamp in milliseconds of the time when the scheduled post should be sent
	ScheduledAt int `json:"scheduled_at"`
}

// UpdateScheduledPostJSONBody defines parameters for UpdateScheduledPost.
type UpdateScheduledPostJSONBody struct {
	// ChannelId The channel ID to post in
	ChannelId string `json:"channel_id"`

	// Id ID of the scheduled post to update
	Id string `json:"id"`

	// Message The message contents, can be formatted with Markdown
	Message string `json:"message"`

	// ScheduledAt UNIX timestamp in milliseconds of the time when the scheduled post should be sent
	ScheduledAt int `json:"scheduled_at"`

	// UserId The current user ID
	UserId string `json:"user_id"`
}

// UpdateScheduledPostParams defines parameters for UpdateScheduledPost.
type UpdateScheduledPostParams struct {
	// TeamId Whether to include scheduled posts from DMs an GMs or not. Default is false
	TeamId *string `form:"team_id,omitempty" json:"team_id,omitempty"`
}

// GetUserScheduledPostsParams defines parameters for GetUserScheduledPosts.
type GetUserScheduledPostsParams struct {
	// IncludeDirectChannels Whether to include scheduled posts from DMs an GMs or not. Default is false
	IncludeDirectChannels *bool `form:"includeDirectChannels,omitempty" json:"includeDirectChannels,omitempty"`
}

// GetPostParams defines parameters for GetPost.
type GetPostParams struct {
	// IncludeDeleted Defines if result should include deleted posts, must have 'manage_system' (admin) permission.
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`
}

// UpdatePostJSONBody defines parameters for UpdatePost.
type UpdatePostJSONBody struct {
	// HasReactions Set to `true` if the post has reactions to it
	HasReactions *bool `json:"has_reactions,omitempty"`

	// Id ID of the post to update
	Id string `json:"id"`

	// IsPinned Set to `true` to pin the post to the channel it is in
	IsPinned *bool `json:"is_pinned,omitempty"`

	// Message The message text of the post
	Message *string `json:"message,omitempty"`

	// Props A general JSON property bag to attach to the post
	Props *string `json:"props,omitempty"`
}

// GetFileInfosForPostParams defines parameters for GetFileInfosForPost.
type GetFileInfosForPostParams struct {
	// IncludeDeleted Defines if result should include deleted posts, must have 'manage_system' (admin) permission.
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`
}

// MoveThreadJSONBody defines parameters for MoveThread.
type MoveThreadJSONBody struct {
	// ChannelId The channel identifier of where the post/thread is to be moved
	ChannelId string `json:"channel_id"`
}

// PatchPostJSONBody defines parameters for PatchPost.
type PatchPostJSONBody struct {
	// FileIds The list of files attached to this post
	FileIds *[]string `json:"file_ids,omitempty"`

	// HasReactions Set to `true` if the post has reactions to it
	HasReactions *bool `json:"has_reactions,omitempty"`

	// IsPinned Set to `true` to pin the post to the channel it is in
	IsPinned *bool `json:"is_pinned,omitempty"`

	// Message The message text of the post
	Message *string `json:"message,omitempty"`

	// Props A general JSON property bag to attach to the post
	Props *string `json:"props,omitempty"`
}

// GetPostThreadParams defines parameters for GetPostThread.
type GetPostThreadParams struct {
	// PerPage The number of posts per page
	PerPage *int `form:"perPage,omitempty" json:"perPage,omitempty"`

	// FromPost The post_id to return the next page of posts from
	FromPost *string `form:"fromPost,omitempty" json:"fromPost,omitempty"`

	// FromCreateAt The create_at timestamp to return the next page of posts from
	FromCreateAt *int `form:"fromCreateAt,omitempty" json:"fromCreateAt,omitempty"`

	// Direction The direction to return the posts. Either up or down.
	Direction *string `form:"direction,omitempty" json:"direction,omitempty"`

	// SkipFetchThreads Whether to skip fetching threads or not
	SkipFetchThreads *bool `form:"skipFetchThreads,omitempty" json:"skipFetchThreads,omitempty"`

	// CollapsedThreads Whether the client uses CRT or not
	CollapsedThreads *bool `form:"collapsedThreads,omitempty" json:"collapsedThreads,omitempty"`

	// CollapsedThreadsExtended Whether to return the associated users as part of the response or not
	CollapsedThreadsExtended *bool `form:"collapsedThreadsExtended,omitempty" json:"collapsedThreadsExtended,omitempty"`
}

// GetRedirectLocationParams defines parameters for GetRedirectLocation.
type GetRedirectLocationParams struct {
	// Url Url to check
	Url string `form:"url" json:"url"`
}

// GetRemoteClustersParams defines parameters for GetRemoteClusters.
type GetRemoteClustersParams struct {
	// Page The page to select
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of remote clusters per page
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// ExcludeOffline Exclude offline remote clusters
	ExcludeOffline *bool `form:"exclude_offline,omitempty" json:"exclude_offline,omitempty"`

	// InChannel Select remote clusters in channel
	InChannel *string `form:"in_channel,omitempty" json:"in_channel,omitempty"`

	// NotInChannel Select remote clusters not in this channel
	NotInChannel *string `form:"not_in_channel,omitempty" json:"not_in_channel,omitempty"`

	// OnlyConfirmed Select only remote clusters already confirmed
	OnlyConfirmed *bool `form:"only_confirmed,omitempty" json:"only_confirmed,omitempty"`

	// OnlyPlugins Select only remote clusters that belong to a plugin
	OnlyPlugins *bool `form:"only_plugins,omitempty" json:"only_plugins,omitempty"`

	// ExcludePlugins Select only remote clusters that don't belong to a plugin
	ExcludePlugins *bool `form:"exclude_plugins,omitempty" json:"exclude_plugins,omitempty"`

	// IncludeDeleted Include those remote clusters that have been deleted
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`
}

// CreateRemoteClusterJSONBody defines parameters for CreateRemoteCluster.
type CreateRemoteClusterJSONBody struct {
	DefaultTeamId string  `json:"default_team_id"`
	DisplayName   *string `json:"display_name,omitempty"`
	Name          string  `json:"name"`

	// Password The password to use in the invite code. If empty,
	// the server will generate one and it will be part
	// of the response
	Password *string `json:"password,omitempty"`
}

// AcceptRemoteClusterInviteJSONBody defines parameters for AcceptRemoteClusterInvite.
type AcceptRemoteClusterInviteJSONBody struct {
	DefaultTeamId string  `json:"default_team_id"`
	DisplayName   *string `json:"display_name,omitempty"`
	Invite        string  `json:"invite"`
	Name          string  `json:"name"`

	// Password The password to decrypt the invite code.
	Password string `json:"password"`
}

// PatchRemoteClusterJSONBody defines parameters for PatchRemoteCluster.
type PatchRemoteClusterJSONBody struct {
	// DefaultTeamId The team where channels from invites are created
	DefaultTeamId *string `json:"default_team_id,omitempty"`
	DisplayName   *string `json:"display_name,omitempty"`
}

// GetSharedChannelRemotesByRemoteClusterParams defines parameters for GetSharedChannelRemotesByRemoteCluster.
type GetSharedChannelRemotesByRemoteClusterParams struct {
	// IncludeUnconfirmed Include those Shared channel remotes that are unconfirmed
	IncludeUnconfirmed *bool `form:"include_unconfirmed,omitempty" json:"include_unconfirmed,omitempty"`

	// ExcludeConfirmed Show only those Shared channel remotes that are not confirmed yet
	ExcludeConfirmed *bool `form:"exclude_confirmed,omitempty" json:"exclude_confirmed,omitempty"`

	// ExcludeHome Show only those Shared channel remotes that were shared with this server
	ExcludeHome *bool `form:"exclude_home,omitempty" json:"exclude_home,omitempty"`

	// ExcludeRemote Show only those Shared channel remotes that were shared from this server
	ExcludeRemote *bool `form:"exclude_remote,omitempty" json:"exclude_remote,omitempty"`

	// IncludeDeleted Include those Shared channel remotes that have been deleted
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`

	// Page The page to select
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of shared channels per page
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetUsersForReportingParams defines parameters for GetUsersForReporting.
type GetUsersForReportingParams struct {
	// SortColumn The column to sort the users by. Must be one of ("CreateAt", "Username", "FirstName", "LastName", "Nickname", "Email") or the API will return an error.
	SortColumn *string `form:"sort_column,omitempty" json:"sort_column,omitempty"`

	// Direction The direction to accept paging values from. Will return values ahead of the cursor if "prev", and below the cursor if "next". Default is "next".
	Direction *string `form:"direction,omitempty" json:"direction,omitempty"`

	// SortDirection The sorting direction. Must be one of ("asc", "desc"). Will default to 'asc' if not specified or the input is invalid.
	SortDirection *string `form:"sort_direction,omitempty" json:"sort_direction,omitempty"`

	// PageSize The maximum number of users to return.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// FromColumnValue The value of the sorted column corresponding to the cursor to read from. Should be blank for the first page asked for.
	FromColumnValue *string `form:"from_column_value,omitempty" json:"from_column_value,omitempty"`

	// FromId The value of the user id corresponding to the cursor to read from. Should be blank for the first page asked for.
	FromId *string `form:"from_id,omitempty" json:"from_id,omitempty"`

	// DateRange The date range of the post statistics to display. Must be one of ("last30days", "previousmonth", "last6months", "alltime"). Will default to 'alltime' if the input is not valid.
	DateRange *string `form:"date_range,omitempty" json:"date_range,omitempty"`

	// RoleFilter Filter users by their role.
	RoleFilter *string `form:"role_filter,omitempty" json:"role_filter,omitempty"`

	// TeamFilter Filter users by a specified team ID.
	TeamFilter *string `form:"team_filter,omitempty" json:"team_filter,omitempty"`

	// HasNoTeam If true, show only users that have no team. Will ignore provided "team_filter" if true.
	HasNoTeam *bool `form:"has_no_team,omitempty" json:"has_no_team,omitempty"`

	// HideActive If true, show only users that are inactive. Cannot be used at the same time as "hide_inactive"
	HideActive *bool `form:"hide_active,omitempty" json:"hide_active,omitempty"`

	// HideInactive If true, show only users that are active. Cannot be used at the same time as "hide_active"
	HideInactive *bool `form:"hide_inactive,omitempty" json:"hide_inactive,omitempty"`

	// SearchTerm A filtering search term that allows filtering by Username, FirstName, LastName, Nickname or Email
	SearchTerm *string `form:"search_term,omitempty" json:"search_term,omitempty"`
}

// GetUserCountForReportingParams defines parameters for GetUserCountForReporting.
type GetUserCountForReportingParams struct {
	// RoleFilter Filter users by their role.
	RoleFilter *string `form:"role_filter,omitempty" json:"role_filter,omitempty"`

	// TeamFilter Filter users by a specified team ID.
	TeamFilter *string `form:"team_filter,omitempty" json:"team_filter,omitempty"`

	// HasNoTeam If true, show only users that have no team. Will ignore provided "team_filter" if true.
	HasNoTeam *bool `form:"has_no_team,omitempty" json:"has_no_team,omitempty"`

	// HideActive If true, show only users that are inactive. Cannot be used at the same time as "hide_inactive"
	HideActive *bool `form:"hide_active,omitempty" json:"hide_active,omitempty"`

	// HideInactive If true, show only users that are active. Cannot be used at the same time as "hide_active"
	HideInactive *bool `form:"hide_inactive,omitempty" json:"hide_inactive,omitempty"`

	// SearchTerm A filtering search term that allows filtering by Username, FirstName, LastName, Nickname or Email
	SearchTerm *string `form:"search_term,omitempty" json:"search_term,omitempty"`
}

// StartBatchUsersExportParams defines parameters for StartBatchUsersExport.
type StartBatchUsersExportParams struct {
	// DateRange The date range of the post statistics to display. Must be one of ("last30days", "previousmonth", "last6months", "alltime"). Will default to 'alltime' if the input is not valid.
	DateRange *string `form:"date_range,omitempty" json:"date_range,omitempty"`
}

// GetRolesByNamesJSONBody defines parameters for GetRolesByNames.
type GetRolesByNamesJSONBody = []string

// PatchRoleJSONBody defines parameters for PatchRole.
type PatchRoleJSONBody struct {
	// Permissions The permissions the role should grant.
	Permissions *[]string `json:"permissions,omitempty"`
}

// UploadSamlIdpCertificateMultipartBody defines parameters for UploadSamlIdpCertificate.
type UploadSamlIdpCertificateMultipartBody struct {
	// Certificate The IDP certificate file
	Certificate openapi_types.File `json:"certificate"`
}

// UploadSamlPrivateCertificateMultipartBody defines parameters for UploadSamlPrivateCertificate.
type UploadSamlPrivateCertificateMultipartBody struct {
	// Certificate The private key file
	Certificate openapi_types.File `json:"certificate"`
}

// UploadSamlPublicCertificateMultipartBody defines parameters for UploadSamlPublicCertificate.
type UploadSamlPublicCertificateMultipartBody struct {
	// Certificate The public certificate file
	Certificate openapi_types.File `json:"certificate"`
}

// GetSamlMetadataFromIdpJSONBody defines parameters for GetSamlMetadataFromIdp.
type GetSamlMetadataFromIdpJSONBody struct {
	// SamlMetadataUrl The URL from which to retrieve the SAML IDP data.
	SamlMetadataUrl *string `json:"saml_metadata_url,omitempty"`
}

// ResetSamlAuthDataToEmailJSONBody defines parameters for ResetSamlAuthDataToEmail.
type ResetSamlAuthDataToEmailJSONBody struct {
	// DryRun If set to true, the number of users who would be affected is returned.
	DryRun *bool `json:"dry_run,omitempty"`

	// IncludeDeleted Whether to include deleted users.
	IncludeDeleted *bool `json:"include_deleted,omitempty"`

	// UserIds If set to a non-empty array, then users whose IDs are not in the array will be excluded.
	UserIds *[]string `json:"user_ids,omitempty"`
}

// GetSchemesParams defines parameters for GetSchemes.
type GetSchemesParams struct {
	// Scope Limit the results returned to the provided scope, either `team` or `channel`.
	Scope *string `form:"scope,omitempty" json:"scope,omitempty"`

	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of schemes per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// CreateSchemeJSONBody defines parameters for CreateScheme.
type CreateSchemeJSONBody struct {
	// Description The description of the scheme
	Description *string `json:"description,omitempty"`

	// DisplayName The display name of the scheme
	DisplayName string `json:"display_name"`

	// Name The name of the scheme
	Name *string `json:"name,omitempty"`

	// Scope The scope of the scheme ("team" or "channel")
	Scope string `json:"scope"`
}

// GetChannelsForSchemeParams defines parameters for GetChannelsForScheme.
type GetChannelsForSchemeParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of channels per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// PatchSchemeJSONBody defines parameters for PatchScheme.
type PatchSchemeJSONBody struct {
	// Description The description of the scheme
	Description *string `json:"description,omitempty"`

	// Name The human readable name of the scheme
	Name *string `json:"name,omitempty"`
}

// GetTeamsForSchemeParams defines parameters for GetTeamsForScheme.
type GetTeamsForSchemeParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of teams per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// SetServerBusyParams defines parameters for SetServerBusy.
type SetServerBusyParams struct {
	// Seconds Number of seconds until server is automatically marked as not busy.
	Seconds *string `form:"seconds,omitempty" json:"seconds,omitempty"`
}

// GetAllSharedChannelsParams defines parameters for GetAllSharedChannels.
type GetAllSharedChannelsParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of sharedchannels per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// TestSiteURLJSONBody defines parameters for TestSiteURL.
type TestSiteURLJSONBody struct {
	// SiteUrl The Site URL to test
	SiteUrl string `json:"site_url"`
}

// MarkNoticesViewedJSONBody defines parameters for MarkNoticesViewed.
type MarkNoticesViewedJSONBody = []string

// GetNoticesParams defines parameters for GetNotices.
type GetNoticesParams struct {
	// ClientVersion Version of the client (desktop/mobile/web) that issues the request
	ClientVersion string `form:"clientVersion" json:"clientVersion"`

	// Locale Client locale
	Locale *string `form:"locale,omitempty" json:"locale,omitempty"`

	// Client Client type (web/mobile-ios/mobile-android/desktop)
	Client string `form:"client" json:"client"`
}

// GetPingParams defines parameters for GetPing.
type GetPingParams struct {
	// GetServerStatus Check the status of the database and file storage as well
	GetServerStatus *bool `form:"get_server_status,omitempty" json:"get_server_status,omitempty"`

	// DeviceId Check whether this device id can receive push notifications
	DeviceId *string `form:"device_id,omitempty" json:"device_id,omitempty"`

	// UseRestSemantics Returns 200 status code even if the server status is unhealthy.
	UseRestSemantics *bool `form:"use_rest_semantics,omitempty" json:"use_rest_semantics,omitempty"`
}

// GenerateSupportPacketParams defines parameters for GenerateSupportPacket.
type GenerateSupportPacketParams struct {
	// BasicServerLogs Specifies whether the server should include or exclude log files. Default value is true.
	//
	// __Minimum server version__: 9.8.0
	BasicServerLogs *bool `form:"basic_server_logs,omitempty" json:"basic_server_logs,omitempty"`

	// PluginPackets Specifies plugin identifiers whose content should be included in the Support Packet.
	//
	// __Minimum server version__: 9.8.0
	PluginPackets *string `form:"plugin_packets,omitempty" json:"plugin_packets,omitempty"`
}

// GetAllTeamsParams defines parameters for GetAllTeams.
type GetAllTeamsParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of teams per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// IncludeTotalCount Appends a total count of returned teams inside the response object - ex: `{ "teams": [], "total_count" : 0 }`.
	IncludeTotalCount *bool `form:"include_total_count,omitempty" json:"include_total_count,omitempty"`

	// ExcludePolicyConstrained If set to true, teams which are part of a data retention policy will be excluded. The `sysconsole_read_compliance` permission is required to use this parameter.
	// __Minimum server version__: 5.35
	ExcludePolicyConstrained *bool `form:"exclude_policy_constrained,omitempty" json:"exclude_policy_constrained,omitempty"`
}

// CreateTeamJSONBody defines parameters for CreateTeam.
type CreateTeamJSONBody struct {
	// DisplayName Non-unique UI name for the team
	DisplayName string `json:"display_name"`

	// Name Unique handler for a team, will be present in the team URL
	Name string `json:"name"`

	// Type `'O'` for open, `'I'` for invite only
	Type string `json:"type"`
}

// AddTeamMemberFromInviteParams defines parameters for AddTeamMemberFromInvite.
type AddTeamMemberFromInviteParams struct {
	// Token Token id from the invitation
	Token string `form:"token" json:"token"`
}

// GetChannelByNameForTeamNameParams defines parameters for GetChannelByNameForTeamName.
type GetChannelByNameForTeamNameParams struct {
	// IncludeDeleted Defines if deleted channels should be returned or not (Mattermost Server 5.26.0+)
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`
}

// SearchTeamsJSONBody defines parameters for SearchTeams.
type SearchTeamsJSONBody struct {
	// AllowOpenInvite Filters results to teams where `allow_open_invite` is set to true or false, excludes group constrained channels if this filter option is passed.
	// If this filter option is not passed then the query will remain unchanged.
	// __Minimum server version__: 5.28
	AllowOpenInvite *bool `json:"allow_open_invite,omitempty"`

	// ExcludePolicyConstrained If set to true, only teams which do not have a granular retention policy assigned to them will be returned. The `sysconsole_read_compliance_data_retention` permission is required to use this parameter.
	// __Minimum server version__: 5.35
	ExcludePolicyConstrained *bool `json:"exclude_policy_constrained,omitempty"`

	// GroupConstrained Filters results to teams where `group_constrained` is set to true or false, returns the union of results when used with `allow_open_invite`
	// If the filter option is not passed then the query will remain unchanged.
	// __Minimum server version__: 5.28
	GroupConstrained *bool `json:"group_constrained,omitempty"`

	// Page The page number to return, if paginated. If this parameter is not present with the `per_page` parameter then the results will be returned un-paged.
	Page *string `json:"page,omitempty"`

	// PerPage The number of entries to return per page, if paginated. If this parameter is not present with the `page` parameter then the results will be returned un-paged.
	PerPage *string `json:"per_page,omitempty"`

	// Term The search term to match against the name or display name of teams
	Term *string `json:"term,omitempty"`
}

// SoftDeleteTeamParams defines parameters for SoftDeleteTeam.
type SoftDeleteTeamParams struct {
	// Permanent Permanently delete the team, to be used for compliance reasons only. As of server version 5.0, `ServiceSettings.EnableAPITeamDeletion` must be set to `true` in the server's configuration.
	Permanent *bool `form:"permanent,omitempty" json:"permanent,omitempty"`
}

// UpdateTeamJSONBody defines parameters for UpdateTeam.
type UpdateTeamJSONBody struct {
	AllowOpenInvite string `json:"allow_open_invite"`
	AllowedDomains  string `json:"allowed_domains"`
	CompanyName     string `json:"company_name"`
	Description     string `json:"description"`
	DisplayName     string `json:"display_name"`
	Id              string `json:"id"`
	InviteId        string `json:"invite_id"`
}

// GetPublicChannelsForTeamParams defines parameters for GetPublicChannelsForTeam.
type GetPublicChannelsForTeamParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of public channels per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// AutocompleteChannelsForTeamParams defines parameters for AutocompleteChannelsForTeam.
type AutocompleteChannelsForTeamParams struct {
	// Name Name or display name
	Name string `form:"name" json:"name"`
}

// GetDeletedChannelsForTeamParams defines parameters for GetDeletedChannelsForTeam.
type GetDeletedChannelsForTeamParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of public channels per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetPublicChannelsByIdsForTeamJSONBody defines parameters for GetPublicChannelsByIdsForTeam.
type GetPublicChannelsByIdsForTeamJSONBody = []string

// GetChannelByNameParams defines parameters for GetChannelByName.
type GetChannelByNameParams struct {
	// IncludeDeleted Defines if deleted channels should be returned or not (Mattermost Server 5.26.0+)
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`
}

// GetPrivateChannelsForTeamParams defines parameters for GetPrivateChannelsForTeam.
type GetPrivateChannelsForTeamParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of private channels per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// SearchChannelsJSONBody defines parameters for SearchChannels.
type SearchChannelsJSONBody struct {
	// Term The search term to match against the name or display name of channels
	Term string `json:"term"`
}

// SearchArchivedChannelsJSONBody defines parameters for SearchArchivedChannels.
type SearchArchivedChannelsJSONBody struct {
	// Term The search term to match against the name or display name of archived channels
	Term string `json:"term"`
}

// AutocompleteChannelsForTeamForSearchParams defines parameters for AutocompleteChannelsForTeamForSearch.
type AutocompleteChannelsForTeamForSearchParams struct {
	// Name Name or display name
	Name string `form:"name" json:"name"`
}

// ListCommandAutocompleteSuggestionsParams defines parameters for ListCommandAutocompleteSuggestions.
type ListCommandAutocompleteSuggestionsParams struct {
	// UserInput String inputted by the user.
	UserInput string `form:"user_input" json:"user_input"`
}

// SearchFilesMultipartBody defines parameters for SearchFiles.
type SearchFilesMultipartBody struct {
	// IncludeDeletedChannels Set to true if deleted channels should be included in the search. (archived channels)
	IncludeDeletedChannels *bool `json:"include_deleted_channels,omitempty"`

	// IsOrSearch Set to true if an Or search should be performed vs an And search.
	IsOrSearch bool `json:"is_or_search"`

	// Page The page to select. (Only works with Elasticsearch)
	Page *int `json:"page,omitempty"`

	// PerPage The number of posts per page. (Only works with Elasticsearch)
	PerPage *int `json:"per_page,omitempty"`

	// Terms The search terms as inputed by the user. To search for files from a user include `from:someusername`, using a user's username. To search in a specific channel include `in:somechannel`, using the channel name (not the display name). To search for specific extensions include `ext:extension`.
	Terms string `json:"terms"`

	// TimeZoneOffset Offset from UTC of user timezone for date searches.
	TimeZoneOffset *int `json:"time_zone_offset,omitempty"`
}

// GetGroupsByTeamParams defines parameters for GetGroupsByTeam.
type GetGroupsByTeamParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of groups per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// FilterAllowReference Boolean which filters in the group entries with the `allow_reference` attribute set.
	FilterAllowReference *bool `form:"filter_allow_reference,omitempty" json:"filter_allow_reference,omitempty"`
}

// GetGroupsAssociatedToChannelsByTeamParams defines parameters for GetGroupsAssociatedToChannelsByTeam.
type GetGroupsAssociatedToChannelsByTeamParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of groups per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// FilterAllowReference Boolean which filters in the group entries with the `allow_reference` attribute set.
	FilterAllowReference *bool `form:"filter_allow_reference,omitempty" json:"filter_allow_reference,omitempty"`

	// Paginate Boolean to determine whether the pagination should be applied or not
	Paginate *bool `form:"paginate,omitempty" json:"paginate,omitempty"`
}

// SetTeamIconMultipartBody defines parameters for SetTeamIcon.
type SetTeamIconMultipartBody struct {
	// Image The image to be uploaded
	Image openapi_types.File `json:"image"`
}

// ImportTeamMultipartBody defines parameters for ImportTeam.
type ImportTeamMultipartBody struct {
	// File A file to be uploaded in zip format.
	File openapi_types.File `json:"file"`

	// Filesize The size of the zip file to be imported.
	Filesize int `json:"filesize"`

	// ImportFrom String that defines from which application the team was exported to be imported into Mattermost.
	ImportFrom string `json:"importFrom"`
}

// InviteGuestsToTeamJSONBody defines parameters for InviteGuestsToTeam.
type InviteGuestsToTeamJSONBody struct {
	// Channels List of channel ids
	Channels []string `json:"channels"`

	// Emails List of emails
	Emails []string `json:"emails"`

	// Message Message to include in the invite
	Message *string `json:"message,omitempty"`
}

// InviteUsersToTeamJSONBody defines parameters for InviteUsersToTeam.
type InviteUsersToTeamJSONBody = []string

// GetTeamMembersParams defines parameters for GetTeamMembers.
type GetTeamMembersParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of users per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Sort To sort by Username, set to 'Username', otherwise sort is by 'UserID'
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// ExcludeDeletedUsers Excludes deleted users from the results
	ExcludeDeletedUsers *bool `form:"exclude_deleted_users,omitempty" json:"exclude_deleted_users,omitempty"`
}

// AddTeamMemberJSONBody defines parameters for AddTeamMember.
type AddTeamMemberJSONBody struct {
	TeamId *string `json:"team_id,omitempty"`
	UserId *string `json:"user_id,omitempty"`
}

// AddTeamMembersJSONBody defines parameters for AddTeamMembers.
type AddTeamMembersJSONBody = []TeamMember

// AddTeamMembersParams defines parameters for AddTeamMembers.
type AddTeamMembersParams struct {
	// Graceful Instead of aborting the operation if a user cannot be added, return an arrray that will contain both the success and added members and the ones with error, in form of `[{"member": {...}, "user_id", "...", "error": {...}}]`
	Graceful *bool `form:"graceful,omitempty" json:"graceful,omitempty"`
}

// GetTeamMembersByIdsJSONBody defines parameters for GetTeamMembersByIds.
type GetTeamMembersByIdsJSONBody = []string

// UpdateTeamMemberRolesJSONBody defines parameters for UpdateTeamMemberRoles.
type UpdateTeamMemberRolesJSONBody struct {
	Roles string `json:"roles"`
}

// UpdateTeamMemberSchemeRolesJSONBody defines parameters for UpdateTeamMemberSchemeRoles.
type UpdateTeamMemberSchemeRolesJSONBody struct {
	SchemeAdmin bool `json:"scheme_admin"`
	SchemeUser  bool `json:"scheme_user"`
}

// TeamMembersMinusGroupMembersParams defines parameters for TeamMembersMinusGroupMembers.
type TeamMembersMinusGroupMembersParams struct {
	// GroupIds A comma-separated list of group ids.
	GroupIds string `form:"group_ids" json:"group_ids"`

	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of users per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// PatchTeamJSONBody defines parameters for PatchTeam.
type PatchTeamJSONBody struct {
	AllowOpenInvite *bool   `json:"allow_open_invite,omitempty"`
	CompanyName     *string `json:"company_name,omitempty"`
	Description     *string `json:"description,omitempty"`
	DisplayName     *string `json:"display_name,omitempty"`
	InviteId        *string `json:"invite_id,omitempty"`
}

// SearchPostsJSONBody defines parameters for SearchPosts.
type SearchPostsJSONBody struct {
	// IncludeDeletedChannels Set to true if deleted channels should be included in the search. (archived channels)
	IncludeDeletedChannels *bool `json:"include_deleted_channels,omitempty"`

	// IsOrSearch Set to true if an Or search should be performed vs an And search.
	IsOrSearch bool `json:"is_or_search"`

	// Page The page to select. (Only works with Elasticsearch)
	Page *int `json:"page,omitempty"`

	// PerPage The number of posts per page. (Only works with Elasticsearch)
	PerPage *int `json:"per_page,omitempty"`

	// Terms The search terms as inputed by the user. To search for posts from a user include `from:someusername`, using a user's username. To search in a specific channel include `in:somechannel`, using the channel name (not the display name).
	Terms string `json:"terms"`

	// TimeZoneOffset Offset from UTC of user timezone for date searches.
	TimeZoneOffset *int `json:"time_zone_offset,omitempty"`
}

// UpdateTeamPrivacyJSONBody defines parameters for UpdateTeamPrivacy.
type UpdateTeamPrivacyJSONBody struct {
	// Privacy Team privacy setting: 'O' for a public (open) team, 'I' for a private (invitation only) team
	Privacy string `json:"privacy"`
}

// UpdateTeamSchemeJSONBody defines parameters for UpdateTeamScheme.
type UpdateTeamSchemeJSONBody struct {
	// SchemeId The ID of the scheme.
	SchemeId string `json:"scheme_id"`
}

// RequestTrialLicenseJSONBody defines parameters for RequestTrialLicense.
type RequestTrialLicenseJSONBody struct {
	// Users Number of users requested (20% extra is going to be added)
	Users int `json:"users"`
}

// CreateUploadJSONBody defines parameters for CreateUpload.
type CreateUploadJSONBody struct {
	// ChannelId The ID of the channel to upload to.
	ChannelId string `json:"channel_id"`

	// FileSize The size of the file to upload in bytes.
	FileSize int `json:"file_size"`

	// Filename The name of the file to upload.
	Filename string `json:"filename"`
}

// UploadDataFormdataBody defines parameters for UploadData.
type UploadDataFormdataBody = struct {
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of users per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// InTeam The ID of the team to get users for.
	InTeam *string `form:"in_team,omitempty" json:"in_team,omitempty"`

	// NotInTeam The ID of the team to exclude users for. Must not be used with "in_team" query parameter.
	NotInTeam *string `form:"not_in_team,omitempty" json:"not_in_team,omitempty"`

	// InChannel The ID of the channel to get users for.
	InChannel *string `form:"in_channel,omitempty" json:"in_channel,omitempty"`

	// NotInChannel The ID of the channel to exclude users for. Must be used with "in_channel" query parameter.
	NotInChannel *string `form:"not_in_channel,omitempty" json:"not_in_channel,omitempty"`

	// InGroup The ID of the group to get users for. Must have `manage_system` permission.
	InGroup *string `form:"in_group,omitempty" json:"in_group,omitempty"`

	// GroupConstrained When used with `not_in_channel` or `not_in_team`, returns only the users that are allowed to join the channel or team based on its group constrains.
	GroupConstrained *bool `form:"group_constrained,omitempty" json:"group_constrained,omitempty"`

	// WithoutTeam Whether or not to list users that are not on any team. This option takes precendence over `in_team`, `in_channel`, and `not_in_channel`.
	WithoutTeam *bool `form:"without_team,omitempty" json:"without_team,omitempty"`

	// Active Whether or not to list only users that are active. This option cannot be used along with the `inactive` option.
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// Inactive Whether or not to list only users that are deactivated. This option cannot be used along with the `active` option.
	Inactive *bool `form:"inactive,omitempty" json:"inactive,omitempty"`

	// Role Returns users that have this role.
	Role *string `form:"role,omitempty" json:"role,omitempty"`

	// Sort Sort is only available in conjunction with certain options below. The paging parameter is also always available.
	//
	// ##### `in_team`
	// Can be "", "last_activity_at" or "create_at".
	// When left blank, sorting is done by username.
	// Note that when "last_activity_at" is specified, an additional "last_activity_at" field will be returned in the response packet.
	// __Minimum server version__: 4.0
	// ##### `in_channel`
	// Can be "", "status".
	// When left blank, sorting is done by username. `status` will sort by User's current status (Online, Away, DND, Offline), then by Username.
	// __Minimum server version__: 4.7
	// ##### `in_group`
	// Can be "", "display_name".
	// When left blank, sorting is done by username. `display_name` will sort alphabetically by user's display name.
	// __Minimum server version__: 7.7
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Roles Comma separated string used to filter users based on any of the specified system roles
	//
	// Example: `?roles=system_admin,system_user` will return users that are either system admins or system users
	//
	// __Minimum server version__: 5.26
	Roles *string `form:"roles,omitempty" json:"roles,omitempty"`

	// ChannelRoles Comma separated string used to filter users based on any of the specified channel roles, can only be used in conjunction with `in_channel`
	//
	// Example: `?in_channel=4eb6axxw7fg3je5iyasnfudc5y&channel_roles=channel_user` will return users that are only channel users and not admins or guests
	//
	// __Minimum server version__: 5.26
	ChannelRoles *string `form:"channel_roles,omitempty" json:"channel_roles,omitempty"`

	// TeamRoles Comma separated string used to filter users based on any of the specified team roles, can only be used in conjunction with `in_team`
	//
	// Example: `?in_team=4eb6axxw7fg3je5iyasnfudc5y&team_roles=team_user` will return users that are only team users and not admins or guests
	//
	// __Minimum server version__: 5.26
	TeamRoles *string `form:"team_roles,omitempty" json:"team_roles,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody struct {
	// AuthData Service-specific authentication data, such as email address.
	AuthData *string `json:"auth_data,omitempty"`

	// AuthService The authentication service, one of "email", "gitlab", "ldap", "saml", "office365", "google", and "".
	AuthService *string          `json:"auth_service,omitempty"`
	Email       string           `json:"email"`
	FirstName   *string          `json:"first_name,omitempty"`
	LastName    *string          `json:"last_name,omitempty"`
	Locale      *string          `json:"locale,omitempty"`
	Nickname    *string          `json:"nickname,omitempty"`
	NotifyProps *UserNotifyProps `json:"notify_props,omitempty"`

	// Password The password used for email authentication.
	Password *string                 `json:"password,omitempty"`
	Position *string                 `json:"position,omitempty"`
	Props    *map[string]interface{} `json:"props,omitempty"`
	Timezone *Timezone               `json:"timezone,omitempty"`
	Username string                  `json:"username"`
}

// CreateUserParams defines parameters for CreateUser.
type CreateUserParams struct {
	// T Token id from an email invitation
	T *string `form:"t,omitempty" json:"t,omitempty"`

	// Iid Token id from an invitation link
	Iid *string `form:"iid,omitempty" json:"iid,omitempty"`
}

// AutocompleteUsersParams defines parameters for AutocompleteUsers.
type AutocompleteUsersParams struct {
	// TeamId Team ID
	TeamId *string `form:"team_id,omitempty" json:"team_id,omitempty"`

	// ChannelId Channel ID
	ChannelId *string `form:"channel_id,omitempty" json:"channel_id,omitempty"`

	// Name Username, nickname first name or last name
	Name string `form:"name" json:"name"`

	// Limit The maximum number of users to return in each subresult
	//
	// __Available as of server version 5.6. Defaults to `100` if not provided or on an earlier server version.__
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// VerifyUserEmailJSONBody defines parameters for VerifyUserEmail.
type VerifyUserEmailJSONBody struct {
	// Token The token given to validate the email
	Token string `json:"token"`
}

// SendVerificationEmailJSONBody defines parameters for SendVerificationEmail.
type SendVerificationEmailJSONBody struct {
	// Email Email of a user
	Email string `json:"email"`
}

// GetUsersByGroupChannelIdsJSONBody defines parameters for GetUsersByGroupChannelIds.
type GetUsersByGroupChannelIdsJSONBody = []string

// GetUsersByIdsJSONBody defines parameters for GetUsersByIds.
type GetUsersByIdsJSONBody = []string

// GetUsersByIdsParams defines parameters for GetUsersByIds.
type GetUsersByIdsParams struct {
	// Since Only return users that have been modified since the given Unix timestamp (in milliseconds).
	//
	// __Minimum server version__: 5.14
	Since *int `form:"since,omitempty" json:"since,omitempty"`
}

// GetUsersWithInvalidEmailsParams defines parameters for GetUsersWithInvalidEmails.
type GetUsersWithInvalidEmailsParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of users per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// LoginJSONBody defines parameters for Login.
type LoginJSONBody struct {
	DeviceId *string `json:"device_id,omitempty"`
	Id       *string `json:"id,omitempty"`
	LdapOnly *bool   `json:"ldap_only,omitempty"`
	LoginId  *string `json:"login_id,omitempty"`

	// Password The password used for email authentication.
	Password *string `json:"password,omitempty"`
	Token    *string `json:"token,omitempty"`
}

// LoginByCwsTokenJSONBody defines parameters for LoginByCwsToken.
type LoginByCwsTokenJSONBody struct {
	CwsToken *string `json:"cws_token,omitempty"`
	LoginId  *string `json:"login_id,omitempty"`
}

// SwitchAccountTypeJSONBody defines parameters for SwitchAccountType.
type SwitchAccountTypeJSONBody struct {
	// CurrentService The service the user currently uses to login
	CurrentService string `json:"current_service"`

	// Email The email of the user
	Email *string `json:"email,omitempty"`

	// LdapId The LDAP/AD id of the user
	LdapId *string `json:"ldap_id,omitempty"`

	// MfaCode The MFA code of the current service
	MfaCode *string `json:"mfa_code,omitempty"`

	// NewService The service the user will use to login
	NewService string `json:"new_service"`

	// Password The password used with the current service
	Password *string `json:"password,omitempty"`
}

// CheckUserMfaJSONBody defines parameters for CheckUserMfa.
type CheckUserMfaJSONBody struct {
	// LoginId The email or username used to login
	LoginId string `json:"login_id"`
}

// MigrateAuthToLdapJSONBody defines parameters for MigrateAuthToLdap.
type MigrateAuthToLdapJSONBody struct {
	Force bool `json:"force"`

	// From The current authentication type for the matched users.
	From string `json:"from"`

	// MatchField Foreign user field name to match.
	MatchField string `json:"match_field"`
}

// MigrateAuthToSamlJSONBody defines parameters for MigrateAuthToSaml.
type MigrateAuthToSamlJSONBody struct {
	Auto bool `json:"auto"`

	// From The current authentication type for the matched users.
	From string `json:"from"`

	// Matches Users map.
	Matches map[string]interface{} `json:"matches"`
}

// ResetPasswordJSONBody defines parameters for ResetPassword.
type ResetPasswordJSONBody struct {
	// Code The recovery code
	Code string `json:"code"`

	// NewPassword The new password for the user
	NewPassword string `json:"new_password"`
}

// SendPasswordResetEmailJSONBody defines parameters for SendPasswordResetEmail.
type SendPasswordResetEmailJSONBody struct {
	// Email The email of the user
	Email string `json:"email"`
}

// SearchUsersJSONBody defines parameters for SearchUsers.
type SearchUsersJSONBody struct {
	// AllowInactive When `true`, include deactivated users in the results
	AllowInactive *bool `json:"allow_inactive,omitempty"`

	// GroupConstrained When used with `not_in_channel_id` or `not_in_team_id`, returns only the users that are allowed to join the channel or team based on its group constrains.
	GroupConstrained *bool `json:"group_constrained,omitempty"`

	// InChannelId If provided, only search users in this channel
	InChannelId *string `json:"in_channel_id,omitempty"`

	// InGroupId If provided, only search users in this group. Must have `manage_system` permission.
	InGroupId *string `json:"in_group_id,omitempty"`

	// Limit The maximum number of users to return in the results
	//
	// __Available as of server version 5.6. Defaults to `100` if not provided or on an earlier server version.__
	Limit *int `json:"limit,omitempty"`

	// NotInChannelId If provided, only search users not in this channel. Must specifiy `team_id` when using this option
	NotInChannelId *string `json:"not_in_channel_id,omitempty"`

	// NotInTeamId If provided, only search users not on this team
	NotInTeamId *string `json:"not_in_team_id,omitempty"`

	// TeamId If provided, only search users on this team
	TeamId *string `json:"team_id,omitempty"`

	// Term The term to match against username, full name, nickname and email
	Term string `json:"term"`

	// WithoutTeam Set this to `true` if you would like to search for users that are not on a team. This option takes precendence over `team_id`, `in_channel_id`, and `not_in_channel_id`.
	WithoutTeam *bool `json:"without_team,omitempty"`
}

// AttachDeviceExtraPropsJSONBody defines parameters for AttachDeviceExtraProps.
type AttachDeviceExtraPropsJSONBody struct {
	// DeviceNotificationDisabled Whether the mobile device has notifications disabled. Accepted values are "true" or "false".
	DeviceNotificationDisabled *string `json:"deviceNotificationDisabled,omitempty"`

	// DeviceId Mobile device id. For Android prefix the id with `android:` and Apple with `apple:`
	DeviceId *string `json:"device_id,omitempty"`

	// MobileVersion Mobile app version. The version must be parseable as a semver.
	MobileVersion *string `json:"mobileVersion,omitempty"`
}

// GetTotalUsersStatsFilteredParams defines parameters for GetTotalUsersStatsFiltered.
type GetTotalUsersStatsFilteredParams struct {
	// InTeam The ID of the team to get user stats for.
	InTeam *string `form:"in_team,omitempty" json:"in_team,omitempty"`

	// InChannel The ID of the channel to get user stats for.
	InChannel *string `form:"in_channel,omitempty" json:"in_channel,omitempty"`

	// IncludeDeleted If deleted accounts should be included in the count.
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`

	// IncludeBots If bot accounts should be included in the count.
	IncludeBots *bool `form:"include_bots,omitempty" json:"include_bots,omitempty"`

	// Roles Comma separated string used to filter users based on any of the specified system roles
	//
	// Example: `?roles=system_admin,system_user` will include users that are either system admins or system users
	Roles *string `form:"roles,omitempty" json:"roles,omitempty"`

	// ChannelRoles Comma separated string used to filter users based on any of the specified channel roles, can only be used in conjunction with `in_channel`
	//
	// Example: `?in_channel=4eb6axxw7fg3je5iyasnfudc5y&channel_roles=channel_user` will include users that are only channel users and not admins or guests
	ChannelRoles *string `form:"channel_roles,omitempty" json:"channel_roles,omitempty"`

	// TeamRoles Comma separated string used to filter users based on any of the specified team roles, can only be used in conjunction with `in_team`
	//
	// Example: `?in_team=4eb6axxw7fg3je5iyasnfudc5y&team_roles=team_user` will include users that are only team users and not admins or guests
	TeamRoles *string `form:"team_roles,omitempty" json:"team_roles,omitempty"`
}

// GetUsersStatusesByIdsJSONBody defines parameters for GetUsersStatusesByIds.
type GetUsersStatusesByIdsJSONBody = []string

// GetUserAccessTokensParams defines parameters for GetUserAccessTokens.
type GetUserAccessTokensParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of tokens per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// DisableUserAccessTokenJSONBody defines parameters for DisableUserAccessToken.
type DisableUserAccessTokenJSONBody struct {
	// TokenId The personal access token GUID to disable
	TokenId string `json:"token_id"`
}

// EnableUserAccessTokenJSONBody defines parameters for EnableUserAccessToken.
type EnableUserAccessTokenJSONBody struct {
	// TokenId The personal access token GUID to enable
	TokenId string `json:"token_id"`
}

// RevokeUserAccessTokenJSONBody defines parameters for RevokeUserAccessToken.
type RevokeUserAccessTokenJSONBody struct {
	// TokenId The user access token GUID to revoke
	TokenId string `json:"token_id"`
}

// SearchUserAccessTokensJSONBody defines parameters for SearchUserAccessTokens.
type SearchUserAccessTokensJSONBody struct {
	// Term The search term to match against the token id, user id or username.
	Term string `json:"term"`
}

// GetUsersByUsernamesJSONBody defines parameters for GetUsersByUsernames.
type GetUsersByUsernamesJSONBody = []string

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
	Email       string                  `json:"email"`
	FirstName   *string                 `json:"first_name,omitempty"`
	Id          string                  `json:"id"`
	LastName    *string                 `json:"last_name,omitempty"`
	Locale      *string                 `json:"locale,omitempty"`
	Nickname    *string                 `json:"nickname,omitempty"`
	NotifyProps *UserNotifyProps        `json:"notify_props,omitempty"`
	Position    *string                 `json:"position,omitempty"`
	Props       *map[string]interface{} `json:"props,omitempty"`
	Timezone    *Timezone               `json:"timezone,omitempty"`
	Username    string                  `json:"username"`
}

// UpdateUserActiveJSONBody defines parameters for UpdateUserActive.
type UpdateUserActiveJSONBody struct {
	Active bool `json:"active"`
}

// GetChannelMembersWithTeamDataForUserParams defines parameters for GetChannelMembersWithTeamDataForUser.
type GetChannelMembersWithTeamDataForUserParams struct {
	// Page Page specifies which part of the results to return, by perPage.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The size of the returned chunk of results.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetChannelsForUserParams defines parameters for GetChannelsForUser.
type GetChannelsForUserParams struct {
	// LastDeleteAt Filters the deleted channels by this time in epoch format. Does not have any effect if include_deleted is set to false.
	LastDeleteAt *int `form:"last_delete_at,omitempty" json:"last_delete_at,omitempty"`

	// IncludeDeleted Defines if deleted channels should be returned or not
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`
}

// GetPostsAroundLastUnreadParams defines parameters for GetPostsAroundLastUnread.
type GetPostsAroundLastUnreadParams struct {
	// LimitBefore Number of posts before the oldest unread posts. Maximum is 200 posts if limit is set greater than that.
	LimitBefore *int `form:"limit_before,omitempty" json:"limit_before,omitempty"`

	// LimitAfter Number of posts after and including the oldest unread post. Maximum is 200 posts if limit is set greater than that.
	LimitAfter *int `form:"limit_after,omitempty" json:"limit_after,omitempty"`

	// SkipFetchThreads Whether to skip fetching threads or not
	SkipFetchThreads *bool `form:"skipFetchThreads,omitempty" json:"skipFetchThreads,omitempty"`

	// CollapsedThreads Whether the client uses CRT or not
	CollapsedThreads *bool `form:"collapsedThreads,omitempty" json:"collapsedThreads,omitempty"`

	// CollapsedThreadsExtended Whether to return the associated users as part of the response or not
	CollapsedThreadsExtended *bool `form:"collapsedThreadsExtended,omitempty" json:"collapsedThreadsExtended,omitempty"`
}

// GetChannelPoliciesForUserParams defines parameters for GetChannelPoliciesForUser.
type GetChannelPoliciesForUserParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of policies per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetTeamPoliciesForUserParams defines parameters for GetTeamPoliciesForUser.
type GetTeamPoliciesForUserParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of policies per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetProfileImageParams defines parameters for GetProfileImage.
type GetProfileImageParams struct {
	// CacheBuster Not used by the server. Clients can pass in the last picture update time of the user to potentially take advantage of caching
	CacheBuster *float32 `form:"cache_buster,omitempty" json:"cache_buster,omitempty"`
}

// SetProfileImageMultipartBody defines parameters for SetProfileImage.
type SetProfileImageMultipartBody struct {
	// Image The image to be uploaded
	Image openapi_types.File `json:"image"`
}

// UpdateUserMfaJSONBody defines parameters for UpdateUserMfa.
type UpdateUserMfaJSONBody struct {
	// Activate Use `true` to activate, `false` to deactivate
	Activate bool `json:"activate"`

	// Code The code produced by your MFA client. Required if `activate` is true
	Code *string `json:"code,omitempty"`
}

// GetAuthorizedOAuthAppsForUserParams defines parameters for GetAuthorizedOAuthAppsForUser.
type GetAuthorizedOAuthAppsForUserParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of apps per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// UpdateUserPasswordJSONBody defines parameters for UpdateUserPassword.
type UpdateUserPasswordJSONBody struct {
	// CurrentPassword The current password for the user
	CurrentPassword *string `json:"current_password,omitempty"`

	// NewPassword The new password for the user
	NewPassword string `json:"new_password"`
}

// PatchUserJSONBody defines parameters for PatchUser.
type PatchUserJSONBody struct {
	Email       *string                 `json:"email,omitempty"`
	FirstName   *string                 `json:"first_name,omitempty"`
	LastName    *string                 `json:"last_name,omitempty"`
	Locale      *string                 `json:"locale,omitempty"`
	Nickname    *string                 `json:"nickname,omitempty"`
	NotifyProps *UserNotifyProps        `json:"notify_props,omitempty"`
	Position    *string                 `json:"position,omitempty"`
	Props       *map[string]interface{} `json:"props,omitempty"`
	Timezone    *Timezone               `json:"timezone,omitempty"`
	Username    *string                 `json:"username,omitempty"`
}

// GetFlaggedPostsForUserParams defines parameters for GetFlaggedPostsForUser.
type GetFlaggedPostsForUserParams struct {
	// TeamId Team ID
	TeamId *string `form:"team_id,omitempty" json:"team_id,omitempty"`

	// ChannelId Channel ID
	ChannelId *string `form:"channel_id,omitempty" json:"channel_id,omitempty"`

	// Page The page to select
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of posts per page
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// SetPostReminderJSONBody defines parameters for SetPostReminder.
type SetPostReminderJSONBody struct {
	// TargetTime Target time for the reminder
	TargetTime int `json:"target_time"`
}

// UpdatePreferencesJSONBody defines parameters for UpdatePreferences.
type UpdatePreferencesJSONBody = []Preference

// DeletePreferencesJSONBody defines parameters for DeletePreferences.
type DeletePreferencesJSONBody = []Preference

// UpdateUserRolesJSONBody defines parameters for UpdateUserRoles.
type UpdateUserRolesJSONBody struct {
	Roles string `json:"roles"`
}

// RevokeSessionJSONBody defines parameters for RevokeSession.
type RevokeSessionJSONBody struct {
	// SessionId The session GUID to revoke.
	SessionId string `json:"session_id"`
}

// UpdateUserStatusJSONBody defines parameters for UpdateUserStatus.
type UpdateUserStatusJSONBody struct {
	// DndEndTime Time in epoch seconds at which a dnd status would be unset.
	DndEndTime *int `json:"dnd_end_time,omitempty"`

	// Status User status, can be `online`, `away`, `offline` and `dnd`
	Status string `json:"status"`

	// UserId User ID
	UserId string `json:"user_id"`
}

// UpdateUserCustomStatusJSONBody defines parameters for UpdateUserCustomStatus.
type UpdateUserCustomStatusJSONBody struct {
	// Duration Duration of custom status, can be `thirty_minutes`, `one_hour`, `four_hours`, `today`, `this_week` or `date_and_time`
	Duration *string `json:"duration,omitempty"`

	// Emoji Any emoji
	Emoji string `json:"emoji"`

	// ExpiresAt The time at which custom status should be expired. It should be in ISO format.
	ExpiresAt *string `json:"expires_at,omitempty"`

	// Text Any custom status text
	Text string `json:"text"`
}

// RemoveRecentCustomStatusJSONBody defines parameters for RemoveRecentCustomStatus.
type RemoveRecentCustomStatusJSONBody struct {
	// Duration Duration of custom status, can be `thirty_minutes`, `one_hour`, `four_hours`, `today`, `this_week` or `date_and_time`
	Duration string `json:"duration"`

	// Emoji Any emoji
	Emoji string `json:"emoji"`

	// ExpiresAt The time at which custom status should be expired. It should be in ISO format.
	ExpiresAt string `json:"expires_at"`

	// Text Any custom status text
	Text string `json:"text"`
}

// PostUserRecentCustomStatusDeleteJSONBody defines parameters for PostUserRecentCustomStatusDelete.
type PostUserRecentCustomStatusDeleteJSONBody struct {
	// Duration Duration of custom status, can be `thirty_minutes`, `one_hour`, `four_hours`, `today`, `this_week` or `date_and_time`
	Duration string `json:"duration"`

	// Emoji Any emoji
	Emoji string `json:"emoji"`

	// ExpiresAt The time at which custom status should be expired. It should be in ISO format.
	ExpiresAt string `json:"expires_at"`

	// Text Any custom status text
	Text string `json:"text"`
}

// GetTeamsUnreadForUserParams defines parameters for GetTeamsUnreadForUser.
type GetTeamsUnreadForUserParams struct {
	// ExcludeTeam Optional team id to be excluded from the results
	ExcludeTeam string `form:"exclude_team" json:"exclude_team"`

	// IncludeCollapsedThreads Boolean to determine whether the collapsed threads should be included or not
	IncludeCollapsedThreads *bool `form:"include_collapsed_threads,omitempty" json:"include_collapsed_threads,omitempty"`
}

// GetChannelsForTeamForUserParams defines parameters for GetChannelsForTeamForUser.
type GetChannelsForTeamForUserParams struct {
	// IncludeDeleted Defines if deleted channels should be returned or not
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`

	// LastDeleteAt Filters the deleted channels by this time in epoch format. Does not have any effect if include_deleted is set to false.
	LastDeleteAt *int `form:"last_delete_at,omitempty" json:"last_delete_at,omitempty"`
}

// UpdateSidebarCategoriesForTeamForUserJSONBody defines parameters for UpdateSidebarCategoriesForTeamForUser.
type UpdateSidebarCategoriesForTeamForUserJSONBody = []SidebarCategory

// UpdateSidebarCategoryOrderForTeamForUserJSONBody defines parameters for UpdateSidebarCategoryOrderForTeamForUser.
type UpdateSidebarCategoryOrderForTeamForUserJSONBody = []string

// GetUserThreadsParams defines parameters for GetUserThreads.
type GetUserThreadsParams struct {
	// Since Since filters the threads based on their LastUpdateAt timestamp.
	Since *int `form:"since,omitempty" json:"since,omitempty"`

	// Deleted Deleted will specify that even deleted threads should be returned (For mobile sync).
	Deleted *bool `form:"deleted,omitempty" json:"deleted,omitempty"`

	// Extended Extended will enrich the response with participant details.
	Extended *bool `form:"extended,omitempty" json:"extended,omitempty"`

	// Page Page specifies which part of the results to return, by per_page.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The size of the returned chunk of results.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// TotalsOnly Setting this to true will only return the total counts.
	TotalsOnly *bool `form:"totalsOnly,omitempty" json:"totalsOnly,omitempty"`

	// ThreadsOnly Setting this to true will only return threads.
	ThreadsOnly *bool `form:"threadsOnly,omitempty" json:"threadsOnly,omitempty"`
}

// RegisterTermsOfServiceActionJSONBody defines parameters for RegisterTermsOfServiceAction.
type RegisterTermsOfServiceActionJSONBody struct {
	// Accepted true or false, indicates whether the user accepted or rejected the terms of service.
	Accepted string `json:"accepted"`

	// ServiceTermsId terms of service ID on which the user is acting on
	ServiceTermsId string `json:"serviceTermsId"`
}

// GetUserAccessTokensForUserParams defines parameters for GetUserAccessTokensForUser.
type GetUserAccessTokensForUserParams struct {
	// Page The page to select.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of tokens per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// CreateUserAccessTokenJSONBody defines parameters for CreateUserAccessToken.
type CreateUserAccessTokenJSONBody struct {
	// Description A description of the token usage
	Description string `json:"description"`
}

// PublishUserTypingJSONBody defines parameters for PublishUserTyping.
type PublishUserTypingJSONBody struct {
	// ChannelId The id of the channel to which to direct the typing event.
	ChannelId string `json:"channel_id"`

	// ParentId The optional id of the root post of the thread to which the user is replying. If unset, the typing event is directed at the entire channel.
	ParentId *string `json:"parent_id,omitempty"`
}

// GetFilePublicParams defines parameters for GetFilePublic.
type GetFilePublicParams struct {
	// H File hash
	H string `form:"h" json:"h"`
}

// GetPlaybooksParams defines parameters for GetPlaybooks.
type GetPlaybooksParams struct {
	// TeamId ID of the team to filter by.
	TeamId string `form:"team_id" json:"team_id"`

	// Page Zero-based index of the page to request.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of playbooks to return per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Sort Field to sort the returned playbooks by title, number of stages or total number of steps.
	Sort *GetPlaybooksParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Direction Direction (ascending or descending) followed by the sorting of the playbooks.
	Direction *GetPlaybooksParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// WithArchived Includes archived playbooks in the result.
	WithArchived *bool `form:"with_archived,omitempty" json:"with_archived,omitempty"`
}

// GetPlaybooksParamsSort defines parameters for GetPlaybooks.
type GetPlaybooksParamsSort string

// GetPlaybooksParamsDirection defines parameters for GetPlaybooks.
type GetPlaybooksParamsDirection string

// CreatePlaybookJSONBody defines parameters for CreatePlaybook.
type CreatePlaybookJSONBody struct {
	// AnnouncementChannelEnabled Boolean that indicates whether the playbook run creation will be announced in the channel declared in announcement_channel_id.
	AnnouncementChannelEnabled *bool `json:"announcement_channel_enabled,omitempty"`

	// AnnouncementChannelId ID of the channel where the playbook run will be automatically announced as soon as the playbook run is created.
	AnnouncementChannelId *string `json:"announcement_channel_id,omitempty"`

	// BroadcastChannelIds The IDs of the channels where all the status updates will be broadcasted. The team of the broadcast channel must be the same as the playbook's team.
	BroadcastChannelIds *[]string `json:"broadcast_channel_ids,omitempty"`

	// Checklists The stages defined by this playbook.
	Checklists []struct {
		// Items The list of tasks to do.
		Items []struct {
			// Command The slash command associated with this item. If the item has no slash command associated, this is an empty string
			Command *string `json:"command,omitempty"`

			// Description A detailed description of the checklist item, formatted with Markdown.
			Description *string `json:"description,omitempty"`

			// Title The title of the checklist item.
			Title string `json:"title"`
		} `json:"items"`

		// Title The title of the checklist.
		Title string `json:"title"`
	} `json:"checklists"`

	// CreatePublicPlaybookRun A boolean indicating whether the playbook runs created from this playbook should be public or private.
	CreatePublicPlaybookRun bool `json:"create_public_playbook_run"`

	// DefaultOwnerEnabled Boolean that indicates whether the member declared in default_owner_id will be automatically assigned as owner.
	DefaultOwnerEnabled *string `json:"default_owner_enabled,omitempty"`

	// DefaultOwnerId User ID of the member that will be automatically assigned as owner as soon as the playbook run is created. If the member is not part of the playbook run's channel or is not included in the invited_user_ids list, they will be automatically invited to the channel.
	DefaultOwnerId *string `json:"default_owner_id,omitempty"`

	// Description The description of the playbook.
	Description *string `json:"description,omitempty"`

	// InviteUsersEnabled Boolean that indicates whether the members declared in invited_user_ids will be automatically invited.
	InviteUsersEnabled *bool `json:"invite_users_enabled,omitempty"`

	// InvitedUserIds A list with the IDs of the members to be automatically invited to the playbook run's channel as soon as the playbook run is created.
	InvitedUserIds *[]string `json:"invited_user_ids,omitempty"`

	// MemberIds The identifiers of all the users that are members of this playbook.
	MemberIds []string `json:"member_ids"`

	// Public A boolean indicating whether the playbook is licensed as public or private. Required 'true' for free tier.
	Public *bool `json:"public,omitempty"`

	// TeamId The identifier of the team where the playbook is in.
	TeamId string `json:"team_id"`

	// Title The title of the playbook.
	Title string `json:"title"`

	// WebhookOnCreationEnabled Boolean that indicates whether the webhook declared in webhook_on_creation_url will be automatically sent.
	WebhookOnCreationEnabled *bool `json:"webhook_on_creation_enabled,omitempty"`

	// WebhookOnCreationUrl An absolute URL where a POST request will be sent as soon as the playbook run is created. The allowed protocols are HTTP and HTTPS.
	WebhookOnCreationUrl *string `json:"webhook_on_creation_url,omitempty"`

	// WebhookOnStatusUpdateEnabled Boolean that indicates whether the webhook declared in webhook_on_status_update_url will be automatically sent.
	WebhookOnStatusUpdateEnabled *bool `json:"webhook_on_status_update_enabled,omitempty"`

	// WebhookOnStatusUpdateUrl An absolute URL where a POST request will be sent as soon as the playbook run's status is updated. The allowed protocols are HTTP and HTTPS.
	WebhookOnStatusUpdateUrl *string `json:"webhook_on_status_update_url,omitempty"`
}

// ListPlaybookRunsParams defines parameters for ListPlaybookRuns.
type ListPlaybookRunsParams struct {
	// TeamId ID of the team to filter by.
	TeamId string `form:"team_id" json:"team_id"`

	// Page Zero-based index of the page to request.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of playbook runs to return per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Sort Field to sort the returned playbook runs by.
	Sort *ListPlaybookRunsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Direction Direction (ascending or descending) followed by the sorting of the playbook runs.
	Direction *ListPlaybookRunsParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// Statuses The returned list will contain only the playbook runs with the specified statuses.
	Statuses *[]ListPlaybookRunsParamsStatuses `form:"statuses,omitempty" json:"statuses,omitempty"`

	// OwnerUserId The returned list will contain only the playbook runs commanded by this user. Specify "me" for current user.
	OwnerUserId *string `form:"owner_user_id,omitempty" json:"owner_user_id,omitempty"`

	// ParticipantId The returned list will contain only the playbook runs for which the given user is a participant. Specify "me" for current user.
	ParticipantId *string `form:"participant_id,omitempty" json:"participant_id,omitempty"`

	// SearchTerm The returned list will contain only the playbook runs whose name contains the search term.
	SearchTerm *string `form:"search_term,omitempty" json:"search_term,omitempty"`
}

// ListPlaybookRunsParamsSort defines parameters for ListPlaybookRuns.
type ListPlaybookRunsParamsSort string

// ListPlaybookRunsParamsDirection defines parameters for ListPlaybookRuns.
type ListPlaybookRunsParamsDirection string

// ListPlaybookRunsParamsStatuses defines parameters for ListPlaybookRuns.
type ListPlaybookRunsParamsStatuses string

// CreatePlaybookRunFromPostJSONBody defines parameters for CreatePlaybookRunFromPost.
type CreatePlaybookRunFromPostJSONBody struct {
	// Description The description of the playbook run.
	Description *string `json:"description,omitempty"`

	// Name The name of the playbook run.
	Name string `json:"name"`

	// OwnerUserId The identifier of the user who is commanding the playbook run.
	OwnerUserId string `json:"owner_user_id"`

	// PlaybookId The identifier of the playbook with from which this playbook run was created.
	PlaybookId string `json:"playbook_id"`

	// PostId If the playbook run was created from a post, this field contains the identifier of such post. If not, this field is empty.
	PostId *string `json:"post_id,omitempty"`

	// TeamId The identifier of the team where the playbook run's channel is in.
	TeamId string `json:"team_id"`
}

// GetChannelsParams defines parameters for GetChannels.
type GetChannelsParams struct {
	// TeamId ID of the team to filter by.
	TeamId string `form:"team_id" json:"team_id"`

	// Sort Field to sort the returned channels by, according to their playbook run.
	Sort *GetChannelsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Direction Direction (ascending or descending) followed by the sorting of the playbook runs associated to the channels.
	Direction *GetChannelsParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// Status The returned list will contain only the channels whose playbook run has this status.
	Status *GetChannelsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// OwnerUserId The returned list will contain only the channels whose playbook run is commanded by this user.
	OwnerUserId *string `form:"owner_user_id,omitempty" json:"owner_user_id,omitempty"`

	// SearchTerm The returned list will contain only the channels associated to a playbook run whose name contains the search term.
	SearchTerm *string `form:"search_term,omitempty" json:"search_term,omitempty"`

	// ParticipantId The returned list will contain only the channels associated to a playbook run for which the given user is a participant.
	ParticipantId *string `form:"participant_id,omitempty" json:"participant_id,omitempty"`
}

// GetChannelsParamsSort defines parameters for GetChannels.
type GetChannelsParamsSort string

// GetChannelsParamsDirection defines parameters for GetChannels.
type GetChannelsParamsDirection string

// GetChannelsParamsStatus defines parameters for GetChannels.
type GetChannelsParamsStatus string

// GetChecklistAutocompleteParams defines parameters for GetChecklistAutocomplete.
type GetChecklistAutocompleteParams struct {
	// ChannelID ID of the channel the user is in.
	ChannelID string `form:"channel_ID" json:"channel_ID"`
}

// CreatePlaybookRunFromDialogJSONBody defines parameters for CreatePlaybookRunFromDialog.
type CreatePlaybookRunFromDialogJSONBody struct {
	// CallbackId Callback ID provided by the integration.
	CallbackId *string `json:"callback_id,omitempty"`

	// Cancelled If the dialog was cancelled.
	Cancelled *bool `json:"cancelled,omitempty"`

	// ChannelId ID of the channel the user was in when submitting the dialog.
	ChannelId *string `json:"channel_id,omitempty"`

	// State Stringified JSON with the post_id and the client_id.
	State *string `json:"state,omitempty"`

	// Submission Map of the dialog fields to their values
	Submission *struct {
		// PlaybookID ID of the playbook to create the playbook run from.
		PlaybookID string `json:"playbookID"`

		// PlaybookRunDescription An optional description of the playbook run.
		PlaybookRunDescription *string `json:"playbookRunDescription,omitempty"`

		// PlaybookRunName The name of the playbook run to be created.
		PlaybookRunName string `json:"playbookRunName"`
	} `json:"submission,omitempty"`

	// TeamId ID of the team the user was on when submitting the dialog.
	TeamId *string `json:"team_id,omitempty"`
	Type   *string `json:"type,omitempty"`
	Url    *string `json:"url,omitempty"`

	// UserId ID of the user who submitted the dialog.
	UserId *string `json:"user_id,omitempty"`
}

// GetOwnersParams defines parameters for GetOwners.
type GetOwnersParams struct {
	// TeamId ID of the team to filter by.
	TeamId string `form:"team_id" json:"team_id"`
}

// UpdatePlaybookRunJSONBody defines parameters for UpdatePlaybookRun.
type UpdatePlaybookRunJSONBody struct {
	// ActiveStage Zero-based index of the stage that will be made active.
	ActiveStage *int `json:"active_stage,omitempty"`
}

// AddChecklistItemJSONBody defines parameters for AddChecklistItem.
type AddChecklistItemJSONBody struct {
	// AssigneeId The identifier of the user that has been assigned to complete this item. If the item has no assignee, this is an empty string.
	AssigneeId *string `json:"assignee_id,omitempty"`

	// AssigneeModified The timestamp for the latest modification of the item's assignee, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the item never got an assignee.
	AssigneeModified *int `json:"assignee_modified,omitempty"`

	// Command The slash command associated with this item. If the item has no slash command associated, this is an empty string
	Command *string `json:"command,omitempty"`

	// CommandLastRun The timestamp for the latest execution of the item's command, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the command was never executed.
	CommandLastRun *int `json:"command_last_run,omitempty"`

	// Description A detailed description of the checklist item, formatted with Markdown.
	Description *string `json:"description,omitempty"`

	// State The state of the checklist item. An empty string means that the item is not done.
	State *AddChecklistItemJSONBodyState `json:"state,omitempty"`

	// StateModified The timestamp for the latest modification of the item's state, formatted as the number of milliseconds since the Unix epoch. It equals 0 if the item was never modified.
	StateModified *int `json:"state_modified,omitempty"`

	// Title The title of the checklist item.
	Title string `json:"title"`
}

// AddChecklistItemJSONBodyState defines parameters for AddChecklistItem.
type AddChecklistItemJSONBodyState string

// ItemRenameJSONBody defines parameters for ItemRename.
type ItemRenameJSONBody struct {
	// Command The new slash command of the item.
	Command string `json:"command"`

	// Title The new title of the item.
	Title string `json:"title"`
}

// ItemSetAssigneeJSONBody defines parameters for ItemSetAssignee.
type ItemSetAssigneeJSONBody struct {
	// AssigneeId The user ID of the new assignee of the item.
	AssigneeId string `json:"assignee_id"`
}

// ItemSetStateJSONBody defines parameters for ItemSetState.
type ItemSetStateJSONBody struct {
	// NewState The new state of the item.
	NewState ItemSetStateJSONBodyNewState `json:"new_state"`
}

// ItemSetStateJSONBodyNewState defines parameters for ItemSetState.
type ItemSetStateJSONBodyNewState string

// ReoderChecklistItemJSONBody defines parameters for ReoderChecklistItem.
type ReoderChecklistItemJSONBody struct {
	// ItemNum Zero-based index of the item to reorder.
	ItemNum int `json:"item_num"`

	// NewLocation Zero-based index of the new place to move the item to.
	NewLocation int `json:"new_location"`
}

// NextStageDialogJSONBody defines parameters for NextStageDialog.
type NextStageDialogJSONBody struct {
	// State String representation of the zero-based index of the stage to go to.
	State *string `json:"state,omitempty"`
}

// ChangeOwnerJSONBody defines parameters for ChangeOwner.
type ChangeOwnerJSONBody struct {
	// OwnerId The user ID of the new owner.
	OwnerId string `json:"owner_id"`
}

// StatusJSONBody defines parameters for Status.
type StatusJSONBody struct {
	// Message The status update message.
	Message string `json:"message"`

	// Reminder The number of seconds until the system will send a reminder to the owner to update the status. No reminder will be scheduled if reminder is 0 or omitted.
	Reminder *float32 `json:"reminder,omitempty"`
}

// OpenInteractiveDialogJSONRequestBody defines body for OpenInteractiveDialog for application/json ContentType.
type OpenInteractiveDialogJSONRequestBody OpenInteractiveDialogJSONBody

// SubmitInteractiveDialogJSONRequestBody defines body for SubmitInteractiveDialog for application/json ContentType.
type SubmitInteractiveDialogJSONRequestBody SubmitInteractiveDialogJSONBody

// CreateBotJSONRequestBody defines body for CreateBot for application/json ContentType.
type CreateBotJSONRequestBody CreateBotJSONBody

// PatchBotJSONRequestBody defines body for PatchBot for application/json ContentType.
type PatchBotJSONRequestBody PatchBotJSONBody

// ConvertBotToUserJSONRequestBody defines body for ConvertBotToUser for application/json ContentType.
type ConvertBotToUserJSONRequestBody ConvertBotToUserJSONBody

// SetBotIconImageMultipartRequestBody defines body for SetBotIconImage for multipart/form-data ContentType.
type SetBotIconImageMultipartRequestBody SetBotIconImageMultipartBody

// UploadBrandImageMultipartRequestBody defines body for UploadBrandImage for multipart/form-data ContentType.
type UploadBrandImageMultipartRequestBody UploadBrandImageMultipartBody

// CreateChannelJSONRequestBody defines body for CreateChannel for application/json ContentType.
type CreateChannelJSONRequestBody CreateChannelJSONBody

// CreateDirectChannelJSONRequestBody defines body for CreateDirectChannel for application/json ContentType.
type CreateDirectChannelJSONRequestBody = CreateDirectChannelJSONBody

// CreateGroupChannelJSONRequestBody defines body for CreateGroupChannel for application/json ContentType.
type CreateGroupChannelJSONRequestBody = CreateGroupChannelJSONBody

// SearchGroupChannelsJSONRequestBody defines body for SearchGroupChannels for application/json ContentType.
type SearchGroupChannelsJSONRequestBody SearchGroupChannelsJSONBody

// ViewChannelJSONRequestBody defines body for ViewChannel for application/json ContentType.
type ViewChannelJSONRequestBody ViewChannelJSONBody

// SearchAllChannelsJSONRequestBody defines body for SearchAllChannels for application/json ContentType.
type SearchAllChannelsJSONRequestBody SearchAllChannelsJSONBody

// UpdateChannelJSONRequestBody defines body for UpdateChannel for application/json ContentType.
type UpdateChannelJSONRequestBody UpdateChannelJSONBody

// CreateChannelBookmarkJSONRequestBody defines body for CreateChannelBookmark for application/json ContentType.
type CreateChannelBookmarkJSONRequestBody CreateChannelBookmarkJSONBody

// UpdateChannelBookmarkJSONRequestBody defines body for UpdateChannelBookmark for application/json ContentType.
type UpdateChannelBookmarkJSONRequestBody UpdateChannelBookmarkJSONBody

// UpdateChannelBookmarkSortOrderJSONRequestBody defines body for UpdateChannelBookmarkSortOrder for application/json ContentType.
type UpdateChannelBookmarkSortOrderJSONRequestBody = UpdateChannelBookmarkSortOrderJSONBody

// AddChannelMemberJSONRequestBody defines body for AddChannelMember for application/json ContentType.
type AddChannelMemberJSONRequestBody AddChannelMemberJSONBody

// GetChannelMembersByIdsJSONRequestBody defines body for GetChannelMembersByIds for application/json ContentType.
type GetChannelMembersByIdsJSONRequestBody = GetChannelMembersByIdsJSONBody

// UpdateChannelNotifyPropsJSONRequestBody defines body for UpdateChannelNotifyProps for application/json ContentType.
type UpdateChannelNotifyPropsJSONRequestBody = ChannelNotifyProps

// UpdateChannelRolesJSONRequestBody defines body for UpdateChannelRoles for application/json ContentType.
type UpdateChannelRolesJSONRequestBody UpdateChannelRolesJSONBody

// UpdateChannelMemberSchemeRolesJSONRequestBody defines body for UpdateChannelMemberSchemeRoles for application/json ContentType.
type UpdateChannelMemberSchemeRolesJSONRequestBody UpdateChannelMemberSchemeRolesJSONBody

// PatchChannelModerationsJSONRequestBody defines body for PatchChannelModerations for application/json ContentType.
type PatchChannelModerationsJSONRequestBody = ChannelModerationPatch

// MoveChannelJSONRequestBody defines body for MoveChannel for application/json ContentType.
type MoveChannelJSONRequestBody MoveChannelJSONBody

// PatchChannelJSONRequestBody defines body for PatchChannel for application/json ContentType.
type PatchChannelJSONRequestBody PatchChannelJSONBody

// UpdateChannelPrivacyJSONRequestBody defines body for UpdateChannelPrivacy for application/json ContentType.
type UpdateChannelPrivacyJSONRequestBody UpdateChannelPrivacyJSONBody

// UpdateChannelSchemeJSONRequestBody defines body for UpdateChannelScheme for application/json ContentType.
type UpdateChannelSchemeJSONRequestBody UpdateChannelSchemeJSONBody

// SubmitPerformanceReportJSONRequestBody defines body for SubmitPerformanceReport for application/json ContentType.
type SubmitPerformanceReportJSONRequestBody SubmitPerformanceReportJSONBody

// UpdateCloudCustomerJSONRequestBody defines body for UpdateCloudCustomer for application/json ContentType.
type UpdateCloudCustomerJSONRequestBody UpdateCloudCustomerJSONBody

// UpdateCloudCustomerAddressJSONRequestBody defines body for UpdateCloudCustomerAddress for application/json ContentType.
type UpdateCloudCustomerAddressJSONRequestBody = Address

// ConfirmCustomerPaymentMultipartRequestBody defines body for ConfirmCustomerPayment for multipart/form-data ContentType.
type ConfirmCustomerPaymentMultipartRequestBody ConfirmCustomerPaymentMultipartBody

// CreateCommandJSONRequestBody defines body for CreateCommand for application/json ContentType.
type CreateCommandJSONRequestBody CreateCommandJSONBody

// ExecuteCommandJSONRequestBody defines body for ExecuteCommand for application/json ContentType.
type ExecuteCommandJSONRequestBody ExecuteCommandJSONBody

// UpdateCommandJSONRequestBody defines body for UpdateCommand for application/json ContentType.
type UpdateCommandJSONRequestBody = Command

// MoveCommandJSONRequestBody defines body for MoveCommand for application/json ContentType.
type MoveCommandJSONRequestBody MoveCommandJSONBody

// UpdateConfigJSONRequestBody defines body for UpdateConfig for application/json ContentType.
type UpdateConfigJSONRequestBody = Config

// PatchConfigJSONRequestBody defines body for PatchConfig for application/json ContentType.
type PatchConfigJSONRequestBody = Config

// CreateDataRetentionPolicyJSONRequestBody defines body for CreateDataRetentionPolicy for application/json ContentType.
type CreateDataRetentionPolicyJSONRequestBody = DataRetentionPolicyCreate

// PatchDataRetentionPolicyJSONRequestBody defines body for PatchDataRetentionPolicy for application/json ContentType.
type PatchDataRetentionPolicyJSONRequestBody = DataRetentionPolicyWithTeamAndChannelIds

// RemoveChannelsFromRetentionPolicyJSONRequestBody defines body for RemoveChannelsFromRetentionPolicy for application/json ContentType.
type RemoveChannelsFromRetentionPolicyJSONRequestBody = RemoveChannelsFromRetentionPolicyJSONBody

// AddChannelsToRetentionPolicyJSONRequestBody defines body for AddChannelsToRetentionPolicy for application/json ContentType.
type AddChannelsToRetentionPolicyJSONRequestBody = AddChannelsToRetentionPolicyJSONBody

// SearchChannelsForRetentionPolicyJSONRequestBody defines body for SearchChannelsForRetentionPolicy for application/json ContentType.
type SearchChannelsForRetentionPolicyJSONRequestBody SearchChannelsForRetentionPolicyJSONBody

// RemoveTeamsFromRetentionPolicyJSONRequestBody defines body for RemoveTeamsFromRetentionPolicy for application/json ContentType.
type RemoveTeamsFromRetentionPolicyJSONRequestBody = RemoveTeamsFromRetentionPolicyJSONBody

// AddTeamsToRetentionPolicyJSONRequestBody defines body for AddTeamsToRetentionPolicy for application/json ContentType.
type AddTeamsToRetentionPolicyJSONRequestBody = AddTeamsToRetentionPolicyJSONBody

// SearchTeamsForRetentionPolicyJSONRequestBody defines body for SearchTeamsForRetentionPolicy for application/json ContentType.
type SearchTeamsForRetentionPolicyJSONRequestBody SearchTeamsForRetentionPolicyJSONBody

// TestEmailJSONRequestBody defines body for TestEmail for application/json ContentType.
type TestEmailJSONRequestBody = Config

// CreateEmojiMultipartRequestBody defines body for CreateEmoji for multipart/form-data ContentType.
type CreateEmojiMultipartRequestBody CreateEmojiMultipartBody

// GetEmojisByNamesJSONRequestBody defines body for GetEmojisByNames for application/json ContentType.
type GetEmojisByNamesJSONRequestBody = GetEmojisByNamesJSONBody

// SearchEmojiJSONRequestBody defines body for SearchEmoji for application/json ContentType.
type SearchEmojiJSONRequestBody SearchEmojiJSONBody

// TestS3ConnectionJSONRequestBody defines body for TestS3Connection for application/json ContentType.
type TestS3ConnectionJSONRequestBody = Config

// UploadFileMultipartRequestBody defines body for UploadFile for multipart/form-data ContentType.
type UploadFileMultipartRequestBody UploadFileMultipartBody

// SearchFilesMultipartRequestBody defines body for SearchFiles for multipart/form-data ContentType.
type SearchFilesMultipartRequestBody SearchFilesMultipartBody

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// PatchGroupSyncableForChannelJSONRequestBody defines body for PatchGroupSyncableForChannel for application/json ContentType.
type PatchGroupSyncableForChannelJSONRequestBody PatchGroupSyncableForChannelJSONBody

// DeleteGroupMembersJSONRequestBody defines body for DeleteGroupMembers for application/json ContentType.
type DeleteGroupMembersJSONRequestBody DeleteGroupMembersJSONBody

// AddGroupMembersJSONRequestBody defines body for AddGroupMembers for application/json ContentType.
type AddGroupMembersJSONRequestBody AddGroupMembersJSONBody

// PatchGroupJSONRequestBody defines body for PatchGroup for application/json ContentType.
type PatchGroupJSONRequestBody PatchGroupJSONBody

// PatchGroupSyncableForTeamJSONRequestBody defines body for PatchGroupSyncableForTeam for application/json ContentType.
type PatchGroupSyncableForTeamJSONRequestBody PatchGroupSyncableForTeamJSONBody

// CreateIncomingWebhookJSONRequestBody defines body for CreateIncomingWebhook for application/json ContentType.
type CreateIncomingWebhookJSONRequestBody CreateIncomingWebhookJSONBody

// UpdateIncomingWebhookJSONRequestBody defines body for UpdateIncomingWebhook for application/json ContentType.
type UpdateIncomingWebhookJSONRequestBody UpdateIncomingWebhookJSONBody

// CreateOutgoingWebhookJSONRequestBody defines body for CreateOutgoingWebhook for application/json ContentType.
type CreateOutgoingWebhookJSONRequestBody CreateOutgoingWebhookJSONBody

// UpdateOutgoingWebhookJSONRequestBody defines body for UpdateOutgoingWebhook for application/json ContentType.
type UpdateOutgoingWebhookJSONRequestBody UpdateOutgoingWebhookJSONBody

// ApplyIPFiltersJSONRequestBody defines body for ApplyIPFilters for application/json ContentType.
type ApplyIPFiltersJSONRequestBody = ApplyIPFiltersJSONBody

// CreateJobJSONRequestBody defines body for CreateJob for application/json ContentType.
type CreateJobJSONRequestBody CreateJobJSONBody

// UpdateJobStatusJSONRequestBody defines body for UpdateJobStatus for application/json ContentType.
type UpdateJobStatusJSONRequestBody UpdateJobStatusJSONBody

// UploadLdapPrivateCertificateMultipartRequestBody defines body for UploadLdapPrivateCertificate for multipart/form-data ContentType.
type UploadLdapPrivateCertificateMultipartRequestBody UploadLdapPrivateCertificateMultipartBody

// UploadLdapPublicCertificateMultipartRequestBody defines body for UploadLdapPublicCertificate for multipart/form-data ContentType.
type UploadLdapPublicCertificateMultipartRequestBody UploadLdapPublicCertificateMultipartBody

// MigrateIdLdapJSONRequestBody defines body for MigrateIdLdap for application/json ContentType.
type MigrateIdLdapJSONRequestBody MigrateIdLdapJSONBody

// UploadLicenseFileMultipartRequestBody defines body for UploadLicenseFile for multipart/form-data ContentType.
type UploadLicenseFileMultipartRequestBody UploadLicenseFileMultipartBody

// PostLogJSONRequestBody defines body for PostLog for application/json ContentType.
type PostLogJSONRequestBody PostLogJSONBody

// CreateOAuthAppJSONRequestBody defines body for CreateOAuthApp for application/json ContentType.
type CreateOAuthAppJSONRequestBody CreateOAuthAppJSONBody

// UpdateOAuthAppJSONRequestBody defines body for UpdateOAuthApp for application/json ContentType.
type UpdateOAuthAppJSONRequestBody UpdateOAuthAppJSONBody

// CreateOutgoingOAuthConnectionJSONRequestBody defines body for CreateOutgoingOAuthConnection for application/json ContentType.
type CreateOutgoingOAuthConnectionJSONRequestBody = OutgoingOAuthConnectionPostItem

// ValidateOutgoingOAuthConnectionJSONRequestBody defines body for ValidateOutgoingOAuthConnection for application/json ContentType.
type ValidateOutgoingOAuthConnectionJSONRequestBody = OutgoingOAuthConnectionPostItem

// UpdateOutgoingOAuthConnectionJSONRequestBody defines body for UpdateOutgoingOAuthConnection for application/json ContentType.
type UpdateOutgoingOAuthConnectionJSONRequestBody = OutgoingOAuthConnectionPostItem

// GetAncillaryPermissionsPostJSONRequestBody defines body for GetAncillaryPermissionsPost for application/json ContentType.
type GetAncillaryPermissionsPostJSONRequestBody = GetAncillaryPermissionsPostJSONBody

// UploadPluginMultipartRequestBody defines body for UploadPlugin for multipart/form-data ContentType.
type UploadPluginMultipartRequestBody UploadPluginMultipartBody

// InstallMarketplacePluginJSONRequestBody defines body for InstallMarketplacePlugin for application/json ContentType.
type InstallMarketplacePluginJSONRequestBody InstallMarketplacePluginJSONBody

// UpdateMarketplaceVisitedByAdminJSONRequestBody defines body for UpdateMarketplaceVisitedByAdmin for application/json ContentType.
type UpdateMarketplaceVisitedByAdminJSONRequestBody = System

// CreatePostJSONRequestBody defines body for CreatePost for application/json ContentType.
type CreatePostJSONRequestBody CreatePostJSONBody

// CreatePostEphemeralJSONRequestBody defines body for CreatePostEphemeral for application/json ContentType.
type CreatePostEphemeralJSONRequestBody CreatePostEphemeralJSONBody

// GetPostsByIdsJSONRequestBody defines body for GetPostsByIds for application/json ContentType.
type GetPostsByIdsJSONRequestBody = GetPostsByIdsJSONBody

// GetBulkReactionsJSONRequestBody defines body for GetBulkReactions for application/json ContentType.
type GetBulkReactionsJSONRequestBody = GetBulkReactionsJSONBody

// CreateScheduledPostJSONRequestBody defines body for CreateScheduledPost for application/json ContentType.
type CreateScheduledPostJSONRequestBody CreateScheduledPostJSONBody

// UpdateScheduledPostJSONRequestBody defines body for UpdateScheduledPost for application/json ContentType.
type UpdateScheduledPostJSONRequestBody UpdateScheduledPostJSONBody

// UpdatePostJSONRequestBody defines body for UpdatePost for application/json ContentType.
type UpdatePostJSONRequestBody UpdatePostJSONBody

// MoveThreadJSONRequestBody defines body for MoveThread for application/json ContentType.
type MoveThreadJSONRequestBody MoveThreadJSONBody

// PatchPostJSONRequestBody defines body for PatchPost for application/json ContentType.
type PatchPostJSONRequestBody PatchPostJSONBody

// SaveReactionJSONRequestBody defines body for SaveReaction for application/json ContentType.
type SaveReactionJSONRequestBody = Reaction

// CreateRemoteClusterJSONRequestBody defines body for CreateRemoteCluster for application/json ContentType.
type CreateRemoteClusterJSONRequestBody CreateRemoteClusterJSONBody

// AcceptRemoteClusterInviteJSONRequestBody defines body for AcceptRemoteClusterInvite for application/json ContentType.
type AcceptRemoteClusterInviteJSONRequestBody AcceptRemoteClusterInviteJSONBody

// PatchRemoteClusterJSONRequestBody defines body for PatchRemoteCluster for application/json ContentType.
type PatchRemoteClusterJSONRequestBody PatchRemoteClusterJSONBody

// GetRolesByNamesJSONRequestBody defines body for GetRolesByNames for application/json ContentType.
type GetRolesByNamesJSONRequestBody = GetRolesByNamesJSONBody

// PatchRoleJSONRequestBody defines body for PatchRole for application/json ContentType.
type PatchRoleJSONRequestBody PatchRoleJSONBody

// UploadSamlIdpCertificateMultipartRequestBody defines body for UploadSamlIdpCertificate for multipart/form-data ContentType.
type UploadSamlIdpCertificateMultipartRequestBody UploadSamlIdpCertificateMultipartBody

// UploadSamlPrivateCertificateMultipartRequestBody defines body for UploadSamlPrivateCertificate for multipart/form-data ContentType.
type UploadSamlPrivateCertificateMultipartRequestBody UploadSamlPrivateCertificateMultipartBody

// UploadSamlPublicCertificateMultipartRequestBody defines body for UploadSamlPublicCertificate for multipart/form-data ContentType.
type UploadSamlPublicCertificateMultipartRequestBody UploadSamlPublicCertificateMultipartBody

// GetSamlMetadataFromIdpJSONRequestBody defines body for GetSamlMetadataFromIdp for application/json ContentType.
type GetSamlMetadataFromIdpJSONRequestBody GetSamlMetadataFromIdpJSONBody

// ResetSamlAuthDataToEmailJSONRequestBody defines body for ResetSamlAuthDataToEmail for application/json ContentType.
type ResetSamlAuthDataToEmailJSONRequestBody ResetSamlAuthDataToEmailJSONBody

// CreateSchemeJSONRequestBody defines body for CreateScheme for application/json ContentType.
type CreateSchemeJSONRequestBody CreateSchemeJSONBody

// PatchSchemeJSONRequestBody defines body for PatchScheme for application/json ContentType.
type PatchSchemeJSONRequestBody PatchSchemeJSONBody

// TestSiteURLJSONRequestBody defines body for TestSiteURL for application/json ContentType.
type TestSiteURLJSONRequestBody TestSiteURLJSONBody

// MarkNoticesViewedJSONRequestBody defines body for MarkNoticesViewed for application/json ContentType.
type MarkNoticesViewedJSONRequestBody = MarkNoticesViewedJSONBody

// CreateTeamJSONRequestBody defines body for CreateTeam for application/json ContentType.
type CreateTeamJSONRequestBody CreateTeamJSONBody

// SearchTeamsJSONRequestBody defines body for SearchTeams for application/json ContentType.
type SearchTeamsJSONRequestBody SearchTeamsJSONBody

// UpdateTeamJSONRequestBody defines body for UpdateTeam for application/json ContentType.
type UpdateTeamJSONRequestBody UpdateTeamJSONBody

// GetPublicChannelsByIdsForTeamJSONRequestBody defines body for GetPublicChannelsByIdsForTeam for application/json ContentType.
type GetPublicChannelsByIdsForTeamJSONRequestBody = GetPublicChannelsByIdsForTeamJSONBody

// SearchChannelsJSONRequestBody defines body for SearchChannels for application/json ContentType.
type SearchChannelsJSONRequestBody SearchChannelsJSONBody

// SearchArchivedChannelsJSONRequestBody defines body for SearchArchivedChannels for application/json ContentType.
type SearchArchivedChannelsJSONRequestBody SearchArchivedChannelsJSONBody

// SearchFilesMultipartRequestBody defines body for SearchFiles for multipart/form-data ContentType.
type SearchFilesMultipartRequestBody SearchFilesMultipartBody

// SetTeamIconMultipartRequestBody defines body for SetTeamIcon for multipart/form-data ContentType.
type SetTeamIconMultipartRequestBody SetTeamIconMultipartBody

// ImportTeamMultipartRequestBody defines body for ImportTeam for multipart/form-data ContentType.
type ImportTeamMultipartRequestBody ImportTeamMultipartBody

// InviteGuestsToTeamJSONRequestBody defines body for InviteGuestsToTeam for application/json ContentType.
type InviteGuestsToTeamJSONRequestBody InviteGuestsToTeamJSONBody

// InviteUsersToTeamJSONRequestBody defines body for InviteUsersToTeam for application/json ContentType.
type InviteUsersToTeamJSONRequestBody = InviteUsersToTeamJSONBody

// AddTeamMemberJSONRequestBody defines body for AddTeamMember for application/json ContentType.
type AddTeamMemberJSONRequestBody AddTeamMemberJSONBody

// AddTeamMembersJSONRequestBody defines body for AddTeamMembers for application/json ContentType.
type AddTeamMembersJSONRequestBody = AddTeamMembersJSONBody

// GetTeamMembersByIdsJSONRequestBody defines body for GetTeamMembersByIds for application/json ContentType.
type GetTeamMembersByIdsJSONRequestBody = GetTeamMembersByIdsJSONBody

// UpdateTeamMemberRolesJSONRequestBody defines body for UpdateTeamMemberRoles for application/json ContentType.
type UpdateTeamMemberRolesJSONRequestBody UpdateTeamMemberRolesJSONBody

// UpdateTeamMemberSchemeRolesJSONRequestBody defines body for UpdateTeamMemberSchemeRoles for application/json ContentType.
type UpdateTeamMemberSchemeRolesJSONRequestBody UpdateTeamMemberSchemeRolesJSONBody

// PatchTeamJSONRequestBody defines body for PatchTeam for application/json ContentType.
type PatchTeamJSONRequestBody PatchTeamJSONBody

// SearchPostsJSONRequestBody defines body for SearchPosts for application/json ContentType.
type SearchPostsJSONRequestBody SearchPostsJSONBody

// UpdateTeamPrivacyJSONRequestBody defines body for UpdateTeamPrivacy for application/json ContentType.
type UpdateTeamPrivacyJSONRequestBody UpdateTeamPrivacyJSONBody

// UpdateTeamSchemeJSONRequestBody defines body for UpdateTeamScheme for application/json ContentType.
type UpdateTeamSchemeJSONRequestBody UpdateTeamSchemeJSONBody

// RequestTrialLicenseJSONRequestBody defines body for RequestTrialLicense for application/json ContentType.
type RequestTrialLicenseJSONRequestBody RequestTrialLicenseJSONBody

// CreateUploadJSONRequestBody defines body for CreateUpload for application/json ContentType.
type CreateUploadJSONRequestBody CreateUploadJSONBody

// UploadDataFormdataRequestBody defines body for UploadData for application/x-www-form-urlencoded ContentType.
type UploadDataFormdataRequestBody = UploadDataFormdataBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// VerifyUserEmailJSONRequestBody defines body for VerifyUserEmail for application/json ContentType.
type VerifyUserEmailJSONRequestBody VerifyUserEmailJSONBody

// SendVerificationEmailJSONRequestBody defines body for SendVerificationEmail for application/json ContentType.
type SendVerificationEmailJSONRequestBody SendVerificationEmailJSONBody

// GetUsersByGroupChannelIdsJSONRequestBody defines body for GetUsersByGroupChannelIds for application/json ContentType.
type GetUsersByGroupChannelIdsJSONRequestBody = GetUsersByGroupChannelIdsJSONBody

// GetUsersByIdsJSONRequestBody defines body for GetUsersByIds for application/json ContentType.
type GetUsersByIdsJSONRequestBody = GetUsersByIdsJSONBody

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// LoginByCwsTokenJSONRequestBody defines body for LoginByCwsToken for application/json ContentType.
type LoginByCwsTokenJSONRequestBody LoginByCwsTokenJSONBody

// SwitchAccountTypeJSONRequestBody defines body for SwitchAccountType for application/json ContentType.
type SwitchAccountTypeJSONRequestBody SwitchAccountTypeJSONBody

// CheckUserMfaJSONRequestBody defines body for CheckUserMfa for application/json ContentType.
type CheckUserMfaJSONRequestBody CheckUserMfaJSONBody

// MigrateAuthToLdapJSONRequestBody defines body for MigrateAuthToLdap for application/json ContentType.
type MigrateAuthToLdapJSONRequestBody MigrateAuthToLdapJSONBody

// MigrateAuthToSamlJSONRequestBody defines body for MigrateAuthToSaml for application/json ContentType.
type MigrateAuthToSamlJSONRequestBody MigrateAuthToSamlJSONBody

// ResetPasswordJSONRequestBody defines body for ResetPassword for application/json ContentType.
type ResetPasswordJSONRequestBody ResetPasswordJSONBody

// SendPasswordResetEmailJSONRequestBody defines body for SendPasswordResetEmail for application/json ContentType.
type SendPasswordResetEmailJSONRequestBody SendPasswordResetEmailJSONBody

// SearchUsersJSONRequestBody defines body for SearchUsers for application/json ContentType.
type SearchUsersJSONRequestBody SearchUsersJSONBody

// AttachDeviceExtraPropsJSONRequestBody defines body for AttachDeviceExtraProps for application/json ContentType.
type AttachDeviceExtraPropsJSONRequestBody AttachDeviceExtraPropsJSONBody

// GetUsersStatusesByIdsJSONRequestBody defines body for GetUsersStatusesByIds for application/json ContentType.
type GetUsersStatusesByIdsJSONRequestBody = GetUsersStatusesByIdsJSONBody

// DisableUserAccessTokenJSONRequestBody defines body for DisableUserAccessToken for application/json ContentType.
type DisableUserAccessTokenJSONRequestBody DisableUserAccessTokenJSONBody

// EnableUserAccessTokenJSONRequestBody defines body for EnableUserAccessToken for application/json ContentType.
type EnableUserAccessTokenJSONRequestBody EnableUserAccessTokenJSONBody

// RevokeUserAccessTokenJSONRequestBody defines body for RevokeUserAccessToken for application/json ContentType.
type RevokeUserAccessTokenJSONRequestBody RevokeUserAccessTokenJSONBody

// SearchUserAccessTokensJSONRequestBody defines body for SearchUserAccessTokens for application/json ContentType.
type SearchUserAccessTokensJSONRequestBody SearchUserAccessTokensJSONBody

// GetUsersByUsernamesJSONRequestBody defines body for GetUsersByUsernames for application/json ContentType.
type GetUsersByUsernamesJSONRequestBody = GetUsersByUsernamesJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// UpdateUserActiveJSONRequestBody defines body for UpdateUserActive for application/json ContentType.
type UpdateUserActiveJSONRequestBody UpdateUserActiveJSONBody

// UpdateUserAuthJSONRequestBody defines body for UpdateUserAuth for application/json ContentType.
type UpdateUserAuthJSONRequestBody = UserAuthData

// SetProfileImageMultipartRequestBody defines body for SetProfileImage for multipart/form-data ContentType.
type SetProfileImageMultipartRequestBody SetProfileImageMultipartBody

// UpdateUserMfaJSONRequestBody defines body for UpdateUserMfa for application/json ContentType.
type UpdateUserMfaJSONRequestBody UpdateUserMfaJSONBody

// UpdateUserPasswordJSONRequestBody defines body for UpdateUserPassword for application/json ContentType.
type UpdateUserPasswordJSONRequestBody UpdateUserPasswordJSONBody

// PatchUserJSONRequestBody defines body for PatchUser for application/json ContentType.
type PatchUserJSONRequestBody PatchUserJSONBody

// SetPostReminderJSONRequestBody defines body for SetPostReminder for application/json ContentType.
type SetPostReminderJSONRequestBody SetPostReminderJSONBody

// UpdatePreferencesJSONRequestBody defines body for UpdatePreferences for application/json ContentType.
type UpdatePreferencesJSONRequestBody = UpdatePreferencesJSONBody

// DeletePreferencesJSONRequestBody defines body for DeletePreferences for application/json ContentType.
type DeletePreferencesJSONRequestBody = DeletePreferencesJSONBody

// UpdateUserRolesJSONRequestBody defines body for UpdateUserRoles for application/json ContentType.
type UpdateUserRolesJSONRequestBody UpdateUserRolesJSONBody

// RevokeSessionJSONRequestBody defines body for RevokeSession for application/json ContentType.
type RevokeSessionJSONRequestBody RevokeSessionJSONBody

// UpdateUserStatusJSONRequestBody defines body for UpdateUserStatus for application/json ContentType.
type UpdateUserStatusJSONRequestBody UpdateUserStatusJSONBody

// UpdateUserCustomStatusJSONRequestBody defines body for UpdateUserCustomStatus for application/json ContentType.
type UpdateUserCustomStatusJSONRequestBody UpdateUserCustomStatusJSONBody

// RemoveRecentCustomStatusJSONRequestBody defines body for RemoveRecentCustomStatus for application/json ContentType.
type RemoveRecentCustomStatusJSONRequestBody RemoveRecentCustomStatusJSONBody

// PostUserRecentCustomStatusDeleteJSONRequestBody defines body for PostUserRecentCustomStatusDelete for application/json ContentType.
type PostUserRecentCustomStatusDeleteJSONRequestBody PostUserRecentCustomStatusDeleteJSONBody

// CreateSidebarCategoryForTeamForUserJSONRequestBody defines body for CreateSidebarCategoryForTeamForUser for application/json ContentType.
type CreateSidebarCategoryForTeamForUserJSONRequestBody = SidebarCategory

// UpdateSidebarCategoriesForTeamForUserJSONRequestBody defines body for UpdateSidebarCategoriesForTeamForUser for application/json ContentType.
type UpdateSidebarCategoriesForTeamForUserJSONRequestBody = UpdateSidebarCategoriesForTeamForUserJSONBody

// UpdateSidebarCategoryOrderForTeamForUserJSONRequestBody defines body for UpdateSidebarCategoryOrderForTeamForUser for application/json ContentType.
type UpdateSidebarCategoryOrderForTeamForUserJSONRequestBody = UpdateSidebarCategoryOrderForTeamForUserJSONBody

// UpdateSidebarCategoryForTeamForUserJSONRequestBody defines body for UpdateSidebarCategoryForTeamForUser for application/json ContentType.
type UpdateSidebarCategoryForTeamForUserJSONRequestBody = SidebarCategory

// RegisterTermsOfServiceActionJSONRequestBody defines body for RegisterTermsOfServiceAction for application/json ContentType.
type RegisterTermsOfServiceActionJSONRequestBody RegisterTermsOfServiceActionJSONBody

// CreateUserAccessTokenJSONRequestBody defines body for CreateUserAccessToken for application/json ContentType.
type CreateUserAccessTokenJSONRequestBody CreateUserAccessTokenJSONBody

// PublishUserTypingJSONRequestBody defines body for PublishUserTyping for application/json ContentType.
type PublishUserTypingJSONRequestBody PublishUserTypingJSONBody

// CreatePlaybookJSONRequestBody defines body for CreatePlaybook for application/json ContentType.
type CreatePlaybookJSONRequestBody CreatePlaybookJSONBody

// UpdatePlaybookJSONRequestBody defines body for UpdatePlaybook for application/json ContentType.
type UpdatePlaybookJSONRequestBody = Playbook

// CreatePlaybookRunFromPostJSONRequestBody defines body for CreatePlaybookRunFromPost for application/json ContentType.
type CreatePlaybookRunFromPostJSONRequestBody CreatePlaybookRunFromPostJSONBody

// CreatePlaybookRunFromDialogJSONRequestBody defines body for CreatePlaybookRunFromDialog for application/json ContentType.
type CreatePlaybookRunFromDialogJSONRequestBody CreatePlaybookRunFromDialogJSONBody

// UpdatePlaybookRunJSONRequestBody defines body for UpdatePlaybookRun for application/json ContentType.
type UpdatePlaybookRunJSONRequestBody UpdatePlaybookRunJSONBody

// AddChecklistItemJSONRequestBody defines body for AddChecklistItem for application/json ContentType.
type AddChecklistItemJSONRequestBody AddChecklistItemJSONBody

// ItemRenameJSONRequestBody defines body for ItemRename for application/json ContentType.
type ItemRenameJSONRequestBody ItemRenameJSONBody

// ItemSetAssigneeJSONRequestBody defines body for ItemSetAssignee for application/json ContentType.
type ItemSetAssigneeJSONRequestBody ItemSetAssigneeJSONBody

// ItemSetStateJSONRequestBody defines body for ItemSetState for application/json ContentType.
type ItemSetStateJSONRequestBody ItemSetStateJSONBody

// ReoderChecklistItemJSONRequestBody defines body for ReoderChecklistItem for application/json ContentType.
type ReoderChecklistItemJSONRequestBody ReoderChecklistItemJSONBody

// NextStageDialogJSONRequestBody defines body for NextStageDialog for application/json ContentType.
type NextStageDialogJSONRequestBody NextStageDialogJSONBody

// ChangeOwnerJSONRequestBody defines body for ChangeOwner for application/json ContentType.
type ChangeOwnerJSONRequestBody ChangeOwnerJSONBody

// StatusJSONRequestBody defines body for Status for application/json ContentType.
type StatusJSONRequestBody StatusJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// OpenInteractiveDialogWithBody request with any body
	OpenInteractiveDialogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OpenInteractiveDialog(ctx context.Context, body OpenInteractiveDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitInteractiveDialogWithBody request with any body
	SubmitInteractiveDialogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubmitInteractiveDialog(ctx context.Context, body SubmitInteractiveDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnalyticsOld request
	GetAnalyticsOld(ctx context.Context, params *GetAnalyticsOldParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudits request
	GetAudits(ctx context.Context, params *GetAuditsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PurgeBleveIndexes request
	PurgeBleveIndexes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBots request
	GetBots(ctx context.Context, params *GetBotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBotWithBody request with any body
	CreateBotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBot(ctx context.Context, body CreateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBot request
	GetBot(ctx context.Context, botUserId string, params *GetBotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchBotWithBody request with any body
	PatchBotWithBody(ctx context.Context, botUserId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchBot(ctx context.Context, botUserId string, body PatchBotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignBot request
	AssignBot(ctx context.Context, botUserId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConvertBotToUserWithBody request with any body
	ConvertBotToUserWithBody(ctx context.Context, botUserId string, params *ConvertBotToUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConvertBotToUser(ctx context.Context, botUserId string, params *ConvertBotToUserParams, body ConvertBotToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableBot request
	DisableBot(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableBot request
	EnableBot(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBotIconImage request
	DeleteBotIconImage(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBotIconImage request
	GetBotIconImage(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBotIconImageWithBody request with any body
	SetBotIconImageWithBody(ctx context.Context, botUserId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBrandImage request
	DeleteBrandImage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBrandImage request
	GetBrandImage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadBrandImageWithBody request with any body
	UploadBrandImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InvalidateCaches request
	InvalidateCaches(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllChannels request
	GetAllChannels(ctx context.Context, params *GetAllChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateChannelWithBody request with any body
	CreateChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateChannel(ctx context.Context, body CreateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDirectChannelWithBody request with any body
	CreateDirectChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDirectChannel(ctx context.Context, body CreateDirectChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroupChannelWithBody request with any body
	CreateGroupChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroupChannel(ctx context.Context, body CreateGroupChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchGroupChannelsWithBody request with any body
	SearchGroupChannelsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchGroupChannels(ctx context.Context, body SearchGroupChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ViewChannelWithBody request with any body
	ViewChannelWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ViewChannel(ctx context.Context, userId string, body ViewChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchAllChannelsWithBody request with any body
	SearchAllChannelsWithBody(ctx context.Context, params *SearchAllChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchAllChannels(ctx context.Context, params *SearchAllChannelsParams, body SearchAllChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteChannel request
	DeleteChannel(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannel request
	GetChannel(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelWithBody request with any body
	UpdateChannelWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateChannel(ctx context.Context, channelId string, body UpdateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListChannelBookmarksForChannel request
	ListChannelBookmarksForChannel(ctx context.Context, channelId string, params *ListChannelBookmarksForChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateChannelBookmarkWithBody request with any body
	CreateChannelBookmarkWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateChannelBookmark(ctx context.Context, channelId string, body CreateChannelBookmarkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteChannelBookmark request
	DeleteChannelBookmark(ctx context.Context, channelId string, bookmarkId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelBookmarkWithBody request with any body
	UpdateChannelBookmarkWithBody(ctx context.Context, channelId string, bookmarkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateChannelBookmark(ctx context.Context, channelId string, bookmarkId string, body UpdateChannelBookmarkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelBookmarkSortOrderWithBody request with any body
	UpdateChannelBookmarkSortOrderWithBody(ctx context.Context, channelId string, bookmarkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateChannelBookmarkSortOrder(ctx context.Context, channelId string, bookmarkId string, body UpdateChannelBookmarkSortOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupsByChannel request
	GetGroupsByChannel(ctx context.Context, channelId string, params *GetGroupsByChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelMemberCountsByGroup request
	GetChannelMemberCountsByGroup(ctx context.Context, channelId string, params *GetChannelMemberCountsByGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelMembers request
	GetChannelMembers(ctx context.Context, channelId string, params *GetChannelMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddChannelMemberWithBody request with any body
	AddChannelMemberWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddChannelMember(ctx context.Context, channelId string, body AddChannelMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelMembersByIdsWithBody request with any body
	GetChannelMembersByIdsWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetChannelMembersByIds(ctx context.Context, channelId string, body GetChannelMembersByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserFromChannel request
	RemoveUserFromChannel(ctx context.Context, channelId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelMember request
	GetChannelMember(ctx context.Context, channelId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelNotifyPropsWithBody request with any body
	UpdateChannelNotifyPropsWithBody(ctx context.Context, channelId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateChannelNotifyProps(ctx context.Context, channelId string, userId string, body UpdateChannelNotifyPropsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelRolesWithBody request with any body
	UpdateChannelRolesWithBody(ctx context.Context, channelId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateChannelRoles(ctx context.Context, channelId string, userId string, body UpdateChannelRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelMemberSchemeRolesWithBody request with any body
	UpdateChannelMemberSchemeRolesWithBody(ctx context.Context, channelId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateChannelMemberSchemeRoles(ctx context.Context, channelId string, userId string, body UpdateChannelMemberSchemeRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChannelMembersMinusGroupMembers request
	ChannelMembersMinusGroupMembers(ctx context.Context, channelId string, params *ChannelMembersMinusGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelModerations request
	GetChannelModerations(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchChannelModerationsWithBody request with any body
	PatchChannelModerationsWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchChannelModerations(ctx context.Context, channelId string, body PatchChannelModerationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MoveChannelWithBody request with any body
	MoveChannelWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MoveChannel(ctx context.Context, channelId string, body MoveChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchChannelWithBody request with any body
	PatchChannelWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchChannel(ctx context.Context, channelId string, body PatchChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPinnedPosts request
	GetPinnedPosts(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPostsForChannel request
	GetPostsForChannel(ctx context.Context, channelId string, params *GetPostsForChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelPrivacyWithBody request with any body
	UpdateChannelPrivacyWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateChannelPrivacy(ctx context.Context, channelId string, body UpdateChannelPrivacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreChannel request
	RestoreChannel(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelSchemeWithBody request with any body
	UpdateChannelSchemeWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateChannelScheme(ctx context.Context, channelId string, body UpdateChannelSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelStats request
	GetChannelStats(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelMembersTimezones request
	GetChannelMembersTimezones(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitPerformanceReportWithBody request with any body
	SubmitPerformanceReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubmitPerformanceReport(ctx context.Context, body SubmitPerformanceReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCloudCustomer request
	GetCloudCustomer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCloudCustomerWithBody request with any body
	UpdateCloudCustomerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCloudCustomer(ctx context.Context, body UpdateCloudCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCloudCustomerAddressWithBody request with any body
	UpdateCloudCustomerAddressWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCloudCustomerAddress(ctx context.Context, body UpdateCloudCustomerAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEndpointForInstallationInformation request
	GetEndpointForInstallationInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCloudLimits request
	GetCloudLimits(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomerPayment request
	CreateCustomerPayment(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmCustomerPaymentWithBody request with any body
	ConfirmCustomerPaymentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCloudProducts request
	GetCloudProducts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscription request
	GetSubscription(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvoicesForSubscription request
	GetInvoicesForSubscription(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvoiceForSubscriptionAsPdf request
	GetInvoiceForSubscriptionAsPdf(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEndpointForCwsWebhooks request
	PostEndpointForCwsWebhooks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterStatus request
	GetClusterStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCommands request
	ListCommands(ctx context.Context, params *ListCommandsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCommandWithBody request with any body
	CreateCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCommand(ctx context.Context, body CreateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteCommandWithBody request with any body
	ExecuteCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecuteCommand(ctx context.Context, body ExecuteCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCommand request
	DeleteCommand(ctx context.Context, commandId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommandById request
	GetCommandById(ctx context.Context, commandId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCommandWithBody request with any body
	UpdateCommandWithBody(ctx context.Context, commandId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCommand(ctx context.Context, commandId string, body UpdateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MoveCommandWithBody request with any body
	MoveCommandWithBody(ctx context.Context, commandId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MoveCommand(ctx context.Context, commandId string, body MoveCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegenCommandToken request
	RegenCommandToken(ctx context.Context, commandId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComplianceReports request
	GetComplianceReports(ctx context.Context, params *GetComplianceReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateComplianceReport request
	CreateComplianceReport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComplianceReport request
	GetComplianceReport(ctx context.Context, reportId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadComplianceReport request
	DownloadComplianceReport(ctx context.Context, reportId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConfigWithBody request with any body
	UpdateConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConfig(ctx context.Context, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientConfig request
	GetClientConfig(ctx context.Context, params *GetClientConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironmentConfig request
	GetEnvironmentConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchConfigWithBody request with any body
	PatchConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchConfig(ctx context.Context, body PatchConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReloadConfig request
	ReloadConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataRetentionPolicies request
	GetDataRetentionPolicies(ctx context.Context, params *GetDataRetentionPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDataRetentionPolicyWithBody request with any body
	CreateDataRetentionPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDataRetentionPolicy(ctx context.Context, body CreateDataRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDataRetentionPolicy request
	DeleteDataRetentionPolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataRetentionPolicyByID request
	GetDataRetentionPolicyByID(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchDataRetentionPolicyWithBody request with any body
	PatchDataRetentionPolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchDataRetentionPolicy(ctx context.Context, policyId string, body PatchDataRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveChannelsFromRetentionPolicyWithBody request with any body
	RemoveChannelsFromRetentionPolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveChannelsFromRetentionPolicy(ctx context.Context, policyId string, body RemoveChannelsFromRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelsForRetentionPolicy request
	GetChannelsForRetentionPolicy(ctx context.Context, policyId string, params *GetChannelsForRetentionPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddChannelsToRetentionPolicyWithBody request with any body
	AddChannelsToRetentionPolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddChannelsToRetentionPolicy(ctx context.Context, policyId string, body AddChannelsToRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchChannelsForRetentionPolicyWithBody request with any body
	SearchChannelsForRetentionPolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchChannelsForRetentionPolicy(ctx context.Context, policyId string, body SearchChannelsForRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTeamsFromRetentionPolicyWithBody request with any body
	RemoveTeamsFromRetentionPolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveTeamsFromRetentionPolicy(ctx context.Context, policyId string, body RemoveTeamsFromRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsForRetentionPolicy request
	GetTeamsForRetentionPolicy(ctx context.Context, policyId string, params *GetTeamsForRetentionPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTeamsToRetentionPolicyWithBody request with any body
	AddTeamsToRetentionPolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTeamsToRetentionPolicy(ctx context.Context, policyId string, body AddTeamsToRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchTeamsForRetentionPolicyWithBody request with any body
	SearchTeamsForRetentionPolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchTeamsForRetentionPolicy(ctx context.Context, policyId string, body SearchTeamsForRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataRetentionPoliciesCount request
	GetDataRetentionPoliciesCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataRetentionPolicy request
	GetDataRetentionPolicy(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DatabaseRecycle request
	DatabaseRecycle(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PurgeElasticsearchIndexes request
	PurgeElasticsearchIndexes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestElasticsearch request
	TestElasticsearch(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestEmailWithBody request with any body
	TestEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestEmail(ctx context.Context, body TestEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmojiList request
	GetEmojiList(ctx context.Context, params *GetEmojiListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEmojiWithBody request with any body
	CreateEmojiWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AutocompleteEmoji request
	AutocompleteEmoji(ctx context.Context, params *AutocompleteEmojiParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmojiByName request
	GetEmojiByName(ctx context.Context, emojiName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmojisByNamesWithBody request with any body
	GetEmojisByNamesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetEmojisByNames(ctx context.Context, body GetEmojisByNamesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchEmojiWithBody request with any body
	SearchEmojiWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchEmoji(ctx context.Context, body SearchEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEmoji request
	DeleteEmoji(ctx context.Context, emojiId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmoji request
	GetEmoji(ctx context.Context, emojiId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmojiImage request
	GetEmojiImage(ctx context.Context, emojiId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExports request
	ListExports(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteExport request
	DeleteExport(ctx context.Context, exportName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadExport request
	DownloadExport(ctx context.Context, exportName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestS3ConnectionWithBody request with any body
	TestS3ConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestS3Connection(ctx context.Context, body TestS3ConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadFileWithBody request with any body
	UploadFileWithBody(ctx context.Context, params *UploadFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchFilesWithBody request with any body
	SearchFilesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFile request
	GetFile(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFileInfo request
	GetFileInfo(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFileLink request
	GetFileLink(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilePreview request
	GetFilePreview(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFileThumbnail request
	GetFileThumbnail(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroups request
	GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroupWithBody request with any body
	CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupSyncablesChannels request
	GetGroupSyncablesChannels(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupSyncableForChannelId request
	GetGroupSyncableForChannelId(ctx context.Context, groupId string, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkGroupSyncableForChannel request
	UnlinkGroupSyncableForChannel(ctx context.Context, groupId string, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkGroupSyncableForChannel request
	LinkGroupSyncableForChannel(ctx context.Context, groupId string, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchGroupSyncableForChannelWithBody request with any body
	PatchGroupSyncableForChannelWithBody(ctx context.Context, groupId string, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchGroupSyncableForChannel(ctx context.Context, groupId string, channelId string, body PatchGroupSyncableForChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupMembersWithBody request with any body
	DeleteGroupMembersWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteGroupMembers(ctx context.Context, groupId string, body DeleteGroupMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupUsers request
	GetGroupUsers(ctx context.Context, groupId string, params *GetGroupUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddGroupMembersWithBody request with any body
	AddGroupMembersWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddGroupMembers(ctx context.Context, groupId string, body AddGroupMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchGroupWithBody request with any body
	PatchGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchGroup(ctx context.Context, groupId string, body PatchGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreGroup request
	RestoreGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupStats request
	GetGroupStats(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupSyncablesTeams request
	GetGroupSyncablesTeams(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupSyncableForTeamId request
	GetGroupSyncableForTeamId(ctx context.Context, groupId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkGroupSyncableForTeam request
	UnlinkGroupSyncableForTeam(ctx context.Context, groupId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkGroupSyncableForTeam request
	LinkGroupSyncableForTeam(ctx context.Context, groupId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchGroupSyncableForTeamWithBody request with any body
	PatchGroupSyncableForTeamWithBody(ctx context.Context, groupId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchGroupSyncableForTeam(ctx context.Context, groupId string, teamId string, body PatchGroupSyncableForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIncomingWebhooks request
	GetIncomingWebhooks(ctx context.Context, params *GetIncomingWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIncomingWebhookWithBody request with any body
	CreateIncomingWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIncomingWebhook(ctx context.Context, body CreateIncomingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIncomingWebhook request
	DeleteIncomingWebhook(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIncomingWebhook request
	GetIncomingWebhook(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIncomingWebhookWithBody request with any body
	UpdateIncomingWebhookWithBody(ctx context.Context, hookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateIncomingWebhook(ctx context.Context, hookId string, body UpdateIncomingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOutgoingWebhooks request
	GetOutgoingWebhooks(ctx context.Context, params *GetOutgoingWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOutgoingWebhookWithBody request with any body
	CreateOutgoingWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOutgoingWebhook(ctx context.Context, body CreateOutgoingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOutgoingWebhook request
	DeleteOutgoingWebhook(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOutgoingWebhook request
	GetOutgoingWebhook(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOutgoingWebhookWithBody request with any body
	UpdateOutgoingWebhookWithBody(ctx context.Context, hookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOutgoingWebhook(ctx context.Context, hookId string, body UpdateOutgoingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegenOutgoingHookToken request
	RegenOutgoingHookToken(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImageByUrl request
	GetImageByUrl(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListImports request
	ListImports(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckIntegrity request
	CheckIntegrity(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIPFilters request
	GetIPFilters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApplyIPFiltersWithBody request with any body
	ApplyIPFiltersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApplyIPFilters(ctx context.Context, body ApplyIPFiltersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MyIP request
	MyIP(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobs request
	GetJobs(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJobWithBody request with any body
	CreateJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateJob(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobsByType request
	GetJobsByType(ctx context.Context, pType string, params *GetJobsByTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelJob request
	CancelJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadJob request
	DownloadJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateJobStatusWithBody request with any body
	UpdateJobStatusWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateJobStatus(ctx context.Context, jobId string, body UpdateJobStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLdapPrivateCertificate request
	DeleteLdapPrivateCertificate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadLdapPrivateCertificateWithBody request with any body
	UploadLdapPrivateCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLdapPublicCertificate request
	DeleteLdapPublicCertificate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadLdapPublicCertificateWithBody request with any body
	UploadLdapPublicCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLdapGroups request
	GetLdapGroups(ctx context.Context, params *GetLdapGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkLdapGroup request
	UnlinkLdapGroup(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkLdapGroup request
	LinkLdapGroup(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrateIdLdapWithBody request with any body
	MigrateIdLdapWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrateIdLdap(ctx context.Context, body MigrateIdLdapJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncLdap request
	SyncLdap(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestLdap request
	TestLdap(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserToGroupSyncables request
	AddUserToGroupSyncables(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveLicenseFile request
	RemoveLicenseFile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadLicenseFileWithBody request with any body
	UploadLicenseFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientLicense request
	GetClientLicense(ctx context.Context, params *GetClientLicenseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestLicenseRenewalLink request
	RequestLicenseRenewalLink(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerLimits request
	GetServerLimits(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogs request
	GetLogs(ctx context.Context, params *GetLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLogWithBody request with any body
	PostLogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLog(ctx context.Context, body PostLogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadSystemLogs request
	DownloadSystemLogs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcknowledgeNotification request
	AcknowledgeNotification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestNotification request
	TestNotification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOAuthApps request
	GetOAuthApps(ctx context.Context, params *GetOAuthAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOAuthAppWithBody request with any body
	CreateOAuthAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOAuthApp(ctx context.Context, body CreateOAuthAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOAuthApp request
	DeleteOAuthApp(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOAuthApp request
	GetOAuthApp(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOAuthAppWithBody request with any body
	UpdateOAuthAppWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOAuthApp(ctx context.Context, appId string, body UpdateOAuthAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOAuthAppInfo request
	GetOAuthAppInfo(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegenerateOAuthAppSecret request
	RegenerateOAuthAppSecret(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOutgoingOAuthConnections request
	ListOutgoingOAuthConnections(ctx context.Context, params *ListOutgoingOAuthConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOutgoingOAuthConnectionWithBody request with any body
	CreateOutgoingOAuthConnectionWithBody(ctx context.Context, params *CreateOutgoingOAuthConnectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOutgoingOAuthConnection(ctx context.Context, params *CreateOutgoingOAuthConnectionParams, body CreateOutgoingOAuthConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateOutgoingOAuthConnectionWithBody request with any body
	ValidateOutgoingOAuthConnectionWithBody(ctx context.Context, params *ValidateOutgoingOAuthConnectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateOutgoingOAuthConnection(ctx context.Context, params *ValidateOutgoingOAuthConnectionParams, body ValidateOutgoingOAuthConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOutgoingOAuthConnection request
	DeleteOutgoingOAuthConnection(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOutgoingOAuthConnection request
	GetOutgoingOAuthConnection(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOutgoingOAuthConnectionWithBody request with any body
	UpdateOutgoingOAuthConnectionWithBody(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOutgoingOAuthConnection(ctx context.Context, connectionId string, body UpdateOutgoingOAuthConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAncillaryPermissionsPostWithBody request with any body
	GetAncillaryPermissionsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetAncillaryPermissionsPost(ctx context.Context, body GetAncillaryPermissionsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlugins request
	GetPlugins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadPluginWithBody request with any body
	UploadPluginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallPluginFromUrl request
	InstallPluginFromUrl(ctx context.Context, params *InstallPluginFromUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMarketplacePlugins request
	GetMarketplacePlugins(ctx context.Context, params *GetMarketplacePluginsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallMarketplacePluginWithBody request with any body
	InstallMarketplacePluginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InstallMarketplacePlugin(ctx context.Context, body InstallMarketplacePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMarketplaceVisitedByAdmin request
	GetMarketplaceVisitedByAdmin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMarketplaceVisitedByAdminWithBody request with any body
	UpdateMarketplaceVisitedByAdminWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMarketplaceVisitedByAdmin(ctx context.Context, body UpdateMarketplaceVisitedByAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPluginStatuses request
	GetPluginStatuses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebappPlugins request
	GetWebappPlugins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePlugin request
	RemovePlugin(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisablePlugin request
	DisablePlugin(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnablePlugin request
	EnablePlugin(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePostWithBody request with any body
	CreatePostWithBody(ctx context.Context, params *CreatePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePost(ctx context.Context, params *CreatePostParams, body CreatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePostEphemeralWithBody request with any body
	CreatePostEphemeralWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePostEphemeral(ctx context.Context, body CreatePostEphemeralJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPostsByIdsWithBody request with any body
	GetPostsByIdsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPostsByIds(ctx context.Context, body GetPostsByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBulkReactionsWithBody request with any body
	GetBulkReactionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetBulkReactions(ctx context.Context, body GetBulkReactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateScheduledPostWithBody request with any body
	CreateScheduledPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateScheduledPost(ctx context.Context, body CreateScheduledPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteScheduledPost request
	DeleteScheduledPost(ctx context.Context, scheduledPostId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateScheduledPostWithBody request with any body
	UpdateScheduledPostWithBody(ctx context.Context, scheduledPostId string, params *UpdateScheduledPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateScheduledPost(ctx context.Context, scheduledPostId string, params *UpdateScheduledPostParams, body UpdateScheduledPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserScheduledPosts request
	GetUserScheduledPosts(ctx context.Context, teamId string, params *GetUserScheduledPostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePost request
	DeletePost(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPost request
	GetPost(ctx context.Context, postId string, params *GetPostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePostWithBody request with any body
	UpdatePostWithBody(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePost(ctx context.Context, postId string, body UpdatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DoPostAction request
	DoPostAction(ctx context.Context, postId string, actionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFileInfosForPost request
	GetFileInfosForPost(ctx context.Context, postId string, params *GetFileInfosForPostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MoveThreadWithBody request with any body
	MoveThreadWithBody(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MoveThread(ctx context.Context, postId string, body MoveThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchPostWithBody request with any body
	PatchPostWithBody(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchPost(ctx context.Context, postId string, body PatchPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PinPost request
	PinPost(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReactions request
	GetReactions(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPostThread request
	GetPostThread(ctx context.Context, postId string, params *GetPostThreadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnpinPost request
	UnpinPost(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveReactionWithBody request with any body
	SaveReactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveReaction(ctx context.Context, body SaveReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRedirectLocation request
	GetRedirectLocation(ctx context.Context, params *GetRedirectLocationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRemoteClusters request
	GetRemoteClusters(ctx context.Context, params *GetRemoteClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRemoteClusterWithBody request with any body
	CreateRemoteClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRemoteCluster(ctx context.Context, body CreateRemoteClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptRemoteClusterInviteWithBody request with any body
	AcceptRemoteClusterInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AcceptRemoteClusterInvite(ctx context.Context, body AcceptRemoteClusterInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRemoteCluster request
	DeleteRemoteCluster(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRemoteCluster request
	GetRemoteCluster(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchRemoteClusterWithBody request with any body
	PatchRemoteClusterWithBody(ctx context.Context, remoteId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchRemoteCluster(ctx context.Context, remoteId string, body PatchRemoteClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteRemoteClusterToChannel request
	InviteRemoteClusterToChannel(ctx context.Context, remoteId string, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UninviteRemoteClusterToChannel request
	UninviteRemoteClusterToChannel(ctx context.Context, remoteId string, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSharedChannelRemotesByRemoteCluster request
	GetSharedChannelRemotesByRemoteCluster(ctx context.Context, remoteId string, params *GetSharedChannelRemotesByRemoteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersForReporting request
	GetUsersForReporting(ctx context.Context, params *GetUsersForReportingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserCountForReporting request
	GetUserCountForReporting(ctx context.Context, params *GetUserCountForReportingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartBatchUsersExport request
	StartBatchUsersExport(ctx context.Context, params *StartBatchUsersExportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartServer request
	RestartServer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllRoles request
	GetAllRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoleByName request
	GetRoleByName(ctx context.Context, roleName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRolesByNamesWithBody request with any body
	GetRolesByNamesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetRolesByNames(ctx context.Context, body GetRolesByNamesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRole request
	GetRole(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchRoleWithBody request with any body
	PatchRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchRole(ctx context.Context, roleId string, body PatchRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSamlIdpCertificate request
	DeleteSamlIdpCertificate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadSamlIdpCertificateWithBody request with any body
	UploadSamlIdpCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSamlPrivateCertificate request
	DeleteSamlPrivateCertificate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadSamlPrivateCertificateWithBody request with any body
	UploadSamlPrivateCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSamlPublicCertificate request
	DeleteSamlPublicCertificate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadSamlPublicCertificateWithBody request with any body
	UploadSamlPublicCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSamlCertificateStatus request
	GetSamlCertificateStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSamlMetadata request
	GetSamlMetadata(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSamlMetadataFromIdpWithBody request with any body
	GetSamlMetadataFromIdpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetSamlMetadataFromIdp(ctx context.Context, body GetSamlMetadataFromIdpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetSamlAuthDataToEmailWithBody request with any body
	ResetSamlAuthDataToEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetSamlAuthDataToEmail(ctx context.Context, body ResetSamlAuthDataToEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemes request
	GetSchemes(ctx context.Context, params *GetSchemesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSchemeWithBody request with any body
	CreateSchemeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateScheme(ctx context.Context, body CreateSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteScheme request
	DeleteScheme(ctx context.Context, schemeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScheme request
	GetScheme(ctx context.Context, schemeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelsForScheme request
	GetChannelsForScheme(ctx context.Context, schemeId string, params *GetChannelsForSchemeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSchemeWithBody request with any body
	PatchSchemeWithBody(ctx context.Context, schemeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchScheme(ctx context.Context, schemeId string, body PatchSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsForScheme request
	GetTeamsForScheme(ctx context.Context, schemeId string, params *GetTeamsForSchemeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearServerBusy request
	ClearServerBusy(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerBusyExpires request
	GetServerBusyExpires(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetServerBusy request
	SetServerBusy(ctx context.Context, params *SetServerBusyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRemoteClusterInfo request
	GetRemoteClusterInfo(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSharedChannels request
	GetAllSharedChannels(ctx context.Context, teamId string, params *GetAllSharedChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestSiteURLWithBody request with any body
	TestSiteURLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestSiteURL(ctx context.Context, body TestSiteURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkNoticesViewedWithBody request with any body
	MarkNoticesViewedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkNoticesViewed(ctx context.Context, body MarkNoticesViewedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotices request
	GetNotices(ctx context.Context, teamId string, params *GetNoticesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPing request
	GetPing(ctx context.Context, params *GetPingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateSupportPacket request
	GenerateSupportPacket(ctx context.Context, params *GenerateSupportPacketParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSupportedTimezone request
	GetSupportedTimezone(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTeams request
	GetAllTeams(ctx context.Context, params *GetAllTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTeamWithBody request with any body
	CreateTeamWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTeam(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamInviteInfo request
	GetTeamInviteInfo(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InvalidateEmailInvites request
	InvalidateEmailInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTeamMemberFromInvite request
	AddTeamMemberFromInvite(ctx context.Context, params *AddTeamMemberFromInviteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamByName request
	GetTeamByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamExists request
	TeamExists(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelByNameForTeamName request
	GetChannelByNameForTeamName(ctx context.Context, teamName string, channelName string, params *GetChannelByNameForTeamNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchTeamsWithBody request with any body
	SearchTeamsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchTeams(ctx context.Context, body SearchTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SoftDeleteTeam request
	SoftDeleteTeam(ctx context.Context, teamId string, params *SoftDeleteTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeam request
	GetTeam(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTeamWithBody request with any body
	UpdateTeamWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTeam(ctx context.Context, teamId string, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicChannelsForTeam request
	GetPublicChannelsForTeam(ctx context.Context, teamId string, params *GetPublicChannelsForTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AutocompleteChannelsForTeam request
	AutocompleteChannelsForTeam(ctx context.Context, teamId string, params *AutocompleteChannelsForTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeletedChannelsForTeam request
	GetDeletedChannelsForTeam(ctx context.Context, teamId string, params *GetDeletedChannelsForTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicChannelsByIdsForTeamWithBody request with any body
	GetPublicChannelsByIdsForTeamWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPublicChannelsByIdsForTeam(ctx context.Context, teamId string, body GetPublicChannelsByIdsForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelByName request
	GetChannelByName(ctx context.Context, teamId string, channelName string, params *GetChannelByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrivateChannelsForTeam request
	GetPrivateChannelsForTeam(ctx context.Context, teamId string, params *GetPrivateChannelsForTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchChannelsWithBody request with any body
	SearchChannelsWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchChannels(ctx context.Context, teamId string, body SearchChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchArchivedChannelsWithBody request with any body
	SearchArchivedChannelsWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchArchivedChannels(ctx context.Context, teamId string, body SearchArchivedChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AutocompleteChannelsForTeamForSearch request
	AutocompleteChannelsForTeamForSearch(ctx context.Context, teamId string, params *AutocompleteChannelsForTeamForSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAutocompleteCommands request
	ListAutocompleteCommands(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCommandAutocompleteSuggestions request
	ListCommandAutocompleteSuggestions(ctx context.Context, teamId string, params *ListCommandAutocompleteSuggestionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchFilesWithBody request with any body
	SearchFilesWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupsByTeam request
	GetGroupsByTeam(ctx context.Context, teamId string, params *GetGroupsByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupsAssociatedToChannelsByTeam request
	GetGroupsAssociatedToChannelsByTeam(ctx context.Context, teamId string, params *GetGroupsAssociatedToChannelsByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTeamIcon request
	RemoveTeamIcon(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamIcon request
	GetTeamIcon(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetTeamIconWithBody request with any body
	SetTeamIconWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportTeamWithBody request with any body
	ImportTeamWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteGuestsToTeamWithBody request with any body
	InviteGuestsToTeamWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteGuestsToTeam(ctx context.Context, teamId string, body InviteGuestsToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteUsersToTeamWithBody request with any body
	InviteUsersToTeamWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteUsersToTeam(ctx context.Context, teamId string, body InviteUsersToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamMembers request
	GetTeamMembers(ctx context.Context, teamId string, params *GetTeamMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTeamMemberWithBody request with any body
	AddTeamMemberWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTeamMember(ctx context.Context, teamId string, body AddTeamMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTeamMembersWithBody request with any body
	AddTeamMembersWithBody(ctx context.Context, teamId string, params *AddTeamMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTeamMembers(ctx context.Context, teamId string, params *AddTeamMembersParams, body AddTeamMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamMembersByIdsWithBody request with any body
	GetTeamMembersByIdsWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetTeamMembersByIds(ctx context.Context, teamId string, body GetTeamMembersByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTeamMember request
	RemoveTeamMember(ctx context.Context, teamId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamMember request
	GetTeamMember(ctx context.Context, teamId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTeamMemberRolesWithBody request with any body
	UpdateTeamMemberRolesWithBody(ctx context.Context, teamId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTeamMemberRoles(ctx context.Context, teamId string, userId string, body UpdateTeamMemberRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTeamMemberSchemeRolesWithBody request with any body
	UpdateTeamMemberSchemeRolesWithBody(ctx context.Context, teamId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTeamMemberSchemeRoles(ctx context.Context, teamId string, userId string, body UpdateTeamMemberSchemeRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamMembersMinusGroupMembers request
	TeamMembersMinusGroupMembers(ctx context.Context, teamId string, params *TeamMembersMinusGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchTeamWithBody request with any body
	PatchTeamWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchTeam(ctx context.Context, teamId string, body PatchTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchPostsWithBody request with any body
	SearchPostsWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchPosts(ctx context.Context, teamId string, body SearchPostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTeamPrivacyWithBody request with any body
	UpdateTeamPrivacyWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTeamPrivacy(ctx context.Context, teamId string, body UpdateTeamPrivacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegenerateTeamInviteId request
	RegenerateTeamInviteId(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreTeam request
	RestoreTeam(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTeamSchemeWithBody request with any body
	UpdateTeamSchemeWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTeamScheme(ctx context.Context, teamId string, body UpdateTeamSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamStats request
	GetTeamStats(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTermsOfService request
	GetTermsOfService(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTermsOfService request
	CreateTermsOfService(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestTrialLicenseWithBody request with any body
	RequestTrialLicenseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestTrialLicense(ctx context.Context, body RequestTrialLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrevTrialLicense request
	GetPrevTrialLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpgradeToEnterprise request
	UpgradeToEnterprise(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpgradeToEnterpriseStatus request
	UpgradeToEnterpriseStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUploadWithBody request with any body
	CreateUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUpload(ctx context.Context, body CreateUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUpload request
	GetUpload(ctx context.Context, uploadId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadDataWithBody request with any body
	UploadDataWithBody(ctx context.Context, uploadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadDataWithFormdataBody(ctx context.Context, uploadId string, body UploadDataFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPostsUsage request
	GetPostsUsage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorageUsage request
	GetStorageUsage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermanentDeleteAllUsers request
	PermanentDeleteAllUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AutocompleteUsers request
	AutocompleteUsers(ctx context.Context, params *AutocompleteUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyUserEmailWithBody request with any body
	VerifyUserEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VerifyUserEmail(ctx context.Context, body VerifyUserEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendVerificationEmailWithBody request with any body
	SendVerificationEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendVerificationEmail(ctx context.Context, body SendVerificationEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserByEmail request
	GetUserByEmail(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersByGroupChannelIdsWithBody request with any body
	GetUsersByGroupChannelIdsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetUsersByGroupChannelIds(ctx context.Context, body GetUsersByGroupChannelIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersByIdsWithBody request with any body
	GetUsersByIdsWithBody(ctx context.Context, params *GetUsersByIdsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetUsersByIds(ctx context.Context, params *GetUsersByIdsParams, body GetUsersByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersWithInvalidEmails request
	GetUsersWithInvalidEmails(ctx context.Context, params *GetUsersWithInvalidEmailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKnownUsers request
	GetKnownUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithBody request with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginByCwsTokenWithBody request with any body
	LoginByCwsTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoginByCwsToken(ctx context.Context, body LoginByCwsTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SwitchAccountTypeWithBody request with any body
	SwitchAccountTypeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SwitchAccountType(ctx context.Context, body SwitchAccountTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckUserMfaWithBody request with any body
	CheckUserMfaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckUserMfa(ctx context.Context, body CheckUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrateAuthToLdapWithBody request with any body
	MigrateAuthToLdapWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrateAuthToLdap(ctx context.Context, body MigrateAuthToLdapJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrateAuthToSamlWithBody request with any body
	MigrateAuthToSamlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrateAuthToSaml(ctx context.Context, body MigrateAuthToSamlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPasswordWithBody request with any body
	ResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetPassword(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendPasswordResetEmailWithBody request with any body
	SendPasswordResetEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendPasswordResetEmail(ctx context.Context, body SendPasswordResetEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUsersWithBody request with any body
	SearchUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUsers(ctx context.Context, body SearchUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachDeviceExtraPropsWithBody request with any body
	AttachDeviceExtraPropsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachDeviceExtraProps(ctx context.Context, body AttachDeviceExtraPropsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeSessionsFromAllUsers request
	RevokeSessionsFromAllUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTotalUsersStats request
	GetTotalUsersStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTotalUsersStatsFiltered request
	GetTotalUsersStatsFiltered(ctx context.Context, params *GetTotalUsersStatsFilteredParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersStatusesByIdsWithBody request with any body
	GetUsersStatusesByIdsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetUsersStatusesByIds(ctx context.Context, body GetUsersStatusesByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserAccessTokens request
	GetUserAccessTokens(ctx context.Context, params *GetUserAccessTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableUserAccessTokenWithBody request with any body
	DisableUserAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DisableUserAccessToken(ctx context.Context, body DisableUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableUserAccessTokenWithBody request with any body
	EnableUserAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnableUserAccessToken(ctx context.Context, body EnableUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeUserAccessTokenWithBody request with any body
	RevokeUserAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevokeUserAccessToken(ctx context.Context, body RevokeUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUserAccessTokensWithBody request with any body
	SearchUserAccessTokensWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUserAccessTokens(ctx context.Context, body SearchUserAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserAccessToken request
	GetUserAccessToken(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserByUsername request
	GetUserByUsername(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersByUsernamesWithBody request with any body
	GetUsersByUsernamesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetUsersByUsernames(ctx context.Context, body GetUsersByUsernamesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserActiveWithBody request with any body
	UpdateUserActiveWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserActive(ctx context.Context, userId string, body UpdateUserActiveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserAudits request
	GetUserAudits(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserAuthWithBody request with any body
	UpdateUserAuthWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserAuth(ctx context.Context, userId string, body UpdateUserAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelMembersWithTeamDataForUser request
	GetChannelMembersWithTeamDataForUser(ctx context.Context, userId string, params *GetChannelMembersWithTeamDataForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelsForUser request
	GetChannelsForUser(ctx context.Context, userId string, params *GetChannelsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPostsAroundLastUnread request
	GetPostsAroundLastUnread(ctx context.Context, userId string, channelId string, params *GetPostsAroundLastUnreadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelUnread request
	GetChannelUnread(ctx context.Context, userId string, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConvertUserToBot request
	ConvertUserToBot(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelPoliciesForUser request
	GetChannelPoliciesForUser(ctx context.Context, userId string, params *GetChannelPoliciesForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamPoliciesForUser request
	GetTeamPoliciesForUser(ctx context.Context, userId string, params *GetTeamPoliciesForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DemoteUserToGuest request
	DemoteUserToGuest(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyUserEmailWithoutToken request
	VerifyUserEmailWithoutToken(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupsByUserId request
	GetGroupsByUserId(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDefaultProfileImage request
	SetDefaultProfileImage(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProfileImage request
	GetProfileImage(ctx context.Context, userId string, params *GetProfileImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetProfileImageWithBody request with any body
	SetProfileImageWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultProfileImage request
	GetDefaultProfileImage(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserMfaWithBody request with any body
	UpdateUserMfaWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserMfa(ctx context.Context, userId string, body UpdateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateMfaSecret request
	GenerateMfaSecret(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorizedOAuthAppsForUser request
	GetAuthorizedOAuthAppsForUser(ctx context.Context, userId string, params *GetAuthorizedOAuthAppsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserPasswordWithBody request with any body
	UpdateUserPasswordWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserPassword(ctx context.Context, userId string, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUserWithBody request with any body
	PatchUserWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUser(ctx context.Context, userId string, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlaggedPostsForUser request
	GetFlaggedPostsForUser(ctx context.Context, userId string, params *GetFlaggedPostsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAcknowledgementForPost request
	DeleteAcknowledgementForPost(ctx context.Context, userId string, postId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveAcknowledgementForPost request
	SaveAcknowledgementForPost(ctx context.Context, userId string, postId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReaction request
	DeleteReaction(ctx context.Context, userId string, postId string, emojiName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPostReminderWithBody request with any body
	SetPostReminderWithBody(ctx context.Context, userId string, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetPostReminder(ctx context.Context, userId string, postId string, body SetPostReminderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPostUnread request
	SetPostUnread(ctx context.Context, userId string, postId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPreferences request
	GetPreferences(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePreferencesWithBody request with any body
	UpdatePreferencesWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePreferences(ctx context.Context, userId string, body UpdatePreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePreferencesWithBody request with any body
	DeletePreferencesWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePreferences(ctx context.Context, userId string, body DeletePreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPreferencesByCategory request
	GetPreferencesByCategory(ctx context.Context, userId string, category string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPreferencesByCategoryByName request
	GetPreferencesByCategoryByName(ctx context.Context, userId string, category string, preferenceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PromoteGuestToUser request
	PromoteGuestToUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserRolesWithBody request with any body
	UpdateUserRolesWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserRoles(ctx context.Context, userId string, body UpdateUserRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSessions request
	GetSessions(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeSessionWithBody request with any body
	RevokeSessionWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevokeSession(ctx context.Context, userId string, body RevokeSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeAllSessions request
	RevokeAllSessions(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserStatus request
	GetUserStatus(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserStatusWithBody request with any body
	UpdateUserStatusWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserStatus(ctx context.Context, userId string, body UpdateUserStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnsetUserCustomStatus request
	UnsetUserCustomStatus(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserCustomStatusWithBody request with any body
	UpdateUserCustomStatusWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserCustomStatus(ctx context.Context, userId string, body UpdateUserCustomStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveRecentCustomStatusWithBody request with any body
	RemoveRecentCustomStatusWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveRecentCustomStatus(ctx context.Context, userId string, body RemoveRecentCustomStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUserRecentCustomStatusDeleteWithBody request with any body
	PostUserRecentCustomStatusDeleteWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUserRecentCustomStatusDelete(ctx context.Context, userId string, body PostUserRecentCustomStatusDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsForUser request
	GetTeamsForUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamMembersForUser request
	GetTeamMembersForUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsUnreadForUser request
	GetTeamsUnreadForUser(ctx context.Context, userId string, params *GetTeamsUnreadForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelsForTeamForUser request
	GetChannelsForTeamForUser(ctx context.Context, userId string, teamId string, params *GetChannelsForTeamForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSidebarCategoriesForTeamForUser request
	GetSidebarCategoriesForTeamForUser(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSidebarCategoryForTeamForUserWithBody request with any body
	CreateSidebarCategoryForTeamForUserWithBody(ctx context.Context, userId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSidebarCategoryForTeamForUser(ctx context.Context, userId string, teamId string, body CreateSidebarCategoryForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSidebarCategoriesForTeamForUserWithBody request with any body
	UpdateSidebarCategoriesForTeamForUserWithBody(ctx context.Context, userId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSidebarCategoriesForTeamForUser(ctx context.Context, userId string, teamId string, body UpdateSidebarCategoriesForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSidebarCategoryOrderForTeamForUser request
	GetSidebarCategoryOrderForTeamForUser(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSidebarCategoryOrderForTeamForUserWithBody request with any body
	UpdateSidebarCategoryOrderForTeamForUserWithBody(ctx context.Context, userId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSidebarCategoryOrderForTeamForUser(ctx context.Context, userId string, teamId string, body UpdateSidebarCategoryOrderForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSidebarCategoryForTeamForUser request
	RemoveSidebarCategoryForTeamForUser(ctx context.Context, userId string, teamId string, categoryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSidebarCategoryForTeamForUser request
	GetSidebarCategoryForTeamForUser(ctx context.Context, userId string, teamId string, categoryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSidebarCategoryForTeamForUserWithBody request with any body
	UpdateSidebarCategoryForTeamForUserWithBody(ctx context.Context, userId string, teamId string, categoryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSidebarCategoryForTeamForUser(ctx context.Context, userId string, teamId string, categoryId string, body UpdateSidebarCategoryForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelMembersForUser request
	GetChannelMembersForUser(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserThreads request
	GetUserThreads(ctx context.Context, userId string, teamId string, params *GetUserThreadsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThreadMentionCountsByChannel request
	GetThreadMentionCountsByChannel(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateThreadsReadForUser request
	UpdateThreadsReadForUser(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserThread request
	GetUserThread(ctx context.Context, userId string, teamId string, threadId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopFollowingThread request
	StopFollowingThread(ctx context.Context, userId string, teamId string, threadId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartFollowingThread request
	StartFollowingThread(ctx context.Context, userId string, teamId string, threadId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateThreadReadForUser request
	UpdateThreadReadForUser(ctx context.Context, userId string, teamId string, threadId string, timestamp string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetThreadUnreadByPostId request
	SetThreadUnreadByPostId(ctx context.Context, userId string, teamId string, threadId string, postId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamUnread request
	GetTeamUnread(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserTermsOfService request
	GetUserTermsOfService(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterTermsOfServiceActionWithBody request with any body
	RegisterTermsOfServiceActionWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterTermsOfServiceAction(ctx context.Context, userId string, body RegisterTermsOfServiceActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserAccessTokensForUser request
	GetUserAccessTokensForUser(ctx context.Context, userId string, params *GetUserAccessTokensForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserAccessTokenWithBody request with any body
	CreateUserAccessTokenWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserAccessToken(ctx context.Context, userId string, body CreateUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublishUserTypingWithBody request with any body
	PublishUserTypingWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PublishUserTyping(ctx context.Context, userId string, body PublishUserTypingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUploadsForUser request
	GetUploadsForUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilePublic request
	GetFilePublic(ctx context.Context, fileId string, params *GetFilePublicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybooks request
	GetPlaybooks(ctx context.Context, params *GetPlaybooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlaybookWithBody request with any body
	CreatePlaybookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlaybook(ctx context.Context, body CreatePlaybookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePlaybook request
	DeletePlaybook(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybook request
	GetPlaybook(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePlaybookWithBody request with any body
	UpdatePlaybookWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePlaybook(ctx context.Context, id string, body UpdatePlaybookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutoFollows request
	GetAutoFollows(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlaybookRuns request
	ListPlaybookRuns(ctx context.Context, params *ListPlaybookRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlaybookRunFromPostWithBody request with any body
	CreatePlaybookRunFromPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlaybookRunFromPost(ctx context.Context, body CreatePlaybookRunFromPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybookRunByChannelId request
	GetPlaybookRunByChannelId(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannels request
	GetChannels(ctx context.Context, params *GetChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChecklistAutocomplete request
	GetChecklistAutocomplete(ctx context.Context, params *GetChecklistAutocompleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlaybookRunFromDialogWithBody request with any body
	CreatePlaybookRunFromDialogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlaybookRunFromDialog(ctx context.Context, body CreatePlaybookRunFromDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOwners request
	GetOwners(ctx context.Context, params *GetOwnersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybookRun request
	GetPlaybookRun(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePlaybookRunWithBody request with any body
	UpdatePlaybookRunWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePlaybookRun(ctx context.Context, id string, body UpdatePlaybookRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddChecklistItemWithBody request with any body
	AddChecklistItemWithBody(ctx context.Context, id string, checklist int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddChecklistItem(ctx context.Context, id string, checklist int, body AddChecklistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemDelete request
	ItemDelete(ctx context.Context, id string, checklist int, item int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemRenameWithBody request with any body
	ItemRenameWithBody(ctx context.Context, id string, checklist int, item int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemRename(ctx context.Context, id string, checklist int, item int, body ItemRenameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemSetAssigneeWithBody request with any body
	ItemSetAssigneeWithBody(ctx context.Context, id string, checklist int, item int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemSetAssignee(ctx context.Context, id string, checklist int, item int, body ItemSetAssigneeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemRun request
	ItemRun(ctx context.Context, id string, checklist int, item int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemSetStateWithBody request with any body
	ItemSetStateWithBody(ctx context.Context, id string, checklist int, item int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemSetState(ctx context.Context, id string, checklist int, item int, body ItemSetStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReoderChecklistItemWithBody request with any body
	ReoderChecklistItemWithBody(ctx context.Context, id string, checklist int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReoderChecklistItem(ctx context.Context, id string, checklist int, body ReoderChecklistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndPlaybookRunDialog request
	EndPlaybookRunDialog(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndPlaybookRun request
	EndPlaybookRun(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Finish request
	Finish(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybookRunMetadata request
	GetPlaybookRunMetadata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NextStageDialogWithBody request with any body
	NextStageDialogWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NextStageDialog(ctx context.Context, id string, body NextStageDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangeOwnerWithBody request with any body
	ChangeOwnerWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangeOwner(ctx context.Context, id string, body ChangeOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartPlaybookRun request
	RestartPlaybookRun(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatusWithBody request with any body
	StatusWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Status(ctx context.Context, id string, body StatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTimelineEvent request
	RemoveTimelineEvent(ctx context.Context, id string, eventId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) OpenInteractiveDialogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenInteractiveDialogRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OpenInteractiveDialog(ctx context.Context, body OpenInteractiveDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenInteractiveDialogRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitInteractiveDialogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitInteractiveDialogRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitInteractiveDialog(ctx context.Context, body SubmitInteractiveDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitInteractiveDialogRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnalyticsOld(ctx context.Context, params *GetAnalyticsOldParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnalyticsOldRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudits(ctx context.Context, params *GetAuditsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuditsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgeBleveIndexes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgeBleveIndexesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBots(ctx context.Context, params *GetBotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBotsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBotRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBot(ctx context.Context, body CreateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBotRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBot(ctx context.Context, botUserId string, params *GetBotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBotRequest(c.Server, botUserId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchBotWithBody(ctx context.Context, botUserId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchBotRequestWithBody(c.Server, botUserId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchBot(ctx context.Context, botUserId string, body PatchBotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchBotRequest(c.Server, botUserId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignBot(ctx context.Context, botUserId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignBotRequest(c.Server, botUserId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertBotToUserWithBody(ctx context.Context, botUserId string, params *ConvertBotToUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertBotToUserRequestWithBody(c.Server, botUserId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertBotToUser(ctx context.Context, botUserId string, params *ConvertBotToUserParams, body ConvertBotToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertBotToUserRequest(c.Server, botUserId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableBot(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableBotRequest(c.Server, botUserId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableBot(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableBotRequest(c.Server, botUserId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBotIconImage(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBotIconImageRequest(c.Server, botUserId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBotIconImage(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBotIconImageRequest(c.Server, botUserId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBotIconImageWithBody(ctx context.Context, botUserId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBotIconImageRequestWithBody(c.Server, botUserId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBrandImage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBrandImageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBrandImage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBrandImageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadBrandImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadBrandImageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InvalidateCaches(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvalidateCachesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllChannels(ctx context.Context, params *GetAllChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateChannelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateChannel(ctx context.Context, body CreateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateChannelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectChannelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectChannel(ctx context.Context, body CreateDirectChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectChannelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupChannelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupChannel(ctx context.Context, body CreateGroupChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupChannelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupChannelsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupChannelsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGroupChannels(ctx context.Context, body SearchGroupChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGroupChannelsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ViewChannelWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewViewChannelRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ViewChannel(ctx context.Context, userId string, body ViewChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewViewChannelRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchAllChannelsWithBody(ctx context.Context, params *SearchAllChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchAllChannelsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchAllChannels(ctx context.Context, params *SearchAllChannelsParams, body SearchAllChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchAllChannelsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteChannel(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteChannelRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannel(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelRequestWithBody(c.Server, channelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannel(ctx context.Context, channelId string, body UpdateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelRequest(c.Server, channelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListChannelBookmarksForChannel(ctx context.Context, channelId string, params *ListChannelBookmarksForChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListChannelBookmarksForChannelRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateChannelBookmarkWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateChannelBookmarkRequestWithBody(c.Server, channelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateChannelBookmark(ctx context.Context, channelId string, body CreateChannelBookmarkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateChannelBookmarkRequest(c.Server, channelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteChannelBookmark(ctx context.Context, channelId string, bookmarkId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteChannelBookmarkRequest(c.Server, channelId, bookmarkId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelBookmarkWithBody(ctx context.Context, channelId string, bookmarkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelBookmarkRequestWithBody(c.Server, channelId, bookmarkId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelBookmark(ctx context.Context, channelId string, bookmarkId string, body UpdateChannelBookmarkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelBookmarkRequest(c.Server, channelId, bookmarkId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelBookmarkSortOrderWithBody(ctx context.Context, channelId string, bookmarkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelBookmarkSortOrderRequestWithBody(c.Server, channelId, bookmarkId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelBookmarkSortOrder(ctx context.Context, channelId string, bookmarkId string, body UpdateChannelBookmarkSortOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelBookmarkSortOrderRequest(c.Server, channelId, bookmarkId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupsByChannel(ctx context.Context, channelId string, params *GetGroupsByChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsByChannelRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelMemberCountsByGroup(ctx context.Context, channelId string, params *GetChannelMemberCountsByGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelMemberCountsByGroupRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelMembers(ctx context.Context, channelId string, params *GetChannelMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelMembersRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddChannelMemberWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddChannelMemberRequestWithBody(c.Server, channelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddChannelMember(ctx context.Context, channelId string, body AddChannelMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddChannelMemberRequest(c.Server, channelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelMembersByIdsWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelMembersByIdsRequestWithBody(c.Server, channelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelMembersByIds(ctx context.Context, channelId string, body GetChannelMembersByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelMembersByIdsRequest(c.Server, channelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserFromChannel(ctx context.Context, channelId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserFromChannelRequest(c.Server, channelId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelMember(ctx context.Context, channelId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelMemberRequest(c.Server, channelId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelNotifyPropsWithBody(ctx context.Context, channelId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelNotifyPropsRequestWithBody(c.Server, channelId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelNotifyProps(ctx context.Context, channelId string, userId string, body UpdateChannelNotifyPropsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelNotifyPropsRequest(c.Server, channelId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelRolesWithBody(ctx context.Context, channelId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelRolesRequestWithBody(c.Server, channelId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelRoles(ctx context.Context, channelId string, userId string, body UpdateChannelRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelRolesRequest(c.Server, channelId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelMemberSchemeRolesWithBody(ctx context.Context, channelId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelMemberSchemeRolesRequestWithBody(c.Server, channelId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelMemberSchemeRoles(ctx context.Context, channelId string, userId string, body UpdateChannelMemberSchemeRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelMemberSchemeRolesRequest(c.Server, channelId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChannelMembersMinusGroupMembers(ctx context.Context, channelId string, params *ChannelMembersMinusGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChannelMembersMinusGroupMembersRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelModerations(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelModerationsRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchChannelModerationsWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchChannelModerationsRequestWithBody(c.Server, channelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchChannelModerations(ctx context.Context, channelId string, body PatchChannelModerationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchChannelModerationsRequest(c.Server, channelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveChannelWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveChannelRequestWithBody(c.Server, channelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveChannel(ctx context.Context, channelId string, body MoveChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveChannelRequest(c.Server, channelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchChannelWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchChannelRequestWithBody(c.Server, channelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchChannel(ctx context.Context, channelId string, body PatchChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchChannelRequest(c.Server, channelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPinnedPosts(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPinnedPostsRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostsForChannel(ctx context.Context, channelId string, params *GetPostsForChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostsForChannelRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelPrivacyWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelPrivacyRequestWithBody(c.Server, channelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelPrivacy(ctx context.Context, channelId string, body UpdateChannelPrivacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelPrivacyRequest(c.Server, channelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreChannel(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreChannelRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelSchemeWithBody(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelSchemeRequestWithBody(c.Server, channelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelScheme(ctx context.Context, channelId string, body UpdateChannelSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelSchemeRequest(c.Server, channelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelStats(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelStatsRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelMembersTimezones(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelMembersTimezonesRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitPerformanceReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitPerformanceReportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitPerformanceReport(ctx context.Context, body SubmitPerformanceReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitPerformanceReportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCloudCustomer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCloudCustomerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCloudCustomerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCloudCustomerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCloudCustomer(ctx context.Context, body UpdateCloudCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCloudCustomerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCloudCustomerAddressWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCloudCustomerAddressRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCloudCustomerAddress(ctx context.Context, body UpdateCloudCustomerAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCloudCustomerAddressRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEndpointForInstallationInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEndpointForInstallationInformationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCloudLimits(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCloudLimitsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomerPayment(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomerPaymentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmCustomerPaymentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmCustomerPaymentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCloudProducts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCloudProductsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscription(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoicesForSubscription(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvoicesForSubscriptionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoiceForSubscriptionAsPdf(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvoiceForSubscriptionAsPdfRequest(c.Server, invoiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEndpointForCwsWebhooks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEndpointForCwsWebhooksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCommands(ctx context.Context, params *ListCommandsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCommandsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommandRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommand(ctx context.Context, body CreateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommandRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteCommandRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteCommand(ctx context.Context, body ExecuteCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteCommandRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCommand(ctx context.Context, commandId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCommandRequest(c.Server, commandId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommandById(ctx context.Context, commandId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommandByIdRequest(c.Server, commandId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCommandWithBody(ctx context.Context, commandId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCommandRequestWithBody(c.Server, commandId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCommand(ctx context.Context, commandId string, body UpdateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCommandRequest(c.Server, commandId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveCommandWithBody(ctx context.Context, commandId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveCommandRequestWithBody(c.Server, commandId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveCommand(ctx context.Context, commandId string, body MoveCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveCommandRequest(c.Server, commandId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegenCommandToken(ctx context.Context, commandId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegenCommandTokenRequest(c.Server, commandId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComplianceReports(ctx context.Context, params *GetComplianceReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComplianceReportsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComplianceReport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateComplianceReportRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComplianceReport(ctx context.Context, reportId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComplianceReportRequest(c.Server, reportId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadComplianceReport(ctx context.Context, reportId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadComplianceReportRequest(c.Server, reportId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfig(ctx context.Context, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientConfig(ctx context.Context, params *GetClientConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientConfigRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironmentConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchConfig(ctx context.Context, body PatchConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReloadConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReloadConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataRetentionPolicies(ctx context.Context, params *GetDataRetentionPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataRetentionPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDataRetentionPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDataRetentionPolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDataRetentionPolicy(ctx context.Context, body CreateDataRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDataRetentionPolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDataRetentionPolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDataRetentionPolicyRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataRetentionPolicyByID(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataRetentionPolicyByIDRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchDataRetentionPolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchDataRetentionPolicyRequestWithBody(c.Server, policyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchDataRetentionPolicy(ctx context.Context, policyId string, body PatchDataRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchDataRetentionPolicyRequest(c.Server, policyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveChannelsFromRetentionPolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveChannelsFromRetentionPolicyRequestWithBody(c.Server, policyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveChannelsFromRetentionPolicy(ctx context.Context, policyId string, body RemoveChannelsFromRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveChannelsFromRetentionPolicyRequest(c.Server, policyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelsForRetentionPolicy(ctx context.Context, policyId string, params *GetChannelsForRetentionPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelsForRetentionPolicyRequest(c.Server, policyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddChannelsToRetentionPolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddChannelsToRetentionPolicyRequestWithBody(c.Server, policyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddChannelsToRetentionPolicy(ctx context.Context, policyId string, body AddChannelsToRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddChannelsToRetentionPolicyRequest(c.Server, policyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchChannelsForRetentionPolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchChannelsForRetentionPolicyRequestWithBody(c.Server, policyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchChannelsForRetentionPolicy(ctx context.Context, policyId string, body SearchChannelsForRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchChannelsForRetentionPolicyRequest(c.Server, policyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTeamsFromRetentionPolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTeamsFromRetentionPolicyRequestWithBody(c.Server, policyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTeamsFromRetentionPolicy(ctx context.Context, policyId string, body RemoveTeamsFromRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTeamsFromRetentionPolicyRequest(c.Server, policyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsForRetentionPolicy(ctx context.Context, policyId string, params *GetTeamsForRetentionPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsForRetentionPolicyRequest(c.Server, policyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTeamsToRetentionPolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTeamsToRetentionPolicyRequestWithBody(c.Server, policyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTeamsToRetentionPolicy(ctx context.Context, policyId string, body AddTeamsToRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTeamsToRetentionPolicyRequest(c.Server, policyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTeamsForRetentionPolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTeamsForRetentionPolicyRequestWithBody(c.Server, policyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTeamsForRetentionPolicy(ctx context.Context, policyId string, body SearchTeamsForRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTeamsForRetentionPolicyRequest(c.Server, policyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataRetentionPoliciesCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataRetentionPoliciesCountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataRetentionPolicy(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataRetentionPolicyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DatabaseRecycle(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDatabaseRecycleRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgeElasticsearchIndexes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgeElasticsearchIndexesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestElasticsearch(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestElasticsearchRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestEmail(ctx context.Context, body TestEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmojiList(ctx context.Context, params *GetEmojiListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmojiListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEmojiWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEmojiRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutocompleteEmoji(ctx context.Context, params *AutocompleteEmojiParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutocompleteEmojiRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmojiByName(ctx context.Context, emojiName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmojiByNameRequest(c.Server, emojiName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmojisByNamesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmojisByNamesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmojisByNames(ctx context.Context, body GetEmojisByNamesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmojisByNamesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchEmojiWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchEmojiRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchEmoji(ctx context.Context, body SearchEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchEmojiRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEmoji(ctx context.Context, emojiId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEmojiRequest(c.Server, emojiId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmoji(ctx context.Context, emojiId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmojiRequest(c.Server, emojiId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmojiImage(ctx context.Context, emojiId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmojiImageRequest(c.Server, emojiId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExports(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExportsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExport(ctx context.Context, exportName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteExportRequest(c.Server, exportName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadExport(ctx context.Context, exportName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadExportRequest(c.Server, exportName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestS3ConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestS3ConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestS3Connection(ctx context.Context, body TestS3ConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestS3ConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadFileWithBody(ctx context.Context, params *UploadFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadFileRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchFilesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchFilesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFile(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFileRequest(c.Server, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFileInfo(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFileInfoRequest(c.Server, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFileLink(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFileLinkRequest(c.Server, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilePreview(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilePreviewRequest(c.Server, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFileThumbnail(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFileThumbnailRequest(c.Server, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupSyncablesChannels(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupSyncablesChannelsRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupSyncableForChannelId(ctx context.Context, groupId string, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupSyncableForChannelIdRequest(c.Server, groupId, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkGroupSyncableForChannel(ctx context.Context, groupId string, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkGroupSyncableForChannelRequest(c.Server, groupId, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkGroupSyncableForChannel(ctx context.Context, groupId string, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkGroupSyncableForChannelRequest(c.Server, groupId, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchGroupSyncableForChannelWithBody(ctx context.Context, groupId string, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchGroupSyncableForChannelRequestWithBody(c.Server, groupId, channelId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchGroupSyncableForChannel(ctx context.Context, groupId string, channelId string, body PatchGroupSyncableForChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchGroupSyncableForChannelRequest(c.Server, groupId, channelId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupMembersWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupMembersRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupMembers(ctx context.Context, groupId string, body DeleteGroupMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupMembersRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupUsers(ctx context.Context, groupId string, params *GetGroupUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupUsersRequest(c.Server, groupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGroupMembersWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGroupMembersRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGroupMembers(ctx context.Context, groupId string, body AddGroupMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGroupMembersRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchGroupRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchGroup(ctx context.Context, groupId string, body PatchGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchGroupRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupStats(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupStatsRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupSyncablesTeams(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupSyncablesTeamsRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupSyncableForTeamId(ctx context.Context, groupId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupSyncableForTeamIdRequest(c.Server, groupId, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkGroupSyncableForTeam(ctx context.Context, groupId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkGroupSyncableForTeamRequest(c.Server, groupId, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkGroupSyncableForTeam(ctx context.Context, groupId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkGroupSyncableForTeamRequest(c.Server, groupId, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchGroupSyncableForTeamWithBody(ctx context.Context, groupId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchGroupSyncableForTeamRequestWithBody(c.Server, groupId, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchGroupSyncableForTeam(ctx context.Context, groupId string, teamId string, body PatchGroupSyncableForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchGroupSyncableForTeamRequest(c.Server, groupId, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIncomingWebhooks(ctx context.Context, params *GetIncomingWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIncomingWebhooksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIncomingWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIncomingWebhookRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIncomingWebhook(ctx context.Context, body CreateIncomingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIncomingWebhookRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIncomingWebhook(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIncomingWebhookRequest(c.Server, hookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIncomingWebhook(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIncomingWebhookRequest(c.Server, hookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIncomingWebhookWithBody(ctx context.Context, hookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIncomingWebhookRequestWithBody(c.Server, hookId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIncomingWebhook(ctx context.Context, hookId string, body UpdateIncomingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIncomingWebhookRequest(c.Server, hookId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOutgoingWebhooks(ctx context.Context, params *GetOutgoingWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutgoingWebhooksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOutgoingWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOutgoingWebhookRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOutgoingWebhook(ctx context.Context, body CreateOutgoingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOutgoingWebhookRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOutgoingWebhook(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOutgoingWebhookRequest(c.Server, hookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOutgoingWebhook(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutgoingWebhookRequest(c.Server, hookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOutgoingWebhookWithBody(ctx context.Context, hookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOutgoingWebhookRequestWithBody(c.Server, hookId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOutgoingWebhook(ctx context.Context, hookId string, body UpdateOutgoingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOutgoingWebhookRequest(c.Server, hookId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegenOutgoingHookToken(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegenOutgoingHookTokenRequest(c.Server, hookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImageByUrl(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImageByUrlRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListImports(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListImportsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckIntegrity(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckIntegrityRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIPFilters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIPFiltersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApplyIPFiltersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApplyIPFiltersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApplyIPFilters(ctx context.Context, body ApplyIPFiltersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApplyIPFiltersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MyIP(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMyIPRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobs(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJob(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobsByType(ctx context.Context, pType string, params *GetJobsByTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobsByTypeRequest(c.Server, pType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJobStatusWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobStatusRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJobStatus(ctx context.Context, jobId string, body UpdateJobStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobStatusRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLdapPrivateCertificate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLdapPrivateCertificateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadLdapPrivateCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadLdapPrivateCertificateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLdapPublicCertificate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLdapPublicCertificateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadLdapPublicCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadLdapPublicCertificateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLdapGroups(ctx context.Context, params *GetLdapGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLdapGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkLdapGroup(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkLdapGroupRequest(c.Server, remoteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkLdapGroup(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkLdapGroupRequest(c.Server, remoteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateIdLdapWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateIdLdapRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateIdLdap(ctx context.Context, body MigrateIdLdapJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateIdLdapRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncLdap(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncLdapRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestLdap(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestLdapRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToGroupSyncables(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToGroupSyncablesRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveLicenseFile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveLicenseFileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadLicenseFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadLicenseFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientLicense(ctx context.Context, params *GetClientLicenseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientLicenseRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestLicenseRenewalLink(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestLicenseRenewalLinkRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerLimits(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerLimitsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogs(ctx context.Context, params *GetLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLogRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLog(ctx context.Context, body PostLogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLogRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadSystemLogs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadSystemLogsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcknowledgeNotification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcknowledgeNotificationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestNotification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestNotificationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthApps(ctx context.Context, params *GetOAuthAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthAppsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOAuthAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOAuthAppRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOAuthApp(ctx context.Context, body CreateOAuthAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOAuthAppRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOAuthApp(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOAuthAppRequest(c.Server, appId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthApp(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthAppRequest(c.Server, appId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOAuthAppWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOAuthAppRequestWithBody(c.Server, appId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOAuthApp(ctx context.Context, appId string, body UpdateOAuthAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOAuthAppRequest(c.Server, appId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthAppInfo(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthAppInfoRequest(c.Server, appId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegenerateOAuthAppSecret(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegenerateOAuthAppSecretRequest(c.Server, appId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOutgoingOAuthConnections(ctx context.Context, params *ListOutgoingOAuthConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOutgoingOAuthConnectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOutgoingOAuthConnectionWithBody(ctx context.Context, params *CreateOutgoingOAuthConnectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOutgoingOAuthConnectionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOutgoingOAuthConnection(ctx context.Context, params *CreateOutgoingOAuthConnectionParams, body CreateOutgoingOAuthConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOutgoingOAuthConnectionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateOutgoingOAuthConnectionWithBody(ctx context.Context, params *ValidateOutgoingOAuthConnectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateOutgoingOAuthConnectionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateOutgoingOAuthConnection(ctx context.Context, params *ValidateOutgoingOAuthConnectionParams, body ValidateOutgoingOAuthConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateOutgoingOAuthConnectionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOutgoingOAuthConnection(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOutgoingOAuthConnectionRequest(c.Server, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOutgoingOAuthConnection(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutgoingOAuthConnectionRequest(c.Server, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOutgoingOAuthConnectionWithBody(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOutgoingOAuthConnectionRequestWithBody(c.Server, connectionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOutgoingOAuthConnection(ctx context.Context, connectionId string, body UpdateOutgoingOAuthConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOutgoingOAuthConnectionRequest(c.Server, connectionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAncillaryPermissionsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAncillaryPermissionsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAncillaryPermissionsPost(ctx context.Context, body GetAncillaryPermissionsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAncillaryPermissionsPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlugins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPluginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPluginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallPluginFromUrl(ctx context.Context, params *InstallPluginFromUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallPluginFromUrlRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMarketplacePlugins(ctx context.Context, params *GetMarketplacePluginsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMarketplacePluginsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallMarketplacePluginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallMarketplacePluginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallMarketplacePlugin(ctx context.Context, body InstallMarketplacePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallMarketplacePluginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMarketplaceVisitedByAdmin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMarketplaceVisitedByAdminRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMarketplaceVisitedByAdminWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMarketplaceVisitedByAdminRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMarketplaceVisitedByAdmin(ctx context.Context, body UpdateMarketplaceVisitedByAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMarketplaceVisitedByAdminRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPluginStatuses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginStatusesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebappPlugins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebappPluginsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePlugin(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePluginRequest(c.Server, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisablePlugin(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisablePluginRequest(c.Server, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnablePlugin(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnablePluginRequest(c.Server, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePostWithBody(ctx context.Context, params *CreatePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePost(ctx context.Context, params *CreatePostParams, body CreatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePostEphemeralWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostEphemeralRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePostEphemeral(ctx context.Context, body CreatePostEphemeralJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostEphemeralRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostsByIdsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostsByIdsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostsByIds(ctx context.Context, body GetPostsByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostsByIdsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBulkReactionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBulkReactionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBulkReactions(ctx context.Context, body GetBulkReactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBulkReactionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScheduledPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScheduledPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScheduledPost(ctx context.Context, body CreateScheduledPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScheduledPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteScheduledPost(ctx context.Context, scheduledPostId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScheduledPostRequest(c.Server, scheduledPostId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScheduledPostWithBody(ctx context.Context, scheduledPostId string, params *UpdateScheduledPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScheduledPostRequestWithBody(c.Server, scheduledPostId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScheduledPost(ctx context.Context, scheduledPostId string, params *UpdateScheduledPostParams, body UpdateScheduledPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScheduledPostRequest(c.Server, scheduledPostId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserScheduledPosts(ctx context.Context, teamId string, params *GetUserScheduledPostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserScheduledPostsRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePost(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePostRequest(c.Server, postId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPost(ctx context.Context, postId string, params *GetPostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostRequest(c.Server, postId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePostWithBody(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePostRequestWithBody(c.Server, postId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePost(ctx context.Context, postId string, body UpdatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePostRequest(c.Server, postId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DoPostAction(ctx context.Context, postId string, actionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDoPostActionRequest(c.Server, postId, actionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFileInfosForPost(ctx context.Context, postId string, params *GetFileInfosForPostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFileInfosForPostRequest(c.Server, postId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveThreadWithBody(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveThreadRequestWithBody(c.Server, postId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveThread(ctx context.Context, postId string, body MoveThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveThreadRequest(c.Server, postId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPostWithBody(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPostRequestWithBody(c.Server, postId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPost(ctx context.Context, postId string, body PatchPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPostRequest(c.Server, postId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PinPost(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPinPostRequest(c.Server, postId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReactions(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReactionsRequest(c.Server, postId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostThread(ctx context.Context, postId string, params *GetPostThreadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostThreadRequest(c.Server, postId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnpinPost(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnpinPostRequest(c.Server, postId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveReactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveReactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveReaction(ctx context.Context, body SaveReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveReactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRedirectLocation(ctx context.Context, params *GetRedirectLocationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRedirectLocationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRemoteClusters(ctx context.Context, params *GetRemoteClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRemoteClustersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRemoteClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRemoteClusterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRemoteCluster(ctx context.Context, body CreateRemoteClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRemoteClusterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptRemoteClusterInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptRemoteClusterInviteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptRemoteClusterInvite(ctx context.Context, body AcceptRemoteClusterInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptRemoteClusterInviteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRemoteCluster(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRemoteClusterRequest(c.Server, remoteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRemoteCluster(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRemoteClusterRequest(c.Server, remoteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRemoteClusterWithBody(ctx context.Context, remoteId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRemoteClusterRequestWithBody(c.Server, remoteId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRemoteCluster(ctx context.Context, remoteId string, body PatchRemoteClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRemoteClusterRequest(c.Server, remoteId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteRemoteClusterToChannel(ctx context.Context, remoteId string, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteRemoteClusterToChannelRequest(c.Server, remoteId, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UninviteRemoteClusterToChannel(ctx context.Context, remoteId string, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUninviteRemoteClusterToChannelRequest(c.Server, remoteId, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSharedChannelRemotesByRemoteCluster(ctx context.Context, remoteId string, params *GetSharedChannelRemotesByRemoteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSharedChannelRemotesByRemoteClusterRequest(c.Server, remoteId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersForReporting(ctx context.Context, params *GetUsersForReportingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersForReportingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserCountForReporting(ctx context.Context, params *GetUserCountForReportingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserCountForReportingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartBatchUsersExport(ctx context.Context, params *StartBatchUsersExportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartBatchUsersExportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartServer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartServerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllRolesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoleByName(ctx context.Context, roleName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleByNameRequest(c.Server, roleName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRolesByNamesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolesByNamesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRolesByNames(ctx context.Context, body GetRolesByNamesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolesByNamesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRole(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleRequest(c.Server, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRoleRequestWithBody(c.Server, roleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRole(ctx context.Context, roleId string, body PatchRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRoleRequest(c.Server, roleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSamlIdpCertificate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSamlIdpCertificateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadSamlIdpCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadSamlIdpCertificateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSamlPrivateCertificate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSamlPrivateCertificateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadSamlPrivateCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadSamlPrivateCertificateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSamlPublicCertificate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSamlPublicCertificateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadSamlPublicCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadSamlPublicCertificateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSamlCertificateStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamlCertificateStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSamlMetadata(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamlMetadataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSamlMetadataFromIdpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamlMetadataFromIdpRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSamlMetadataFromIdp(ctx context.Context, body GetSamlMetadataFromIdpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamlMetadataFromIdpRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetSamlAuthDataToEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetSamlAuthDataToEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetSamlAuthDataToEmail(ctx context.Context, body ResetSamlAuthDataToEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetSamlAuthDataToEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemes(ctx context.Context, params *GetSchemesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSchemeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSchemeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScheme(ctx context.Context, body CreateSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSchemeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteScheme(ctx context.Context, schemeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSchemeRequest(c.Server, schemeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScheme(ctx context.Context, schemeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemeRequest(c.Server, schemeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelsForScheme(ctx context.Context, schemeId string, params *GetChannelsForSchemeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelsForSchemeRequest(c.Server, schemeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSchemeWithBody(ctx context.Context, schemeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSchemeRequestWithBody(c.Server, schemeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchScheme(ctx context.Context, schemeId string, body PatchSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSchemeRequest(c.Server, schemeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsForScheme(ctx context.Context, schemeId string, params *GetTeamsForSchemeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsForSchemeRequest(c.Server, schemeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearServerBusy(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearServerBusyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerBusyExpires(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerBusyExpiresRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetServerBusy(ctx context.Context, params *SetServerBusyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetServerBusyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRemoteClusterInfo(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRemoteClusterInfoRequest(c.Server, remoteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSharedChannels(ctx context.Context, teamId string, params *GetAllSharedChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSharedChannelsRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestSiteURLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestSiteURLRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestSiteURL(ctx context.Context, body TestSiteURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestSiteURLRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkNoticesViewedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkNoticesViewedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkNoticesViewed(ctx context.Context, body MarkNoticesViewedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkNoticesViewedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotices(ctx context.Context, teamId string, params *GetNoticesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNoticesRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPing(ctx context.Context, params *GetPingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateSupportPacket(ctx context.Context, params *GenerateSupportPacketParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateSupportPacketRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSupportedTimezone(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSupportedTimezoneRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTeams(ctx context.Context, params *GetAllTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeam(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamInviteInfo(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamInviteInfoRequest(c.Server, inviteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InvalidateEmailInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvalidateEmailInvitesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTeamMemberFromInvite(ctx context.Context, params *AddTeamMemberFromInviteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTeamMemberFromInviteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamExists(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamExistsRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelByNameForTeamName(ctx context.Context, teamName string, channelName string, params *GetChannelByNameForTeamNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelByNameForTeamNameRequest(c.Server, teamName, channelName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTeamsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTeamsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTeams(ctx context.Context, body SearchTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTeamsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SoftDeleteTeam(ctx context.Context, teamId string, params *SoftDeleteTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSoftDeleteTeamRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeam(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeam(ctx context.Context, teamId string, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicChannelsForTeam(ctx context.Context, teamId string, params *GetPublicChannelsForTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicChannelsForTeamRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutocompleteChannelsForTeam(ctx context.Context, teamId string, params *AutocompleteChannelsForTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutocompleteChannelsForTeamRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeletedChannelsForTeam(ctx context.Context, teamId string, params *GetDeletedChannelsForTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeletedChannelsForTeamRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicChannelsByIdsForTeamWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicChannelsByIdsForTeamRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicChannelsByIdsForTeam(ctx context.Context, teamId string, body GetPublicChannelsByIdsForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicChannelsByIdsForTeamRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelByName(ctx context.Context, teamId string, channelName string, params *GetChannelByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelByNameRequest(c.Server, teamId, channelName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrivateChannelsForTeam(ctx context.Context, teamId string, params *GetPrivateChannelsForTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPrivateChannelsForTeamRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchChannelsWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchChannelsRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchChannels(ctx context.Context, teamId string, body SearchChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchChannelsRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchArchivedChannelsWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchArchivedChannelsRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchArchivedChannels(ctx context.Context, teamId string, body SearchArchivedChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchArchivedChannelsRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutocompleteChannelsForTeamForSearch(ctx context.Context, teamId string, params *AutocompleteChannelsForTeamForSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutocompleteChannelsForTeamForSearchRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAutocompleteCommands(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAutocompleteCommandsRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCommandAutocompleteSuggestions(ctx context.Context, teamId string, params *ListCommandAutocompleteSuggestionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCommandAutocompleteSuggestionsRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchFilesWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchFilesRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupsByTeam(ctx context.Context, teamId string, params *GetGroupsByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsByTeamRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupsAssociatedToChannelsByTeam(ctx context.Context, teamId string, params *GetGroupsAssociatedToChannelsByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsAssociatedToChannelsByTeamRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTeamIcon(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTeamIconRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamIcon(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamIconRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetTeamIconWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetTeamIconRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportTeamWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportTeamRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteGuestsToTeamWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteGuestsToTeamRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteGuestsToTeam(ctx context.Context, teamId string, body InviteGuestsToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteGuestsToTeamRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUsersToTeamWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUsersToTeamRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUsersToTeam(ctx context.Context, teamId string, body InviteUsersToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUsersToTeamRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamMembers(ctx context.Context, teamId string, params *GetTeamMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamMembersRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTeamMemberWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTeamMemberRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTeamMember(ctx context.Context, teamId string, body AddTeamMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTeamMemberRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTeamMembersWithBody(ctx context.Context, teamId string, params *AddTeamMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTeamMembersRequestWithBody(c.Server, teamId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTeamMembers(ctx context.Context, teamId string, params *AddTeamMembersParams, body AddTeamMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTeamMembersRequest(c.Server, teamId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamMembersByIdsWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamMembersByIdsRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamMembersByIds(ctx context.Context, teamId string, body GetTeamMembersByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamMembersByIdsRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTeamMember(ctx context.Context, teamId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTeamMemberRequest(c.Server, teamId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamMember(ctx context.Context, teamId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamMemberRequest(c.Server, teamId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamMemberRolesWithBody(ctx context.Context, teamId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamMemberRolesRequestWithBody(c.Server, teamId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamMemberRoles(ctx context.Context, teamId string, userId string, body UpdateTeamMemberRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamMemberRolesRequest(c.Server, teamId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamMemberSchemeRolesWithBody(ctx context.Context, teamId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamMemberSchemeRolesRequestWithBody(c.Server, teamId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamMemberSchemeRoles(ctx context.Context, teamId string, userId string, body UpdateTeamMemberSchemeRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamMemberSchemeRolesRequest(c.Server, teamId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamMembersMinusGroupMembers(ctx context.Context, teamId string, params *TeamMembersMinusGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamMembersMinusGroupMembersRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchTeamWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchTeamRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchTeam(ctx context.Context, teamId string, body PatchTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchTeamRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchPostsWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchPostsRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchPosts(ctx context.Context, teamId string, body SearchPostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchPostsRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamPrivacyWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamPrivacyRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamPrivacy(ctx context.Context, teamId string, body UpdateTeamPrivacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamPrivacyRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegenerateTeamInviteId(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegenerateTeamInviteIdRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreTeam(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreTeamRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamSchemeWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamSchemeRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamScheme(ctx context.Context, teamId string, body UpdateTeamSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamSchemeRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamStats(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamStatsRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTermsOfService(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTermsOfServiceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTermsOfService(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTermsOfServiceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestTrialLicenseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestTrialLicenseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestTrialLicense(ctx context.Context, body RequestTrialLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestTrialLicenseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrevTrialLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPrevTrialLicenseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpgradeToEnterprise(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpgradeToEnterpriseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpgradeToEnterpriseStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpgradeToEnterpriseStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUploadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUpload(ctx context.Context, body CreateUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUploadRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUpload(ctx context.Context, uploadId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUploadRequest(c.Server, uploadId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadDataWithBody(ctx context.Context, uploadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadDataRequestWithBody(c.Server, uploadId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadDataWithFormdataBody(ctx context.Context, uploadId string, body UploadDataFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadDataRequestWithFormdataBody(c.Server, uploadId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostsUsage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostsUsageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageUsage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStorageUsageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermanentDeleteAllUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermanentDeleteAllUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutocompleteUsers(ctx context.Context, params *AutocompleteUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutocompleteUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyUserEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyUserEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyUserEmail(ctx context.Context, body VerifyUserEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyUserEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendVerificationEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendVerificationEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendVerificationEmail(ctx context.Context, body SendVerificationEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendVerificationEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserByEmail(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserByEmailRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersByGroupChannelIdsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersByGroupChannelIdsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersByGroupChannelIds(ctx context.Context, body GetUsersByGroupChannelIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersByGroupChannelIdsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersByIdsWithBody(ctx context.Context, params *GetUsersByIdsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersByIdsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersByIds(ctx context.Context, params *GetUsersByIdsParams, body GetUsersByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersByIdsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersWithInvalidEmails(ctx context.Context, params *GetUsersWithInvalidEmailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersWithInvalidEmailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKnownUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKnownUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginByCwsTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginByCwsTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginByCwsToken(ctx context.Context, body LoginByCwsTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginByCwsTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SwitchAccountTypeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSwitchAccountTypeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SwitchAccountType(ctx context.Context, body SwitchAccountTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSwitchAccountTypeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckUserMfaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckUserMfaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckUserMfa(ctx context.Context, body CheckUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckUserMfaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateAuthToLdapWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateAuthToLdapRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateAuthToLdap(ctx context.Context, body MigrateAuthToLdapJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateAuthToLdapRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateAuthToSamlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateAuthToSamlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrateAuthToSaml(ctx context.Context, body MigrateAuthToSamlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrateAuthToSamlRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPassword(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendPasswordResetEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendPasswordResetEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendPasswordResetEmail(ctx context.Context, body SendPasswordResetEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendPasswordResetEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsers(ctx context.Context, body SearchUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachDeviceExtraPropsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachDeviceExtraPropsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachDeviceExtraProps(ctx context.Context, body AttachDeviceExtraPropsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachDeviceExtraPropsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeSessionsFromAllUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeSessionsFromAllUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTotalUsersStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTotalUsersStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTotalUsersStatsFiltered(ctx context.Context, params *GetTotalUsersStatsFilteredParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTotalUsersStatsFilteredRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersStatusesByIdsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersStatusesByIdsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersStatusesByIds(ctx context.Context, body GetUsersStatusesByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersStatusesByIdsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserAccessTokens(ctx context.Context, params *GetUserAccessTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserAccessTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableUserAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableUserAccessTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableUserAccessToken(ctx context.Context, body DisableUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableUserAccessTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableUserAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableUserAccessTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableUserAccessToken(ctx context.Context, body EnableUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableUserAccessTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeUserAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeUserAccessTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeUserAccessToken(ctx context.Context, body RevokeUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeUserAccessTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUserAccessTokensWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUserAccessTokensRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUserAccessTokens(ctx context.Context, body SearchUserAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUserAccessTokensRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserAccessToken(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserAccessTokenRequest(c.Server, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserByUsername(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserByUsernameRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersByUsernamesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersByUsernamesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersByUsernames(ctx context.Context, body GetUsersByUsernamesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersByUsernamesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserActiveWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserActiveRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserActive(ctx context.Context, userId string, body UpdateUserActiveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserActiveRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserAudits(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserAuditsRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserAuthWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserAuthRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserAuth(ctx context.Context, userId string, body UpdateUserAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserAuthRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelMembersWithTeamDataForUser(ctx context.Context, userId string, params *GetChannelMembersWithTeamDataForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelMembersWithTeamDataForUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelsForUser(ctx context.Context, userId string, params *GetChannelsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelsForUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostsAroundLastUnread(ctx context.Context, userId string, channelId string, params *GetPostsAroundLastUnreadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostsAroundLastUnreadRequest(c.Server, userId, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelUnread(ctx context.Context, userId string, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelUnreadRequest(c.Server, userId, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertUserToBot(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertUserToBotRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelPoliciesForUser(ctx context.Context, userId string, params *GetChannelPoliciesForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelPoliciesForUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamPoliciesForUser(ctx context.Context, userId string, params *GetTeamPoliciesForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamPoliciesForUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DemoteUserToGuest(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDemoteUserToGuestRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyUserEmailWithoutToken(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyUserEmailWithoutTokenRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupsByUserId(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsByUserIdRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultProfileImage(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultProfileImageRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProfileImage(ctx context.Context, userId string, params *GetProfileImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProfileImageRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetProfileImageWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetProfileImageRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultProfileImage(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultProfileImageRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserMfaWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserMfaRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserMfa(ctx context.Context, userId string, body UpdateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserMfaRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateMfaSecret(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateMfaSecretRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorizedOAuthAppsForUser(ctx context.Context, userId string, params *GetAuthorizedOAuthAppsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorizedOAuthAppsForUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPasswordWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPasswordRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPassword(ctx context.Context, userId string, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPasswordRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUser(ctx context.Context, userId string, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlaggedPostsForUser(ctx context.Context, userId string, params *GetFlaggedPostsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlaggedPostsForUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAcknowledgementForPost(ctx context.Context, userId string, postId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAcknowledgementForPostRequest(c.Server, userId, postId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveAcknowledgementForPost(ctx context.Context, userId string, postId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveAcknowledgementForPostRequest(c.Server, userId, postId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReaction(ctx context.Context, userId string, postId string, emojiName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReactionRequest(c.Server, userId, postId, emojiName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPostReminderWithBody(ctx context.Context, userId string, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPostReminderRequestWithBody(c.Server, userId, postId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPostReminder(ctx context.Context, userId string, postId string, body SetPostReminderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPostReminderRequest(c.Server, userId, postId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPostUnread(ctx context.Context, userId string, postId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPostUnreadRequest(c.Server, userId, postId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPreferences(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPreferencesRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePreferencesWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePreferencesRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePreferences(ctx context.Context, userId string, body UpdatePreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePreferencesRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePreferencesWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePreferencesRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePreferences(ctx context.Context, userId string, body DeletePreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePreferencesRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPreferencesByCategory(ctx context.Context, userId string, category string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPreferencesByCategoryRequest(c.Server, userId, category)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPreferencesByCategoryByName(ctx context.Context, userId string, category string, preferenceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPreferencesByCategoryByNameRequest(c.Server, userId, category, preferenceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromoteGuestToUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromoteGuestToUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserRolesWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRolesRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserRoles(ctx context.Context, userId string, body UpdateUserRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRolesRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSessions(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionsRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeSessionWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeSessionRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeSession(ctx context.Context, userId string, body RevokeSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeSessionRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeAllSessions(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeAllSessionsRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserStatus(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserStatusRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserStatusWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserStatusRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserStatus(ctx context.Context, userId string, body UpdateUserStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserStatusRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnsetUserCustomStatus(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnsetUserCustomStatusRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserCustomStatusWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserCustomStatusRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserCustomStatus(ctx context.Context, userId string, body UpdateUserCustomStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserCustomStatusRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRecentCustomStatusWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRecentCustomStatusRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRecentCustomStatus(ctx context.Context, userId string, body RemoveRecentCustomStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRecentCustomStatusRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserRecentCustomStatusDeleteWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserRecentCustomStatusDeleteRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserRecentCustomStatusDelete(ctx context.Context, userId string, body PostUserRecentCustomStatusDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserRecentCustomStatusDeleteRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsForUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsForUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamMembersForUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamMembersForUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsUnreadForUser(ctx context.Context, userId string, params *GetTeamsUnreadForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsUnreadForUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelsForTeamForUser(ctx context.Context, userId string, teamId string, params *GetChannelsForTeamForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelsForTeamForUserRequest(c.Server, userId, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSidebarCategoriesForTeamForUser(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSidebarCategoriesForTeamForUserRequest(c.Server, userId, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSidebarCategoryForTeamForUserWithBody(ctx context.Context, userId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSidebarCategoryForTeamForUserRequestWithBody(c.Server, userId, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSidebarCategoryForTeamForUser(ctx context.Context, userId string, teamId string, body CreateSidebarCategoryForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSidebarCategoryForTeamForUserRequest(c.Server, userId, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSidebarCategoriesForTeamForUserWithBody(ctx context.Context, userId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSidebarCategoriesForTeamForUserRequestWithBody(c.Server, userId, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSidebarCategoriesForTeamForUser(ctx context.Context, userId string, teamId string, body UpdateSidebarCategoriesForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSidebarCategoriesForTeamForUserRequest(c.Server, userId, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSidebarCategoryOrderForTeamForUser(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSidebarCategoryOrderForTeamForUserRequest(c.Server, userId, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSidebarCategoryOrderForTeamForUserWithBody(ctx context.Context, userId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSidebarCategoryOrderForTeamForUserRequestWithBody(c.Server, userId, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSidebarCategoryOrderForTeamForUser(ctx context.Context, userId string, teamId string, body UpdateSidebarCategoryOrderForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSidebarCategoryOrderForTeamForUserRequest(c.Server, userId, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSidebarCategoryForTeamForUser(ctx context.Context, userId string, teamId string, categoryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSidebarCategoryForTeamForUserRequest(c.Server, userId, teamId, categoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSidebarCategoryForTeamForUser(ctx context.Context, userId string, teamId string, categoryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSidebarCategoryForTeamForUserRequest(c.Server, userId, teamId, categoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSidebarCategoryForTeamForUserWithBody(ctx context.Context, userId string, teamId string, categoryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSidebarCategoryForTeamForUserRequestWithBody(c.Server, userId, teamId, categoryId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSidebarCategoryForTeamForUser(ctx context.Context, userId string, teamId string, categoryId string, body UpdateSidebarCategoryForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSidebarCategoryForTeamForUserRequest(c.Server, userId, teamId, categoryId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelMembersForUser(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelMembersForUserRequest(c.Server, userId, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserThreads(ctx context.Context, userId string, teamId string, params *GetUserThreadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserThreadsRequest(c.Server, userId, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThreadMentionCountsByChannel(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThreadMentionCountsByChannelRequest(c.Server, userId, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThreadsReadForUser(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThreadsReadForUserRequest(c.Server, userId, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserThread(ctx context.Context, userId string, teamId string, threadId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserThreadRequest(c.Server, userId, teamId, threadId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopFollowingThread(ctx context.Context, userId string, teamId string, threadId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopFollowingThreadRequest(c.Server, userId, teamId, threadId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartFollowingThread(ctx context.Context, userId string, teamId string, threadId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartFollowingThreadRequest(c.Server, userId, teamId, threadId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThreadReadForUser(ctx context.Context, userId string, teamId string, threadId string, timestamp string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThreadReadForUserRequest(c.Server, userId, teamId, threadId, timestamp)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetThreadUnreadByPostId(ctx context.Context, userId string, teamId string, threadId string, postId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetThreadUnreadByPostIdRequest(c.Server, userId, teamId, threadId, postId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamUnread(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamUnreadRequest(c.Server, userId, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserTermsOfService(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserTermsOfServiceRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterTermsOfServiceActionWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterTermsOfServiceActionRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterTermsOfServiceAction(ctx context.Context, userId string, body RegisterTermsOfServiceActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterTermsOfServiceActionRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserAccessTokensForUser(ctx context.Context, userId string, params *GetUserAccessTokensForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserAccessTokensForUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserAccessTokenWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserAccessTokenRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserAccessToken(ctx context.Context, userId string, body CreateUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserAccessTokenRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishUserTypingWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishUserTypingRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishUserTyping(ctx context.Context, userId string, body PublishUserTypingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishUserTypingRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUploadsForUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUploadsForUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilePublic(ctx context.Context, fileId string, params *GetFilePublicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilePublicRequest(c.Server, fileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybooks(ctx context.Context, params *GetPlaybooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybooksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlaybookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlaybookRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlaybook(ctx context.Context, body CreatePlaybookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlaybookRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePlaybook(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePlaybookRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybook(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybookRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlaybookWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlaybookRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlaybook(ctx context.Context, id string, body UpdatePlaybookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlaybookRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutoFollows(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutoFollowsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlaybookRuns(ctx context.Context, params *ListPlaybookRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlaybookRunsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlaybookRunFromPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlaybookRunFromPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlaybookRunFromPost(ctx context.Context, body CreatePlaybookRunFromPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlaybookRunFromPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybookRunByChannelId(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybookRunByChannelIdRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannels(ctx context.Context, params *GetChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChecklistAutocomplete(ctx context.Context, params *GetChecklistAutocompleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChecklistAutocompleteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlaybookRunFromDialogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlaybookRunFromDialogRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlaybookRunFromDialog(ctx context.Context, body CreatePlaybookRunFromDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlaybookRunFromDialogRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOwners(ctx context.Context, params *GetOwnersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOwnersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybookRun(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybookRunRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlaybookRunWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlaybookRunRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlaybookRun(ctx context.Context, id string, body UpdatePlaybookRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlaybookRunRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddChecklistItemWithBody(ctx context.Context, id string, checklist int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddChecklistItemRequestWithBody(c.Server, id, checklist, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddChecklistItem(ctx context.Context, id string, checklist int, body AddChecklistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddChecklistItemRequest(c.Server, id, checklist, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemDelete(ctx context.Context, id string, checklist int, item int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemDeleteRequest(c.Server, id, checklist, item)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemRenameWithBody(ctx context.Context, id string, checklist int, item int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemRenameRequestWithBody(c.Server, id, checklist, item, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemRename(ctx context.Context, id string, checklist int, item int, body ItemRenameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemRenameRequest(c.Server, id, checklist, item, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemSetAssigneeWithBody(ctx context.Context, id string, checklist int, item int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemSetAssigneeRequestWithBody(c.Server, id, checklist, item, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemSetAssignee(ctx context.Context, id string, checklist int, item int, body ItemSetAssigneeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemSetAssigneeRequest(c.Server, id, checklist, item, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemRun(ctx context.Context, id string, checklist int, item int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemRunRequest(c.Server, id, checklist, item)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemSetStateWithBody(ctx context.Context, id string, checklist int, item int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemSetStateRequestWithBody(c.Server, id, checklist, item, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemSetState(ctx context.Context, id string, checklist int, item int, body ItemSetStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemSetStateRequest(c.Server, id, checklist, item, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReoderChecklistItemWithBody(ctx context.Context, id string, checklist int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReoderChecklistItemRequestWithBody(c.Server, id, checklist, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReoderChecklistItem(ctx context.Context, id string, checklist int, body ReoderChecklistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReoderChecklistItemRequest(c.Server, id, checklist, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndPlaybookRunDialog(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndPlaybookRunDialogRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndPlaybookRun(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndPlaybookRunRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Finish(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFinishRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybookRunMetadata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybookRunMetadataRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NextStageDialogWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNextStageDialogRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NextStageDialog(ctx context.Context, id string, body NextStageDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNextStageDialogRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeOwnerWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeOwnerRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeOwner(ctx context.Context, id string, body ChangeOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeOwnerRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartPlaybookRun(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartPlaybookRunRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatusWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatusRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Status(ctx context.Context, id string, body StatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatusRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTimelineEvent(ctx context.Context, id string, eventId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTimelineEventRequest(c.Server, id, eventId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewOpenInteractiveDialogRequest calls the generic OpenInteractiveDialog builder with application/json body
func NewOpenInteractiveDialogRequest(server string, body OpenInteractiveDialogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOpenInteractiveDialogRequestWithBody(server, "application/json", bodyReader)
}

// NewOpenInteractiveDialogRequestWithBody generates requests for OpenInteractiveDialog with any type of body
func NewOpenInteractiveDialogRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/actions/dialogs/open")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSubmitInteractiveDialogRequest calls the generic SubmitInteractiveDialog builder with application/json body
func NewSubmitInteractiveDialogRequest(server string, body SubmitInteractiveDialogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitInteractiveDialogRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitInteractiveDialogRequestWithBody generates requests for SubmitInteractiveDialog with any type of body
func NewSubmitInteractiveDialogRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/actions/dialogs/submit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAnalyticsOldRequest generates requests for GetAnalyticsOld
func NewGetAnalyticsOldRequest(server string, params *GetAnalyticsOldParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/analytics/old")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuditsRequest generates requests for GetAudits
func NewGetAuditsRequest(server string, params *GetAuditsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/audits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPurgeBleveIndexesRequest generates requests for PurgeBleveIndexes
func NewPurgeBleveIndexesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/bleve/purge_indexes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBotsRequest generates requests for GetBots
func NewGetBotsRequest(server string, params *GetBotsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/bots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyOrphaned != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_orphaned", runtime.ParamLocationQuery, *params.OnlyOrphaned); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBotRequest calls the generic CreateBot builder with application/json body
func NewCreateBotRequest(server string, body CreateBotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBotRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBotRequestWithBody generates requests for CreateBot with any type of body
func NewCreateBotRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/bots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBotRequest generates requests for GetBot
func NewGetBotRequest(server string, botUserId string, params *GetBotParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_user_id", runtime.ParamLocationPath, botUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/bots/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchBotRequest calls the generic PatchBot builder with application/json body
func NewPatchBotRequest(server string, botUserId string, body PatchBotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchBotRequestWithBody(server, botUserId, "application/json", bodyReader)
}

// NewPatchBotRequestWithBody generates requests for PatchBot with any type of body
func NewPatchBotRequestWithBody(server string, botUserId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_user_id", runtime.ParamLocationPath, botUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/bots/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssignBotRequest generates requests for AssignBot
func NewAssignBotRequest(server string, botUserId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_user_id", runtime.ParamLocationPath, botUserId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/bots/%s/assign/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConvertBotToUserRequest calls the generic ConvertBotToUser builder with application/json body
func NewConvertBotToUserRequest(server string, botUserId string, params *ConvertBotToUserParams, body ConvertBotToUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConvertBotToUserRequestWithBody(server, botUserId, params, "application/json", bodyReader)
}

// NewConvertBotToUserRequestWithBody generates requests for ConvertBotToUser with any type of body
func NewConvertBotToUserRequestWithBody(server string, botUserId string, params *ConvertBotToUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_user_id", runtime.ParamLocationPath, botUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/bots/%s/convert_to_user", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SetSystemAdmin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "set_system_admin", runtime.ParamLocationQuery, *params.SetSystemAdmin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisableBotRequest generates requests for DisableBot
func NewDisableBotRequest(server string, botUserId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_user_id", runtime.ParamLocationPath, botUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/bots/%s/disable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnableBotRequest generates requests for EnableBot
func NewEnableBotRequest(server string, botUserId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_user_id", runtime.ParamLocationPath, botUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/bots/%s/enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBotIconImageRequest generates requests for DeleteBotIconImage
func NewDeleteBotIconImageRequest(server string, botUserId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_user_id", runtime.ParamLocationPath, botUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/bots/%s/icon", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBotIconImageRequest generates requests for GetBotIconImage
func NewGetBotIconImageRequest(server string, botUserId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_user_id", runtime.ParamLocationPath, botUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/bots/%s/icon", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetBotIconImageRequestWithBody generates requests for SetBotIconImage with any type of body
func NewSetBotIconImageRequestWithBody(server string, botUserId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bot_user_id", runtime.ParamLocationPath, botUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/bots/%s/icon", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBrandImageRequest generates requests for DeleteBrandImage
func NewDeleteBrandImageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/brand/image")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBrandImageRequest generates requests for GetBrandImage
func NewGetBrandImageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/brand/image")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadBrandImageRequestWithBody generates requests for UploadBrandImage with any type of body
func NewUploadBrandImageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/brand/image")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInvalidateCachesRequest generates requests for InvalidateCaches
func NewInvalidateCachesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/caches/invalidate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllChannelsRequest generates requests for GetAllChannels
func NewGetAllChannelsRequest(server string, params *GetAllChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NotAssociatedToGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_associated_to_group", runtime.ParamLocationQuery, *params.NotAssociatedToGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeDefaultChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_default_channels", runtime.ParamLocationQuery, *params.ExcludeDefaultChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTotalCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_total_count", runtime.ParamLocationQuery, *params.IncludeTotalCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludePolicyConstrained != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_policy_constrained", runtime.ParamLocationQuery, *params.ExcludePolicyConstrained); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateChannelRequest calls the generic CreateChannel builder with application/json body
func NewCreateChannelRequest(server string, body CreateChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateChannelRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateChannelRequestWithBody generates requests for CreateChannel with any type of body
func NewCreateChannelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDirectChannelRequest calls the generic CreateDirectChannel builder with application/json body
func NewCreateDirectChannelRequest(server string, body CreateDirectChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDirectChannelRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDirectChannelRequestWithBody generates requests for CreateDirectChannel with any type of body
func NewCreateDirectChannelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/direct")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateGroupChannelRequest calls the generic CreateGroupChannel builder with application/json body
func NewCreateGroupChannelRequest(server string, body CreateGroupChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupChannelRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGroupChannelRequestWithBody generates requests for CreateGroupChannel with any type of body
func NewCreateGroupChannelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/group")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchGroupChannelsRequest calls the generic SearchGroupChannels builder with application/json body
func NewSearchGroupChannelsRequest(server string, body SearchGroupChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchGroupChannelsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchGroupChannelsRequestWithBody generates requests for SearchGroupChannels with any type of body
func NewSearchGroupChannelsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/group/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewViewChannelRequest calls the generic ViewChannel builder with application/json body
func NewViewChannelRequest(server string, userId string, body ViewChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewViewChannelRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewViewChannelRequestWithBody generates requests for ViewChannel with any type of body
func NewViewChannelRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/members/%s/view", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchAllChannelsRequest calls the generic SearchAllChannels builder with application/json body
func NewSearchAllChannelsRequest(server string, params *SearchAllChannelsParams, body SearchAllChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchAllChannelsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSearchAllChannelsRequestWithBody generates requests for SearchAllChannels with any type of body
func NewSearchAllChannelsRequestWithBody(server string, params *SearchAllChannelsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SystemConsole != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "system_console", runtime.ParamLocationQuery, *params.SystemConsole); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteChannelRequest generates requests for DeleteChannel
func NewDeleteChannelRequest(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelRequest generates requests for GetChannel
func NewGetChannelRequest(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateChannelRequest calls the generic UpdateChannel builder with application/json body
func NewUpdateChannelRequest(server string, channelId string, body UpdateChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChannelRequestWithBody(server, channelId, "application/json", bodyReader)
}

// NewUpdateChannelRequestWithBody generates requests for UpdateChannel with any type of body
func NewUpdateChannelRequestWithBody(server string, channelId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListChannelBookmarksForChannelRequest generates requests for ListChannelBookmarksForChannel
func NewListChannelBookmarksForChannelRequest(server string, channelId string, params *ListChannelBookmarksForChannelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/bookmarks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BookmarksSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bookmarks_since", runtime.ParamLocationQuery, *params.BookmarksSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateChannelBookmarkRequest calls the generic CreateChannelBookmark builder with application/json body
func NewCreateChannelBookmarkRequest(server string, channelId string, body CreateChannelBookmarkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateChannelBookmarkRequestWithBody(server, channelId, "application/json", bodyReader)
}

// NewCreateChannelBookmarkRequestWithBody generates requests for CreateChannelBookmark with any type of body
func NewCreateChannelBookmarkRequestWithBody(server string, channelId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/bookmarks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteChannelBookmarkRequest generates requests for DeleteChannelBookmark
func NewDeleteChannelBookmarkRequest(server string, channelId string, bookmarkId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bookmark_id", runtime.ParamLocationPath, bookmarkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/bookmarks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateChannelBookmarkRequest calls the generic UpdateChannelBookmark builder with application/json body
func NewUpdateChannelBookmarkRequest(server string, channelId string, bookmarkId string, body UpdateChannelBookmarkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChannelBookmarkRequestWithBody(server, channelId, bookmarkId, "application/json", bodyReader)
}

// NewUpdateChannelBookmarkRequestWithBody generates requests for UpdateChannelBookmark with any type of body
func NewUpdateChannelBookmarkRequestWithBody(server string, channelId string, bookmarkId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bookmark_id", runtime.ParamLocationPath, bookmarkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/bookmarks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateChannelBookmarkSortOrderRequest calls the generic UpdateChannelBookmarkSortOrder builder with application/json body
func NewUpdateChannelBookmarkSortOrderRequest(server string, channelId string, bookmarkId string, body UpdateChannelBookmarkSortOrderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChannelBookmarkSortOrderRequestWithBody(server, channelId, bookmarkId, "application/json", bodyReader)
}

// NewUpdateChannelBookmarkSortOrderRequestWithBody generates requests for UpdateChannelBookmarkSortOrder with any type of body
func NewUpdateChannelBookmarkSortOrderRequestWithBody(server string, channelId string, bookmarkId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bookmark_id", runtime.ParamLocationPath, bookmarkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/bookmarks/%s/sort_order", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGroupsByChannelRequest generates requests for GetGroupsByChannel
func NewGetGroupsByChannelRequest(server string, channelId string, params *GetGroupsByChannelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterAllowReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_allow_reference", runtime.ParamLocationQuery, *params.FilterAllowReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelMemberCountsByGroupRequest generates requests for GetChannelMemberCountsByGroup
func NewGetChannelMemberCountsByGroupRequest(server string, channelId string, params *GetChannelMemberCountsByGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/member_counts_by_group", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeTimezones != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_timezones", runtime.ParamLocationQuery, *params.IncludeTimezones); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelMembersRequest generates requests for GetChannelMembers
func NewGetChannelMembersRequest(server string, channelId string, params *GetChannelMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddChannelMemberRequest calls the generic AddChannelMember builder with application/json body
func NewAddChannelMemberRequest(server string, channelId string, body AddChannelMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddChannelMemberRequestWithBody(server, channelId, "application/json", bodyReader)
}

// NewAddChannelMemberRequestWithBody generates requests for AddChannelMember with any type of body
func NewAddChannelMemberRequestWithBody(server string, channelId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelMembersByIdsRequest calls the generic GetChannelMembersByIds builder with application/json body
func NewGetChannelMembersByIdsRequest(server string, channelId string, body GetChannelMembersByIdsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetChannelMembersByIdsRequestWithBody(server, channelId, "application/json", bodyReader)
}

// NewGetChannelMembersByIdsRequestWithBody generates requests for GetChannelMembersByIds with any type of body
func NewGetChannelMembersByIdsRequestWithBody(server string, channelId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/members/ids", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveUserFromChannelRequest generates requests for RemoveUserFromChannel
func NewRemoveUserFromChannelRequest(server string, channelId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelMemberRequest generates requests for GetChannelMember
func NewGetChannelMemberRequest(server string, channelId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateChannelNotifyPropsRequest calls the generic UpdateChannelNotifyProps builder with application/json body
func NewUpdateChannelNotifyPropsRequest(server string, channelId string, userId string, body UpdateChannelNotifyPropsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChannelNotifyPropsRequestWithBody(server, channelId, userId, "application/json", bodyReader)
}

// NewUpdateChannelNotifyPropsRequestWithBody generates requests for UpdateChannelNotifyProps with any type of body
func NewUpdateChannelNotifyPropsRequestWithBody(server string, channelId string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/members/%s/notify_props", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateChannelRolesRequest calls the generic UpdateChannelRoles builder with application/json body
func NewUpdateChannelRolesRequest(server string, channelId string, userId string, body UpdateChannelRolesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChannelRolesRequestWithBody(server, channelId, userId, "application/json", bodyReader)
}

// NewUpdateChannelRolesRequestWithBody generates requests for UpdateChannelRoles with any type of body
func NewUpdateChannelRolesRequestWithBody(server string, channelId string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/members/%s/roles", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateChannelMemberSchemeRolesRequest calls the generic UpdateChannelMemberSchemeRoles builder with application/json body
func NewUpdateChannelMemberSchemeRolesRequest(server string, channelId string, userId string, body UpdateChannelMemberSchemeRolesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChannelMemberSchemeRolesRequestWithBody(server, channelId, userId, "application/json", bodyReader)
}

// NewUpdateChannelMemberSchemeRolesRequestWithBody generates requests for UpdateChannelMemberSchemeRoles with any type of body
func NewUpdateChannelMemberSchemeRolesRequestWithBody(server string, channelId string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/members/%s/schemeRoles", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChannelMembersMinusGroupMembersRequest generates requests for ChannelMembersMinusGroupMembers
func NewChannelMembersMinusGroupMembersRequest(server string, channelId string, params *ChannelMembersMinusGroupMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/members_minus_group_members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group_ids", runtime.ParamLocationQuery, params.GroupIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelModerationsRequest generates requests for GetChannelModerations
func NewGetChannelModerationsRequest(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/moderations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchChannelModerationsRequest calls the generic PatchChannelModerations builder with application/json body
func NewPatchChannelModerationsRequest(server string, channelId string, body PatchChannelModerationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchChannelModerationsRequestWithBody(server, channelId, "application/json", bodyReader)
}

// NewPatchChannelModerationsRequestWithBody generates requests for PatchChannelModerations with any type of body
func NewPatchChannelModerationsRequestWithBody(server string, channelId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/moderations/patch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMoveChannelRequest calls the generic MoveChannel builder with application/json body
func NewMoveChannelRequest(server string, channelId string, body MoveChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMoveChannelRequestWithBody(server, channelId, "application/json", bodyReader)
}

// NewMoveChannelRequestWithBody generates requests for MoveChannel with any type of body
func NewMoveChannelRequestWithBody(server string, channelId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/move", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchChannelRequest calls the generic PatchChannel builder with application/json body
func NewPatchChannelRequest(server string, channelId string, body PatchChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchChannelRequestWithBody(server, channelId, "application/json", bodyReader)
}

// NewPatchChannelRequestWithBody generates requests for PatchChannel with any type of body
func NewPatchChannelRequestWithBody(server string, channelId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/patch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPinnedPostsRequest generates requests for GetPinnedPosts
func NewGetPinnedPostsRequest(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/pinned", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPostsForChannelRequest generates requests for GetPostsForChannel
func NewGetPostsForChannelRequest(server string, channelId string, params *GetPostsForChannelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/posts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateChannelPrivacyRequest calls the generic UpdateChannelPrivacy builder with application/json body
func NewUpdateChannelPrivacyRequest(server string, channelId string, body UpdateChannelPrivacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChannelPrivacyRequestWithBody(server, channelId, "application/json", bodyReader)
}

// NewUpdateChannelPrivacyRequestWithBody generates requests for UpdateChannelPrivacy with any type of body
func NewUpdateChannelPrivacyRequestWithBody(server string, channelId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/privacy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreChannelRequest generates requests for RestoreChannel
func NewRestoreChannelRequest(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateChannelSchemeRequest calls the generic UpdateChannelScheme builder with application/json body
func NewUpdateChannelSchemeRequest(server string, channelId string, body UpdateChannelSchemeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChannelSchemeRequestWithBody(server, channelId, "application/json", bodyReader)
}

// NewUpdateChannelSchemeRequestWithBody generates requests for UpdateChannelScheme with any type of body
func NewUpdateChannelSchemeRequestWithBody(server string, channelId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/scheme", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelStatsRequest generates requests for GetChannelStats
func NewGetChannelStatsRequest(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelMembersTimezonesRequest generates requests for GetChannelMembersTimezones
func NewGetChannelMembersTimezonesRequest(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/channels/%s/timezones", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitPerformanceReportRequest calls the generic SubmitPerformanceReport builder with application/json body
func NewSubmitPerformanceReportRequest(server string, body SubmitPerformanceReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitPerformanceReportRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitPerformanceReportRequestWithBody generates requests for SubmitPerformanceReport with any type of body
func NewSubmitPerformanceReportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/client_perf")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCloudCustomerRequest generates requests for GetCloudCustomer
func NewGetCloudCustomerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/cloud/customer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCloudCustomerRequest calls the generic UpdateCloudCustomer builder with application/json body
func NewUpdateCloudCustomerRequest(server string, body UpdateCloudCustomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCloudCustomerRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateCloudCustomerRequestWithBody generates requests for UpdateCloudCustomer with any type of body
func NewUpdateCloudCustomerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/cloud/customer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateCloudCustomerAddressRequest calls the generic UpdateCloudCustomerAddress builder with application/json body
func NewUpdateCloudCustomerAddressRequest(server string, body UpdateCloudCustomerAddressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCloudCustomerAddressRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateCloudCustomerAddressRequestWithBody generates requests for UpdateCloudCustomerAddress with any type of body
func NewUpdateCloudCustomerAddressRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/cloud/customer/address")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEndpointForInstallationInformationRequest generates requests for GetEndpointForInstallationInformation
func NewGetEndpointForInstallationInformationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/cloud/installation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCloudLimitsRequest generates requests for GetCloudLimits
func NewGetCloudLimitsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/cloud/limits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCustomerPaymentRequest generates requests for CreateCustomerPayment
func NewCreateCustomerPaymentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/cloud/payment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfirmCustomerPaymentRequestWithBody generates requests for ConfirmCustomerPayment with any type of body
func NewConfirmCustomerPaymentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/cloud/payment/confirm")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCloudProductsRequest generates requests for GetCloudProducts
func NewGetCloudProductsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/cloud/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionRequest generates requests for GetSubscription
func NewGetSubscriptionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/cloud/subscription")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoicesForSubscriptionRequest generates requests for GetInvoicesForSubscription
func NewGetInvoicesForSubscriptionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/cloud/subscription/invoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoiceForSubscriptionAsPdfRequest generates requests for GetInvoiceForSubscriptionAsPdf
func NewGetInvoiceForSubscriptionAsPdfRequest(server string, invoiceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoice_id", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/cloud/subscription/invoices/%s/pdf", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEndpointForCwsWebhooksRequest generates requests for PostEndpointForCwsWebhooks
func NewPostEndpointForCwsWebhooksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/cloud/webhook")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterStatusRequest generates requests for GetClusterStatus
func NewGetClusterStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/cluster/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCommandsRequest generates requests for ListCommands
func NewListCommandsRequest(server string, params *ListCommandsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/commands")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_only", runtime.ParamLocationQuery, *params.CustomOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCommandRequest calls the generic CreateCommand builder with application/json body
func NewCreateCommandRequest(server string, body CreateCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCommandRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCommandRequestWithBody generates requests for CreateCommand with any type of body
func NewCreateCommandRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/commands")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExecuteCommandRequest calls the generic ExecuteCommand builder with application/json body
func NewExecuteCommandRequest(server string, body ExecuteCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecuteCommandRequestWithBody(server, "application/json", bodyReader)
}

// NewExecuteCommandRequestWithBody generates requests for ExecuteCommand with any type of body
func NewExecuteCommandRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/commands/execute")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCommandRequest generates requests for DeleteCommand
func NewDeleteCommandRequest(server string, commandId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "command_id", runtime.ParamLocationPath, commandId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/commands/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCommandByIdRequest generates requests for GetCommandById
func NewGetCommandByIdRequest(server string, commandId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "command_id", runtime.ParamLocationPath, commandId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/commands/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCommandRequest calls the generic UpdateCommand builder with application/json body
func NewUpdateCommandRequest(server string, commandId string, body UpdateCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCommandRequestWithBody(server, commandId, "application/json", bodyReader)
}

// NewUpdateCommandRequestWithBody generates requests for UpdateCommand with any type of body
func NewUpdateCommandRequestWithBody(server string, commandId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "command_id", runtime.ParamLocationPath, commandId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/commands/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMoveCommandRequest calls the generic MoveCommand builder with application/json body
func NewMoveCommandRequest(server string, commandId string, body MoveCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMoveCommandRequestWithBody(server, commandId, "application/json", bodyReader)
}

// NewMoveCommandRequestWithBody generates requests for MoveCommand with any type of body
func NewMoveCommandRequestWithBody(server string, commandId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "command_id", runtime.ParamLocationPath, commandId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/commands/%s/move", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRegenCommandTokenRequest generates requests for RegenCommandToken
func NewRegenCommandTokenRequest(server string, commandId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "command_id", runtime.ParamLocationPath, commandId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/commands/%s/regen_token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComplianceReportsRequest generates requests for GetComplianceReports
func NewGetComplianceReportsRequest(server string, params *GetComplianceReportsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/compliance/reports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateComplianceReportRequest generates requests for CreateComplianceReport
func NewCreateComplianceReportRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/compliance/reports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComplianceReportRequest generates requests for GetComplianceReport
func NewGetComplianceReportRequest(server string, reportId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "report_id", runtime.ParamLocationPath, reportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/compliance/reports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadComplianceReportRequest generates requests for DownloadComplianceReport
func NewDownloadComplianceReportRequest(server string, reportId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "report_id", runtime.ParamLocationPath, reportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/compliance/reports/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string, params *GetConfigParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RemoveMasked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove_masked", runtime.ParamLocationQuery, *params.RemoveMasked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoveDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove_defaults", runtime.ParamLocationQuery, *params.RemoveDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConfigRequest calls the generic UpdateConfig builder with application/json body
func NewUpdateConfigRequest(server string, body UpdateConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateConfigRequestWithBody generates requests for UpdateConfig with any type of body
func NewUpdateConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClientConfigRequest generates requests for GetClientConfig
func NewGetClientConfigRequest(server string, params *GetClientConfigParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/config/client")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnvironmentConfigRequest generates requests for GetEnvironmentConfig
func NewGetEnvironmentConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/config/environment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchConfigRequest calls the generic PatchConfig builder with application/json body
func NewPatchConfigRequest(server string, body PatchConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewPatchConfigRequestWithBody generates requests for PatchConfig with any type of body
func NewPatchConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/config/patch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReloadConfigRequest generates requests for ReloadConfig
func NewReloadConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/config/reload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataRetentionPoliciesRequest generates requests for GetDataRetentionPolicies
func NewGetDataRetentionPoliciesRequest(server string, params *GetDataRetentionPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDataRetentionPolicyRequest calls the generic CreateDataRetentionPolicy builder with application/json body
func NewCreateDataRetentionPolicyRequest(server string, body CreateDataRetentionPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDataRetentionPolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDataRetentionPolicyRequestWithBody generates requests for CreateDataRetentionPolicy with any type of body
func NewCreateDataRetentionPolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDataRetentionPolicyRequest generates requests for DeleteDataRetentionPolicy
func NewDeleteDataRetentionPolicyRequest(server string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataRetentionPolicyByIDRequest generates requests for GetDataRetentionPolicyByID
func NewGetDataRetentionPolicyByIDRequest(server string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchDataRetentionPolicyRequest calls the generic PatchDataRetentionPolicy builder with application/json body
func NewPatchDataRetentionPolicyRequest(server string, policyId string, body PatchDataRetentionPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchDataRetentionPolicyRequestWithBody(server, policyId, "application/json", bodyReader)
}

// NewPatchDataRetentionPolicyRequestWithBody generates requests for PatchDataRetentionPolicy with any type of body
func NewPatchDataRetentionPolicyRequestWithBody(server string, policyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveChannelsFromRetentionPolicyRequest calls the generic RemoveChannelsFromRetentionPolicy builder with application/json body
func NewRemoveChannelsFromRetentionPolicyRequest(server string, policyId string, body RemoveChannelsFromRetentionPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveChannelsFromRetentionPolicyRequestWithBody(server, policyId, "application/json", bodyReader)
}

// NewRemoveChannelsFromRetentionPolicyRequestWithBody generates requests for RemoveChannelsFromRetentionPolicy with any type of body
func NewRemoveChannelsFromRetentionPolicyRequestWithBody(server string, policyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policies/%s/channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelsForRetentionPolicyRequest generates requests for GetChannelsForRetentionPolicy
func NewGetChannelsForRetentionPolicyRequest(server string, policyId string, params *GetChannelsForRetentionPolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policies/%s/channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddChannelsToRetentionPolicyRequest calls the generic AddChannelsToRetentionPolicy builder with application/json body
func NewAddChannelsToRetentionPolicyRequest(server string, policyId string, body AddChannelsToRetentionPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddChannelsToRetentionPolicyRequestWithBody(server, policyId, "application/json", bodyReader)
}

// NewAddChannelsToRetentionPolicyRequestWithBody generates requests for AddChannelsToRetentionPolicy with any type of body
func NewAddChannelsToRetentionPolicyRequestWithBody(server string, policyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policies/%s/channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchChannelsForRetentionPolicyRequest calls the generic SearchChannelsForRetentionPolicy builder with application/json body
func NewSearchChannelsForRetentionPolicyRequest(server string, policyId string, body SearchChannelsForRetentionPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchChannelsForRetentionPolicyRequestWithBody(server, policyId, "application/json", bodyReader)
}

// NewSearchChannelsForRetentionPolicyRequestWithBody generates requests for SearchChannelsForRetentionPolicy with any type of body
func NewSearchChannelsForRetentionPolicyRequestWithBody(server string, policyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policies/%s/channels/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveTeamsFromRetentionPolicyRequest calls the generic RemoveTeamsFromRetentionPolicy builder with application/json body
func NewRemoveTeamsFromRetentionPolicyRequest(server string, policyId string, body RemoveTeamsFromRetentionPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveTeamsFromRetentionPolicyRequestWithBody(server, policyId, "application/json", bodyReader)
}

// NewRemoveTeamsFromRetentionPolicyRequestWithBody generates requests for RemoveTeamsFromRetentionPolicy with any type of body
func NewRemoveTeamsFromRetentionPolicyRequestWithBody(server string, policyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policies/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamsForRetentionPolicyRequest generates requests for GetTeamsForRetentionPolicy
func NewGetTeamsForRetentionPolicyRequest(server string, policyId string, params *GetTeamsForRetentionPolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policies/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTeamsToRetentionPolicyRequest calls the generic AddTeamsToRetentionPolicy builder with application/json body
func NewAddTeamsToRetentionPolicyRequest(server string, policyId string, body AddTeamsToRetentionPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTeamsToRetentionPolicyRequestWithBody(server, policyId, "application/json", bodyReader)
}

// NewAddTeamsToRetentionPolicyRequestWithBody generates requests for AddTeamsToRetentionPolicy with any type of body
func NewAddTeamsToRetentionPolicyRequestWithBody(server string, policyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policies/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchTeamsForRetentionPolicyRequest calls the generic SearchTeamsForRetentionPolicy builder with application/json body
func NewSearchTeamsForRetentionPolicyRequest(server string, policyId string, body SearchTeamsForRetentionPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchTeamsForRetentionPolicyRequestWithBody(server, policyId, "application/json", bodyReader)
}

// NewSearchTeamsForRetentionPolicyRequestWithBody generates requests for SearchTeamsForRetentionPolicy with any type of body
func NewSearchTeamsForRetentionPolicyRequestWithBody(server string, policyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policies/%s/teams/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDataRetentionPoliciesCountRequest generates requests for GetDataRetentionPoliciesCount
func NewGetDataRetentionPoliciesCountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policies_count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataRetentionPolicyRequest generates requests for GetDataRetentionPolicy
func NewGetDataRetentionPolicyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/data_retention/policy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDatabaseRecycleRequest generates requests for DatabaseRecycle
func NewDatabaseRecycleRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/database/recycle")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPurgeElasticsearchIndexesRequest generates requests for PurgeElasticsearchIndexes
func NewPurgeElasticsearchIndexesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/elasticsearch/purge_indexes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestElasticsearchRequest generates requests for TestElasticsearch
func NewTestElasticsearchRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/elasticsearch/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestEmailRequest calls the generic TestEmail builder with application/json body
func NewTestEmailRequest(server string, body TestEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewTestEmailRequestWithBody generates requests for TestEmail with any type of body
func NewTestEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/email/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEmojiListRequest generates requests for GetEmojiList
func NewGetEmojiListRequest(server string, params *GetEmojiListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/emoji")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEmojiRequestWithBody generates requests for CreateEmoji with any type of body
func NewCreateEmojiRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/emoji")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAutocompleteEmojiRequest generates requests for AutocompleteEmoji
func NewAutocompleteEmojiRequest(server string, params *AutocompleteEmojiParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/emoji/autocomplete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmojiByNameRequest generates requests for GetEmojiByName
func NewGetEmojiByNameRequest(server string, emojiName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "emoji_name", runtime.ParamLocationPath, emojiName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/emoji/name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmojisByNamesRequest calls the generic GetEmojisByNames builder with application/json body
func NewGetEmojisByNamesRequest(server string, body GetEmojisByNamesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetEmojisByNamesRequestWithBody(server, "application/json", bodyReader)
}

// NewGetEmojisByNamesRequestWithBody generates requests for GetEmojisByNames with any type of body
func NewGetEmojisByNamesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/emoji/names")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchEmojiRequest calls the generic SearchEmoji builder with application/json body
func NewSearchEmojiRequest(server string, body SearchEmojiJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchEmojiRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchEmojiRequestWithBody generates requests for SearchEmoji with any type of body
func NewSearchEmojiRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/emoji/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEmojiRequest generates requests for DeleteEmoji
func NewDeleteEmojiRequest(server string, emojiId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "emoji_id", runtime.ParamLocationPath, emojiId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/emoji/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmojiRequest generates requests for GetEmoji
func NewGetEmojiRequest(server string, emojiId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "emoji_id", runtime.ParamLocationPath, emojiId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/emoji/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmojiImageRequest generates requests for GetEmojiImage
func NewGetEmojiImageRequest(server string, emojiId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "emoji_id", runtime.ParamLocationPath, emojiId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/emoji/%s/image", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListExportsRequest generates requests for ListExports
func NewListExportsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/exports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteExportRequest generates requests for DeleteExport
func NewDeleteExportRequest(server string, exportName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "export_name", runtime.ParamLocationPath, exportName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/exports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadExportRequest generates requests for DownloadExport
func NewDownloadExportRequest(server string, exportName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "export_name", runtime.ParamLocationPath, exportName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/exports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestS3ConnectionRequest calls the generic TestS3Connection builder with application/json body
func NewTestS3ConnectionRequest(server string, body TestS3ConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestS3ConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewTestS3ConnectionRequestWithBody generates requests for TestS3Connection with any type of body
func NewTestS3ConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/file/s3_test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadFileRequestWithBody generates requests for UploadFile with any type of body
func NewUploadFileRequestWithBody(server string, params *UploadFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_id", runtime.ParamLocationQuery, *params.ChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchFilesRequestWithBody generates requests for SearchFiles with any type of body
func NewSearchFilesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/files/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFileRequest generates requests for GetFile
func NewGetFileRequest(server string, fileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFileInfoRequest generates requests for GetFileInfo
func NewGetFileInfoRequest(server string, fileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/files/%s/info", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFileLinkRequest generates requests for GetFileLink
func NewGetFileLinkRequest(server string, fileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/files/%s/link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFilePreviewRequest generates requests for GetFilePreview
func NewGetFilePreviewRequest(server string, fileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/files/%s/preview", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFileThumbnailRequest generates requests for GetFileThumbnail
func NewGetFileThumbnailRequest(server string, fileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/files/%s/thumbnail", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsRequest generates requests for GetGroups
func NewGetGroupsRequest(server string, params *GetGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeMemberCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_member_count", runtime.ParamLocationQuery, *params.IncludeMemberCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_associated_to_team", runtime.ParamLocationQuery, params.NotAssociatedToTeam); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_associated_to_channel", runtime.ParamLocationQuery, params.NotAssociatedToChannel); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterAllowReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_allow_reference", runtime.ParamLocationQuery, *params.FilterAllowReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupSyncablesChannelsRequest generates requests for GetGroupSyncablesChannels
func NewGetGroupSyncablesChannelsRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupSyncableForChannelIdRequest generates requests for GetGroupSyncableForChannelId
func NewGetGroupSyncableForChannelIdRequest(server string, groupId string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/channels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnlinkGroupSyncableForChannelRequest generates requests for UnlinkGroupSyncableForChannel
func NewUnlinkGroupSyncableForChannelRequest(server string, groupId string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/channels/%s/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkGroupSyncableForChannelRequest generates requests for LinkGroupSyncableForChannel
func NewLinkGroupSyncableForChannelRequest(server string, groupId string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/channels/%s/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchGroupSyncableForChannelRequest calls the generic PatchGroupSyncableForChannel builder with application/json body
func NewPatchGroupSyncableForChannelRequest(server string, groupId string, channelId string, body PatchGroupSyncableForChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchGroupSyncableForChannelRequestWithBody(server, groupId, channelId, "application/json", bodyReader)
}

// NewPatchGroupSyncableForChannelRequestWithBody generates requests for PatchGroupSyncableForChannel with any type of body
func NewPatchGroupSyncableForChannelRequestWithBody(server string, groupId string, channelId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/channels/%s/patch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupMembersRequest calls the generic DeleteGroupMembers builder with application/json body
func NewDeleteGroupMembersRequest(server string, groupId string, body DeleteGroupMembersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteGroupMembersRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewDeleteGroupMembersRequestWithBody generates requests for DeleteGroupMembers with any type of body
func NewDeleteGroupMembersRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGroupUsersRequest generates requests for GetGroupUsers
func NewGetGroupUsersRequest(server string, groupId string, params *GetGroupUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddGroupMembersRequest calls the generic AddGroupMembers builder with application/json body
func NewAddGroupMembersRequest(server string, groupId string, body AddGroupMembersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddGroupMembersRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewAddGroupMembersRequestWithBody generates requests for AddGroupMembers with any type of body
func NewAddGroupMembersRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchGroupRequest calls the generic PatchGroup builder with application/json body
func NewPatchGroupRequest(server string, groupId string, body PatchGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchGroupRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewPatchGroupRequestWithBody generates requests for PatchGroup with any type of body
func NewPatchGroupRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/patch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreGroupRequest generates requests for RestoreGroup
func NewRestoreGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupStatsRequest generates requests for GetGroupStats
func NewGetGroupStatsRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupSyncablesTeamsRequest generates requests for GetGroupSyncablesTeams
func NewGetGroupSyncablesTeamsRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupSyncableForTeamIdRequest generates requests for GetGroupSyncableForTeamId
func NewGetGroupSyncableForTeamIdRequest(server string, groupId string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/teams/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnlinkGroupSyncableForTeamRequest generates requests for UnlinkGroupSyncableForTeam
func NewUnlinkGroupSyncableForTeamRequest(server string, groupId string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/teams/%s/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkGroupSyncableForTeamRequest generates requests for LinkGroupSyncableForTeam
func NewLinkGroupSyncableForTeamRequest(server string, groupId string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/teams/%s/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchGroupSyncableForTeamRequest calls the generic PatchGroupSyncableForTeam builder with application/json body
func NewPatchGroupSyncableForTeamRequest(server string, groupId string, teamId string, body PatchGroupSyncableForTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchGroupSyncableForTeamRequestWithBody(server, groupId, teamId, "application/json", bodyReader)
}

// NewPatchGroupSyncableForTeamRequestWithBody generates requests for PatchGroupSyncableForTeam with any type of body
func NewPatchGroupSyncableForTeamRequestWithBody(server string, groupId string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/groups/%s/teams/%s/patch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIncomingWebhooksRequest generates requests for GetIncomingWebhooks
func NewGetIncomingWebhooksRequest(server string, params *GetIncomingWebhooksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/hooks/incoming")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTotalCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_total_count", runtime.ParamLocationQuery, *params.IncludeTotalCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIncomingWebhookRequest calls the generic CreateIncomingWebhook builder with application/json body
func NewCreateIncomingWebhookRequest(server string, body CreateIncomingWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIncomingWebhookRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIncomingWebhookRequestWithBody generates requests for CreateIncomingWebhook with any type of body
func NewCreateIncomingWebhookRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/hooks/incoming")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIncomingWebhookRequest generates requests for DeleteIncomingWebhook
func NewDeleteIncomingWebhookRequest(server string, hookId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/hooks/incoming/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIncomingWebhookRequest generates requests for GetIncomingWebhook
func NewGetIncomingWebhookRequest(server string, hookId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/hooks/incoming/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIncomingWebhookRequest calls the generic UpdateIncomingWebhook builder with application/json body
func NewUpdateIncomingWebhookRequest(server string, hookId string, body UpdateIncomingWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateIncomingWebhookRequestWithBody(server, hookId, "application/json", bodyReader)
}

// NewUpdateIncomingWebhookRequestWithBody generates requests for UpdateIncomingWebhook with any type of body
func NewUpdateIncomingWebhookRequestWithBody(server string, hookId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/hooks/incoming/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOutgoingWebhooksRequest generates requests for GetOutgoingWebhooks
func NewGetOutgoingWebhooksRequest(server string, params *GetOutgoingWebhooksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/hooks/outgoing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_id", runtime.ParamLocationQuery, *params.ChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOutgoingWebhookRequest calls the generic CreateOutgoingWebhook builder with application/json body
func NewCreateOutgoingWebhookRequest(server string, body CreateOutgoingWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOutgoingWebhookRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOutgoingWebhookRequestWithBody generates requests for CreateOutgoingWebhook with any type of body
func NewCreateOutgoingWebhookRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/hooks/outgoing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOutgoingWebhookRequest generates requests for DeleteOutgoingWebhook
func NewDeleteOutgoingWebhookRequest(server string, hookId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/hooks/outgoing/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOutgoingWebhookRequest generates requests for GetOutgoingWebhook
func NewGetOutgoingWebhookRequest(server string, hookId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/hooks/outgoing/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOutgoingWebhookRequest calls the generic UpdateOutgoingWebhook builder with application/json body
func NewUpdateOutgoingWebhookRequest(server string, hookId string, body UpdateOutgoingWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOutgoingWebhookRequestWithBody(server, hookId, "application/json", bodyReader)
}

// NewUpdateOutgoingWebhookRequestWithBody generates requests for UpdateOutgoingWebhook with any type of body
func NewUpdateOutgoingWebhookRequestWithBody(server string, hookId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/hooks/outgoing/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRegenOutgoingHookTokenRequest generates requests for RegenOutgoingHookToken
func NewRegenOutgoingHookTokenRequest(server string, hookId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/hooks/outgoing/%s/regen_token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetImageByUrlRequest generates requests for GetImageByUrl
func NewGetImageByUrlRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/image")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListImportsRequest generates requests for ListImports
func NewListImportsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/imports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckIntegrityRequest generates requests for CheckIntegrity
func NewCheckIntegrityRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/integrity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIPFiltersRequest generates requests for GetIPFilters
func NewGetIPFiltersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/ip_filtering")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApplyIPFiltersRequest calls the generic ApplyIPFilters builder with application/json body
func NewApplyIPFiltersRequest(server string, body ApplyIPFiltersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApplyIPFiltersRequestWithBody(server, "application/json", bodyReader)
}

// NewApplyIPFiltersRequestWithBody generates requests for ApplyIPFilters with any type of body
func NewApplyIPFiltersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/ip_filtering")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMyIPRequest generates requests for MyIP
func NewMyIPRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/ip_filtering/my_ip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobsRequest generates requests for GetJobs
func NewGetJobsRequest(server string, params *GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_type", runtime.ParamLocationQuery, *params.JobType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateJobRequest calls the generic CreateJob builder with application/json body
func NewCreateJobRequest(server string, body CreateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateJobRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateJobRequestWithBody generates requests for CreateJob with any type of body
func NewCreateJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetJobsByTypeRequest generates requests for GetJobsByType
func NewGetJobsByTypeRequest(server string, pType string, params *GetJobsByTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/jobs/type/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelJobRequest generates requests for CancelJob
func NewCancelJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/jobs/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadJobRequest generates requests for DownloadJob
func NewDownloadJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/jobs/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateJobStatusRequest calls the generic UpdateJobStatus builder with application/json body
func NewUpdateJobStatusRequest(server string, jobId string, body UpdateJobStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateJobStatusRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewUpdateJobStatusRequestWithBody generates requests for UpdateJobStatus with any type of body
func NewUpdateJobStatusRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/jobs/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLdapPrivateCertificateRequest generates requests for DeleteLdapPrivateCertificate
func NewDeleteLdapPrivateCertificateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/ldap/certificate/private")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadLdapPrivateCertificateRequestWithBody generates requests for UploadLdapPrivateCertificate with any type of body
func NewUploadLdapPrivateCertificateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/ldap/certificate/private")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLdapPublicCertificateRequest generates requests for DeleteLdapPublicCertificate
func NewDeleteLdapPublicCertificateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/ldap/certificate/public")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadLdapPublicCertificateRequestWithBody generates requests for UploadLdapPublicCertificate with any type of body
func NewUploadLdapPublicCertificateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/ldap/certificate/public")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLdapGroupsRequest generates requests for GetLdapGroups
func NewGetLdapGroupsRequest(server string, params *GetLdapGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/ldap/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnlinkLdapGroupRequest generates requests for UnlinkLdapGroup
func NewUnlinkLdapGroupRequest(server string, remoteId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "remote_id", runtime.ParamLocationPath, remoteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/ldap/groups/%s/link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkLdapGroupRequest generates requests for LinkLdapGroup
func NewLinkLdapGroupRequest(server string, remoteId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "remote_id", runtime.ParamLocationPath, remoteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/ldap/groups/%s/link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrateIdLdapRequest calls the generic MigrateIdLdap builder with application/json body
func NewMigrateIdLdapRequest(server string, body MigrateIdLdapJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrateIdLdapRequestWithBody(server, "application/json", bodyReader)
}

// NewMigrateIdLdapRequestWithBody generates requests for MigrateIdLdap with any type of body
func NewMigrateIdLdapRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/ldap/migrateid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncLdapRequest generates requests for SyncLdap
func NewSyncLdapRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/ldap/sync")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestLdapRequest generates requests for TestLdap
func NewTestLdapRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/ldap/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUserToGroupSyncablesRequest generates requests for AddUserToGroupSyncables
func NewAddUserToGroupSyncablesRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/ldap/users/%s/group_sync_memberships", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveLicenseFileRequest generates requests for RemoveLicenseFile
func NewRemoveLicenseFileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadLicenseFileRequestWithBody generates requests for UploadLicenseFile with any type of body
func NewUploadLicenseFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClientLicenseRequest generates requests for GetClientLicense
func NewGetClientLicenseRequest(server string, params *GetClientLicenseParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/license/client")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRequestLicenseRenewalLinkRequest generates requests for RequestLicenseRenewalLink
func NewRequestLicenseRenewalLinkRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/license/renewal")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerLimitsRequest generates requests for GetServerLimits
func NewGetServerLimitsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/limits/server")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogsRequest generates requests for GetLogs
func NewGetLogsRequest(server string, params *GetLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogsPerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "logs_per_page", runtime.ParamLocationQuery, *params.LogsPerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLogRequest calls the generic PostLog builder with application/json body
func NewPostLogRequest(server string, body PostLogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLogRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLogRequestWithBody generates requests for PostLog with any type of body
func NewPostLogRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadSystemLogsRequest generates requests for DownloadSystemLogs
func NewDownloadSystemLogsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/logs/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcknowledgeNotificationRequest generates requests for AcknowledgeNotification
func NewAcknowledgeNotificationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/notifications/ack")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestNotificationRequest generates requests for TestNotification
func NewTestNotificationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/notifications/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOAuthAppsRequest generates requests for GetOAuthApps
func NewGetOAuthAppsRequest(server string, params *GetOAuthAppsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOAuthAppRequest calls the generic CreateOAuthApp builder with application/json body
func NewCreateOAuthAppRequest(server string, body CreateOAuthAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOAuthAppRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOAuthAppRequestWithBody generates requests for CreateOAuthApp with any type of body
func NewCreateOAuthAppRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOAuthAppRequest generates requests for DeleteOAuthApp
func NewDeleteOAuthAppRequest(server string, appId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_id", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOAuthAppRequest generates requests for GetOAuthApp
func NewGetOAuthAppRequest(server string, appId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_id", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOAuthAppRequest calls the generic UpdateOAuthApp builder with application/json body
func NewUpdateOAuthAppRequest(server string, appId string, body UpdateOAuthAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOAuthAppRequestWithBody(server, appId, "application/json", bodyReader)
}

// NewUpdateOAuthAppRequestWithBody generates requests for UpdateOAuthApp with any type of body
func NewUpdateOAuthAppRequestWithBody(server string, appId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_id", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOAuthAppInfoRequest generates requests for GetOAuthAppInfo
func NewGetOAuthAppInfoRequest(server string, appId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_id", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth/apps/%s/info", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegenerateOAuthAppSecretRequest generates requests for RegenerateOAuthAppSecret
func NewRegenerateOAuthAppSecretRequest(server string, appId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_id", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth/apps/%s/regen_secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOutgoingOAuthConnectionsRequest generates requests for ListOutgoingOAuthConnections
func NewListOutgoingOAuthConnectionsRequest(server string, params *ListOutgoingOAuthConnectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth/outgoing_connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, params.TeamId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOutgoingOAuthConnectionRequest calls the generic CreateOutgoingOAuthConnection builder with application/json body
func NewCreateOutgoingOAuthConnectionRequest(server string, params *CreateOutgoingOAuthConnectionParams, body CreateOutgoingOAuthConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOutgoingOAuthConnectionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOutgoingOAuthConnectionRequestWithBody generates requests for CreateOutgoingOAuthConnection with any type of body
func NewCreateOutgoingOAuthConnectionRequestWithBody(server string, params *CreateOutgoingOAuthConnectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth/outgoing_connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, params.TeamId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidateOutgoingOAuthConnectionRequest calls the generic ValidateOutgoingOAuthConnection builder with application/json body
func NewValidateOutgoingOAuthConnectionRequest(server string, params *ValidateOutgoingOAuthConnectionParams, body ValidateOutgoingOAuthConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateOutgoingOAuthConnectionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewValidateOutgoingOAuthConnectionRequestWithBody generates requests for ValidateOutgoingOAuthConnection with any type of body
func NewValidateOutgoingOAuthConnectionRequestWithBody(server string, params *ValidateOutgoingOAuthConnectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth/outgoing_connections/validate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, params.TeamId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOutgoingOAuthConnectionRequest generates requests for DeleteOutgoingOAuthConnection
func NewDeleteOutgoingOAuthConnectionRequest(server string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connection_id", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth/outgoing_connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOutgoingOAuthConnectionRequest generates requests for GetOutgoingOAuthConnection
func NewGetOutgoingOAuthConnectionRequest(server string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connection_id", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth/outgoing_connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOutgoingOAuthConnectionRequest calls the generic UpdateOutgoingOAuthConnection builder with application/json body
func NewUpdateOutgoingOAuthConnectionRequest(server string, connectionId string, body UpdateOutgoingOAuthConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOutgoingOAuthConnectionRequestWithBody(server, connectionId, "application/json", bodyReader)
}

// NewUpdateOutgoingOAuthConnectionRequestWithBody generates requests for UpdateOutgoingOAuthConnection with any type of body
func NewUpdateOutgoingOAuthConnectionRequestWithBody(server string, connectionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connection_id", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth/outgoing_connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAncillaryPermissionsPostRequest calls the generic GetAncillaryPermissionsPost builder with application/json body
func NewGetAncillaryPermissionsPostRequest(server string, body GetAncillaryPermissionsPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetAncillaryPermissionsPostRequestWithBody(server, "application/json", bodyReader)
}

// NewGetAncillaryPermissionsPostRequestWithBody generates requests for GetAncillaryPermissionsPost with any type of body
func NewGetAncillaryPermissionsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/permissions/ancillary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPluginsRequest generates requests for GetPlugins
func NewGetPluginsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/plugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadPluginRequestWithBody generates requests for UploadPlugin with any type of body
func NewUploadPluginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/plugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInstallPluginFromUrlRequest generates requests for InstallPluginFromUrl
func NewInstallPluginFromUrlRequest(server string, params *InstallPluginFromUrlParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/plugins/install_from_url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "plugin_download_url", runtime.ParamLocationQuery, params.PluginDownloadUrl); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMarketplacePluginsRequest generates requests for GetMarketplacePlugins
func NewGetMarketplacePluginsRequest(server string, params *GetMarketplacePluginsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/plugins/marketplace")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ServerVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "server_version", runtime.ParamLocationQuery, *params.ServerVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_only", runtime.ParamLocationQuery, *params.LocalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallMarketplacePluginRequest calls the generic InstallMarketplacePlugin builder with application/json body
func NewInstallMarketplacePluginRequest(server string, body InstallMarketplacePluginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInstallMarketplacePluginRequestWithBody(server, "application/json", bodyReader)
}

// NewInstallMarketplacePluginRequestWithBody generates requests for InstallMarketplacePlugin with any type of body
func NewInstallMarketplacePluginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/plugins/marketplace")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMarketplaceVisitedByAdminRequest generates requests for GetMarketplaceVisitedByAdmin
func NewGetMarketplaceVisitedByAdminRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/plugins/marketplace/first_admin_visit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMarketplaceVisitedByAdminRequest calls the generic UpdateMarketplaceVisitedByAdmin builder with application/json body
func NewUpdateMarketplaceVisitedByAdminRequest(server string, body UpdateMarketplaceVisitedByAdminJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMarketplaceVisitedByAdminRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateMarketplaceVisitedByAdminRequestWithBody generates requests for UpdateMarketplaceVisitedByAdmin with any type of body
func NewUpdateMarketplaceVisitedByAdminRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/plugins/marketplace/first_admin_visit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPluginStatusesRequest generates requests for GetPluginStatuses
func NewGetPluginStatusesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/plugins/statuses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebappPluginsRequest generates requests for GetWebappPlugins
func NewGetWebappPluginsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/plugins/webapp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemovePluginRequest generates requests for RemovePlugin
func NewRemovePluginRequest(server string, pluginId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/plugins/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisablePluginRequest generates requests for DisablePlugin
func NewDisablePluginRequest(server string, pluginId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/plugins/%s/disable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnablePluginRequest generates requests for EnablePlugin
func NewEnablePluginRequest(server string, pluginId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/plugins/%s/enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePostRequest calls the generic CreatePost builder with application/json body
func NewCreatePostRequest(server string, params *CreatePostParams, body CreatePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePostRequestWithBody generates requests for CreatePost with any type of body
func NewCreatePostRequestWithBody(server string, params *CreatePostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SetOnline != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "set_online", runtime.ParamLocationQuery, *params.SetOnline); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePostEphemeralRequest calls the generic CreatePostEphemeral builder with application/json body
func NewCreatePostEphemeralRequest(server string, body CreatePostEphemeralJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePostEphemeralRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePostEphemeralRequestWithBody generates requests for CreatePostEphemeral with any type of body
func NewCreatePostEphemeralRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/ephemeral")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPostsByIdsRequest calls the generic GetPostsByIds builder with application/json body
func NewGetPostsByIdsRequest(server string, body GetPostsByIdsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPostsByIdsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetPostsByIdsRequestWithBody generates requests for GetPostsByIds with any type of body
func NewGetPostsByIdsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/ids")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBulkReactionsRequest calls the generic GetBulkReactions builder with application/json body
func NewGetBulkReactionsRequest(server string, body GetBulkReactionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetBulkReactionsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetBulkReactionsRequestWithBody generates requests for GetBulkReactions with any type of body
func NewGetBulkReactionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/ids/reactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateScheduledPostRequest calls the generic CreateScheduledPost builder with application/json body
func NewCreateScheduledPostRequest(server string, body CreateScheduledPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateScheduledPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateScheduledPostRequestWithBody generates requests for CreateScheduledPost with any type of body
func NewCreateScheduledPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/schedule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteScheduledPostRequest generates requests for DeleteScheduledPost
func NewDeleteScheduledPostRequest(server string, scheduledPostId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scheduled_post_id", runtime.ParamLocationPath, scheduledPostId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/schedule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateScheduledPostRequest calls the generic UpdateScheduledPost builder with application/json body
func NewUpdateScheduledPostRequest(server string, scheduledPostId string, params *UpdateScheduledPostParams, body UpdateScheduledPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateScheduledPostRequestWithBody(server, scheduledPostId, params, "application/json", bodyReader)
}

// NewUpdateScheduledPostRequestWithBody generates requests for UpdateScheduledPost with any type of body
func NewUpdateScheduledPostRequestWithBody(server string, scheduledPostId string, params *UpdateScheduledPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scheduled_post_id", runtime.ParamLocationPath, scheduledPostId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/schedule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserScheduledPostsRequest generates requests for GetUserScheduledPosts
func NewGetUserScheduledPostsRequest(server string, teamId string, params *GetUserScheduledPostsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/scheduled/team/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDirectChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeDirectChannels", runtime.ParamLocationQuery, *params.IncludeDirectChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePostRequest generates requests for DeletePost
func NewDeletePostRequest(server string, postId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPostRequest generates requests for GetPost
func NewGetPostRequest(server string, postId string, params *GetPostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePostRequest calls the generic UpdatePost builder with application/json body
func NewUpdatePostRequest(server string, postId string, body UpdatePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePostRequestWithBody(server, postId, "application/json", bodyReader)
}

// NewUpdatePostRequestWithBody generates requests for UpdatePost with any type of body
func NewUpdatePostRequestWithBody(server string, postId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDoPostActionRequest generates requests for DoPostAction
func NewDoPostActionRequest(server string, postId string, actionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/%s/actions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFileInfosForPostRequest generates requests for GetFileInfosForPost
func NewGetFileInfosForPostRequest(server string, postId string, params *GetFileInfosForPostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/%s/files/info", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMoveThreadRequest calls the generic MoveThread builder with application/json body
func NewMoveThreadRequest(server string, postId string, body MoveThreadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMoveThreadRequestWithBody(server, postId, "application/json", bodyReader)
}

// NewMoveThreadRequestWithBody generates requests for MoveThread with any type of body
func NewMoveThreadRequestWithBody(server string, postId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/%s/move", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchPostRequest calls the generic PatchPost builder with application/json body
func NewPatchPostRequest(server string, postId string, body PatchPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchPostRequestWithBody(server, postId, "application/json", bodyReader)
}

// NewPatchPostRequestWithBody generates requests for PatchPost with any type of body
func NewPatchPostRequestWithBody(server string, postId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/%s/patch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPinPostRequest generates requests for PinPost
func NewPinPostRequest(server string, postId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/%s/pin", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReactionsRequest generates requests for GetReactions
func NewGetReactionsRequest(server string, postId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/%s/reactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPostThreadRequest generates requests for GetPostThread
func NewGetPostThreadRequest(server string, postId string, params *GetPostThreadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/%s/thread", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromPost != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromPost", runtime.ParamLocationQuery, *params.FromPost); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromCreateAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromCreateAt", runtime.ParamLocationQuery, *params.FromCreateAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipFetchThreads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipFetchThreads", runtime.ParamLocationQuery, *params.SkipFetchThreads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollapsedThreads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collapsedThreads", runtime.ParamLocationQuery, *params.CollapsedThreads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollapsedThreadsExtended != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collapsedThreadsExtended", runtime.ParamLocationQuery, *params.CollapsedThreadsExtended); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnpinPostRequest generates requests for UnpinPost
func NewUnpinPostRequest(server string, postId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/posts/%s/unpin", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveReactionRequest calls the generic SaveReaction builder with application/json body
func NewSaveReactionRequest(server string, body SaveReactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveReactionRequestWithBody(server, "application/json", bodyReader)
}

// NewSaveReactionRequestWithBody generates requests for SaveReaction with any type of body
func NewSaveReactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/reactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRedirectLocationRequest generates requests for GetRedirectLocation
func NewGetRedirectLocationRequest(server string, params *GetRedirectLocationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/redirect_location")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRemoteClustersRequest generates requests for GetRemoteClusters
func NewGetRemoteClustersRequest(server string, params *GetRemoteClustersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/remotecluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeOffline != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_offline", runtime.ParamLocationQuery, *params.ExcludeOffline); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InChannel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "in_channel", runtime.ParamLocationQuery, *params.InChannel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NotInChannel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_in_channel", runtime.ParamLocationQuery, *params.NotInChannel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyConfirmed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_confirmed", runtime.ParamLocationQuery, *params.OnlyConfirmed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyPlugins != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_plugins", runtime.ParamLocationQuery, *params.OnlyPlugins); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludePlugins != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_plugins", runtime.ParamLocationQuery, *params.ExcludePlugins); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRemoteClusterRequest calls the generic CreateRemoteCluster builder with application/json body
func NewCreateRemoteClusterRequest(server string, body CreateRemoteClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRemoteClusterRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRemoteClusterRequestWithBody generates requests for CreateRemoteCluster with any type of body
func NewCreateRemoteClusterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/remotecluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAcceptRemoteClusterInviteRequest calls the generic AcceptRemoteClusterInvite builder with application/json body
func NewAcceptRemoteClusterInviteRequest(server string, body AcceptRemoteClusterInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAcceptRemoteClusterInviteRequestWithBody(server, "application/json", bodyReader)
}

// NewAcceptRemoteClusterInviteRequestWithBody generates requests for AcceptRemoteClusterInvite with any type of body
func NewAcceptRemoteClusterInviteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/remotecluster/accept_invite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRemoteClusterRequest generates requests for DeleteRemoteCluster
func NewDeleteRemoteClusterRequest(server string, remoteId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "remote_id", runtime.ParamLocationPath, remoteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/remotecluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRemoteClusterRequest generates requests for GetRemoteCluster
func NewGetRemoteClusterRequest(server string, remoteId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "remote_id", runtime.ParamLocationPath, remoteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/remotecluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchRemoteClusterRequest calls the generic PatchRemoteCluster builder with application/json body
func NewPatchRemoteClusterRequest(server string, remoteId string, body PatchRemoteClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchRemoteClusterRequestWithBody(server, remoteId, "application/json", bodyReader)
}

// NewPatchRemoteClusterRequestWithBody generates requests for PatchRemoteCluster with any type of body
func NewPatchRemoteClusterRequestWithBody(server string, remoteId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "remote_id", runtime.ParamLocationPath, remoteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/remotecluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInviteRemoteClusterToChannelRequest generates requests for InviteRemoteClusterToChannel
func NewInviteRemoteClusterToChannelRequest(server string, remoteId string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "remote_id", runtime.ParamLocationPath, remoteId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/remotecluster/%s/channels/%s/invite", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUninviteRemoteClusterToChannelRequest generates requests for UninviteRemoteClusterToChannel
func NewUninviteRemoteClusterToChannelRequest(server string, remoteId string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "remote_id", runtime.ParamLocationPath, remoteId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/remotecluster/%s/channels/%s/uninvite", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSharedChannelRemotesByRemoteClusterRequest generates requests for GetSharedChannelRemotesByRemoteCluster
func NewGetSharedChannelRemotesByRemoteClusterRequest(server string, remoteId string, params *GetSharedChannelRemotesByRemoteClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "remote_id", runtime.ParamLocationPath, remoteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/remotecluster/%s/sharedchannelremotes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeUnconfirmed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_unconfirmed", runtime.ParamLocationQuery, *params.IncludeUnconfirmed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeConfirmed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_confirmed", runtime.ParamLocationQuery, *params.ExcludeConfirmed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeHome != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_home", runtime.ParamLocationQuery, *params.ExcludeHome); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeRemote != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_remote", runtime.ParamLocationQuery, *params.ExcludeRemote); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersForReportingRequest generates requests for GetUsersForReporting
func NewGetUsersForReportingRequest(server string, params *GetUsersForReportingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/reports/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_column", runtime.ParamLocationQuery, *params.SortColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_direction", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromColumnValue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_column_value", runtime.ParamLocationQuery, *params.FromColumnValue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_id", runtime.ParamLocationQuery, *params.FromId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateRange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_range", runtime.ParamLocationQuery, *params.DateRange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role_filter", runtime.ParamLocationQuery, *params.RoleFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_filter", runtime.ParamLocationQuery, *params.TeamFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasNoTeam != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "has_no_team", runtime.ParamLocationQuery, *params.HasNoTeam); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HideActive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hide_active", runtime.ParamLocationQuery, *params.HideActive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HideInactive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hide_inactive", runtime.ParamLocationQuery, *params.HideInactive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserCountForReportingRequest generates requests for GetUserCountForReporting
func NewGetUserCountForReportingRequest(server string, params *GetUserCountForReportingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/reports/users/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RoleFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role_filter", runtime.ParamLocationQuery, *params.RoleFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_filter", runtime.ParamLocationQuery, *params.TeamFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasNoTeam != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "has_no_team", runtime.ParamLocationQuery, *params.HasNoTeam); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HideActive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hide_active", runtime.ParamLocationQuery, *params.HideActive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HideInactive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hide_inactive", runtime.ParamLocationQuery, *params.HideInactive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartBatchUsersExportRequest generates requests for StartBatchUsersExport
func NewStartBatchUsersExportRequest(server string, params *StartBatchUsersExportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/reports/users/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DateRange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_range", runtime.ParamLocationQuery, *params.DateRange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestartServerRequest generates requests for RestartServer
func NewRestartServerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/restart")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllRolesRequest generates requests for GetAllRoles
func NewGetAllRolesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoleByNameRequest generates requests for GetRoleByName
func NewGetRoleByNameRequest(server string, roleName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "role_name", runtime.ParamLocationPath, roleName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/roles/name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRolesByNamesRequest calls the generic GetRolesByNames builder with application/json body
func NewGetRolesByNamesRequest(server string, body GetRolesByNamesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetRolesByNamesRequestWithBody(server, "application/json", bodyReader)
}

// NewGetRolesByNamesRequestWithBody generates requests for GetRolesByNames with any type of body
func NewGetRolesByNamesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/roles/names")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRoleRequest generates requests for GetRole
func NewGetRoleRequest(server string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchRoleRequest calls the generic PatchRole builder with application/json body
func NewPatchRoleRequest(server string, roleId string, body PatchRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchRoleRequestWithBody(server, roleId, "application/json", bodyReader)
}

// NewPatchRoleRequestWithBody generates requests for PatchRole with any type of body
func NewPatchRoleRequestWithBody(server string, roleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/roles/%s/patch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSamlIdpCertificateRequest generates requests for DeleteSamlIdpCertificate
func NewDeleteSamlIdpCertificateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/saml/certificate/idp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadSamlIdpCertificateRequestWithBody generates requests for UploadSamlIdpCertificate with any type of body
func NewUploadSamlIdpCertificateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/saml/certificate/idp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSamlPrivateCertificateRequest generates requests for DeleteSamlPrivateCertificate
func NewDeleteSamlPrivateCertificateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/saml/certificate/private")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadSamlPrivateCertificateRequestWithBody generates requests for UploadSamlPrivateCertificate with any type of body
func NewUploadSamlPrivateCertificateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/saml/certificate/private")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSamlPublicCertificateRequest generates requests for DeleteSamlPublicCertificate
func NewDeleteSamlPublicCertificateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/saml/certificate/public")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadSamlPublicCertificateRequestWithBody generates requests for UploadSamlPublicCertificate with any type of body
func NewUploadSamlPublicCertificateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/saml/certificate/public")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSamlCertificateStatusRequest generates requests for GetSamlCertificateStatus
func NewGetSamlCertificateStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/saml/certificate/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSamlMetadataRequest generates requests for GetSamlMetadata
func NewGetSamlMetadataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/saml/metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSamlMetadataFromIdpRequest calls the generic GetSamlMetadataFromIdp builder with application/json body
func NewGetSamlMetadataFromIdpRequest(server string, body GetSamlMetadataFromIdpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetSamlMetadataFromIdpRequestWithBody(server, "application/json", bodyReader)
}

// NewGetSamlMetadataFromIdpRequestWithBody generates requests for GetSamlMetadataFromIdp with any type of body
func NewGetSamlMetadataFromIdpRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/saml/metadatafromidp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetSamlAuthDataToEmailRequest calls the generic ResetSamlAuthDataToEmail builder with application/json body
func NewResetSamlAuthDataToEmailRequest(server string, body ResetSamlAuthDataToEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetSamlAuthDataToEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewResetSamlAuthDataToEmailRequestWithBody generates requests for ResetSamlAuthDataToEmail with any type of body
func NewResetSamlAuthDataToEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/saml/reset_auth_data")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchemesRequest generates requests for GetSchemes
func NewGetSchemesRequest(server string, params *GetSchemesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/schemes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSchemeRequest calls the generic CreateScheme builder with application/json body
func NewCreateSchemeRequest(server string, body CreateSchemeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSchemeRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSchemeRequestWithBody generates requests for CreateScheme with any type of body
func NewCreateSchemeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/schemes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSchemeRequest generates requests for DeleteScheme
func NewDeleteSchemeRequest(server string, schemeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scheme_id", runtime.ParamLocationPath, schemeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/schemes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchemeRequest generates requests for GetScheme
func NewGetSchemeRequest(server string, schemeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scheme_id", runtime.ParamLocationPath, schemeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/schemes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelsForSchemeRequest generates requests for GetChannelsForScheme
func NewGetChannelsForSchemeRequest(server string, schemeId string, params *GetChannelsForSchemeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scheme_id", runtime.ParamLocationPath, schemeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/schemes/%s/channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSchemeRequest calls the generic PatchScheme builder with application/json body
func NewPatchSchemeRequest(server string, schemeId string, body PatchSchemeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSchemeRequestWithBody(server, schemeId, "application/json", bodyReader)
}

// NewPatchSchemeRequestWithBody generates requests for PatchScheme with any type of body
func NewPatchSchemeRequestWithBody(server string, schemeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scheme_id", runtime.ParamLocationPath, schemeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/schemes/%s/patch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamsForSchemeRequest generates requests for GetTeamsForScheme
func NewGetTeamsForSchemeRequest(server string, schemeId string, params *GetTeamsForSchemeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scheme_id", runtime.ParamLocationPath, schemeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/schemes/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearServerBusyRequest generates requests for ClearServerBusy
func NewClearServerBusyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/server_busy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerBusyExpiresRequest generates requests for GetServerBusyExpires
func NewGetServerBusyExpiresRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/server_busy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetServerBusyRequest generates requests for SetServerBusy
func NewSetServerBusyRequest(server string, params *SetServerBusyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/server_busy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Seconds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seconds", runtime.ParamLocationQuery, *params.Seconds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRemoteClusterInfoRequest generates requests for GetRemoteClusterInfo
func NewGetRemoteClusterInfoRequest(server string, remoteId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "remote_id", runtime.ParamLocationPath, remoteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/sharedchannels/remote_info/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSharedChannelsRequest generates requests for GetAllSharedChannels
func NewGetAllSharedChannelsRequest(server string, teamId string, params *GetAllSharedChannelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/sharedchannels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestSiteURLRequest calls the generic TestSiteURL builder with application/json body
func NewTestSiteURLRequest(server string, body TestSiteURLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestSiteURLRequestWithBody(server, "application/json", bodyReader)
}

// NewTestSiteURLRequestWithBody generates requests for TestSiteURL with any type of body
func NewTestSiteURLRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/site_url/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarkNoticesViewedRequest calls the generic MarkNoticesViewed builder with application/json body
func NewMarkNoticesViewedRequest(server string, body MarkNoticesViewedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkNoticesViewedRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkNoticesViewedRequestWithBody generates requests for MarkNoticesViewed with any type of body
func NewMarkNoticesViewedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/system/notices/view")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNoticesRequest generates requests for GetNotices
func NewGetNoticesRequest(server string, teamId string, params *GetNoticesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/system/notices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clientVersion", runtime.ParamLocationQuery, params.ClientVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client", runtime.ParamLocationQuery, params.Client); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPingRequest generates requests for GetPing
func NewGetPingRequest(server string, params *GetPingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/system/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GetServerStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "get_server_status", runtime.ParamLocationQuery, *params.GetServerStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "device_id", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UseRestSemantics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "use_rest_semantics", runtime.ParamLocationQuery, *params.UseRestSemantics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateSupportPacketRequest generates requests for GenerateSupportPacket
func NewGenerateSupportPacketRequest(server string, params *GenerateSupportPacketParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/system/support_packet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BasicServerLogs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "basic_server_logs", runtime.ParamLocationQuery, *params.BasicServerLogs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PluginPackets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "plugin_packets", runtime.ParamLocationQuery, *params.PluginPackets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSupportedTimezoneRequest generates requests for GetSupportedTimezone
func NewGetSupportedTimezoneRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/system/timezones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllTeamsRequest generates requests for GetAllTeams
func NewGetAllTeamsRequest(server string, params *GetAllTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTotalCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_total_count", runtime.ParamLocationQuery, *params.IncludeTotalCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludePolicyConstrained != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_policy_constrained", runtime.ParamLocationQuery, *params.ExcludePolicyConstrained); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTeamRequest calls the generic CreateTeam builder with application/json body
func NewCreateTeamRequest(server string, body CreateTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTeamRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTeamRequestWithBody generates requests for CreateTeam with any type of body
func NewCreateTeamRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamInviteInfoRequest generates requests for GetTeamInviteInfo
func NewGetTeamInviteInfoRequest(server string, inviteId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invite_id", runtime.ParamLocationPath, inviteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/invite/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInvalidateEmailInvitesRequest generates requests for InvalidateEmailInvites
func NewInvalidateEmailInvitesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/invites/email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTeamMemberFromInviteRequest generates requests for AddTeamMemberFromInvite
func NewAddTeamMemberFromInviteRequest(server string, params *AddTeamMemberFromInviteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/members/invite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamByNameRequest generates requests for GetTeamByName
func NewGetTeamByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamExistsRequest generates requests for TeamExists
func NewTeamExistsRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/name/%s/exists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelByNameForTeamNameRequest generates requests for GetChannelByNameForTeamName
func NewGetChannelByNameForTeamNameRequest(server string, teamName string, channelName string, params *GetChannelByNameForTeamNameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel_name", runtime.ParamLocationPath, channelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/name/%s/channels/name/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchTeamsRequest calls the generic SearchTeams builder with application/json body
func NewSearchTeamsRequest(server string, body SearchTeamsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchTeamsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchTeamsRequestWithBody generates requests for SearchTeams with any type of body
func NewSearchTeamsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSoftDeleteTeamRequest generates requests for SoftDeleteTeam
func NewSoftDeleteTeamRequest(server string, teamId string, params *SoftDeleteTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Permanent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permanent", runtime.ParamLocationQuery, *params.Permanent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamRequest generates requests for GetTeam
func NewGetTeamRequest(server string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTeamRequest calls the generic UpdateTeam builder with application/json body
func NewUpdateTeamRequest(server string, teamId string, body UpdateTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTeamRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewUpdateTeamRequestWithBody generates requests for UpdateTeam with any type of body
func NewUpdateTeamRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPublicChannelsForTeamRequest generates requests for GetPublicChannelsForTeam
func NewGetPublicChannelsForTeamRequest(server string, teamId string, params *GetPublicChannelsForTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAutocompleteChannelsForTeamRequest generates requests for AutocompleteChannelsForTeam
func NewAutocompleteChannelsForTeamRequest(server string, teamId string, params *AutocompleteChannelsForTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/channels/autocomplete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeletedChannelsForTeamRequest generates requests for GetDeletedChannelsForTeam
func NewGetDeletedChannelsForTeamRequest(server string, teamId string, params *GetDeletedChannelsForTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/channels/deleted", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPublicChannelsByIdsForTeamRequest calls the generic GetPublicChannelsByIdsForTeam builder with application/json body
func NewGetPublicChannelsByIdsForTeamRequest(server string, teamId string, body GetPublicChannelsByIdsForTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPublicChannelsByIdsForTeamRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewGetPublicChannelsByIdsForTeamRequestWithBody generates requests for GetPublicChannelsByIdsForTeam with any type of body
func NewGetPublicChannelsByIdsForTeamRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/channels/ids", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelByNameRequest generates requests for GetChannelByName
func NewGetChannelByNameRequest(server string, teamId string, channelName string, params *GetChannelByNameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel_name", runtime.ParamLocationPath, channelName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/channels/name/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPrivateChannelsForTeamRequest generates requests for GetPrivateChannelsForTeam
func NewGetPrivateChannelsForTeamRequest(server string, teamId string, params *GetPrivateChannelsForTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/channels/private", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchChannelsRequest calls the generic SearchChannels builder with application/json body
func NewSearchChannelsRequest(server string, teamId string, body SearchChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchChannelsRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewSearchChannelsRequestWithBody generates requests for SearchChannels with any type of body
func NewSearchChannelsRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/channels/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchArchivedChannelsRequest calls the generic SearchArchivedChannels builder with application/json body
func NewSearchArchivedChannelsRequest(server string, teamId string, body SearchArchivedChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchArchivedChannelsRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewSearchArchivedChannelsRequestWithBody generates requests for SearchArchivedChannels with any type of body
func NewSearchArchivedChannelsRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/channels/search_archived", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAutocompleteChannelsForTeamForSearchRequest generates requests for AutocompleteChannelsForTeamForSearch
func NewAutocompleteChannelsForTeamForSearchRequest(server string, teamId string, params *AutocompleteChannelsForTeamForSearchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/channels/search_autocomplete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAutocompleteCommandsRequest generates requests for ListAutocompleteCommands
func NewListAutocompleteCommandsRequest(server string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/commands/autocomplete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCommandAutocompleteSuggestionsRequest generates requests for ListCommandAutocompleteSuggestions
func NewListCommandAutocompleteSuggestionsRequest(server string, teamId string, params *ListCommandAutocompleteSuggestionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/commands/autocomplete_suggestions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_input", runtime.ParamLocationQuery, params.UserInput); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchFilesRequestWithBody generates requests for SearchFiles with any type of body
func NewSearchFilesRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/files/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGroupsByTeamRequest generates requests for GetGroupsByTeam
func NewGetGroupsByTeamRequest(server string, teamId string, params *GetGroupsByTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterAllowReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_allow_reference", runtime.ParamLocationQuery, *params.FilterAllowReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsAssociatedToChannelsByTeamRequest generates requests for GetGroupsAssociatedToChannelsByTeam
func NewGetGroupsAssociatedToChannelsByTeamRequest(server string, teamId string, params *GetGroupsAssociatedToChannelsByTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/groups_by_channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterAllowReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_allow_reference", runtime.ParamLocationQuery, *params.FilterAllowReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Paginate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginate", runtime.ParamLocationQuery, *params.Paginate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveTeamIconRequest generates requests for RemoveTeamIcon
func NewRemoveTeamIconRequest(server string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/image", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamIconRequest generates requests for GetTeamIcon
func NewGetTeamIconRequest(server string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/image", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetTeamIconRequestWithBody generates requests for SetTeamIcon with any type of body
func NewSetTeamIconRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/image", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewImportTeamRequestWithBody generates requests for ImportTeam with any type of body
func NewImportTeamRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/import", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInviteGuestsToTeamRequest calls the generic InviteGuestsToTeam builder with application/json body
func NewInviteGuestsToTeamRequest(server string, teamId string, body InviteGuestsToTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteGuestsToTeamRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewInviteGuestsToTeamRequestWithBody generates requests for InviteGuestsToTeam with any type of body
func NewInviteGuestsToTeamRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/invite-guests/email", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInviteUsersToTeamRequest calls the generic InviteUsersToTeam builder with application/json body
func NewInviteUsersToTeamRequest(server string, teamId string, body InviteUsersToTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteUsersToTeamRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewInviteUsersToTeamRequestWithBody generates requests for InviteUsersToTeam with any type of body
func NewInviteUsersToTeamRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/invite/email", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamMembersRequest generates requests for GetTeamMembers
func NewGetTeamMembersRequest(server string, teamId string, params *GetTeamMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeDeletedUsers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_deleted_users", runtime.ParamLocationQuery, *params.ExcludeDeletedUsers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTeamMemberRequest calls the generic AddTeamMember builder with application/json body
func NewAddTeamMemberRequest(server string, teamId string, body AddTeamMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTeamMemberRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewAddTeamMemberRequestWithBody generates requests for AddTeamMember with any type of body
func NewAddTeamMemberRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddTeamMembersRequest calls the generic AddTeamMembers builder with application/json body
func NewAddTeamMembersRequest(server string, teamId string, params *AddTeamMembersParams, body AddTeamMembersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTeamMembersRequestWithBody(server, teamId, params, "application/json", bodyReader)
}

// NewAddTeamMembersRequestWithBody generates requests for AddTeamMembers with any type of body
func NewAddTeamMembersRequestWithBody(server string, teamId string, params *AddTeamMembersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/members/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Graceful != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "graceful", runtime.ParamLocationQuery, *params.Graceful); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamMembersByIdsRequest calls the generic GetTeamMembersByIds builder with application/json body
func NewGetTeamMembersByIdsRequest(server string, teamId string, body GetTeamMembersByIdsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetTeamMembersByIdsRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewGetTeamMembersByIdsRequestWithBody generates requests for GetTeamMembersByIds with any type of body
func NewGetTeamMembersByIdsRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/members/ids", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveTeamMemberRequest generates requests for RemoveTeamMember
func NewRemoveTeamMemberRequest(server string, teamId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamMemberRequest generates requests for GetTeamMember
func NewGetTeamMemberRequest(server string, teamId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTeamMemberRolesRequest calls the generic UpdateTeamMemberRoles builder with application/json body
func NewUpdateTeamMemberRolesRequest(server string, teamId string, userId string, body UpdateTeamMemberRolesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTeamMemberRolesRequestWithBody(server, teamId, userId, "application/json", bodyReader)
}

// NewUpdateTeamMemberRolesRequestWithBody generates requests for UpdateTeamMemberRoles with any type of body
func NewUpdateTeamMemberRolesRequestWithBody(server string, teamId string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/members/%s/roles", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateTeamMemberSchemeRolesRequest calls the generic UpdateTeamMemberSchemeRoles builder with application/json body
func NewUpdateTeamMemberSchemeRolesRequest(server string, teamId string, userId string, body UpdateTeamMemberSchemeRolesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTeamMemberSchemeRolesRequestWithBody(server, teamId, userId, "application/json", bodyReader)
}

// NewUpdateTeamMemberSchemeRolesRequestWithBody generates requests for UpdateTeamMemberSchemeRoles with any type of body
func NewUpdateTeamMemberSchemeRolesRequestWithBody(server string, teamId string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/members/%s/schemeRoles", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamMembersMinusGroupMembersRequest generates requests for TeamMembersMinusGroupMembers
func NewTeamMembersMinusGroupMembersRequest(server string, teamId string, params *TeamMembersMinusGroupMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/members_minus_group_members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group_ids", runtime.ParamLocationQuery, params.GroupIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchTeamRequest calls the generic PatchTeam builder with application/json body
func NewPatchTeamRequest(server string, teamId string, body PatchTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchTeamRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewPatchTeamRequestWithBody generates requests for PatchTeam with any type of body
func NewPatchTeamRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/patch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchPostsRequest calls the generic SearchPosts builder with application/json body
func NewSearchPostsRequest(server string, teamId string, body SearchPostsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchPostsRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewSearchPostsRequestWithBody generates requests for SearchPosts with any type of body
func NewSearchPostsRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/posts/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateTeamPrivacyRequest calls the generic UpdateTeamPrivacy builder with application/json body
func NewUpdateTeamPrivacyRequest(server string, teamId string, body UpdateTeamPrivacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTeamPrivacyRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewUpdateTeamPrivacyRequestWithBody generates requests for UpdateTeamPrivacy with any type of body
func NewUpdateTeamPrivacyRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/privacy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRegenerateTeamInviteIdRequest generates requests for RegenerateTeamInviteId
func NewRegenerateTeamInviteIdRequest(server string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/regenerate_invite_id", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreTeamRequest generates requests for RestoreTeam
func NewRestoreTeamRequest(server string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTeamSchemeRequest calls the generic UpdateTeamScheme builder with application/json body
func NewUpdateTeamSchemeRequest(server string, teamId string, body UpdateTeamSchemeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTeamSchemeRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewUpdateTeamSchemeRequestWithBody generates requests for UpdateTeamScheme with any type of body
func NewUpdateTeamSchemeRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/scheme", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamStatsRequest generates requests for GetTeamStats
func NewGetTeamStatsRequest(server string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/teams/%s/stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTermsOfServiceRequest generates requests for GetTermsOfService
func NewGetTermsOfServiceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/terms_of_service")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTermsOfServiceRequest generates requests for CreateTermsOfService
func NewCreateTermsOfServiceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/terms_of_service")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRequestTrialLicenseRequest calls the generic RequestTrialLicense builder with application/json body
func NewRequestTrialLicenseRequest(server string, body RequestTrialLicenseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestTrialLicenseRequestWithBody(server, "application/json", bodyReader)
}

// NewRequestTrialLicenseRequestWithBody generates requests for RequestTrialLicense with any type of body
func NewRequestTrialLicenseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/trial-license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPrevTrialLicenseRequest generates requests for GetPrevTrialLicense
func NewGetPrevTrialLicenseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/trial-license/prev")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpgradeToEnterpriseRequest generates requests for UpgradeToEnterprise
func NewUpgradeToEnterpriseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/upgrade_to_enterprise")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpgradeToEnterpriseStatusRequest generates requests for UpgradeToEnterpriseStatus
func NewUpgradeToEnterpriseStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/upgrade_to_enterprise/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUploadRequest calls the generic CreateUpload builder with application/json body
func NewCreateUploadRequest(server string, body CreateUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUploadRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUploadRequestWithBody generates requests for CreateUpload with any type of body
func NewCreateUploadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/uploads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUploadRequest generates requests for GetUpload
func NewGetUploadRequest(server string, uploadId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upload_id", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/uploads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadDataRequestWithFormdataBody calls the generic UploadData builder with application/x-www-form-urlencoded body
func NewUploadDataRequestWithFormdataBody(server string, uploadId string, body UploadDataFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUploadDataRequestWithBody(server, uploadId, "application/x-www-form-urlencoded", bodyReader)
}

// NewUploadDataRequestWithBody generates requests for UploadData with any type of body
func NewUploadDataRequestWithBody(server string, uploadId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upload_id", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/uploads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPostsUsageRequest generates requests for GetPostsUsage
func NewGetPostsUsageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/usage/posts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStorageUsageRequest generates requests for GetStorageUsage
func NewGetStorageUsageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/usage/storage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPermanentDeleteAllUsersRequest generates requests for PermanentDeleteAllUsers
func NewPermanentDeleteAllUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InTeam != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "in_team", runtime.ParamLocationQuery, *params.InTeam); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NotInTeam != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_in_team", runtime.ParamLocationQuery, *params.NotInTeam); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InChannel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "in_channel", runtime.ParamLocationQuery, *params.InChannel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NotInChannel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "not_in_channel", runtime.ParamLocationQuery, *params.NotInChannel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "in_group", runtime.ParamLocationQuery, *params.InGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupConstrained != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group_constrained", runtime.ParamLocationQuery, *params.GroupConstrained); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutTeam != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "without_team", runtime.ParamLocationQuery, *params.WithoutTeam); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Active != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Inactive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inactive", runtime.ParamLocationQuery, *params.Inactive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Role != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, *params.Role); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Roles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "roles", runtime.ParamLocationQuery, *params.Roles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChannelRoles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_roles", runtime.ParamLocationQuery, *params.ChannelRoles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamRoles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_roles", runtime.ParamLocationQuery, *params.TeamRoles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, params *CreateUserParams, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, params *CreateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.T != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "t", runtime.ParamLocationQuery, *params.T); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Iid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "iid", runtime.ParamLocationQuery, *params.Iid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAutocompleteUsersRequest generates requests for AutocompleteUsers
func NewAutocompleteUsersRequest(server string, params *AutocompleteUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/autocomplete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_id", runtime.ParamLocationQuery, *params.ChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerifyUserEmailRequest calls the generic VerifyUserEmail builder with application/json body
func NewVerifyUserEmailRequest(server string, body VerifyUserEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVerifyUserEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewVerifyUserEmailRequestWithBody generates requests for VerifyUserEmail with any type of body
func NewVerifyUserEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/email/verify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendVerificationEmailRequest calls the generic SendVerificationEmail builder with application/json body
func NewSendVerificationEmailRequest(server string, body SendVerificationEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendVerificationEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewSendVerificationEmailRequestWithBody generates requests for SendVerificationEmail with any type of body
func NewSendVerificationEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/email/verify/send")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserByEmailRequest generates requests for GetUserByEmail
func NewGetUserByEmailRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/email/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersByGroupChannelIdsRequest calls the generic GetUsersByGroupChannelIds builder with application/json body
func NewGetUsersByGroupChannelIdsRequest(server string, body GetUsersByGroupChannelIdsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetUsersByGroupChannelIdsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetUsersByGroupChannelIdsRequestWithBody generates requests for GetUsersByGroupChannelIds with any type of body
func NewGetUsersByGroupChannelIdsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/group_channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsersByIdsRequest calls the generic GetUsersByIds builder with application/json body
func NewGetUsersByIdsRequest(server string, params *GetUsersByIdsParams, body GetUsersByIdsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetUsersByIdsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetUsersByIdsRequestWithBody generates requests for GetUsersByIds with any type of body
func NewGetUsersByIdsRequestWithBody(server string, params *GetUsersByIdsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/ids")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsersWithInvalidEmailsRequest generates requests for GetUsersWithInvalidEmails
func NewGetUsersWithInvalidEmailsRequest(server string, params *GetUsersWithInvalidEmailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/invalid_emails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKnownUsersRequest generates requests for GetKnownUsers
func NewGetKnownUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/known")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLoginByCwsTokenRequest calls the generic LoginByCwsToken builder with application/json body
func NewLoginByCwsTokenRequest(server string, body LoginByCwsTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginByCwsTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginByCwsTokenRequestWithBody generates requests for LoginByCwsToken with any type of body
func NewLoginByCwsTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/login/cws")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSwitchAccountTypeRequest calls the generic SwitchAccountType builder with application/json body
func NewSwitchAccountTypeRequest(server string, body SwitchAccountTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSwitchAccountTypeRequestWithBody(server, "application/json", bodyReader)
}

// NewSwitchAccountTypeRequestWithBody generates requests for SwitchAccountType with any type of body
func NewSwitchAccountTypeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/login/switch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckUserMfaRequest calls the generic CheckUserMfa builder with application/json body
func NewCheckUserMfaRequest(server string, body CheckUserMfaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckUserMfaRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckUserMfaRequestWithBody generates requests for CheckUserMfa with any type of body
func NewCheckUserMfaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/mfa")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMigrateAuthToLdapRequest calls the generic MigrateAuthToLdap builder with application/json body
func NewMigrateAuthToLdapRequest(server string, body MigrateAuthToLdapJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrateAuthToLdapRequestWithBody(server, "application/json", bodyReader)
}

// NewMigrateAuthToLdapRequestWithBody generates requests for MigrateAuthToLdap with any type of body
func NewMigrateAuthToLdapRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/migrate_auth/ldap")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMigrateAuthToSamlRequest calls the generic MigrateAuthToSaml builder with application/json body
func NewMigrateAuthToSamlRequest(server string, body MigrateAuthToSamlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrateAuthToSamlRequestWithBody(server, "application/json", bodyReader)
}

// NewMigrateAuthToSamlRequestWithBody generates requests for MigrateAuthToSaml with any type of body
func NewMigrateAuthToSamlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/migrate_auth/saml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetPasswordRequest calls the generic ResetPassword builder with application/json body
func NewResetPasswordRequest(server string, body ResetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewResetPasswordRequestWithBody generates requests for ResetPassword with any type of body
func NewResetPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/password/reset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendPasswordResetEmailRequest calls the generic SendPasswordResetEmail builder with application/json body
func NewSendPasswordResetEmailRequest(server string, body SendPasswordResetEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendPasswordResetEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewSendPasswordResetEmailRequestWithBody generates requests for SendPasswordResetEmail with any type of body
func NewSendPasswordResetEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/password/reset/send")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchUsersRequest calls the generic SearchUsers builder with application/json body
func NewSearchUsersRequest(server string, body SearchUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchUsersRequestWithBody generates requests for SearchUsers with any type of body
func NewSearchUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAttachDeviceExtraPropsRequest calls the generic AttachDeviceExtraProps builder with application/json body
func NewAttachDeviceExtraPropsRequest(server string, body AttachDeviceExtraPropsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachDeviceExtraPropsRequestWithBody(server, "application/json", bodyReader)
}

// NewAttachDeviceExtraPropsRequestWithBody generates requests for AttachDeviceExtraProps with any type of body
func NewAttachDeviceExtraPropsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/sessions/device")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevokeSessionsFromAllUsersRequest generates requests for RevokeSessionsFromAllUsers
func NewRevokeSessionsFromAllUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/sessions/revoke/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTotalUsersStatsRequest generates requests for GetTotalUsersStats
func NewGetTotalUsersStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTotalUsersStatsFilteredRequest generates requests for GetTotalUsersStatsFiltered
func NewGetTotalUsersStatsFilteredRequest(server string, params *GetTotalUsersStatsFilteredParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/stats/filtered")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.InTeam != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "in_team", runtime.ParamLocationQuery, *params.InTeam); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InChannel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "in_channel", runtime.ParamLocationQuery, *params.InChannel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeBots != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_bots", runtime.ParamLocationQuery, *params.IncludeBots); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Roles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "roles", runtime.ParamLocationQuery, *params.Roles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChannelRoles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_roles", runtime.ParamLocationQuery, *params.ChannelRoles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TeamRoles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_roles", runtime.ParamLocationQuery, *params.TeamRoles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersStatusesByIdsRequest calls the generic GetUsersStatusesByIds builder with application/json body
func NewGetUsersStatusesByIdsRequest(server string, body GetUsersStatusesByIdsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetUsersStatusesByIdsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetUsersStatusesByIdsRequestWithBody generates requests for GetUsersStatusesByIds with any type of body
func NewGetUsersStatusesByIdsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/status/ids")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserAccessTokensRequest generates requests for GetUserAccessTokens
func NewGetUserAccessTokensRequest(server string, params *GetUserAccessTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisableUserAccessTokenRequest calls the generic DisableUserAccessToken builder with application/json body
func NewDisableUserAccessTokenRequest(server string, body DisableUserAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDisableUserAccessTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewDisableUserAccessTokenRequestWithBody generates requests for DisableUserAccessToken with any type of body
func NewDisableUserAccessTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/tokens/disable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnableUserAccessTokenRequest calls the generic EnableUserAccessToken builder with application/json body
func NewEnableUserAccessTokenRequest(server string, body EnableUserAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnableUserAccessTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewEnableUserAccessTokenRequestWithBody generates requests for EnableUserAccessToken with any type of body
func NewEnableUserAccessTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/tokens/enable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevokeUserAccessTokenRequest calls the generic RevokeUserAccessToken builder with application/json body
func NewRevokeUserAccessTokenRequest(server string, body RevokeUserAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevokeUserAccessTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewRevokeUserAccessTokenRequestWithBody generates requests for RevokeUserAccessToken with any type of body
func NewRevokeUserAccessTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/tokens/revoke")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchUserAccessTokensRequest calls the generic SearchUserAccessTokens builder with application/json body
func NewSearchUserAccessTokensRequest(server string, body SearchUserAccessTokensJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchUserAccessTokensRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchUserAccessTokensRequestWithBody generates requests for SearchUserAccessTokens with any type of body
func NewSearchUserAccessTokensRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/tokens/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserAccessTokenRequest generates requests for GetUserAccessToken
func NewGetUserAccessTokenRequest(server string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserByUsernameRequest generates requests for GetUserByUsername
func NewGetUserByUsernameRequest(server string, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/username/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersByUsernamesRequest calls the generic GetUsersByUsernames builder with application/json body
func NewGetUsersByUsernamesRequest(server string, body GetUsersByUsernamesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetUsersByUsernamesRequestWithBody(server, "application/json", bodyReader)
}

// NewGetUsersByUsernamesRequestWithBody generates requests for GetUsersByUsernames with any type of body
func NewGetUsersByUsernamesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/usernames")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, userId string, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateUserActiveRequest calls the generic UpdateUserActive builder with application/json body
func NewUpdateUserActiveRequest(server string, userId string, body UpdateUserActiveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserActiveRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserActiveRequestWithBody generates requests for UpdateUserActive with any type of body
func NewUpdateUserActiveRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/active", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserAuditsRequest generates requests for GetUserAudits
func NewGetUserAuditsRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/audits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserAuthRequest calls the generic UpdateUserAuth builder with application/json body
func NewUpdateUserAuthRequest(server string, userId string, body UpdateUserAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserAuthRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserAuthRequestWithBody generates requests for UpdateUserAuth with any type of body
func NewUpdateUserAuthRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/auth", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelMembersWithTeamDataForUserRequest generates requests for GetChannelMembersWithTeamDataForUser
func NewGetChannelMembersWithTeamDataForUserRequest(server string, userId string, params *GetChannelMembersWithTeamDataForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/channel_members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelsForUserRequest generates requests for GetChannelsForUser
func NewGetChannelsForUserRequest(server string, userId string, params *GetChannelsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LastDeleteAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_delete_at", runtime.ParamLocationQuery, *params.LastDeleteAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPostsAroundLastUnreadRequest generates requests for GetPostsAroundLastUnread
func NewGetPostsAroundLastUnreadRequest(server string, userId string, channelId string, params *GetPostsAroundLastUnreadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/channels/%s/posts/unread", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LimitBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_before", runtime.ParamLocationQuery, *params.LimitBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_after", runtime.ParamLocationQuery, *params.LimitAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipFetchThreads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipFetchThreads", runtime.ParamLocationQuery, *params.SkipFetchThreads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollapsedThreads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collapsedThreads", runtime.ParamLocationQuery, *params.CollapsedThreads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollapsedThreadsExtended != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collapsedThreadsExtended", runtime.ParamLocationQuery, *params.CollapsedThreadsExtended); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelUnreadRequest generates requests for GetChannelUnread
func NewGetChannelUnreadRequest(server string, userId string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/channels/%s/unread", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConvertUserToBotRequest generates requests for ConvertUserToBot
func NewConvertUserToBotRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/convert_to_bot", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelPoliciesForUserRequest generates requests for GetChannelPoliciesForUser
func NewGetChannelPoliciesForUserRequest(server string, userId string, params *GetChannelPoliciesForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/data_retention/channel_policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamPoliciesForUserRequest generates requests for GetTeamPoliciesForUser
func NewGetTeamPoliciesForUserRequest(server string, userId string, params *GetTeamPoliciesForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/data_retention/team_policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDemoteUserToGuestRequest generates requests for DemoteUserToGuest
func NewDemoteUserToGuestRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/demote", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerifyUserEmailWithoutTokenRequest generates requests for VerifyUserEmailWithoutToken
func NewVerifyUserEmailWithoutTokenRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/email/verify/member", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupsByUserIdRequest generates requests for GetGroupsByUserId
func NewGetGroupsByUserIdRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDefaultProfileImageRequest generates requests for SetDefaultProfileImage
func NewSetDefaultProfileImageRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/image", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProfileImageRequest generates requests for GetProfileImage
func NewGetProfileImageRequest(server string, userId string, params *GetProfileImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/image", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CacheBuster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cache_buster", runtime.ParamLocationQuery, *params.CacheBuster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetProfileImageRequestWithBody generates requests for SetProfileImage with any type of body
func NewSetProfileImageRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/image", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultProfileImageRequest generates requests for GetDefaultProfileImage
func NewGetDefaultProfileImageRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/image/default", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserMfaRequest calls the generic UpdateUserMfa builder with application/json body
func NewUpdateUserMfaRequest(server string, userId string, body UpdateUserMfaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserMfaRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserMfaRequestWithBody generates requests for UpdateUserMfa with any type of body
func NewUpdateUserMfaRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/mfa", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateMfaSecretRequest generates requests for GenerateMfaSecret
func NewGenerateMfaSecretRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/mfa/generate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthorizedOAuthAppsForUserRequest generates requests for GetAuthorizedOAuthAppsForUser
func NewGetAuthorizedOAuthAppsForUserRequest(server string, userId string, params *GetAuthorizedOAuthAppsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/oauth/apps/authorized", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserPasswordRequest calls the generic UpdateUserPassword builder with application/json body
func NewUpdateUserPasswordRequest(server string, userId string, body UpdateUserPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserPasswordRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserPasswordRequestWithBody generates requests for UpdateUserPassword with any type of body
func NewUpdateUserPasswordRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/password", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchUserRequest calls the generic PatchUser builder with application/json body
func NewPatchUserRequest(server string, userId string, body PatchUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewPatchUserRequestWithBody generates requests for PatchUser with any type of body
func NewPatchUserRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/patch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFlaggedPostsForUserRequest generates requests for GetFlaggedPostsForUser
func NewGetFlaggedPostsForUserRequest(server string, userId string, params *GetFlaggedPostsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/posts/flagged", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TeamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, *params.TeamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_id", runtime.ParamLocationQuery, *params.ChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAcknowledgementForPostRequest generates requests for DeleteAcknowledgementForPost
func NewDeleteAcknowledgementForPostRequest(server string, userId string, postId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/posts/%s/ack", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveAcknowledgementForPostRequest generates requests for SaveAcknowledgementForPost
func NewSaveAcknowledgementForPostRequest(server string, userId string, postId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/posts/%s/ack", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteReactionRequest generates requests for DeleteReaction
func NewDeleteReactionRequest(server string, userId string, postId string, emojiName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "emoji_name", runtime.ParamLocationPath, emojiName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/posts/%s/reactions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPostReminderRequest calls the generic SetPostReminder builder with application/json body
func NewSetPostReminderRequest(server string, userId string, postId string, body SetPostReminderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPostReminderRequestWithBody(server, userId, postId, "application/json", bodyReader)
}

// NewSetPostReminderRequestWithBody generates requests for SetPostReminder with any type of body
func NewSetPostReminderRequestWithBody(server string, userId string, postId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/posts/%s/reminder", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetPostUnreadRequest generates requests for SetPostUnread
func NewSetPostUnreadRequest(server string, userId string, postId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/posts/%s/set_unread", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPreferencesRequest generates requests for GetPreferences
func NewGetPreferencesRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/preferences", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePreferencesRequest calls the generic UpdatePreferences builder with application/json body
func NewUpdatePreferencesRequest(server string, userId string, body UpdatePreferencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePreferencesRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdatePreferencesRequestWithBody generates requests for UpdatePreferences with any type of body
func NewUpdatePreferencesRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/preferences", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePreferencesRequest calls the generic DeletePreferences builder with application/json body
func NewDeletePreferencesRequest(server string, userId string, body DeletePreferencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePreferencesRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewDeletePreferencesRequestWithBody generates requests for DeletePreferences with any type of body
func NewDeletePreferencesRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/preferences/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPreferencesByCategoryRequest generates requests for GetPreferencesByCategory
func NewGetPreferencesByCategoryRequest(server string, userId string, category string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "category", runtime.ParamLocationPath, category)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/preferences/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPreferencesByCategoryByNameRequest generates requests for GetPreferencesByCategoryByName
func NewGetPreferencesByCategoryByNameRequest(server string, userId string, category string, preferenceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "category", runtime.ParamLocationPath, category)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "preference_name", runtime.ParamLocationPath, preferenceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/preferences/%s/name/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPromoteGuestToUserRequest generates requests for PromoteGuestToUser
func NewPromoteGuestToUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/promote", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRolesRequest calls the generic UpdateUserRoles builder with application/json body
func NewUpdateUserRolesRequest(server string, userId string, body UpdateUserRolesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRolesRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserRolesRequestWithBody generates requests for UpdateUserRoles with any type of body
func NewUpdateUserRolesRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSessionsRequest generates requests for GetSessions
func NewGetSessionsRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokeSessionRequest calls the generic RevokeSession builder with application/json body
func NewRevokeSessionRequest(server string, userId string, body RevokeSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevokeSessionRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewRevokeSessionRequestWithBody generates requests for RevokeSession with any type of body
func NewRevokeSessionRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/sessions/revoke", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevokeAllSessionsRequest generates requests for RevokeAllSessions
func NewRevokeAllSessionsRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/sessions/revoke/all", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserStatusRequest generates requests for GetUserStatus
func NewGetUserStatusRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserStatusRequest calls the generic UpdateUserStatus builder with application/json body
func NewUpdateUserStatusRequest(server string, userId string, body UpdateUserStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserStatusRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserStatusRequestWithBody generates requests for UpdateUserStatus with any type of body
func NewUpdateUserStatusRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnsetUserCustomStatusRequest generates requests for UnsetUserCustomStatus
func NewUnsetUserCustomStatusRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/status/custom", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserCustomStatusRequest calls the generic UpdateUserCustomStatus builder with application/json body
func NewUpdateUserCustomStatusRequest(server string, userId string, body UpdateUserCustomStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserCustomStatusRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserCustomStatusRequestWithBody generates requests for UpdateUserCustomStatus with any type of body
func NewUpdateUserCustomStatusRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/status/custom", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveRecentCustomStatusRequest calls the generic RemoveRecentCustomStatus builder with application/json body
func NewRemoveRecentCustomStatusRequest(server string, userId string, body RemoveRecentCustomStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveRecentCustomStatusRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewRemoveRecentCustomStatusRequestWithBody generates requests for RemoveRecentCustomStatus with any type of body
func NewRemoveRecentCustomStatusRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/status/custom/recent", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUserRecentCustomStatusDeleteRequest calls the generic PostUserRecentCustomStatusDelete builder with application/json body
func NewPostUserRecentCustomStatusDeleteRequest(server string, userId string, body PostUserRecentCustomStatusDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUserRecentCustomStatusDeleteRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewPostUserRecentCustomStatusDeleteRequestWithBody generates requests for PostUserRecentCustomStatusDelete with any type of body
func NewPostUserRecentCustomStatusDeleteRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/status/custom/recent/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamsForUserRequest generates requests for GetTeamsForUser
func NewGetTeamsForUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamMembersForUserRequest generates requests for GetTeamMembersForUser
func NewGetTeamMembersForUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsUnreadForUserRequest generates requests for GetTeamsUnreadForUser
func NewGetTeamsUnreadForUserRequest(server string, userId string, params *GetTeamsUnreadForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/unread", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_team", runtime.ParamLocationQuery, params.ExcludeTeam); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IncludeCollapsedThreads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_collapsed_threads", runtime.ParamLocationQuery, *params.IncludeCollapsedThreads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelsForTeamForUserRequest generates requests for GetChannelsForTeamForUser
func NewGetChannelsForTeamForUserRequest(server string, userId string, teamId string, params *GetChannelsForTeamForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/channels", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastDeleteAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_delete_at", runtime.ParamLocationQuery, *params.LastDeleteAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSidebarCategoriesForTeamForUserRequest generates requests for GetSidebarCategoriesForTeamForUser
func NewGetSidebarCategoriesForTeamForUserRequest(server string, userId string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/channels/categories", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSidebarCategoryForTeamForUserRequest calls the generic CreateSidebarCategoryForTeamForUser builder with application/json body
func NewCreateSidebarCategoryForTeamForUserRequest(server string, userId string, teamId string, body CreateSidebarCategoryForTeamForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSidebarCategoryForTeamForUserRequestWithBody(server, userId, teamId, "application/json", bodyReader)
}

// NewCreateSidebarCategoryForTeamForUserRequestWithBody generates requests for CreateSidebarCategoryForTeamForUser with any type of body
func NewCreateSidebarCategoryForTeamForUserRequestWithBody(server string, userId string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/channels/categories", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateSidebarCategoriesForTeamForUserRequest calls the generic UpdateSidebarCategoriesForTeamForUser builder with application/json body
func NewUpdateSidebarCategoriesForTeamForUserRequest(server string, userId string, teamId string, body UpdateSidebarCategoriesForTeamForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSidebarCategoriesForTeamForUserRequestWithBody(server, userId, teamId, "application/json", bodyReader)
}

// NewUpdateSidebarCategoriesForTeamForUserRequestWithBody generates requests for UpdateSidebarCategoriesForTeamForUser with any type of body
func NewUpdateSidebarCategoriesForTeamForUserRequestWithBody(server string, userId string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/channels/categories", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSidebarCategoryOrderForTeamForUserRequest generates requests for GetSidebarCategoryOrderForTeamForUser
func NewGetSidebarCategoryOrderForTeamForUserRequest(server string, userId string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/channels/categories/order", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSidebarCategoryOrderForTeamForUserRequest calls the generic UpdateSidebarCategoryOrderForTeamForUser builder with application/json body
func NewUpdateSidebarCategoryOrderForTeamForUserRequest(server string, userId string, teamId string, body UpdateSidebarCategoryOrderForTeamForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSidebarCategoryOrderForTeamForUserRequestWithBody(server, userId, teamId, "application/json", bodyReader)
}

// NewUpdateSidebarCategoryOrderForTeamForUserRequestWithBody generates requests for UpdateSidebarCategoryOrderForTeamForUser with any type of body
func NewUpdateSidebarCategoryOrderForTeamForUserRequestWithBody(server string, userId string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/channels/categories/order", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveSidebarCategoryForTeamForUserRequest generates requests for RemoveSidebarCategoryForTeamForUser
func NewRemoveSidebarCategoryForTeamForUserRequest(server string, userId string, teamId string, categoryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "category_id", runtime.ParamLocationPath, categoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/channels/categories/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSidebarCategoryForTeamForUserRequest generates requests for GetSidebarCategoryForTeamForUser
func NewGetSidebarCategoryForTeamForUserRequest(server string, userId string, teamId string, categoryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "category_id", runtime.ParamLocationPath, categoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/channels/categories/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSidebarCategoryForTeamForUserRequest calls the generic UpdateSidebarCategoryForTeamForUser builder with application/json body
func NewUpdateSidebarCategoryForTeamForUserRequest(server string, userId string, teamId string, categoryId string, body UpdateSidebarCategoryForTeamForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSidebarCategoryForTeamForUserRequestWithBody(server, userId, teamId, categoryId, "application/json", bodyReader)
}

// NewUpdateSidebarCategoryForTeamForUserRequestWithBody generates requests for UpdateSidebarCategoryForTeamForUser with any type of body
func NewUpdateSidebarCategoryForTeamForUserRequestWithBody(server string, userId string, teamId string, categoryId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "category_id", runtime.ParamLocationPath, categoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/channels/categories/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelMembersForUserRequest generates requests for GetChannelMembersForUser
func NewGetChannelMembersForUserRequest(server string, userId string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/channels/members", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserThreadsRequest generates requests for GetUserThreads
func NewGetUserThreadsRequest(server string, userId string, teamId string, params *GetUserThreadsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/threads", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Deleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted", runtime.ParamLocationQuery, *params.Deleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Extended != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extended", runtime.ParamLocationQuery, *params.Extended); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalsOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "totalsOnly", runtime.ParamLocationQuery, *params.TotalsOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ThreadsOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "threadsOnly", runtime.ParamLocationQuery, *params.ThreadsOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetThreadMentionCountsByChannelRequest generates requests for GetThreadMentionCountsByChannel
func NewGetThreadMentionCountsByChannelRequest(server string, userId string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/threads/mention_counts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateThreadsReadForUserRequest generates requests for UpdateThreadsReadForUser
func NewUpdateThreadsReadForUserRequest(server string, userId string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/threads/read", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserThreadRequest generates requests for GetUserThread
func NewGetUserThreadRequest(server string, userId string, teamId string, threadId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/threads/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopFollowingThreadRequest generates requests for StopFollowingThread
func NewStopFollowingThreadRequest(server string, userId string, teamId string, threadId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/threads/%s/following", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartFollowingThreadRequest generates requests for StartFollowingThread
func NewStartFollowingThreadRequest(server string, userId string, teamId string, threadId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/threads/%s/following", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateThreadReadForUserRequest generates requests for UpdateThreadReadForUser
func NewUpdateThreadReadForUserRequest(server string, userId string, teamId string, threadId string, timestamp string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationPath, timestamp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/threads/%s/read/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetThreadUnreadByPostIdRequest generates requests for SetThreadUnreadByPostId
func NewSetThreadUnreadByPostIdRequest(server string, userId string, teamId string, threadId string, postId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "post_id", runtime.ParamLocationPath, postId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/threads/%s/set_unread/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamUnreadRequest generates requests for GetTeamUnread
func NewGetTeamUnreadRequest(server string, userId string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/teams/%s/unread", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserTermsOfServiceRequest generates requests for GetUserTermsOfService
func NewGetUserTermsOfServiceRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/terms_of_service", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterTermsOfServiceActionRequest calls the generic RegisterTermsOfServiceAction builder with application/json body
func NewRegisterTermsOfServiceActionRequest(server string, userId string, body RegisterTermsOfServiceActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterTermsOfServiceActionRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewRegisterTermsOfServiceActionRequestWithBody generates requests for RegisterTermsOfServiceAction with any type of body
func NewRegisterTermsOfServiceActionRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/terms_of_service", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserAccessTokensForUserRequest generates requests for GetUserAccessTokensForUser
func NewGetUserAccessTokensForUserRequest(server string, userId string, params *GetUserAccessTokensForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserAccessTokenRequest calls the generic CreateUserAccessToken builder with application/json body
func NewCreateUserAccessTokenRequest(server string, userId string, body CreateUserAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserAccessTokenRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewCreateUserAccessTokenRequestWithBody generates requests for CreateUserAccessToken with any type of body
func NewCreateUserAccessTokenRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPublishUserTypingRequest calls the generic PublishUserTyping builder with application/json body
func NewPublishUserTypingRequest(server string, userId string, body PublishUserTypingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPublishUserTypingRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewPublishUserTypingRequestWithBody generates requests for PublishUserTyping with any type of body
func NewPublishUserTypingRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/typing", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUploadsForUserRequest generates requests for GetUploadsForUser
func NewGetUploadsForUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/users/%s/uploads", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFilePublicRequest generates requests for GetFilePublic
func NewGetFilePublicRequest(server string, fileId string, params *GetFilePublicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s/public", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "h", runtime.ParamLocationQuery, params.H); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaybooksRequest generates requests for GetPlaybooks
func NewGetPlaybooksRequest(server string, params *GetPlaybooksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/playbooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, params.TeamId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithArchived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_archived", runtime.ParamLocationQuery, *params.WithArchived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePlaybookRequest calls the generic CreatePlaybook builder with application/json body
func NewCreatePlaybookRequest(server string, body CreatePlaybookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlaybookRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePlaybookRequestWithBody generates requests for CreatePlaybook with any type of body
func NewCreatePlaybookRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/playbooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePlaybookRequest generates requests for DeletePlaybook
func NewDeletePlaybookRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/playbooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaybookRequest generates requests for GetPlaybook
func NewGetPlaybookRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/playbooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePlaybookRequest calls the generic UpdatePlaybook builder with application/json body
func NewUpdatePlaybookRequest(server string, id string, body UpdatePlaybookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePlaybookRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdatePlaybookRequestWithBody generates requests for UpdatePlaybook with any type of body
func NewUpdatePlaybookRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/playbooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAutoFollowsRequest generates requests for GetAutoFollows
func NewGetAutoFollowsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/playbooks/%s/autofollows", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPlaybookRunsRequest generates requests for ListPlaybookRuns
func NewListPlaybookRunsRequest(server string, params *ListPlaybookRunsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, params.TeamId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnerUserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner_user_id", runtime.ParamLocationQuery, *params.OwnerUserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParticipantId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "participant_id", runtime.ParamLocationQuery, *params.ParticipantId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePlaybookRunFromPostRequest calls the generic CreatePlaybookRunFromPost builder with application/json body
func NewCreatePlaybookRunFromPostRequest(server string, body CreatePlaybookRunFromPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlaybookRunFromPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePlaybookRunFromPostRequestWithBody generates requests for CreatePlaybookRunFromPost with any type of body
func NewCreatePlaybookRunFromPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlaybookRunByChannelIdRequest generates requests for GetPlaybookRunByChannelId
func NewGetPlaybookRunByChannelIdRequest(server string, channelId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/channel/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelsRequest generates requests for GetChannels
func NewGetChannelsRequest(server string, params *GetChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, params.TeamId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnerUserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner_user_id", runtime.ParamLocationQuery, *params.OwnerUserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParticipantId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "participant_id", runtime.ParamLocationQuery, *params.ParticipantId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChecklistAutocompleteRequest generates requests for GetChecklistAutocomplete
func NewGetChecklistAutocompleteRequest(server string, params *GetChecklistAutocompleteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/checklist-autocomplete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_ID", runtime.ParamLocationQuery, params.ChannelID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePlaybookRunFromDialogRequest calls the generic CreatePlaybookRunFromDialog builder with application/json body
func NewCreatePlaybookRunFromDialogRequest(server string, body CreatePlaybookRunFromDialogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlaybookRunFromDialogRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePlaybookRunFromDialogRequestWithBody generates requests for CreatePlaybookRunFromDialog with any type of body
func NewCreatePlaybookRunFromDialogRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/dialog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOwnersRequest generates requests for GetOwners
func NewGetOwnersRequest(server string, params *GetOwnersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/owners")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "team_id", runtime.ParamLocationQuery, params.TeamId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaybookRunRequest generates requests for GetPlaybookRun
func NewGetPlaybookRunRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePlaybookRunRequest calls the generic UpdatePlaybookRun builder with application/json body
func NewUpdatePlaybookRunRequest(server string, id string, body UpdatePlaybookRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePlaybookRunRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdatePlaybookRunRequestWithBody generates requests for UpdatePlaybookRun with any type of body
func NewUpdatePlaybookRunRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddChecklistItemRequest calls the generic AddChecklistItem builder with application/json body
func NewAddChecklistItemRequest(server string, id string, checklist int, body AddChecklistItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddChecklistItemRequestWithBody(server, id, checklist, "application/json", bodyReader)
}

// NewAddChecklistItemRequestWithBody generates requests for AddChecklistItem with any type of body
func NewAddChecklistItemRequestWithBody(server string, id string, checklist int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "checklist", runtime.ParamLocationPath, checklist)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/checklists/%s/add", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemDeleteRequest generates requests for ItemDelete
func NewItemDeleteRequest(server string, id string, checklist int, item int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "checklist", runtime.ParamLocationPath, checklist)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "item", runtime.ParamLocationPath, item)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/checklists/%s/item/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemRenameRequest calls the generic ItemRename builder with application/json body
func NewItemRenameRequest(server string, id string, checklist int, item int, body ItemRenameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemRenameRequestWithBody(server, id, checklist, item, "application/json", bodyReader)
}

// NewItemRenameRequestWithBody generates requests for ItemRename with any type of body
func NewItemRenameRequestWithBody(server string, id string, checklist int, item int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "checklist", runtime.ParamLocationPath, checklist)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "item", runtime.ParamLocationPath, item)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/checklists/%s/item/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemSetAssigneeRequest calls the generic ItemSetAssignee builder with application/json body
func NewItemSetAssigneeRequest(server string, id string, checklist int, item int, body ItemSetAssigneeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemSetAssigneeRequestWithBody(server, id, checklist, item, "application/json", bodyReader)
}

// NewItemSetAssigneeRequestWithBody generates requests for ItemSetAssignee with any type of body
func NewItemSetAssigneeRequestWithBody(server string, id string, checklist int, item int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "checklist", runtime.ParamLocationPath, checklist)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "item", runtime.ParamLocationPath, item)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/checklists/%s/item/%s/assignee", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemRunRequest generates requests for ItemRun
func NewItemRunRequest(server string, id string, checklist int, item int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "checklist", runtime.ParamLocationPath, checklist)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "item", runtime.ParamLocationPath, item)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/checklists/%s/item/%s/run", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewItemSetStateRequest calls the generic ItemSetState builder with application/json body
func NewItemSetStateRequest(server string, id string, checklist int, item int, body ItemSetStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemSetStateRequestWithBody(server, id, checklist, item, "application/json", bodyReader)
}

// NewItemSetStateRequestWithBody generates requests for ItemSetState with any type of body
func NewItemSetStateRequestWithBody(server string, id string, checklist int, item int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "checklist", runtime.ParamLocationPath, checklist)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "item", runtime.ParamLocationPath, item)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/checklists/%s/item/%s/state", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReoderChecklistItemRequest calls the generic ReoderChecklistItem builder with application/json body
func NewReoderChecklistItemRequest(server string, id string, checklist int, body ReoderChecklistItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReoderChecklistItemRequestWithBody(server, id, checklist, "application/json", bodyReader)
}

// NewReoderChecklistItemRequestWithBody generates requests for ReoderChecklistItem with any type of body
func NewReoderChecklistItemRequestWithBody(server string, id string, checklist int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "checklist", runtime.ParamLocationPath, checklist)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/checklists/%s/reorder", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEndPlaybookRunDialogRequest generates requests for EndPlaybookRunDialog
func NewEndPlaybookRunDialogRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/end", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndPlaybookRunRequest generates requests for EndPlaybookRun
func NewEndPlaybookRunRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/end", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFinishRequest generates requests for Finish
func NewFinishRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/finish", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaybookRunMetadataRequest generates requests for GetPlaybookRunMetadata
func NewGetPlaybookRunMetadataRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNextStageDialogRequest calls the generic NextStageDialog builder with application/json body
func NewNextStageDialogRequest(server string, id string, body NextStageDialogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNextStageDialogRequestWithBody(server, id, "application/json", bodyReader)
}

// NewNextStageDialogRequestWithBody generates requests for NextStageDialog with any type of body
func NewNextStageDialogRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/next-stage-dialog", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChangeOwnerRequest calls the generic ChangeOwner builder with application/json body
func NewChangeOwnerRequest(server string, id string, body ChangeOwnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangeOwnerRequestWithBody(server, id, "application/json", bodyReader)
}

// NewChangeOwnerRequestWithBody generates requests for ChangeOwner with any type of body
func NewChangeOwnerRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/owner", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestartPlaybookRunRequest generates requests for RestartPlaybookRun
func NewRestartPlaybookRunRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/restart", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatusRequest calls the generic Status builder with application/json body
func NewStatusRequest(server string, id string, body StatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStatusRequestWithBody(server, id, "application/json", bodyReader)
}

// NewStatusRequestWithBody generates requests for Status with any type of body
func NewStatusRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveTimelineEventRequest generates requests for RemoveTimelineEvent
func NewRemoveTimelineEventRequest(server string, id string, eventId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/playbooks/api/v0/runs/%s/timeline/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// OpenInteractiveDialogWithBodyWithResponse request with any body
	OpenInteractiveDialogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OpenInteractiveDialogResponse, error)

	OpenInteractiveDialogWithResponse(ctx context.Context, body OpenInteractiveDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*OpenInteractiveDialogResponse, error)

	// SubmitInteractiveDialogWithBodyWithResponse request with any body
	SubmitInteractiveDialogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitInteractiveDialogResponse, error)

	SubmitInteractiveDialogWithResponse(ctx context.Context, body SubmitInteractiveDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitInteractiveDialogResponse, error)

	// GetAnalyticsOldWithResponse request
	GetAnalyticsOldWithResponse(ctx context.Context, params *GetAnalyticsOldParams, reqEditors ...RequestEditorFn) (*GetAnalyticsOldResponse, error)

	// GetAuditsWithResponse request
	GetAuditsWithResponse(ctx context.Context, params *GetAuditsParams, reqEditors ...RequestEditorFn) (*GetAuditsResponse, error)

	// PurgeBleveIndexesWithResponse request
	PurgeBleveIndexesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PurgeBleveIndexesResponse, error)

	// GetBotsWithResponse request
	GetBotsWithResponse(ctx context.Context, params *GetBotsParams, reqEditors ...RequestEditorFn) (*GetBotsResponse, error)

	// CreateBotWithBodyWithResponse request with any body
	CreateBotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBotResponse, error)

	CreateBotWithResponse(ctx context.Context, body CreateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBotResponse, error)

	// GetBotWithResponse request
	GetBotWithResponse(ctx context.Context, botUserId string, params *GetBotParams, reqEditors ...RequestEditorFn) (*GetBotResponse, error)

	// PatchBotWithBodyWithResponse request with any body
	PatchBotWithBodyWithResponse(ctx context.Context, botUserId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchBotResponse, error)

	PatchBotWithResponse(ctx context.Context, botUserId string, body PatchBotJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchBotResponse, error)

	// AssignBotWithResponse request
	AssignBotWithResponse(ctx context.Context, botUserId string, userId string, reqEditors ...RequestEditorFn) (*AssignBotResponse, error)

	// ConvertBotToUserWithBodyWithResponse request with any body
	ConvertBotToUserWithBodyWithResponse(ctx context.Context, botUserId string, params *ConvertBotToUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertBotToUserResponse, error)

	ConvertBotToUserWithResponse(ctx context.Context, botUserId string, params *ConvertBotToUserParams, body ConvertBotToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertBotToUserResponse, error)

	// DisableBotWithResponse request
	DisableBotWithResponse(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*DisableBotResponse, error)

	// EnableBotWithResponse request
	EnableBotWithResponse(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*EnableBotResponse, error)

	// DeleteBotIconImageWithResponse request
	DeleteBotIconImageWithResponse(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*DeleteBotIconImageResponse, error)

	// GetBotIconImageWithResponse request
	GetBotIconImageWithResponse(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*GetBotIconImageResponse, error)

	// SetBotIconImageWithBodyWithResponse request with any body
	SetBotIconImageWithBodyWithResponse(ctx context.Context, botUserId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBotIconImageResponse, error)

	// DeleteBrandImageWithResponse request
	DeleteBrandImageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteBrandImageResponse, error)

	// GetBrandImageWithResponse request
	GetBrandImageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBrandImageResponse, error)

	// UploadBrandImageWithBodyWithResponse request with any body
	UploadBrandImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadBrandImageResponse, error)

	// InvalidateCachesWithResponse request
	InvalidateCachesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InvalidateCachesResponse, error)

	// GetAllChannelsWithResponse request
	GetAllChannelsWithResponse(ctx context.Context, params *GetAllChannelsParams, reqEditors ...RequestEditorFn) (*GetAllChannelsResponse, error)

	// CreateChannelWithBodyWithResponse request with any body
	CreateChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateChannelResponse, error)

	CreateChannelWithResponse(ctx context.Context, body CreateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateChannelResponse, error)

	// CreateDirectChannelWithBodyWithResponse request with any body
	CreateDirectChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectChannelResponse, error)

	CreateDirectChannelWithResponse(ctx context.Context, body CreateDirectChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectChannelResponse, error)

	// CreateGroupChannelWithBodyWithResponse request with any body
	CreateGroupChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupChannelResponse, error)

	CreateGroupChannelWithResponse(ctx context.Context, body CreateGroupChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupChannelResponse, error)

	// SearchGroupChannelsWithBodyWithResponse request with any body
	SearchGroupChannelsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupChannelsResponse, error)

	SearchGroupChannelsWithResponse(ctx context.Context, body SearchGroupChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupChannelsResponse, error)

	// ViewChannelWithBodyWithResponse request with any body
	ViewChannelWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ViewChannelResponse, error)

	ViewChannelWithResponse(ctx context.Context, userId string, body ViewChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*ViewChannelResponse, error)

	// SearchAllChannelsWithBodyWithResponse request with any body
	SearchAllChannelsWithBodyWithResponse(ctx context.Context, params *SearchAllChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchAllChannelsResponse, error)

	SearchAllChannelsWithResponse(ctx context.Context, params *SearchAllChannelsParams, body SearchAllChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchAllChannelsResponse, error)

	// DeleteChannelWithResponse request
	DeleteChannelWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*DeleteChannelResponse, error)

	// GetChannelWithResponse request
	GetChannelWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetChannelResponse, error)

	// UpdateChannelWithBodyWithResponse request with any body
	UpdateChannelWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelResponse, error)

	UpdateChannelWithResponse(ctx context.Context, channelId string, body UpdateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelResponse, error)

	// ListChannelBookmarksForChannelWithResponse request
	ListChannelBookmarksForChannelWithResponse(ctx context.Context, channelId string, params *ListChannelBookmarksForChannelParams, reqEditors ...RequestEditorFn) (*ListChannelBookmarksForChannelResponse, error)

	// CreateChannelBookmarkWithBodyWithResponse request with any body
	CreateChannelBookmarkWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateChannelBookmarkResponse, error)

	CreateChannelBookmarkWithResponse(ctx context.Context, channelId string, body CreateChannelBookmarkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateChannelBookmarkResponse, error)

	// DeleteChannelBookmarkWithResponse request
	DeleteChannelBookmarkWithResponse(ctx context.Context, channelId string, bookmarkId string, reqEditors ...RequestEditorFn) (*DeleteChannelBookmarkResponse, error)

	// UpdateChannelBookmarkWithBodyWithResponse request with any body
	UpdateChannelBookmarkWithBodyWithResponse(ctx context.Context, channelId string, bookmarkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelBookmarkResponse, error)

	UpdateChannelBookmarkWithResponse(ctx context.Context, channelId string, bookmarkId string, body UpdateChannelBookmarkJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelBookmarkResponse, error)

	// UpdateChannelBookmarkSortOrderWithBodyWithResponse request with any body
	UpdateChannelBookmarkSortOrderWithBodyWithResponse(ctx context.Context, channelId string, bookmarkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelBookmarkSortOrderResponse, error)

	UpdateChannelBookmarkSortOrderWithResponse(ctx context.Context, channelId string, bookmarkId string, body UpdateChannelBookmarkSortOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelBookmarkSortOrderResponse, error)

	// GetGroupsByChannelWithResponse request
	GetGroupsByChannelWithResponse(ctx context.Context, channelId string, params *GetGroupsByChannelParams, reqEditors ...RequestEditorFn) (*GetGroupsByChannelResponse, error)

	// GetChannelMemberCountsByGroupWithResponse request
	GetChannelMemberCountsByGroupWithResponse(ctx context.Context, channelId string, params *GetChannelMemberCountsByGroupParams, reqEditors ...RequestEditorFn) (*GetChannelMemberCountsByGroupResponse, error)

	// GetChannelMembersWithResponse request
	GetChannelMembersWithResponse(ctx context.Context, channelId string, params *GetChannelMembersParams, reqEditors ...RequestEditorFn) (*GetChannelMembersResponse, error)

	// AddChannelMemberWithBodyWithResponse request with any body
	AddChannelMemberWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddChannelMemberResponse, error)

	AddChannelMemberWithResponse(ctx context.Context, channelId string, body AddChannelMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*AddChannelMemberResponse, error)

	// GetChannelMembersByIdsWithBodyWithResponse request with any body
	GetChannelMembersByIdsWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetChannelMembersByIdsResponse, error)

	GetChannelMembersByIdsWithResponse(ctx context.Context, channelId string, body GetChannelMembersByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetChannelMembersByIdsResponse, error)

	// RemoveUserFromChannelWithResponse request
	RemoveUserFromChannelWithResponse(ctx context.Context, channelId string, userId string, reqEditors ...RequestEditorFn) (*RemoveUserFromChannelResponse, error)

	// GetChannelMemberWithResponse request
	GetChannelMemberWithResponse(ctx context.Context, channelId string, userId string, reqEditors ...RequestEditorFn) (*GetChannelMemberResponse, error)

	// UpdateChannelNotifyPropsWithBodyWithResponse request with any body
	UpdateChannelNotifyPropsWithBodyWithResponse(ctx context.Context, channelId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelNotifyPropsResponse, error)

	UpdateChannelNotifyPropsWithResponse(ctx context.Context, channelId string, userId string, body UpdateChannelNotifyPropsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelNotifyPropsResponse, error)

	// UpdateChannelRolesWithBodyWithResponse request with any body
	UpdateChannelRolesWithBodyWithResponse(ctx context.Context, channelId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelRolesResponse, error)

	UpdateChannelRolesWithResponse(ctx context.Context, channelId string, userId string, body UpdateChannelRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelRolesResponse, error)

	// UpdateChannelMemberSchemeRolesWithBodyWithResponse request with any body
	UpdateChannelMemberSchemeRolesWithBodyWithResponse(ctx context.Context, channelId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelMemberSchemeRolesResponse, error)

	UpdateChannelMemberSchemeRolesWithResponse(ctx context.Context, channelId string, userId string, body UpdateChannelMemberSchemeRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelMemberSchemeRolesResponse, error)

	// ChannelMembersMinusGroupMembersWithResponse request
	ChannelMembersMinusGroupMembersWithResponse(ctx context.Context, channelId string, params *ChannelMembersMinusGroupMembersParams, reqEditors ...RequestEditorFn) (*ChannelMembersMinusGroupMembersResponse, error)

	// GetChannelModerationsWithResponse request
	GetChannelModerationsWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetChannelModerationsResponse, error)

	// PatchChannelModerationsWithBodyWithResponse request with any body
	PatchChannelModerationsWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchChannelModerationsResponse, error)

	PatchChannelModerationsWithResponse(ctx context.Context, channelId string, body PatchChannelModerationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchChannelModerationsResponse, error)

	// MoveChannelWithBodyWithResponse request with any body
	MoveChannelWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveChannelResponse, error)

	MoveChannelWithResponse(ctx context.Context, channelId string, body MoveChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveChannelResponse, error)

	// PatchChannelWithBodyWithResponse request with any body
	PatchChannelWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchChannelResponse, error)

	PatchChannelWithResponse(ctx context.Context, channelId string, body PatchChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchChannelResponse, error)

	// GetPinnedPostsWithResponse request
	GetPinnedPostsWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetPinnedPostsResponse, error)

	// GetPostsForChannelWithResponse request
	GetPostsForChannelWithResponse(ctx context.Context, channelId string, params *GetPostsForChannelParams, reqEditors ...RequestEditorFn) (*GetPostsForChannelResponse, error)

	// UpdateChannelPrivacyWithBodyWithResponse request with any body
	UpdateChannelPrivacyWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelPrivacyResponse, error)

	UpdateChannelPrivacyWithResponse(ctx context.Context, channelId string, body UpdateChannelPrivacyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelPrivacyResponse, error)

	// RestoreChannelWithResponse request
	RestoreChannelWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*RestoreChannelResponse, error)

	// UpdateChannelSchemeWithBodyWithResponse request with any body
	UpdateChannelSchemeWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelSchemeResponse, error)

	UpdateChannelSchemeWithResponse(ctx context.Context, channelId string, body UpdateChannelSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelSchemeResponse, error)

	// GetChannelStatsWithResponse request
	GetChannelStatsWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetChannelStatsResponse, error)

	// GetChannelMembersTimezonesWithResponse request
	GetChannelMembersTimezonesWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetChannelMembersTimezonesResponse, error)

	// SubmitPerformanceReportWithBodyWithResponse request with any body
	SubmitPerformanceReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitPerformanceReportResponse, error)

	SubmitPerformanceReportWithResponse(ctx context.Context, body SubmitPerformanceReportJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitPerformanceReportResponse, error)

	// GetCloudCustomerWithResponse request
	GetCloudCustomerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCloudCustomerResponse, error)

	// UpdateCloudCustomerWithBodyWithResponse request with any body
	UpdateCloudCustomerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCloudCustomerResponse, error)

	UpdateCloudCustomerWithResponse(ctx context.Context, body UpdateCloudCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCloudCustomerResponse, error)

	// UpdateCloudCustomerAddressWithBodyWithResponse request with any body
	UpdateCloudCustomerAddressWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCloudCustomerAddressResponse, error)

	UpdateCloudCustomerAddressWithResponse(ctx context.Context, body UpdateCloudCustomerAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCloudCustomerAddressResponse, error)

	// GetEndpointForInstallationInformationWithResponse request
	GetEndpointForInstallationInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEndpointForInstallationInformationResponse, error)

	// GetCloudLimitsWithResponse request
	GetCloudLimitsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCloudLimitsResponse, error)

	// CreateCustomerPaymentWithResponse request
	CreateCustomerPaymentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateCustomerPaymentResponse, error)

	// ConfirmCustomerPaymentWithBodyWithResponse request with any body
	ConfirmCustomerPaymentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmCustomerPaymentResponse, error)

	// GetCloudProductsWithResponse request
	GetCloudProductsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCloudProductsResponse, error)

	// GetSubscriptionWithResponse request
	GetSubscriptionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSubscriptionResponse, error)

	// GetInvoicesForSubscriptionWithResponse request
	GetInvoicesForSubscriptionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInvoicesForSubscriptionResponse, error)

	// GetInvoiceForSubscriptionAsPdfWithResponse request
	GetInvoiceForSubscriptionAsPdfWithResponse(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*GetInvoiceForSubscriptionAsPdfResponse, error)

	// PostEndpointForCwsWebhooksWithResponse request
	PostEndpointForCwsWebhooksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostEndpointForCwsWebhooksResponse, error)

	// GetClusterStatusWithResponse request
	GetClusterStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterStatusResponse, error)

	// ListCommandsWithResponse request
	ListCommandsWithResponse(ctx context.Context, params *ListCommandsParams, reqEditors ...RequestEditorFn) (*ListCommandsResponse, error)

	// CreateCommandWithBodyWithResponse request with any body
	CreateCommandWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommandResponse, error)

	CreateCommandWithResponse(ctx context.Context, body CreateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommandResponse, error)

	// ExecuteCommandWithBodyWithResponse request with any body
	ExecuteCommandWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteCommandResponse, error)

	ExecuteCommandWithResponse(ctx context.Context, body ExecuteCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteCommandResponse, error)

	// DeleteCommandWithResponse request
	DeleteCommandWithResponse(ctx context.Context, commandId string, reqEditors ...RequestEditorFn) (*DeleteCommandResponse, error)

	// GetCommandByIdWithResponse request
	GetCommandByIdWithResponse(ctx context.Context, commandId string, reqEditors ...RequestEditorFn) (*GetCommandByIdResponse, error)

	// UpdateCommandWithBodyWithResponse request with any body
	UpdateCommandWithBodyWithResponse(ctx context.Context, commandId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCommandResponse, error)

	UpdateCommandWithResponse(ctx context.Context, commandId string, body UpdateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCommandResponse, error)

	// MoveCommandWithBodyWithResponse request with any body
	MoveCommandWithBodyWithResponse(ctx context.Context, commandId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveCommandResponse, error)

	MoveCommandWithResponse(ctx context.Context, commandId string, body MoveCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveCommandResponse, error)

	// RegenCommandTokenWithResponse request
	RegenCommandTokenWithResponse(ctx context.Context, commandId string, reqEditors ...RequestEditorFn) (*RegenCommandTokenResponse, error)

	// GetComplianceReportsWithResponse request
	GetComplianceReportsWithResponse(ctx context.Context, params *GetComplianceReportsParams, reqEditors ...RequestEditorFn) (*GetComplianceReportsResponse, error)

	// CreateComplianceReportWithResponse request
	CreateComplianceReportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateComplianceReportResponse, error)

	// GetComplianceReportWithResponse request
	GetComplianceReportWithResponse(ctx context.Context, reportId string, reqEditors ...RequestEditorFn) (*GetComplianceReportResponse, error)

	// DownloadComplianceReportWithResponse request
	DownloadComplianceReportWithResponse(ctx context.Context, reportId string, reqEditors ...RequestEditorFn) (*DownloadComplianceReportResponse, error)

	// GetConfigWithResponse request
	GetConfigWithResponse(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// UpdateConfigWithBodyWithResponse request with any body
	UpdateConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	UpdateConfigWithResponse(ctx context.Context, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	// GetClientConfigWithResponse request
	GetClientConfigWithResponse(ctx context.Context, params *GetClientConfigParams, reqEditors ...RequestEditorFn) (*GetClientConfigResponse, error)

	// GetEnvironmentConfigWithResponse request
	GetEnvironmentConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEnvironmentConfigResponse, error)

	// PatchConfigWithBodyWithResponse request with any body
	PatchConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchConfigResponse, error)

	PatchConfigWithResponse(ctx context.Context, body PatchConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchConfigResponse, error)

	// ReloadConfigWithResponse request
	ReloadConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReloadConfigResponse, error)

	// GetDataRetentionPoliciesWithResponse request
	GetDataRetentionPoliciesWithResponse(ctx context.Context, params *GetDataRetentionPoliciesParams, reqEditors ...RequestEditorFn) (*GetDataRetentionPoliciesResponse, error)

	// CreateDataRetentionPolicyWithBodyWithResponse request with any body
	CreateDataRetentionPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDataRetentionPolicyResponse, error)

	CreateDataRetentionPolicyWithResponse(ctx context.Context, body CreateDataRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDataRetentionPolicyResponse, error)

	// DeleteDataRetentionPolicyWithResponse request
	DeleteDataRetentionPolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*DeleteDataRetentionPolicyResponse, error)

	// GetDataRetentionPolicyByIDWithResponse request
	GetDataRetentionPolicyByIDWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetDataRetentionPolicyByIDResponse, error)

	// PatchDataRetentionPolicyWithBodyWithResponse request with any body
	PatchDataRetentionPolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchDataRetentionPolicyResponse, error)

	PatchDataRetentionPolicyWithResponse(ctx context.Context, policyId string, body PatchDataRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchDataRetentionPolicyResponse, error)

	// RemoveChannelsFromRetentionPolicyWithBodyWithResponse request with any body
	RemoveChannelsFromRetentionPolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveChannelsFromRetentionPolicyResponse, error)

	RemoveChannelsFromRetentionPolicyWithResponse(ctx context.Context, policyId string, body RemoveChannelsFromRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveChannelsFromRetentionPolicyResponse, error)

	// GetChannelsForRetentionPolicyWithResponse request
	GetChannelsForRetentionPolicyWithResponse(ctx context.Context, policyId string, params *GetChannelsForRetentionPolicyParams, reqEditors ...RequestEditorFn) (*GetChannelsForRetentionPolicyResponse, error)

	// AddChannelsToRetentionPolicyWithBodyWithResponse request with any body
	AddChannelsToRetentionPolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddChannelsToRetentionPolicyResponse, error)

	AddChannelsToRetentionPolicyWithResponse(ctx context.Context, policyId string, body AddChannelsToRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddChannelsToRetentionPolicyResponse, error)

	// SearchChannelsForRetentionPolicyWithBodyWithResponse request with any body
	SearchChannelsForRetentionPolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchChannelsForRetentionPolicyResponse, error)

	SearchChannelsForRetentionPolicyWithResponse(ctx context.Context, policyId string, body SearchChannelsForRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchChannelsForRetentionPolicyResponse, error)

	// RemoveTeamsFromRetentionPolicyWithBodyWithResponse request with any body
	RemoveTeamsFromRetentionPolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTeamsFromRetentionPolicyResponse, error)

	RemoveTeamsFromRetentionPolicyWithResponse(ctx context.Context, policyId string, body RemoveTeamsFromRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTeamsFromRetentionPolicyResponse, error)

	// GetTeamsForRetentionPolicyWithResponse request
	GetTeamsForRetentionPolicyWithResponse(ctx context.Context, policyId string, params *GetTeamsForRetentionPolicyParams, reqEditors ...RequestEditorFn) (*GetTeamsForRetentionPolicyResponse, error)

	// AddTeamsToRetentionPolicyWithBodyWithResponse request with any body
	AddTeamsToRetentionPolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTeamsToRetentionPolicyResponse, error)

	AddTeamsToRetentionPolicyWithResponse(ctx context.Context, policyId string, body AddTeamsToRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTeamsToRetentionPolicyResponse, error)

	// SearchTeamsForRetentionPolicyWithBodyWithResponse request with any body
	SearchTeamsForRetentionPolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchTeamsForRetentionPolicyResponse, error)

	SearchTeamsForRetentionPolicyWithResponse(ctx context.Context, policyId string, body SearchTeamsForRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchTeamsForRetentionPolicyResponse, error)

	// GetDataRetentionPoliciesCountWithResponse request
	GetDataRetentionPoliciesCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDataRetentionPoliciesCountResponse, error)

	// GetDataRetentionPolicyWithResponse request
	GetDataRetentionPolicyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDataRetentionPolicyResponse, error)

	// DatabaseRecycleWithResponse request
	DatabaseRecycleWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DatabaseRecycleResponse, error)

	// PurgeElasticsearchIndexesWithResponse request
	PurgeElasticsearchIndexesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PurgeElasticsearchIndexesResponse, error)

	// TestElasticsearchWithResponse request
	TestElasticsearchWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TestElasticsearchResponse, error)

	// TestEmailWithBodyWithResponse request with any body
	TestEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestEmailResponse, error)

	TestEmailWithResponse(ctx context.Context, body TestEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*TestEmailResponse, error)

	// GetEmojiListWithResponse request
	GetEmojiListWithResponse(ctx context.Context, params *GetEmojiListParams, reqEditors ...RequestEditorFn) (*GetEmojiListResponse, error)

	// CreateEmojiWithBodyWithResponse request with any body
	CreateEmojiWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEmojiResponse, error)

	// AutocompleteEmojiWithResponse request
	AutocompleteEmojiWithResponse(ctx context.Context, params *AutocompleteEmojiParams, reqEditors ...RequestEditorFn) (*AutocompleteEmojiResponse, error)

	// GetEmojiByNameWithResponse request
	GetEmojiByNameWithResponse(ctx context.Context, emojiName string, reqEditors ...RequestEditorFn) (*GetEmojiByNameResponse, error)

	// GetEmojisByNamesWithBodyWithResponse request with any body
	GetEmojisByNamesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetEmojisByNamesResponse, error)

	GetEmojisByNamesWithResponse(ctx context.Context, body GetEmojisByNamesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetEmojisByNamesResponse, error)

	// SearchEmojiWithBodyWithResponse request with any body
	SearchEmojiWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchEmojiResponse, error)

	SearchEmojiWithResponse(ctx context.Context, body SearchEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchEmojiResponse, error)

	// DeleteEmojiWithResponse request
	DeleteEmojiWithResponse(ctx context.Context, emojiId string, reqEditors ...RequestEditorFn) (*DeleteEmojiResponse, error)

	// GetEmojiWithResponse request
	GetEmojiWithResponse(ctx context.Context, emojiId string, reqEditors ...RequestEditorFn) (*GetEmojiResponse, error)

	// GetEmojiImageWithResponse request
	GetEmojiImageWithResponse(ctx context.Context, emojiId string, reqEditors ...RequestEditorFn) (*GetEmojiImageResponse, error)

	// ListExportsWithResponse request
	ListExportsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListExportsResponse, error)

	// DeleteExportWithResponse request
	DeleteExportWithResponse(ctx context.Context, exportName string, reqEditors ...RequestEditorFn) (*DeleteExportResponse, error)

	// DownloadExportWithResponse request
	DownloadExportWithResponse(ctx context.Context, exportName string, reqEditors ...RequestEditorFn) (*DownloadExportResponse, error)

	// TestS3ConnectionWithBodyWithResponse request with any body
	TestS3ConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestS3ConnectionResponse, error)

	TestS3ConnectionWithResponse(ctx context.Context, body TestS3ConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestS3ConnectionResponse, error)

	// UploadFileWithBodyWithResponse request with any body
	UploadFileWithBodyWithResponse(ctx context.Context, params *UploadFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileResponse, error)

	// SearchFilesWithBodyWithResponse request with any body
	SearchFilesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchFilesResponse, error)

	// GetFileWithResponse request
	GetFileWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*GetFileResponse, error)

	// GetFileInfoWithResponse request
	GetFileInfoWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*GetFileInfoResponse, error)

	// GetFileLinkWithResponse request
	GetFileLinkWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*GetFileLinkResponse, error)

	// GetFilePreviewWithResponse request
	GetFilePreviewWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*GetFilePreviewResponse, error)

	// GetFileThumbnailWithResponse request
	GetFileThumbnailWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*GetFileThumbnailResponse, error)

	// GetGroupsWithResponse request
	GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error)

	// CreateGroupWithBodyWithResponse request with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroupWithResponse request
	DeleteGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroupWithResponse request
	GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// GetGroupSyncablesChannelsWithResponse request
	GetGroupSyncablesChannelsWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupSyncablesChannelsResponse, error)

	// GetGroupSyncableForChannelIdWithResponse request
	GetGroupSyncableForChannelIdWithResponse(ctx context.Context, groupId string, channelId string, reqEditors ...RequestEditorFn) (*GetGroupSyncableForChannelIdResponse, error)

	// UnlinkGroupSyncableForChannelWithResponse request
	UnlinkGroupSyncableForChannelWithResponse(ctx context.Context, groupId string, channelId string, reqEditors ...RequestEditorFn) (*UnlinkGroupSyncableForChannelResponse, error)

	// LinkGroupSyncableForChannelWithResponse request
	LinkGroupSyncableForChannelWithResponse(ctx context.Context, groupId string, channelId string, reqEditors ...RequestEditorFn) (*LinkGroupSyncableForChannelResponse, error)

	// PatchGroupSyncableForChannelWithBodyWithResponse request with any body
	PatchGroupSyncableForChannelWithBodyWithResponse(ctx context.Context, groupId string, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchGroupSyncableForChannelResponse, error)

	PatchGroupSyncableForChannelWithResponse(ctx context.Context, groupId string, channelId string, body PatchGroupSyncableForChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchGroupSyncableForChannelResponse, error)

	// DeleteGroupMembersWithBodyWithResponse request with any body
	DeleteGroupMembersWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGroupMembersResponse, error)

	DeleteGroupMembersWithResponse(ctx context.Context, groupId string, body DeleteGroupMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGroupMembersResponse, error)

	// GetGroupUsersWithResponse request
	GetGroupUsersWithResponse(ctx context.Context, groupId string, params *GetGroupUsersParams, reqEditors ...RequestEditorFn) (*GetGroupUsersResponse, error)

	// AddGroupMembersWithBodyWithResponse request with any body
	AddGroupMembersWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddGroupMembersResponse, error)

	AddGroupMembersWithResponse(ctx context.Context, groupId string, body AddGroupMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*AddGroupMembersResponse, error)

	// PatchGroupWithBodyWithResponse request with any body
	PatchGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchGroupResponse, error)

	PatchGroupWithResponse(ctx context.Context, groupId string, body PatchGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchGroupResponse, error)

	// RestoreGroupWithResponse request
	RestoreGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*RestoreGroupResponse, error)

	// GetGroupStatsWithResponse request
	GetGroupStatsWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupStatsResponse, error)

	// GetGroupSyncablesTeamsWithResponse request
	GetGroupSyncablesTeamsWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupSyncablesTeamsResponse, error)

	// GetGroupSyncableForTeamIdWithResponse request
	GetGroupSyncableForTeamIdWithResponse(ctx context.Context, groupId string, teamId string, reqEditors ...RequestEditorFn) (*GetGroupSyncableForTeamIdResponse, error)

	// UnlinkGroupSyncableForTeamWithResponse request
	UnlinkGroupSyncableForTeamWithResponse(ctx context.Context, groupId string, teamId string, reqEditors ...RequestEditorFn) (*UnlinkGroupSyncableForTeamResponse, error)

	// LinkGroupSyncableForTeamWithResponse request
	LinkGroupSyncableForTeamWithResponse(ctx context.Context, groupId string, teamId string, reqEditors ...RequestEditorFn) (*LinkGroupSyncableForTeamResponse, error)

	// PatchGroupSyncableForTeamWithBodyWithResponse request with any body
	PatchGroupSyncableForTeamWithBodyWithResponse(ctx context.Context, groupId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchGroupSyncableForTeamResponse, error)

	PatchGroupSyncableForTeamWithResponse(ctx context.Context, groupId string, teamId string, body PatchGroupSyncableForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchGroupSyncableForTeamResponse, error)

	// GetIncomingWebhooksWithResponse request
	GetIncomingWebhooksWithResponse(ctx context.Context, params *GetIncomingWebhooksParams, reqEditors ...RequestEditorFn) (*GetIncomingWebhooksResponse, error)

	// CreateIncomingWebhookWithBodyWithResponse request with any body
	CreateIncomingWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIncomingWebhookResponse, error)

	CreateIncomingWebhookWithResponse(ctx context.Context, body CreateIncomingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIncomingWebhookResponse, error)

	// DeleteIncomingWebhookWithResponse request
	DeleteIncomingWebhookWithResponse(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*DeleteIncomingWebhookResponse, error)

	// GetIncomingWebhookWithResponse request
	GetIncomingWebhookWithResponse(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*GetIncomingWebhookResponse, error)

	// UpdateIncomingWebhookWithBodyWithResponse request with any body
	UpdateIncomingWebhookWithBodyWithResponse(ctx context.Context, hookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIncomingWebhookResponse, error)

	UpdateIncomingWebhookWithResponse(ctx context.Context, hookId string, body UpdateIncomingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIncomingWebhookResponse, error)

	// GetOutgoingWebhooksWithResponse request
	GetOutgoingWebhooksWithResponse(ctx context.Context, params *GetOutgoingWebhooksParams, reqEditors ...RequestEditorFn) (*GetOutgoingWebhooksResponse, error)

	// CreateOutgoingWebhookWithBodyWithResponse request with any body
	CreateOutgoingWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOutgoingWebhookResponse, error)

	CreateOutgoingWebhookWithResponse(ctx context.Context, body CreateOutgoingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOutgoingWebhookResponse, error)

	// DeleteOutgoingWebhookWithResponse request
	DeleteOutgoingWebhookWithResponse(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*DeleteOutgoingWebhookResponse, error)

	// GetOutgoingWebhookWithResponse request
	GetOutgoingWebhookWithResponse(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*GetOutgoingWebhookResponse, error)

	// UpdateOutgoingWebhookWithBodyWithResponse request with any body
	UpdateOutgoingWebhookWithBodyWithResponse(ctx context.Context, hookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOutgoingWebhookResponse, error)

	UpdateOutgoingWebhookWithResponse(ctx context.Context, hookId string, body UpdateOutgoingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOutgoingWebhookResponse, error)

	// RegenOutgoingHookTokenWithResponse request
	RegenOutgoingHookTokenWithResponse(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*RegenOutgoingHookTokenResponse, error)

	// GetImageByUrlWithResponse request
	GetImageByUrlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetImageByUrlResponse, error)

	// ListImportsWithResponse request
	ListImportsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListImportsResponse, error)

	// CheckIntegrityWithResponse request
	CheckIntegrityWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CheckIntegrityResponse, error)

	// GetIPFiltersWithResponse request
	GetIPFiltersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetIPFiltersResponse, error)

	// ApplyIPFiltersWithBodyWithResponse request with any body
	ApplyIPFiltersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplyIPFiltersResponse, error)

	ApplyIPFiltersWithResponse(ctx context.Context, body ApplyIPFiltersJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplyIPFiltersResponse, error)

	// MyIPWithResponse request
	MyIPWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MyIPResponse, error)

	// GetJobsWithResponse request
	GetJobsWithResponse(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*GetJobsResponse, error)

	// CreateJobWithBodyWithResponse request with any body
	CreateJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobResponse, error)

	CreateJobWithResponse(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobResponse, error)

	// GetJobsByTypeWithResponse request
	GetJobsByTypeWithResponse(ctx context.Context, pType string, params *GetJobsByTypeParams, reqEditors ...RequestEditorFn) (*GetJobsByTypeResponse, error)

	// GetJobWithResponse request
	GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetJobResponse, error)

	// CancelJobWithResponse request
	CancelJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*CancelJobResponse, error)

	// DownloadJobWithResponse request
	DownloadJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*DownloadJobResponse, error)

	// UpdateJobStatusWithBodyWithResponse request with any body
	UpdateJobStatusWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobStatusResponse, error)

	UpdateJobStatusWithResponse(ctx context.Context, jobId string, body UpdateJobStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobStatusResponse, error)

	// DeleteLdapPrivateCertificateWithResponse request
	DeleteLdapPrivateCertificateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteLdapPrivateCertificateResponse, error)

	// UploadLdapPrivateCertificateWithBodyWithResponse request with any body
	UploadLdapPrivateCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadLdapPrivateCertificateResponse, error)

	// DeleteLdapPublicCertificateWithResponse request
	DeleteLdapPublicCertificateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteLdapPublicCertificateResponse, error)

	// UploadLdapPublicCertificateWithBodyWithResponse request with any body
	UploadLdapPublicCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadLdapPublicCertificateResponse, error)

	// GetLdapGroupsWithResponse request
	GetLdapGroupsWithResponse(ctx context.Context, params *GetLdapGroupsParams, reqEditors ...RequestEditorFn) (*GetLdapGroupsResponse, error)

	// UnlinkLdapGroupWithResponse request
	UnlinkLdapGroupWithResponse(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*UnlinkLdapGroupResponse, error)

	// LinkLdapGroupWithResponse request
	LinkLdapGroupWithResponse(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*LinkLdapGroupResponse, error)

	// MigrateIdLdapWithBodyWithResponse request with any body
	MigrateIdLdapWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateIdLdapResponse, error)

	MigrateIdLdapWithResponse(ctx context.Context, body MigrateIdLdapJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateIdLdapResponse, error)

	// SyncLdapWithResponse request
	SyncLdapWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SyncLdapResponse, error)

	// TestLdapWithResponse request
	TestLdapWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TestLdapResponse, error)

	// AddUserToGroupSyncablesWithResponse request
	AddUserToGroupSyncablesWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*AddUserToGroupSyncablesResponse, error)

	// RemoveLicenseFileWithResponse request
	RemoveLicenseFileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RemoveLicenseFileResponse, error)

	// UploadLicenseFileWithBodyWithResponse request with any body
	UploadLicenseFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadLicenseFileResponse, error)

	// GetClientLicenseWithResponse request
	GetClientLicenseWithResponse(ctx context.Context, params *GetClientLicenseParams, reqEditors ...RequestEditorFn) (*GetClientLicenseResponse, error)

	// RequestLicenseRenewalLinkWithResponse request
	RequestLicenseRenewalLinkWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RequestLicenseRenewalLinkResponse, error)

	// GetServerLimitsWithResponse request
	GetServerLimitsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServerLimitsResponse, error)

	// GetLogsWithResponse request
	GetLogsWithResponse(ctx context.Context, params *GetLogsParams, reqEditors ...RequestEditorFn) (*GetLogsResponse, error)

	// PostLogWithBodyWithResponse request with any body
	PostLogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLogResponse, error)

	PostLogWithResponse(ctx context.Context, body PostLogJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLogResponse, error)

	// DownloadSystemLogsWithResponse request
	DownloadSystemLogsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DownloadSystemLogsResponse, error)

	// AcknowledgeNotificationWithResponse request
	AcknowledgeNotificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AcknowledgeNotificationResponse, error)

	// TestNotificationWithResponse request
	TestNotificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TestNotificationResponse, error)

	// GetOAuthAppsWithResponse request
	GetOAuthAppsWithResponse(ctx context.Context, params *GetOAuthAppsParams, reqEditors ...RequestEditorFn) (*GetOAuthAppsResponse, error)

	// CreateOAuthAppWithBodyWithResponse request with any body
	CreateOAuthAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOAuthAppResponse, error)

	CreateOAuthAppWithResponse(ctx context.Context, body CreateOAuthAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOAuthAppResponse, error)

	// DeleteOAuthAppWithResponse request
	DeleteOAuthAppWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*DeleteOAuthAppResponse, error)

	// GetOAuthAppWithResponse request
	GetOAuthAppWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetOAuthAppResponse, error)

	// UpdateOAuthAppWithBodyWithResponse request with any body
	UpdateOAuthAppWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOAuthAppResponse, error)

	UpdateOAuthAppWithResponse(ctx context.Context, appId string, body UpdateOAuthAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOAuthAppResponse, error)

	// GetOAuthAppInfoWithResponse request
	GetOAuthAppInfoWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetOAuthAppInfoResponse, error)

	// RegenerateOAuthAppSecretWithResponse request
	RegenerateOAuthAppSecretWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*RegenerateOAuthAppSecretResponse, error)

	// ListOutgoingOAuthConnectionsWithResponse request
	ListOutgoingOAuthConnectionsWithResponse(ctx context.Context, params *ListOutgoingOAuthConnectionsParams, reqEditors ...RequestEditorFn) (*ListOutgoingOAuthConnectionsResponse, error)

	// CreateOutgoingOAuthConnectionWithBodyWithResponse request with any body
	CreateOutgoingOAuthConnectionWithBodyWithResponse(ctx context.Context, params *CreateOutgoingOAuthConnectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOutgoingOAuthConnectionResponse, error)

	CreateOutgoingOAuthConnectionWithResponse(ctx context.Context, params *CreateOutgoingOAuthConnectionParams, body CreateOutgoingOAuthConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOutgoingOAuthConnectionResponse, error)

	// ValidateOutgoingOAuthConnectionWithBodyWithResponse request with any body
	ValidateOutgoingOAuthConnectionWithBodyWithResponse(ctx context.Context, params *ValidateOutgoingOAuthConnectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateOutgoingOAuthConnectionResponse, error)

	ValidateOutgoingOAuthConnectionWithResponse(ctx context.Context, params *ValidateOutgoingOAuthConnectionParams, body ValidateOutgoingOAuthConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateOutgoingOAuthConnectionResponse, error)

	// DeleteOutgoingOAuthConnectionWithResponse request
	DeleteOutgoingOAuthConnectionWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*DeleteOutgoingOAuthConnectionResponse, error)

	// GetOutgoingOAuthConnectionWithResponse request
	GetOutgoingOAuthConnectionWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*GetOutgoingOAuthConnectionResponse, error)

	// UpdateOutgoingOAuthConnectionWithBodyWithResponse request with any body
	UpdateOutgoingOAuthConnectionWithBodyWithResponse(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOutgoingOAuthConnectionResponse, error)

	UpdateOutgoingOAuthConnectionWithResponse(ctx context.Context, connectionId string, body UpdateOutgoingOAuthConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOutgoingOAuthConnectionResponse, error)

	// GetAncillaryPermissionsPostWithBodyWithResponse request with any body
	GetAncillaryPermissionsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetAncillaryPermissionsPostResponse, error)

	GetAncillaryPermissionsPostWithResponse(ctx context.Context, body GetAncillaryPermissionsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GetAncillaryPermissionsPostResponse, error)

	// GetPluginsWithResponse request
	GetPluginsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPluginsResponse, error)

	// UploadPluginWithBodyWithResponse request with any body
	UploadPluginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPluginResponse, error)

	// InstallPluginFromUrlWithResponse request
	InstallPluginFromUrlWithResponse(ctx context.Context, params *InstallPluginFromUrlParams, reqEditors ...RequestEditorFn) (*InstallPluginFromUrlResponse, error)

	// GetMarketplacePluginsWithResponse request
	GetMarketplacePluginsWithResponse(ctx context.Context, params *GetMarketplacePluginsParams, reqEditors ...RequestEditorFn) (*GetMarketplacePluginsResponse, error)

	// InstallMarketplacePluginWithBodyWithResponse request with any body
	InstallMarketplacePluginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallMarketplacePluginResponse, error)

	InstallMarketplacePluginWithResponse(ctx context.Context, body InstallMarketplacePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallMarketplacePluginResponse, error)

	// GetMarketplaceVisitedByAdminWithResponse request
	GetMarketplaceVisitedByAdminWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMarketplaceVisitedByAdminResponse, error)

	// UpdateMarketplaceVisitedByAdminWithBodyWithResponse request with any body
	UpdateMarketplaceVisitedByAdminWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMarketplaceVisitedByAdminResponse, error)

	UpdateMarketplaceVisitedByAdminWithResponse(ctx context.Context, body UpdateMarketplaceVisitedByAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMarketplaceVisitedByAdminResponse, error)

	// GetPluginStatusesWithResponse request
	GetPluginStatusesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPluginStatusesResponse, error)

	// GetWebappPluginsWithResponse request
	GetWebappPluginsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebappPluginsResponse, error)

	// RemovePluginWithResponse request
	RemovePluginWithResponse(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*RemovePluginResponse, error)

	// DisablePluginWithResponse request
	DisablePluginWithResponse(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*DisablePluginResponse, error)

	// EnablePluginWithResponse request
	EnablePluginWithResponse(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*EnablePluginResponse, error)

	// CreatePostWithBodyWithResponse request with any body
	CreatePostWithBodyWithResponse(ctx context.Context, params *CreatePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostResponse, error)

	CreatePostWithResponse(ctx context.Context, params *CreatePostParams, body CreatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostResponse, error)

	// CreatePostEphemeralWithBodyWithResponse request with any body
	CreatePostEphemeralWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostEphemeralResponse, error)

	CreatePostEphemeralWithResponse(ctx context.Context, body CreatePostEphemeralJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostEphemeralResponse, error)

	// GetPostsByIdsWithBodyWithResponse request with any body
	GetPostsByIdsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPostsByIdsResponse, error)

	GetPostsByIdsWithResponse(ctx context.Context, body GetPostsByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPostsByIdsResponse, error)

	// GetBulkReactionsWithBodyWithResponse request with any body
	GetBulkReactionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetBulkReactionsResponse, error)

	GetBulkReactionsWithResponse(ctx context.Context, body GetBulkReactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBulkReactionsResponse, error)

	// CreateScheduledPostWithBodyWithResponse request with any body
	CreateScheduledPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScheduledPostResponse, error)

	CreateScheduledPostWithResponse(ctx context.Context, body CreateScheduledPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScheduledPostResponse, error)

	// DeleteScheduledPostWithResponse request
	DeleteScheduledPostWithResponse(ctx context.Context, scheduledPostId string, reqEditors ...RequestEditorFn) (*DeleteScheduledPostResponse, error)

	// UpdateScheduledPostWithBodyWithResponse request with any body
	UpdateScheduledPostWithBodyWithResponse(ctx context.Context, scheduledPostId string, params *UpdateScheduledPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScheduledPostResponse, error)

	UpdateScheduledPostWithResponse(ctx context.Context, scheduledPostId string, params *UpdateScheduledPostParams, body UpdateScheduledPostJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScheduledPostResponse, error)

	// GetUserScheduledPostsWithResponse request
	GetUserScheduledPostsWithResponse(ctx context.Context, teamId string, params *GetUserScheduledPostsParams, reqEditors ...RequestEditorFn) (*GetUserScheduledPostsResponse, error)

	// DeletePostWithResponse request
	DeletePostWithResponse(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*DeletePostResponse, error)

	// GetPostWithResponse request
	GetPostWithResponse(ctx context.Context, postId string, params *GetPostParams, reqEditors ...RequestEditorFn) (*GetPostResponse, error)

	// UpdatePostWithBodyWithResponse request with any body
	UpdatePostWithBodyWithResponse(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePostResponse, error)

	UpdatePostWithResponse(ctx context.Context, postId string, body UpdatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePostResponse, error)

	// DoPostActionWithResponse request
	DoPostActionWithResponse(ctx context.Context, postId string, actionId string, reqEditors ...RequestEditorFn) (*DoPostActionResponse, error)

	// GetFileInfosForPostWithResponse request
	GetFileInfosForPostWithResponse(ctx context.Context, postId string, params *GetFileInfosForPostParams, reqEditors ...RequestEditorFn) (*GetFileInfosForPostResponse, error)

	// MoveThreadWithBodyWithResponse request with any body
	MoveThreadWithBodyWithResponse(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveThreadResponse, error)

	MoveThreadWithResponse(ctx context.Context, postId string, body MoveThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveThreadResponse, error)

	// PatchPostWithBodyWithResponse request with any body
	PatchPostWithBodyWithResponse(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPostResponse, error)

	PatchPostWithResponse(ctx context.Context, postId string, body PatchPostJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPostResponse, error)

	// PinPostWithResponse request
	PinPostWithResponse(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*PinPostResponse, error)

	// GetReactionsWithResponse request
	GetReactionsWithResponse(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*GetReactionsResponse, error)

	// GetPostThreadWithResponse request
	GetPostThreadWithResponse(ctx context.Context, postId string, params *GetPostThreadParams, reqEditors ...RequestEditorFn) (*GetPostThreadResponse, error)

	// UnpinPostWithResponse request
	UnpinPostWithResponse(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*UnpinPostResponse, error)

	// SaveReactionWithBodyWithResponse request with any body
	SaveReactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveReactionResponse, error)

	SaveReactionWithResponse(ctx context.Context, body SaveReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveReactionResponse, error)

	// GetRedirectLocationWithResponse request
	GetRedirectLocationWithResponse(ctx context.Context, params *GetRedirectLocationParams, reqEditors ...RequestEditorFn) (*GetRedirectLocationResponse, error)

	// GetRemoteClustersWithResponse request
	GetRemoteClustersWithResponse(ctx context.Context, params *GetRemoteClustersParams, reqEditors ...RequestEditorFn) (*GetRemoteClustersResponse, error)

	// CreateRemoteClusterWithBodyWithResponse request with any body
	CreateRemoteClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRemoteClusterResponse, error)

	CreateRemoteClusterWithResponse(ctx context.Context, body CreateRemoteClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRemoteClusterResponse, error)

	// AcceptRemoteClusterInviteWithBodyWithResponse request with any body
	AcceptRemoteClusterInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptRemoteClusterInviteResponse, error)

	AcceptRemoteClusterInviteWithResponse(ctx context.Context, body AcceptRemoteClusterInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptRemoteClusterInviteResponse, error)

	// DeleteRemoteClusterWithResponse request
	DeleteRemoteClusterWithResponse(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*DeleteRemoteClusterResponse, error)

	// GetRemoteClusterWithResponse request
	GetRemoteClusterWithResponse(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*GetRemoteClusterResponse, error)

	// PatchRemoteClusterWithBodyWithResponse request with any body
	PatchRemoteClusterWithBodyWithResponse(ctx context.Context, remoteId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRemoteClusterResponse, error)

	PatchRemoteClusterWithResponse(ctx context.Context, remoteId string, body PatchRemoteClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRemoteClusterResponse, error)

	// InviteRemoteClusterToChannelWithResponse request
	InviteRemoteClusterToChannelWithResponse(ctx context.Context, remoteId string, channelId string, reqEditors ...RequestEditorFn) (*InviteRemoteClusterToChannelResponse, error)

	// UninviteRemoteClusterToChannelWithResponse request
	UninviteRemoteClusterToChannelWithResponse(ctx context.Context, remoteId string, channelId string, reqEditors ...RequestEditorFn) (*UninviteRemoteClusterToChannelResponse, error)

	// GetSharedChannelRemotesByRemoteClusterWithResponse request
	GetSharedChannelRemotesByRemoteClusterWithResponse(ctx context.Context, remoteId string, params *GetSharedChannelRemotesByRemoteClusterParams, reqEditors ...RequestEditorFn) (*GetSharedChannelRemotesByRemoteClusterResponse, error)

	// GetUsersForReportingWithResponse request
	GetUsersForReportingWithResponse(ctx context.Context, params *GetUsersForReportingParams, reqEditors ...RequestEditorFn) (*GetUsersForReportingResponse, error)

	// GetUserCountForReportingWithResponse request
	GetUserCountForReportingWithResponse(ctx context.Context, params *GetUserCountForReportingParams, reqEditors ...RequestEditorFn) (*GetUserCountForReportingResponse, error)

	// StartBatchUsersExportWithResponse request
	StartBatchUsersExportWithResponse(ctx context.Context, params *StartBatchUsersExportParams, reqEditors ...RequestEditorFn) (*StartBatchUsersExportResponse, error)

	// RestartServerWithResponse request
	RestartServerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RestartServerResponse, error)

	// GetAllRolesWithResponse request
	GetAllRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllRolesResponse, error)

	// GetRoleByNameWithResponse request
	GetRoleByNameWithResponse(ctx context.Context, roleName string, reqEditors ...RequestEditorFn) (*GetRoleByNameResponse, error)

	// GetRolesByNamesWithBodyWithResponse request with any body
	GetRolesByNamesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetRolesByNamesResponse, error)

	GetRolesByNamesWithResponse(ctx context.Context, body GetRolesByNamesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetRolesByNamesResponse, error)

	// GetRoleWithResponse request
	GetRoleWithResponse(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error)

	// PatchRoleWithBodyWithResponse request with any body
	PatchRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRoleResponse, error)

	PatchRoleWithResponse(ctx context.Context, roleId string, body PatchRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRoleResponse, error)

	// DeleteSamlIdpCertificateWithResponse request
	DeleteSamlIdpCertificateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteSamlIdpCertificateResponse, error)

	// UploadSamlIdpCertificateWithBodyWithResponse request with any body
	UploadSamlIdpCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadSamlIdpCertificateResponse, error)

	// DeleteSamlPrivateCertificateWithResponse request
	DeleteSamlPrivateCertificateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteSamlPrivateCertificateResponse, error)

	// UploadSamlPrivateCertificateWithBodyWithResponse request with any body
	UploadSamlPrivateCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadSamlPrivateCertificateResponse, error)

	// DeleteSamlPublicCertificateWithResponse request
	DeleteSamlPublicCertificateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteSamlPublicCertificateResponse, error)

	// UploadSamlPublicCertificateWithBodyWithResponse request with any body
	UploadSamlPublicCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadSamlPublicCertificateResponse, error)

	// GetSamlCertificateStatusWithResponse request
	GetSamlCertificateStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSamlCertificateStatusResponse, error)

	// GetSamlMetadataWithResponse request
	GetSamlMetadataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSamlMetadataResponse, error)

	// GetSamlMetadataFromIdpWithBodyWithResponse request with any body
	GetSamlMetadataFromIdpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetSamlMetadataFromIdpResponse, error)

	GetSamlMetadataFromIdpWithResponse(ctx context.Context, body GetSamlMetadataFromIdpJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSamlMetadataFromIdpResponse, error)

	// ResetSamlAuthDataToEmailWithBodyWithResponse request with any body
	ResetSamlAuthDataToEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetSamlAuthDataToEmailResponse, error)

	ResetSamlAuthDataToEmailWithResponse(ctx context.Context, body ResetSamlAuthDataToEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetSamlAuthDataToEmailResponse, error)

	// GetSchemesWithResponse request
	GetSchemesWithResponse(ctx context.Context, params *GetSchemesParams, reqEditors ...RequestEditorFn) (*GetSchemesResponse, error)

	// CreateSchemeWithBodyWithResponse request with any body
	CreateSchemeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSchemeResponse, error)

	CreateSchemeWithResponse(ctx context.Context, body CreateSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSchemeResponse, error)

	// DeleteSchemeWithResponse request
	DeleteSchemeWithResponse(ctx context.Context, schemeId string, reqEditors ...RequestEditorFn) (*DeleteSchemeResponse, error)

	// GetSchemeWithResponse request
	GetSchemeWithResponse(ctx context.Context, schemeId string, reqEditors ...RequestEditorFn) (*GetSchemeResponse, error)

	// GetChannelsForSchemeWithResponse request
	GetChannelsForSchemeWithResponse(ctx context.Context, schemeId string, params *GetChannelsForSchemeParams, reqEditors ...RequestEditorFn) (*GetChannelsForSchemeResponse, error)

	// PatchSchemeWithBodyWithResponse request with any body
	PatchSchemeWithBodyWithResponse(ctx context.Context, schemeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSchemeResponse, error)

	PatchSchemeWithResponse(ctx context.Context, schemeId string, body PatchSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSchemeResponse, error)

	// GetTeamsForSchemeWithResponse request
	GetTeamsForSchemeWithResponse(ctx context.Context, schemeId string, params *GetTeamsForSchemeParams, reqEditors ...RequestEditorFn) (*GetTeamsForSchemeResponse, error)

	// ClearServerBusyWithResponse request
	ClearServerBusyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClearServerBusyResponse, error)

	// GetServerBusyExpiresWithResponse request
	GetServerBusyExpiresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServerBusyExpiresResponse, error)

	// SetServerBusyWithResponse request
	SetServerBusyWithResponse(ctx context.Context, params *SetServerBusyParams, reqEditors ...RequestEditorFn) (*SetServerBusyResponse, error)

	// GetRemoteClusterInfoWithResponse request
	GetRemoteClusterInfoWithResponse(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*GetRemoteClusterInfoResponse, error)

	// GetAllSharedChannelsWithResponse request
	GetAllSharedChannelsWithResponse(ctx context.Context, teamId string, params *GetAllSharedChannelsParams, reqEditors ...RequestEditorFn) (*GetAllSharedChannelsResponse, error)

	// TestSiteURLWithBodyWithResponse request with any body
	TestSiteURLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestSiteURLResponse, error)

	TestSiteURLWithResponse(ctx context.Context, body TestSiteURLJSONRequestBody, reqEditors ...RequestEditorFn) (*TestSiteURLResponse, error)

	// MarkNoticesViewedWithBodyWithResponse request with any body
	MarkNoticesViewedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkNoticesViewedResponse, error)

	MarkNoticesViewedWithResponse(ctx context.Context, body MarkNoticesViewedJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkNoticesViewedResponse, error)

	// GetNoticesWithResponse request
	GetNoticesWithResponse(ctx context.Context, teamId string, params *GetNoticesParams, reqEditors ...RequestEditorFn) (*GetNoticesResponse, error)

	// GetPingWithResponse request
	GetPingWithResponse(ctx context.Context, params *GetPingParams, reqEditors ...RequestEditorFn) (*GetPingResponse, error)

	// GenerateSupportPacketWithResponse request
	GenerateSupportPacketWithResponse(ctx context.Context, params *GenerateSupportPacketParams, reqEditors ...RequestEditorFn) (*GenerateSupportPacketResponse, error)

	// GetSupportedTimezoneWithResponse request
	GetSupportedTimezoneWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSupportedTimezoneResponse, error)

	// GetAllTeamsWithResponse request
	GetAllTeamsWithResponse(ctx context.Context, params *GetAllTeamsParams, reqEditors ...RequestEditorFn) (*GetAllTeamsResponse, error)

	// CreateTeamWithBodyWithResponse request with any body
	CreateTeamWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error)

	CreateTeamWithResponse(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error)

	// GetTeamInviteInfoWithResponse request
	GetTeamInviteInfoWithResponse(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*GetTeamInviteInfoResponse, error)

	// InvalidateEmailInvitesWithResponse request
	InvalidateEmailInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InvalidateEmailInvitesResponse, error)

	// AddTeamMemberFromInviteWithResponse request
	AddTeamMemberFromInviteWithResponse(ctx context.Context, params *AddTeamMemberFromInviteParams, reqEditors ...RequestEditorFn) (*AddTeamMemberFromInviteResponse, error)

	// GetTeamByNameWithResponse request
	GetTeamByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetTeamByNameResponse, error)

	// TeamExistsWithResponse request
	TeamExistsWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*TeamExistsResponse, error)

	// GetChannelByNameForTeamNameWithResponse request
	GetChannelByNameForTeamNameWithResponse(ctx context.Context, teamName string, channelName string, params *GetChannelByNameForTeamNameParams, reqEditors ...RequestEditorFn) (*GetChannelByNameForTeamNameResponse, error)

	// SearchTeamsWithBodyWithResponse request with any body
	SearchTeamsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchTeamsResponse, error)

	SearchTeamsWithResponse(ctx context.Context, body SearchTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchTeamsResponse, error)

	// SoftDeleteTeamWithResponse request
	SoftDeleteTeamWithResponse(ctx context.Context, teamId string, params *SoftDeleteTeamParams, reqEditors ...RequestEditorFn) (*SoftDeleteTeamResponse, error)

	// GetTeamWithResponse request
	GetTeamWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*GetTeamResponse, error)

	// UpdateTeamWithBodyWithResponse request with any body
	UpdateTeamWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error)

	UpdateTeamWithResponse(ctx context.Context, teamId string, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error)

	// GetPublicChannelsForTeamWithResponse request
	GetPublicChannelsForTeamWithResponse(ctx context.Context, teamId string, params *GetPublicChannelsForTeamParams, reqEditors ...RequestEditorFn) (*GetPublicChannelsForTeamResponse, error)

	// AutocompleteChannelsForTeamWithResponse request
	AutocompleteChannelsForTeamWithResponse(ctx context.Context, teamId string, params *AutocompleteChannelsForTeamParams, reqEditors ...RequestEditorFn) (*AutocompleteChannelsForTeamResponse, error)

	// GetDeletedChannelsForTeamWithResponse request
	GetDeletedChannelsForTeamWithResponse(ctx context.Context, teamId string, params *GetDeletedChannelsForTeamParams, reqEditors ...RequestEditorFn) (*GetDeletedChannelsForTeamResponse, error)

	// GetPublicChannelsByIdsForTeamWithBodyWithResponse request with any body
	GetPublicChannelsByIdsForTeamWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPublicChannelsByIdsForTeamResponse, error)

	GetPublicChannelsByIdsForTeamWithResponse(ctx context.Context, teamId string, body GetPublicChannelsByIdsForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPublicChannelsByIdsForTeamResponse, error)

	// GetChannelByNameWithResponse request
	GetChannelByNameWithResponse(ctx context.Context, teamId string, channelName string, params *GetChannelByNameParams, reqEditors ...RequestEditorFn) (*GetChannelByNameResponse, error)

	// GetPrivateChannelsForTeamWithResponse request
	GetPrivateChannelsForTeamWithResponse(ctx context.Context, teamId string, params *GetPrivateChannelsForTeamParams, reqEditors ...RequestEditorFn) (*GetPrivateChannelsForTeamResponse, error)

	// SearchChannelsWithBodyWithResponse request with any body
	SearchChannelsWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchChannelsResponse, error)

	SearchChannelsWithResponse(ctx context.Context, teamId string, body SearchChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchChannelsResponse, error)

	// SearchArchivedChannelsWithBodyWithResponse request with any body
	SearchArchivedChannelsWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchArchivedChannelsResponse, error)

	SearchArchivedChannelsWithResponse(ctx context.Context, teamId string, body SearchArchivedChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchArchivedChannelsResponse, error)

	// AutocompleteChannelsForTeamForSearchWithResponse request
	AutocompleteChannelsForTeamForSearchWithResponse(ctx context.Context, teamId string, params *AutocompleteChannelsForTeamForSearchParams, reqEditors ...RequestEditorFn) (*AutocompleteChannelsForTeamForSearchResponse, error)

	// ListAutocompleteCommandsWithResponse request
	ListAutocompleteCommandsWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*ListAutocompleteCommandsResponse, error)

	// ListCommandAutocompleteSuggestionsWithResponse request
	ListCommandAutocompleteSuggestionsWithResponse(ctx context.Context, teamId string, params *ListCommandAutocompleteSuggestionsParams, reqEditors ...RequestEditorFn) (*ListCommandAutocompleteSuggestionsResponse, error)

	// SearchFilesWithBodyWithResponse request with any body
	SearchFilesWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchFilesResponse, error)

	// GetGroupsByTeamWithResponse request
	GetGroupsByTeamWithResponse(ctx context.Context, teamId string, params *GetGroupsByTeamParams, reqEditors ...RequestEditorFn) (*GetGroupsByTeamResponse, error)

	// GetGroupsAssociatedToChannelsByTeamWithResponse request
	GetGroupsAssociatedToChannelsByTeamWithResponse(ctx context.Context, teamId string, params *GetGroupsAssociatedToChannelsByTeamParams, reqEditors ...RequestEditorFn) (*GetGroupsAssociatedToChannelsByTeamResponse, error)

	// RemoveTeamIconWithResponse request
	RemoveTeamIconWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*RemoveTeamIconResponse, error)

	// GetTeamIconWithResponse request
	GetTeamIconWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*GetTeamIconResponse, error)

	// SetTeamIconWithBodyWithResponse request with any body
	SetTeamIconWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetTeamIconResponse, error)

	// ImportTeamWithBodyWithResponse request with any body
	ImportTeamWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportTeamResponse, error)

	// InviteGuestsToTeamWithBodyWithResponse request with any body
	InviteGuestsToTeamWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteGuestsToTeamResponse, error)

	InviteGuestsToTeamWithResponse(ctx context.Context, teamId string, body InviteGuestsToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteGuestsToTeamResponse, error)

	// InviteUsersToTeamWithBodyWithResponse request with any body
	InviteUsersToTeamWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUsersToTeamResponse, error)

	InviteUsersToTeamWithResponse(ctx context.Context, teamId string, body InviteUsersToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUsersToTeamResponse, error)

	// GetTeamMembersWithResponse request
	GetTeamMembersWithResponse(ctx context.Context, teamId string, params *GetTeamMembersParams, reqEditors ...RequestEditorFn) (*GetTeamMembersResponse, error)

	// AddTeamMemberWithBodyWithResponse request with any body
	AddTeamMemberWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTeamMemberResponse, error)

	AddTeamMemberWithResponse(ctx context.Context, teamId string, body AddTeamMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTeamMemberResponse, error)

	// AddTeamMembersWithBodyWithResponse request with any body
	AddTeamMembersWithBodyWithResponse(ctx context.Context, teamId string, params *AddTeamMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTeamMembersResponse, error)

	AddTeamMembersWithResponse(ctx context.Context, teamId string, params *AddTeamMembersParams, body AddTeamMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTeamMembersResponse, error)

	// GetTeamMembersByIdsWithBodyWithResponse request with any body
	GetTeamMembersByIdsWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetTeamMembersByIdsResponse, error)

	GetTeamMembersByIdsWithResponse(ctx context.Context, teamId string, body GetTeamMembersByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTeamMembersByIdsResponse, error)

	// RemoveTeamMemberWithResponse request
	RemoveTeamMemberWithResponse(ctx context.Context, teamId string, userId string, reqEditors ...RequestEditorFn) (*RemoveTeamMemberResponse, error)

	// GetTeamMemberWithResponse request
	GetTeamMemberWithResponse(ctx context.Context, teamId string, userId string, reqEditors ...RequestEditorFn) (*GetTeamMemberResponse, error)

	// UpdateTeamMemberRolesWithBodyWithResponse request with any body
	UpdateTeamMemberRolesWithBodyWithResponse(ctx context.Context, teamId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamMemberRolesResponse, error)

	UpdateTeamMemberRolesWithResponse(ctx context.Context, teamId string, userId string, body UpdateTeamMemberRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamMemberRolesResponse, error)

	// UpdateTeamMemberSchemeRolesWithBodyWithResponse request with any body
	UpdateTeamMemberSchemeRolesWithBodyWithResponse(ctx context.Context, teamId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamMemberSchemeRolesResponse, error)

	UpdateTeamMemberSchemeRolesWithResponse(ctx context.Context, teamId string, userId string, body UpdateTeamMemberSchemeRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamMemberSchemeRolesResponse, error)

	// TeamMembersMinusGroupMembersWithResponse request
	TeamMembersMinusGroupMembersWithResponse(ctx context.Context, teamId string, params *TeamMembersMinusGroupMembersParams, reqEditors ...RequestEditorFn) (*TeamMembersMinusGroupMembersResponse, error)

	// PatchTeamWithBodyWithResponse request with any body
	PatchTeamWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchTeamResponse, error)

	PatchTeamWithResponse(ctx context.Context, teamId string, body PatchTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchTeamResponse, error)

	// SearchPostsWithBodyWithResponse request with any body
	SearchPostsWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchPostsResponse, error)

	SearchPostsWithResponse(ctx context.Context, teamId string, body SearchPostsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchPostsResponse, error)

	// UpdateTeamPrivacyWithBodyWithResponse request with any body
	UpdateTeamPrivacyWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamPrivacyResponse, error)

	UpdateTeamPrivacyWithResponse(ctx context.Context, teamId string, body UpdateTeamPrivacyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamPrivacyResponse, error)

	// RegenerateTeamInviteIdWithResponse request
	RegenerateTeamInviteIdWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*RegenerateTeamInviteIdResponse, error)

	// RestoreTeamWithResponse request
	RestoreTeamWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*RestoreTeamResponse, error)

	// UpdateTeamSchemeWithBodyWithResponse request with any body
	UpdateTeamSchemeWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamSchemeResponse, error)

	UpdateTeamSchemeWithResponse(ctx context.Context, teamId string, body UpdateTeamSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamSchemeResponse, error)

	// GetTeamStatsWithResponse request
	GetTeamStatsWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*GetTeamStatsResponse, error)

	// GetTermsOfServiceWithResponse request
	GetTermsOfServiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTermsOfServiceResponse, error)

	// CreateTermsOfServiceWithResponse request
	CreateTermsOfServiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateTermsOfServiceResponse, error)

	// RequestTrialLicenseWithBodyWithResponse request with any body
	RequestTrialLicenseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestTrialLicenseResponse, error)

	RequestTrialLicenseWithResponse(ctx context.Context, body RequestTrialLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestTrialLicenseResponse, error)

	// GetPrevTrialLicenseWithResponse request
	GetPrevTrialLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPrevTrialLicenseResponse, error)

	// UpgradeToEnterpriseWithResponse request
	UpgradeToEnterpriseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpgradeToEnterpriseResponse, error)

	// UpgradeToEnterpriseStatusWithResponse request
	UpgradeToEnterpriseStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpgradeToEnterpriseStatusResponse, error)

	// CreateUploadWithBodyWithResponse request with any body
	CreateUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUploadResponse, error)

	CreateUploadWithResponse(ctx context.Context, body CreateUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUploadResponse, error)

	// GetUploadWithResponse request
	GetUploadWithResponse(ctx context.Context, uploadId string, reqEditors ...RequestEditorFn) (*GetUploadResponse, error)

	// UploadDataWithBodyWithResponse request with any body
	UploadDataWithBodyWithResponse(ctx context.Context, uploadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadDataResponse, error)

	UploadDataWithFormdataBodyWithResponse(ctx context.Context, uploadId string, body UploadDataFormdataRequestBody, reqEditors ...RequestEditorFn) (*UploadDataResponse, error)

	// GetPostsUsageWithResponse request
	GetPostsUsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPostsUsageResponse, error)

	// GetStorageUsageWithResponse request
	GetStorageUsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageUsageResponse, error)

	// PermanentDeleteAllUsersWithResponse request
	PermanentDeleteAllUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PermanentDeleteAllUsersResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// AutocompleteUsersWithResponse request
	AutocompleteUsersWithResponse(ctx context.Context, params *AutocompleteUsersParams, reqEditors ...RequestEditorFn) (*AutocompleteUsersResponse, error)

	// VerifyUserEmailWithBodyWithResponse request with any body
	VerifyUserEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyUserEmailResponse, error)

	VerifyUserEmailWithResponse(ctx context.Context, body VerifyUserEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyUserEmailResponse, error)

	// SendVerificationEmailWithBodyWithResponse request with any body
	SendVerificationEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendVerificationEmailResponse, error)

	SendVerificationEmailWithResponse(ctx context.Context, body SendVerificationEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*SendVerificationEmailResponse, error)

	// GetUserByEmailWithResponse request
	GetUserByEmailWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*GetUserByEmailResponse, error)

	// GetUsersByGroupChannelIdsWithBodyWithResponse request with any body
	GetUsersByGroupChannelIdsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUsersByGroupChannelIdsResponse, error)

	GetUsersByGroupChannelIdsWithResponse(ctx context.Context, body GetUsersByGroupChannelIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUsersByGroupChannelIdsResponse, error)

	// GetUsersByIdsWithBodyWithResponse request with any body
	GetUsersByIdsWithBodyWithResponse(ctx context.Context, params *GetUsersByIdsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUsersByIdsResponse, error)

	GetUsersByIdsWithResponse(ctx context.Context, params *GetUsersByIdsParams, body GetUsersByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUsersByIdsResponse, error)

	// GetUsersWithInvalidEmailsWithResponse request
	GetUsersWithInvalidEmailsWithResponse(ctx context.Context, params *GetUsersWithInvalidEmailsParams, reqEditors ...RequestEditorFn) (*GetUsersWithInvalidEmailsResponse, error)

	// GetKnownUsersWithResponse request
	GetKnownUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKnownUsersResponse, error)

	// LoginWithBodyWithResponse request with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// LoginByCwsTokenWithBodyWithResponse request with any body
	LoginByCwsTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginByCwsTokenResponse, error)

	LoginByCwsTokenWithResponse(ctx context.Context, body LoginByCwsTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginByCwsTokenResponse, error)

	// SwitchAccountTypeWithBodyWithResponse request with any body
	SwitchAccountTypeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SwitchAccountTypeResponse, error)

	SwitchAccountTypeWithResponse(ctx context.Context, body SwitchAccountTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*SwitchAccountTypeResponse, error)

	// LogoutWithResponse request
	LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// CheckUserMfaWithBodyWithResponse request with any body
	CheckUserMfaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckUserMfaResponse, error)

	CheckUserMfaWithResponse(ctx context.Context, body CheckUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckUserMfaResponse, error)

	// MigrateAuthToLdapWithBodyWithResponse request with any body
	MigrateAuthToLdapWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateAuthToLdapResponse, error)

	MigrateAuthToLdapWithResponse(ctx context.Context, body MigrateAuthToLdapJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateAuthToLdapResponse, error)

	// MigrateAuthToSamlWithBodyWithResponse request with any body
	MigrateAuthToSamlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateAuthToSamlResponse, error)

	MigrateAuthToSamlWithResponse(ctx context.Context, body MigrateAuthToSamlJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateAuthToSamlResponse, error)

	// ResetPasswordWithBodyWithResponse request with any body
	ResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	ResetPasswordWithResponse(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	// SendPasswordResetEmailWithBodyWithResponse request with any body
	SendPasswordResetEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendPasswordResetEmailResponse, error)

	SendPasswordResetEmailWithResponse(ctx context.Context, body SendPasswordResetEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*SendPasswordResetEmailResponse, error)

	// SearchUsersWithBodyWithResponse request with any body
	SearchUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUsersResponse, error)

	SearchUsersWithResponse(ctx context.Context, body SearchUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUsersResponse, error)

	// AttachDeviceExtraPropsWithBodyWithResponse request with any body
	AttachDeviceExtraPropsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachDeviceExtraPropsResponse, error)

	AttachDeviceExtraPropsWithResponse(ctx context.Context, body AttachDeviceExtraPropsJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachDeviceExtraPropsResponse, error)

	// RevokeSessionsFromAllUsersWithResponse request
	RevokeSessionsFromAllUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RevokeSessionsFromAllUsersResponse, error)

	// GetTotalUsersStatsWithResponse request
	GetTotalUsersStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTotalUsersStatsResponse, error)

	// GetTotalUsersStatsFilteredWithResponse request
	GetTotalUsersStatsFilteredWithResponse(ctx context.Context, params *GetTotalUsersStatsFilteredParams, reqEditors ...RequestEditorFn) (*GetTotalUsersStatsFilteredResponse, error)

	// GetUsersStatusesByIdsWithBodyWithResponse request with any body
	GetUsersStatusesByIdsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUsersStatusesByIdsResponse, error)

	GetUsersStatusesByIdsWithResponse(ctx context.Context, body GetUsersStatusesByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUsersStatusesByIdsResponse, error)

	// GetUserAccessTokensWithResponse request
	GetUserAccessTokensWithResponse(ctx context.Context, params *GetUserAccessTokensParams, reqEditors ...RequestEditorFn) (*GetUserAccessTokensResponse, error)

	// DisableUserAccessTokenWithBodyWithResponse request with any body
	DisableUserAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableUserAccessTokenResponse, error)

	DisableUserAccessTokenWithResponse(ctx context.Context, body DisableUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableUserAccessTokenResponse, error)

	// EnableUserAccessTokenWithBodyWithResponse request with any body
	EnableUserAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableUserAccessTokenResponse, error)

	EnableUserAccessTokenWithResponse(ctx context.Context, body EnableUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableUserAccessTokenResponse, error)

	// RevokeUserAccessTokenWithBodyWithResponse request with any body
	RevokeUserAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeUserAccessTokenResponse, error)

	RevokeUserAccessTokenWithResponse(ctx context.Context, body RevokeUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeUserAccessTokenResponse, error)

	// SearchUserAccessTokensWithBodyWithResponse request with any body
	SearchUserAccessTokensWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUserAccessTokensResponse, error)

	SearchUserAccessTokensWithResponse(ctx context.Context, body SearchUserAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUserAccessTokensResponse, error)

	// GetUserAccessTokenWithResponse request
	GetUserAccessTokenWithResponse(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*GetUserAccessTokenResponse, error)

	// GetUserByUsernameWithResponse request
	GetUserByUsernameWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserByUsernameResponse, error)

	// GetUsersByUsernamesWithBodyWithResponse request with any body
	GetUsersByUsernamesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUsersByUsernamesResponse, error)

	GetUsersByUsernamesWithResponse(ctx context.Context, body GetUsersByUsernamesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUsersByUsernamesResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// UpdateUserActiveWithBodyWithResponse request with any body
	UpdateUserActiveWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserActiveResponse, error)

	UpdateUserActiveWithResponse(ctx context.Context, userId string, body UpdateUserActiveJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserActiveResponse, error)

	// GetUserAuditsWithResponse request
	GetUserAuditsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserAuditsResponse, error)

	// UpdateUserAuthWithBodyWithResponse request with any body
	UpdateUserAuthWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserAuthResponse, error)

	UpdateUserAuthWithResponse(ctx context.Context, userId string, body UpdateUserAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserAuthResponse, error)

	// GetChannelMembersWithTeamDataForUserWithResponse request
	GetChannelMembersWithTeamDataForUserWithResponse(ctx context.Context, userId string, params *GetChannelMembersWithTeamDataForUserParams, reqEditors ...RequestEditorFn) (*GetChannelMembersWithTeamDataForUserResponse, error)

	// GetChannelsForUserWithResponse request
	GetChannelsForUserWithResponse(ctx context.Context, userId string, params *GetChannelsForUserParams, reqEditors ...RequestEditorFn) (*GetChannelsForUserResponse, error)

	// GetPostsAroundLastUnreadWithResponse request
	GetPostsAroundLastUnreadWithResponse(ctx context.Context, userId string, channelId string, params *GetPostsAroundLastUnreadParams, reqEditors ...RequestEditorFn) (*GetPostsAroundLastUnreadResponse, error)

	// GetChannelUnreadWithResponse request
	GetChannelUnreadWithResponse(ctx context.Context, userId string, channelId string, reqEditors ...RequestEditorFn) (*GetChannelUnreadResponse, error)

	// ConvertUserToBotWithResponse request
	ConvertUserToBotWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*ConvertUserToBotResponse, error)

	// GetChannelPoliciesForUserWithResponse request
	GetChannelPoliciesForUserWithResponse(ctx context.Context, userId string, params *GetChannelPoliciesForUserParams, reqEditors ...RequestEditorFn) (*GetChannelPoliciesForUserResponse, error)

	// GetTeamPoliciesForUserWithResponse request
	GetTeamPoliciesForUserWithResponse(ctx context.Context, userId string, params *GetTeamPoliciesForUserParams, reqEditors ...RequestEditorFn) (*GetTeamPoliciesForUserResponse, error)

	// DemoteUserToGuestWithResponse request
	DemoteUserToGuestWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DemoteUserToGuestResponse, error)

	// VerifyUserEmailWithoutTokenWithResponse request
	VerifyUserEmailWithoutTokenWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*VerifyUserEmailWithoutTokenResponse, error)

	// GetGroupsByUserIdWithResponse request
	GetGroupsByUserIdWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetGroupsByUserIdResponse, error)

	// SetDefaultProfileImageWithResponse request
	SetDefaultProfileImageWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*SetDefaultProfileImageResponse, error)

	// GetProfileImageWithResponse request
	GetProfileImageWithResponse(ctx context.Context, userId string, params *GetProfileImageParams, reqEditors ...RequestEditorFn) (*GetProfileImageResponse, error)

	// SetProfileImageWithBodyWithResponse request with any body
	SetProfileImageWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetProfileImageResponse, error)

	// GetDefaultProfileImageWithResponse request
	GetDefaultProfileImageWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetDefaultProfileImageResponse, error)

	// UpdateUserMfaWithBodyWithResponse request with any body
	UpdateUserMfaWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserMfaResponse, error)

	UpdateUserMfaWithResponse(ctx context.Context, userId string, body UpdateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserMfaResponse, error)

	// GenerateMfaSecretWithResponse request
	GenerateMfaSecretWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GenerateMfaSecretResponse, error)

	// GetAuthorizedOAuthAppsForUserWithResponse request
	GetAuthorizedOAuthAppsForUserWithResponse(ctx context.Context, userId string, params *GetAuthorizedOAuthAppsForUserParams, reqEditors ...RequestEditorFn) (*GetAuthorizedOAuthAppsForUserResponse, error)

	// UpdateUserPasswordWithBodyWithResponse request with any body
	UpdateUserPasswordWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error)

	UpdateUserPasswordWithResponse(ctx context.Context, userId string, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error)

	// PatchUserWithBodyWithResponse request with any body
	PatchUserWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserResponse, error)

	PatchUserWithResponse(ctx context.Context, userId string, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserResponse, error)

	// GetFlaggedPostsForUserWithResponse request
	GetFlaggedPostsForUserWithResponse(ctx context.Context, userId string, params *GetFlaggedPostsForUserParams, reqEditors ...RequestEditorFn) (*GetFlaggedPostsForUserResponse, error)

	// DeleteAcknowledgementForPostWithResponse request
	DeleteAcknowledgementForPostWithResponse(ctx context.Context, userId string, postId string, reqEditors ...RequestEditorFn) (*DeleteAcknowledgementForPostResponse, error)

	// SaveAcknowledgementForPostWithResponse request
	SaveAcknowledgementForPostWithResponse(ctx context.Context, userId string, postId string, reqEditors ...RequestEditorFn) (*SaveAcknowledgementForPostResponse, error)

	// DeleteReactionWithResponse request
	DeleteReactionWithResponse(ctx context.Context, userId string, postId string, emojiName string, reqEditors ...RequestEditorFn) (*DeleteReactionResponse, error)

	// SetPostReminderWithBodyWithResponse request with any body
	SetPostReminderWithBodyWithResponse(ctx context.Context, userId string, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPostReminderResponse, error)

	SetPostReminderWithResponse(ctx context.Context, userId string, postId string, body SetPostReminderJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPostReminderResponse, error)

	// SetPostUnreadWithResponse request
	SetPostUnreadWithResponse(ctx context.Context, userId string, postId string, reqEditors ...RequestEditorFn) (*SetPostUnreadResponse, error)

	// GetPreferencesWithResponse request
	GetPreferencesWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetPreferencesResponse, error)

	// UpdatePreferencesWithBodyWithResponse request with any body
	UpdatePreferencesWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePreferencesResponse, error)

	UpdatePreferencesWithResponse(ctx context.Context, userId string, body UpdatePreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePreferencesResponse, error)

	// DeletePreferencesWithBodyWithResponse request with any body
	DeletePreferencesWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePreferencesResponse, error)

	DeletePreferencesWithResponse(ctx context.Context, userId string, body DeletePreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePreferencesResponse, error)

	// GetPreferencesByCategoryWithResponse request
	GetPreferencesByCategoryWithResponse(ctx context.Context, userId string, category string, reqEditors ...RequestEditorFn) (*GetPreferencesByCategoryResponse, error)

	// GetPreferencesByCategoryByNameWithResponse request
	GetPreferencesByCategoryByNameWithResponse(ctx context.Context, userId string, category string, preferenceName string, reqEditors ...RequestEditorFn) (*GetPreferencesByCategoryByNameResponse, error)

	// PromoteGuestToUserWithResponse request
	PromoteGuestToUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*PromoteGuestToUserResponse, error)

	// UpdateUserRolesWithBodyWithResponse request with any body
	UpdateUserRolesWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserRolesResponse, error)

	UpdateUserRolesWithResponse(ctx context.Context, userId string, body UpdateUserRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserRolesResponse, error)

	// GetSessionsWithResponse request
	GetSessionsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetSessionsResponse, error)

	// RevokeSessionWithBodyWithResponse request with any body
	RevokeSessionWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeSessionResponse, error)

	RevokeSessionWithResponse(ctx context.Context, userId string, body RevokeSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeSessionResponse, error)

	// RevokeAllSessionsWithResponse request
	RevokeAllSessionsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*RevokeAllSessionsResponse, error)

	// GetUserStatusWithResponse request
	GetUserStatusWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserStatusResponse, error)

	// UpdateUserStatusWithBodyWithResponse request with any body
	UpdateUserStatusWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserStatusResponse, error)

	UpdateUserStatusWithResponse(ctx context.Context, userId string, body UpdateUserStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserStatusResponse, error)

	// UnsetUserCustomStatusWithResponse request
	UnsetUserCustomStatusWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*UnsetUserCustomStatusResponse, error)

	// UpdateUserCustomStatusWithBodyWithResponse request with any body
	UpdateUserCustomStatusWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserCustomStatusResponse, error)

	UpdateUserCustomStatusWithResponse(ctx context.Context, userId string, body UpdateUserCustomStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserCustomStatusResponse, error)

	// RemoveRecentCustomStatusWithBodyWithResponse request with any body
	RemoveRecentCustomStatusWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveRecentCustomStatusResponse, error)

	RemoveRecentCustomStatusWithResponse(ctx context.Context, userId string, body RemoveRecentCustomStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveRecentCustomStatusResponse, error)

	// PostUserRecentCustomStatusDeleteWithBodyWithResponse request with any body
	PostUserRecentCustomStatusDeleteWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserRecentCustomStatusDeleteResponse, error)

	PostUserRecentCustomStatusDeleteWithResponse(ctx context.Context, userId string, body PostUserRecentCustomStatusDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUserRecentCustomStatusDeleteResponse, error)

	// GetTeamsForUserWithResponse request
	GetTeamsForUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetTeamsForUserResponse, error)

	// GetTeamMembersForUserWithResponse request
	GetTeamMembersForUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetTeamMembersForUserResponse, error)

	// GetTeamsUnreadForUserWithResponse request
	GetTeamsUnreadForUserWithResponse(ctx context.Context, userId string, params *GetTeamsUnreadForUserParams, reqEditors ...RequestEditorFn) (*GetTeamsUnreadForUserResponse, error)

	// GetChannelsForTeamForUserWithResponse request
	GetChannelsForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, params *GetChannelsForTeamForUserParams, reqEditors ...RequestEditorFn) (*GetChannelsForTeamForUserResponse, error)

	// GetSidebarCategoriesForTeamForUserWithResponse request
	GetSidebarCategoriesForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*GetSidebarCategoriesForTeamForUserResponse, error)

	// CreateSidebarCategoryForTeamForUserWithBodyWithResponse request with any body
	CreateSidebarCategoryForTeamForUserWithBodyWithResponse(ctx context.Context, userId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSidebarCategoryForTeamForUserResponse, error)

	CreateSidebarCategoryForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, body CreateSidebarCategoryForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSidebarCategoryForTeamForUserResponse, error)

	// UpdateSidebarCategoriesForTeamForUserWithBodyWithResponse request with any body
	UpdateSidebarCategoriesForTeamForUserWithBodyWithResponse(ctx context.Context, userId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSidebarCategoriesForTeamForUserResponse, error)

	UpdateSidebarCategoriesForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, body UpdateSidebarCategoriesForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSidebarCategoriesForTeamForUserResponse, error)

	// GetSidebarCategoryOrderForTeamForUserWithResponse request
	GetSidebarCategoryOrderForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*GetSidebarCategoryOrderForTeamForUserResponse, error)

	// UpdateSidebarCategoryOrderForTeamForUserWithBodyWithResponse request with any body
	UpdateSidebarCategoryOrderForTeamForUserWithBodyWithResponse(ctx context.Context, userId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSidebarCategoryOrderForTeamForUserResponse, error)

	UpdateSidebarCategoryOrderForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, body UpdateSidebarCategoryOrderForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSidebarCategoryOrderForTeamForUserResponse, error)

	// RemoveSidebarCategoryForTeamForUserWithResponse request
	RemoveSidebarCategoryForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, categoryId string, reqEditors ...RequestEditorFn) (*RemoveSidebarCategoryForTeamForUserResponse, error)

	// GetSidebarCategoryForTeamForUserWithResponse request
	GetSidebarCategoryForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, categoryId string, reqEditors ...RequestEditorFn) (*GetSidebarCategoryForTeamForUserResponse, error)

	// UpdateSidebarCategoryForTeamForUserWithBodyWithResponse request with any body
	UpdateSidebarCategoryForTeamForUserWithBodyWithResponse(ctx context.Context, userId string, teamId string, categoryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSidebarCategoryForTeamForUserResponse, error)

	UpdateSidebarCategoryForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, categoryId string, body UpdateSidebarCategoryForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSidebarCategoryForTeamForUserResponse, error)

	// GetChannelMembersForUserWithResponse request
	GetChannelMembersForUserWithResponse(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*GetChannelMembersForUserResponse, error)

	// GetUserThreadsWithResponse request
	GetUserThreadsWithResponse(ctx context.Context, userId string, teamId string, params *GetUserThreadsParams, reqEditors ...RequestEditorFn) (*GetUserThreadsResponse, error)

	// GetThreadMentionCountsByChannelWithResponse request
	GetThreadMentionCountsByChannelWithResponse(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*GetThreadMentionCountsByChannelResponse, error)

	// UpdateThreadsReadForUserWithResponse request
	UpdateThreadsReadForUserWithResponse(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*UpdateThreadsReadForUserResponse, error)

	// GetUserThreadWithResponse request
	GetUserThreadWithResponse(ctx context.Context, userId string, teamId string, threadId string, reqEditors ...RequestEditorFn) (*GetUserThreadResponse, error)

	// StopFollowingThreadWithResponse request
	StopFollowingThreadWithResponse(ctx context.Context, userId string, teamId string, threadId string, reqEditors ...RequestEditorFn) (*StopFollowingThreadResponse, error)

	// StartFollowingThreadWithResponse request
	StartFollowingThreadWithResponse(ctx context.Context, userId string, teamId string, threadId string, reqEditors ...RequestEditorFn) (*StartFollowingThreadResponse, error)

	// UpdateThreadReadForUserWithResponse request
	UpdateThreadReadForUserWithResponse(ctx context.Context, userId string, teamId string, threadId string, timestamp string, reqEditors ...RequestEditorFn) (*UpdateThreadReadForUserResponse, error)

	// SetThreadUnreadByPostIdWithResponse request
	SetThreadUnreadByPostIdWithResponse(ctx context.Context, userId string, teamId string, threadId string, postId string, reqEditors ...RequestEditorFn) (*SetThreadUnreadByPostIdResponse, error)

	// GetTeamUnreadWithResponse request
	GetTeamUnreadWithResponse(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*GetTeamUnreadResponse, error)

	// GetUserTermsOfServiceWithResponse request
	GetUserTermsOfServiceWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserTermsOfServiceResponse, error)

	// RegisterTermsOfServiceActionWithBodyWithResponse request with any body
	RegisterTermsOfServiceActionWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterTermsOfServiceActionResponse, error)

	RegisterTermsOfServiceActionWithResponse(ctx context.Context, userId string, body RegisterTermsOfServiceActionJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterTermsOfServiceActionResponse, error)

	// GetUserAccessTokensForUserWithResponse request
	GetUserAccessTokensForUserWithResponse(ctx context.Context, userId string, params *GetUserAccessTokensForUserParams, reqEditors ...RequestEditorFn) (*GetUserAccessTokensForUserResponse, error)

	// CreateUserAccessTokenWithBodyWithResponse request with any body
	CreateUserAccessTokenWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserAccessTokenResponse, error)

	CreateUserAccessTokenWithResponse(ctx context.Context, userId string, body CreateUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserAccessTokenResponse, error)

	// PublishUserTypingWithBodyWithResponse request with any body
	PublishUserTypingWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishUserTypingResponse, error)

	PublishUserTypingWithResponse(ctx context.Context, userId string, body PublishUserTypingJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishUserTypingResponse, error)

	// GetUploadsForUserWithResponse request
	GetUploadsForUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUploadsForUserResponse, error)

	// GetFilePublicWithResponse request
	GetFilePublicWithResponse(ctx context.Context, fileId string, params *GetFilePublicParams, reqEditors ...RequestEditorFn) (*GetFilePublicResponse, error)

	// GetPlaybooksWithResponse request
	GetPlaybooksWithResponse(ctx context.Context, params *GetPlaybooksParams, reqEditors ...RequestEditorFn) (*GetPlaybooksResponse, error)

	// CreatePlaybookWithBodyWithResponse request with any body
	CreatePlaybookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlaybookResponse, error)

	CreatePlaybookWithResponse(ctx context.Context, body CreatePlaybookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlaybookResponse, error)

	// DeletePlaybookWithResponse request
	DeletePlaybookWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePlaybookResponse, error)

	// GetPlaybookWithResponse request
	GetPlaybookWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPlaybookResponse, error)

	// UpdatePlaybookWithBodyWithResponse request with any body
	UpdatePlaybookWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlaybookResponse, error)

	UpdatePlaybookWithResponse(ctx context.Context, id string, body UpdatePlaybookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlaybookResponse, error)

	// GetAutoFollowsWithResponse request
	GetAutoFollowsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAutoFollowsResponse, error)

	// ListPlaybookRunsWithResponse request
	ListPlaybookRunsWithResponse(ctx context.Context, params *ListPlaybookRunsParams, reqEditors ...RequestEditorFn) (*ListPlaybookRunsResponse, error)

	// CreatePlaybookRunFromPostWithBodyWithResponse request with any body
	CreatePlaybookRunFromPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlaybookRunFromPostResponse, error)

	CreatePlaybookRunFromPostWithResponse(ctx context.Context, body CreatePlaybookRunFromPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlaybookRunFromPostResponse, error)

	// GetPlaybookRunByChannelIdWithResponse request
	GetPlaybookRunByChannelIdWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetPlaybookRunByChannelIdResponse, error)

	// GetChannelsWithResponse request
	GetChannelsWithResponse(ctx context.Context, params *GetChannelsParams, reqEditors ...RequestEditorFn) (*GetChannelsResponse, error)

	// GetChecklistAutocompleteWithResponse request
	GetChecklistAutocompleteWithResponse(ctx context.Context, params *GetChecklistAutocompleteParams, reqEditors ...RequestEditorFn) (*GetChecklistAutocompleteResponse, error)

	// CreatePlaybookRunFromDialogWithBodyWithResponse request with any body
	CreatePlaybookRunFromDialogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlaybookRunFromDialogResponse, error)

	CreatePlaybookRunFromDialogWithResponse(ctx context.Context, body CreatePlaybookRunFromDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlaybookRunFromDialogResponse, error)

	// GetOwnersWithResponse request
	GetOwnersWithResponse(ctx context.Context, params *GetOwnersParams, reqEditors ...RequestEditorFn) (*GetOwnersResponse, error)

	// GetPlaybookRunWithResponse request
	GetPlaybookRunWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPlaybookRunResponse, error)

	// UpdatePlaybookRunWithBodyWithResponse request with any body
	UpdatePlaybookRunWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlaybookRunResponse, error)

	UpdatePlaybookRunWithResponse(ctx context.Context, id string, body UpdatePlaybookRunJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlaybookRunResponse, error)

	// AddChecklistItemWithBodyWithResponse request with any body
	AddChecklistItemWithBodyWithResponse(ctx context.Context, id string, checklist int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddChecklistItemResponse, error)

	AddChecklistItemWithResponse(ctx context.Context, id string, checklist int, body AddChecklistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddChecklistItemResponse, error)

	// ItemDeleteWithResponse request
	ItemDeleteWithResponse(ctx context.Context, id string, checklist int, item int, reqEditors ...RequestEditorFn) (*ItemDeleteResponse, error)

	// ItemRenameWithBodyWithResponse request with any body
	ItemRenameWithBodyWithResponse(ctx context.Context, id string, checklist int, item int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemRenameResponse, error)

	ItemRenameWithResponse(ctx context.Context, id string, checklist int, item int, body ItemRenameJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemRenameResponse, error)

	// ItemSetAssigneeWithBodyWithResponse request with any body
	ItemSetAssigneeWithBodyWithResponse(ctx context.Context, id string, checklist int, item int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemSetAssigneeResponse, error)

	ItemSetAssigneeWithResponse(ctx context.Context, id string, checklist int, item int, body ItemSetAssigneeJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemSetAssigneeResponse, error)

	// ItemRunWithResponse request
	ItemRunWithResponse(ctx context.Context, id string, checklist int, item int, reqEditors ...RequestEditorFn) (*ItemRunResponse, error)

	// ItemSetStateWithBodyWithResponse request with any body
	ItemSetStateWithBodyWithResponse(ctx context.Context, id string, checklist int, item int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemSetStateResponse, error)

	ItemSetStateWithResponse(ctx context.Context, id string, checklist int, item int, body ItemSetStateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemSetStateResponse, error)

	// ReoderChecklistItemWithBodyWithResponse request with any body
	ReoderChecklistItemWithBodyWithResponse(ctx context.Context, id string, checklist int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReoderChecklistItemResponse, error)

	ReoderChecklistItemWithResponse(ctx context.Context, id string, checklist int, body ReoderChecklistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*ReoderChecklistItemResponse, error)

	// EndPlaybookRunDialogWithResponse request
	EndPlaybookRunDialogWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*EndPlaybookRunDialogResponse, error)

	// EndPlaybookRunWithResponse request
	EndPlaybookRunWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*EndPlaybookRunResponse, error)

	// FinishWithResponse request
	FinishWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FinishResponse, error)

	// GetPlaybookRunMetadataWithResponse request
	GetPlaybookRunMetadataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPlaybookRunMetadataResponse, error)

	// NextStageDialogWithBodyWithResponse request with any body
	NextStageDialogWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NextStageDialogResponse, error)

	NextStageDialogWithResponse(ctx context.Context, id string, body NextStageDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*NextStageDialogResponse, error)

	// ChangeOwnerWithBodyWithResponse request with any body
	ChangeOwnerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeOwnerResponse, error)

	ChangeOwnerWithResponse(ctx context.Context, id string, body ChangeOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeOwnerResponse, error)

	// RestartPlaybookRunWithResponse request
	RestartPlaybookRunWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RestartPlaybookRunResponse, error)

	// StatusWithBodyWithResponse request with any body
	StatusWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StatusResponse, error)

	StatusWithResponse(ctx context.Context, id string, body StatusJSONRequestBody, reqEditors ...RequestEditorFn) (*StatusResponse, error)

	// RemoveTimelineEventWithResponse request
	RemoveTimelineEventWithResponse(ctx context.Context, id string, eventId string, reqEditors ...RequestEditorFn) (*RemoveTimelineEventResponse, error)
}

type OpenInteractiveDialogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r OpenInteractiveDialogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OpenInteractiveDialogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitInteractiveDialogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r SubmitInteractiveDialogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitInteractiveDialogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnalyticsOldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetAnalyticsOldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnalyticsOldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Audit
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetAuditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PurgeBleveIndexesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PurgeBleveIndexesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PurgeBleveIndexesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Bot
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetBotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Bot
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreateBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bot
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bot
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r PatchBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bot
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r AssignBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConvertBotToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ConvertBotToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConvertBotToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bot
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r DisableBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bot
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r EnableBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBotIconImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r DeleteBotIconImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBotIconImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBotIconImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetBotIconImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBotIconImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBotIconImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON413      *TooLarge
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r SetBotIconImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBotIconImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBrandImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteBrandImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBrandImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBrandImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetBrandImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBrandImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadBrandImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON413      *TooLarge
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UploadBrandImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadBrandImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InvalidateCachesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r InvalidateCachesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InvalidateCachesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelListWithTeamData
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetAllChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreateChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDirectChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreateDirectChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDirectChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreateGroupChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchGroupChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r SearchGroupChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchGroupChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ViewChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// LastViewedAtTimes A JSON object mapping channel IDs to the channel view times
		LastViewedAtTimes *map[string]interface{} `json:"last_viewed_at_times,omitempty"`

		// Status Value should be "OK" if successful
		Status *string `json:"status,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
}

// Status returns HTTPResponse.Status
func (r ViewChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ViewChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchAllChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Channels The channels that matched the query.
		Channels *[]Channel `json:"channels,omitempty"`

		// TotalCount The total number of results, regardless of page and per_page requested.
		TotalCount *float32 `json:"total_count,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r SearchAllChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchAllChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r DeleteChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Channel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListChannelBookmarksForChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]ChannelBookmarkWithFileInfo
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r ListChannelBookmarksForChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListChannelBookmarksForChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateChannelBookmarkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ChannelBookmarkWithFileInfo
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreateChannelBookmarkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateChannelBookmarkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteChannelBookmarkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelBookmarkWithFileInfo
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteChannelBookmarkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteChannelBookmarkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelBookmarkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateChannelBookmarkResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateChannelBookmarkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelBookmarkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelBookmarkSortOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ChannelBookmarkWithFileInfo
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r UpdateChannelBookmarkSortOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelBookmarkSortOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsByChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Group
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetGroupsByChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsByChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelMemberCountsByGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetChannelMemberCountsByGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelMemberCountsByGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ChannelMember
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetChannelMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddChannelMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ChannelMember
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r AddChannelMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddChannelMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelMembersByIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ChannelMember
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetChannelMembersByIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelMembersByIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserFromChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r RemoveUserFromChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserFromChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelMember
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetChannelMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelNotifyPropsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateChannelNotifyPropsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelNotifyPropsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r UpdateChannelRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelMemberSchemeRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateChannelMemberSchemeRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelMemberSchemeRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChannelMembersMinusGroupMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r ChannelMembersMinusGroupMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChannelMembersMinusGroupMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelModerationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ChannelModeration
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetChannelModerationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelModerationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchChannelModerationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ChannelModeration
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r PatchChannelModerationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchChannelModerationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MoveChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r MoveChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MoveChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r PatchChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPinnedPostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostList
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetPinnedPostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPinnedPostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostsForChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostList
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetPostsForChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostsForChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelPrivacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateChannelPrivacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelPrivacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Channel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r RestoreChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelSchemeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UpdateChannelSchemeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelSchemeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelStats
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetChannelStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelMembersTimezonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetChannelMembersTimezonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelMembersTimezonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitPerformanceReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SubmitPerformanceReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitPerformanceReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCloudCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloudCustomer
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetCloudCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCloudCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCloudCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloudCustomer
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UpdateCloudCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCloudCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCloudCustomerAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloudCustomer
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UpdateCloudCustomerAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCloudCustomerAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEndpointForInstallationInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Installation
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetEndpointForInstallationInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEndpointForInstallationInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCloudLimitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductLimits
	JSON401      *Unauthorized
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetCloudLimitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCloudLimitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomerPaymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PaymentSetupIntent
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CreateCustomerPaymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomerPaymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmCustomerPaymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r ConfirmCustomerPaymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmCustomerPaymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCloudProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Product
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetCloudProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCloudProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Subscription
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoicesForSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Invoice
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetInvoicesForSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesForSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoiceForSubscriptionAsPdfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetInvoiceForSubscriptionAsPdfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoiceForSubscriptionAsPdfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEndpointForCwsWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PostEndpointForCwsWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEndpointForCwsWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClusterInfo
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetClusterStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCommandsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Command
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r ListCommandsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCommandsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Command
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CreateCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommandResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r ExecuteCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommandByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Command
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetCommandByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommandByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Command
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r UpdateCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MoveCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r MoveCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MoveCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegenCommandTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Token The new token
		Token *string `json:"token,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
}

// Status returns HTTPResponse.Status
func (r RegenCommandTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegenCommandTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComplianceReportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Compliance
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetComplianceReportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComplianceReportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateComplianceReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Compliance
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CreateComplianceReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateComplianceReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComplianceReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Compliance
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetComplianceReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComplianceReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadComplianceReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r DownloadComplianceReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadComplianceReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSON400      *BadRequest
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSON400      *BadRequest
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r UpdateConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetClientConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnvironmentConfig
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSON400      *BadRequest
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r PatchConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReloadConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r ReloadConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReloadConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataRetentionPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DataRetentionPolicyWithTeamAndChannelCounts
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetDataRetentionPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataRetentionPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDataRetentionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DataRetentionPolicyWithTeamAndChannelCounts
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CreateDataRetentionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDataRetentionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDataRetentionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r DeleteDataRetentionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDataRetentionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataRetentionPolicyByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataRetentionPolicyWithTeamAndChannelCounts
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetDataRetentionPolicyByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataRetentionPolicyByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchDataRetentionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataRetentionPolicyWithTeamAndChannelCounts
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PatchDataRetentionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchDataRetentionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveChannelsFromRetentionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r RemoveChannelsFromRetentionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveChannelsFromRetentionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelsForRetentionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelListWithTeamData
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetChannelsForRetentionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelsForRetentionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddChannelsToRetentionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r AddChannelsToRetentionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddChannelsToRetentionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchChannelsForRetentionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelListWithTeamData
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r SearchChannelsForRetentionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchChannelsForRetentionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTeamsFromRetentionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r RemoveTeamsFromRetentionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTeamsFromRetentionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsForRetentionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetTeamsForRetentionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsForRetentionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTeamsToRetentionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r AddTeamsToRetentionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTeamsToRetentionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchTeamsForRetentionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r SearchTeamsForRetentionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchTeamsForRetentionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataRetentionPoliciesCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TotalCount The number of granular retention policies.
		TotalCount *int `json:"total_count,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON500 *InternalServerError
	JSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetDataRetentionPoliciesCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataRetentionPoliciesCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataRetentionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalDataRetentionPolicy
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetDataRetentionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataRetentionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DatabaseRecycleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r DatabaseRecycleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DatabaseRecycleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PurgeElasticsearchIndexesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PurgeElasticsearchIndexesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PurgeElasticsearchIndexesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestElasticsearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r TestElasticsearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestElasticsearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r TestEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmojiListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Emoji
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetEmojiListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmojiListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEmojiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Emoji
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON413      *TooLarge
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CreateEmojiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEmojiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AutocompleteEmojiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Emoji
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r AutocompleteEmojiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AutocompleteEmojiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmojiByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Emoji
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetEmojiByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmojiByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmojisByNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetEmojisByNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmojisByNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchEmojiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Emoji
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r SearchEmojiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchEmojiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEmojiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Emoji
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r DeleteEmojiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEmojiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmojiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Emoji
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetEmojiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmojiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmojiImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetEmojiImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmojiImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListExportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DownloadExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestS3ConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r TestS3ConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestS3ConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// ClientIds A list of the client_ids that were provided in the request
		ClientIds *[]string `json:"client_ids,omitempty"`

		// FileInfos A list of file metadata that has been stored in the database
		FileInfos *[]FileInfo `json:"file_infos,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON413 *TooLarge
	JSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UploadFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileInfoList
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r SearchFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AppError
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFileInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileInfo
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AppError
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetFileInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFileInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFileLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Link *string `json:"link,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *AppError
	JSON404 *NotFound
	JSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetFileLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFileLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilePreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AppError
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetFilePreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilePreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFileThumbnailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AppError
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetFileThumbnailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFileThumbnailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Group
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupSyncablesChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GroupSyncableChannels
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetGroupSyncablesChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupSyncablesChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupSyncableForChannelIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupSyncableChannel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetGroupSyncableForChannelIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupSyncableForChannelIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkGroupSyncableForChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UnlinkGroupSyncableForChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkGroupSyncableForChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkGroupSyncableForChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GroupSyncableChannel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r LinkGroupSyncableForChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkGroupSyncableForChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchGroupSyncableForChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupSyncableChannel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PatchGroupSyncableForChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchGroupSyncableForChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GroupMember
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r DeleteGroupMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Members          *[]User `json:"members,omitempty"`
		TotalMemberCount *int    `json:"total_member_count,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON500 *InternalServerError
	JSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetGroupUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddGroupMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GroupMember
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r AddGroupMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddGroupMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PatchGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r RestoreGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		GroupId          *string `json:"group_id,omitempty"`
		TotalMemberCount *int    `json:"total_member_count,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON500 *InternalServerError
	JSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetGroupStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupSyncablesTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GroupSyncableTeams
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetGroupSyncablesTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupSyncablesTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupSyncableForTeamIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupSyncableTeam
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetGroupSyncableForTeamIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupSyncableForTeamIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkGroupSyncableForTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UnlinkGroupSyncableForTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkGroupSyncableForTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkGroupSyncableForTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GroupSyncableTeam
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r LinkGroupSyncableForTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkGroupSyncableForTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchGroupSyncableForTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupSyncableTeam
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PatchGroupSyncableForTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchGroupSyncableForTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIncomingWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IncomingWebhook
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetIncomingWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIncomingWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIncomingWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IncomingWebhook
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreateIncomingWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIncomingWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIncomingWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteIncomingWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIncomingWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIncomingWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IncomingWebhook
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetIncomingWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIncomingWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIncomingWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IncomingWebhook
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateIncomingWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIncomingWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOutgoingWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OutgoingWebhook
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetOutgoingWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutgoingWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOutgoingWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OutgoingWebhook
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r CreateOutgoingWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOutgoingWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOutgoingWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteOutgoingWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOutgoingWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOutgoingWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OutgoingWebhook
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetOutgoingWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutgoingWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOutgoingWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OutgoingWebhook
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateOutgoingWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOutgoingWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegenOutgoingHookTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r RegenOutgoingHookTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegenOutgoingHookTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImageByUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetImageByUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImageByUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListImportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ListImportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListImportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckIntegrityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IntegrityCheckResult
}

// Status returns HTTPResponse.Status
func (r CheckIntegrityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckIntegrityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIPFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AllowedIPRange
	JSON401      *Unauthorized
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetIPFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIPFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApplyIPFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AllowedIPRange
	JSON401      *Unauthorized
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r ApplyIPFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApplyIPFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MyIPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Ip Your current IP address
		Ip *string `json:"ip,omitempty"`
	}
	JSON401 *Unauthorized
	JSON500 *InternalServerError
	JSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r MyIPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MyIPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Job
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Job
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobsByTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Job
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetJobsByTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobsByTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r CancelJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DownloadJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateJobStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r UpdateJobStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateJobStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLdapPrivateCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r DeleteLdapPrivateCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLdapPrivateCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadLdapPrivateCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UploadLdapPrivateCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadLdapPrivateCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLdapPublicCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r DeleteLdapPublicCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLdapPublicCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadLdapPublicCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UploadLdapPublicCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadLdapPublicCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLdapGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LDAPGroupsPaged
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetLdapGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLdapGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkLdapGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r UnlinkLdapGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkLdapGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkLdapGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r LinkLdapGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkLdapGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrateIdLdapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r MigrateIdLdapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrateIdLdapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncLdapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r SyncLdapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncLdapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestLdapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r TestLdapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestLdapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserToGroupSyncablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r AddUserToGroupSyncablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserToGroupSyncablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveLicenseFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r RemoveLicenseFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveLicenseFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadLicenseFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON413      *TooLarge
}

// Status returns HTTPResponse.Status
func (r UploadLicenseFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadLicenseFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetClientLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestLicenseRenewalLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LicenseRenewalLink
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RequestLicenseRenewalLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestLicenseRenewalLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerLimitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ServerLimits
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetServerLimitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerLimitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r PostLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadSystemLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DownloadSystemLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadSystemLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcknowledgeNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PushNotification
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AcknowledgeNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcknowledgeNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r TestNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOAuthAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OAuthApp
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetOAuthAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOAuthAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOAuthAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OAuthApp
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CreateOAuthAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOAuthAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOAuthAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r DeleteOAuthAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOAuthAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOAuthAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthApp
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetOAuthAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOAuthAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOAuthAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthApp
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UpdateOAuthAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOAuthAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOAuthAppInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthApp
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetOAuthAppInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOAuthAppInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegenerateOAuthAppSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthApp
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r RegenerateOAuthAppSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegenerateOAuthAppSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOutgoingOAuthConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OutgoingOAuthConnectionGetItem
	JSON401      *Unauthorized
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r ListOutgoingOAuthConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOutgoingOAuthConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOutgoingOAuthConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OutgoingOAuthConnectionGetItem
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CreateOutgoingOAuthConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOutgoingOAuthConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateOutgoingOAuthConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
	JSON501      *NotImplemented
	JSON502      *BadGateway
}

// Status returns HTTPResponse.Status
func (r ValidateOutgoingOAuthConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateOutgoingOAuthConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOutgoingOAuthConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r DeleteOutgoingOAuthConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOutgoingOAuthConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOutgoingOAuthConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OutgoingOAuthConnectionGetItem
	JSON401      *Unauthorized
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetOutgoingOAuthConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutgoingOAuthConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOutgoingOAuthConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OutgoingOAuthConnectionGetItem
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UpdateOutgoingOAuthConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOutgoingOAuthConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAncillaryPermissionsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r GetAncillaryPermissionsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAncillaryPermissionsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Active   *[]PluginManifest `json:"active,omitempty"`
		Inactive *[]PluginManifest `json:"inactive,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetPluginsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadPluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON413      *TooLarge
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UploadPluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadPluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallPluginFromUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StatusOK
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r InstallPluginFromUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallPluginFromUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMarketplacePluginsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MarketplacePlugin
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetMarketplacePluginsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMarketplacePluginsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallMarketplacePluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginManifest
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r InstallMarketplacePluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallMarketplacePluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMarketplaceVisitedByAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *System
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMarketplaceVisitedByAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMarketplaceVisitedByAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMarketplaceVisitedByAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateMarketplaceVisitedByAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMarketplaceVisitedByAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PluginStatus
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetPluginStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebappPluginsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PluginManifestWebapp
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetWebappPluginsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebappPluginsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r RemovePluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisablePluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r DisablePluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisablePluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnablePluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r EnablePluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnablePluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Post
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreatePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePostEphemeralResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Post
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreatePostEphemeralResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePostEphemeralResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostsByIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Post
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetPostsByIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostsByIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBulkReactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostIdToReactionsMap
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetBulkReactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBulkReactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateScheduledPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateScheduledPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateScheduledPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScheduledPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteScheduledPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScheduledPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateScheduledPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateScheduledPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateScheduledPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserScheduledPostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string][]ScheduledPost
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserScheduledPostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserScheduledPostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r DeletePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Post
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Post
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r UpdatePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DoPostActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r DoPostActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DoPostActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFileInfosForPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FileInfo
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetFileInfosForPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFileInfosForPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MoveThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r MoveThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MoveThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Post
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r PatchPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PinPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r PinPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PinPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Reaction
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetReactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostList
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetPostThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnpinPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r UnpinPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnpinPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveReactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Reaction
	JSON400      *BadRequest
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r SaveReactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveReactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRedirectLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetRedirectLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRedirectLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRemoteClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RemoteCluster
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetRemoteClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRemoteClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRemoteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Invite The encrypted invite for the newly created remote cluster
		Invite *string `json:"invite,omitempty"`

		// Password The password generated by the server if none was
		// sent on the create request
		Password      *string        `json:"password,omitempty"`
		RemoteCluster *RemoteCluster `json:"remote_cluster,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreateRemoteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRemoteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptRemoteClusterInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RemoteCluster
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r AcceptRemoteClusterInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptRemoteClusterInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRemoteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteRemoteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRemoteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRemoteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RemoteCluster
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetRemoteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRemoteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchRemoteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RemoteCluster
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r PatchRemoteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchRemoteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteRemoteClusterToChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r InviteRemoteClusterToChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteRemoteClusterToChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UninviteRemoteClusterToChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r UninviteRemoteClusterToChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UninviteRemoteClusterToChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSharedChannelRemotesByRemoteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SharedChannelRemote
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetSharedChannelRemotesByRemoteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSharedChannelRemotesByRemoteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersForReportingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserReport
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUsersForReportingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersForReportingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserCountForReportingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *float32
}

// Status returns HTTPResponse.Status
func (r GetUserCountForReportingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserCountForReportingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartBatchUsersExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserReport
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StartBatchUsersExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartBatchUsersExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r RestartServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Role
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetAllRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetRoleByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolesByNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Role
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetRolesByNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolesByNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r PatchRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSamlIdpCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r DeleteSamlIdpCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSamlIdpCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadSamlIdpCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UploadSamlIdpCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadSamlIdpCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSamlPrivateCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r DeleteSamlPrivateCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSamlPrivateCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadSamlPrivateCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UploadSamlPrivateCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadSamlPrivateCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSamlPublicCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r DeleteSamlPublicCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSamlPublicCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadSamlPublicCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UploadSamlPublicCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadSamlPublicCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSamlCertificateStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SamlCertificateStatus
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetSamlCertificateStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamlCertificateStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSamlMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetSamlMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamlMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSamlMetadataFromIdpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetSamlMetadataFromIdpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamlMetadataFromIdpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetSamlAuthDataToEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NumAffected The number of users whose AuthData field was reset.
		NumAffected *int `json:"num_affected,omitempty"`
	}
	JSON403 *Forbidden
	JSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r ResetSamlAuthDataToEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetSamlAuthDataToEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Scheme
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetSchemesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSchemeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Scheme
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CreateSchemeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSchemeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSchemeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r DeleteSchemeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSchemeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Scheme
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetSchemeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelsForSchemeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetChannelsForSchemeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelsForSchemeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSchemeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Scheme
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PatchSchemeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSchemeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsForSchemeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTeamsForSchemeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsForSchemeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearServerBusyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r ClearServerBusyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearServerBusyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerBusyExpiresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerBusy
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetServerBusyExpiresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerBusyExpiresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetServerBusyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r SetServerBusyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetServerBusyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRemoteClusterInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RemoteClusterInfo
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetRemoteClusterInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRemoteClusterInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSharedChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SharedChannel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetAllSharedChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSharedChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestSiteURLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r TestSiteURLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestSiteURLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkNoticesViewedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r MarkNoticesViewedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkNoticesViewedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNoticesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Notice
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetNoticesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNoticesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SystemStatusResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateSupportPacketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GenerateSupportPacketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateSupportPacketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSupportedTimezoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSupportedTimezoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSupportedTimezoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetAllTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Team
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreateTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamInviteInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Description *string `json:"description,omitempty"`
		DisplayName *string `json:"display_name,omitempty"`
		Id          *string `json:"id,omitempty"`
		Name        *string `json:"name,omitempty"`
	}
	JSON400 *BadRequest
}

// Status returns HTTPResponse.Status
func (r GetTeamInviteInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamInviteInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InvalidateEmailInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r InvalidateEmailInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InvalidateEmailInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTeamMemberFromInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TeamMember
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AddTeamMemberFromInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTeamMemberFromInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTeamByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamExistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamExists
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r TeamExistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamExistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelByNameForTeamNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Channel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetChannelByNameForTeamNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelByNameForTeamNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Teams The teams that matched the query.
		Teams *[]Team `json:"teams,omitempty"`

		// TotalCount The total number of results, regardless of page and per_page requested.
		TotalCount *float32 `json:"total_count,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r SearchTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SoftDeleteTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r SoftDeleteTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SoftDeleteTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicChannelsForTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetPublicChannelsForTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicChannelsForTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AutocompleteChannelsForTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AutocompleteChannelsForTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AutocompleteChannelsForTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeletedChannelsForTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetDeletedChannelsForTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeletedChannelsForTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicChannelsByIdsForTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetPublicChannelsByIdsForTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicChannelsByIdsForTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Channel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetChannelByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPrivateChannelsForTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetPrivateChannelsForTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPrivateChannelsForTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r SearchChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchArchivedChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r SearchArchivedChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchArchivedChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AutocompleteChannelsForTeamForSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AutocompleteChannelsForTeamForSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AutocompleteChannelsForTeamForSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAutocompleteCommandsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Command
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r ListAutocompleteCommandsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAutocompleteCommandsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCommandAutocompleteSuggestionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AutocompleteSuggestion
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r ListCommandAutocompleteSuggestionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCommandAutocompleteSuggestionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileInfoList
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r SearchFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Group
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetGroupsByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsAssociatedToChannelsByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetGroupsAssociatedToChannelsByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsAssociatedToChannelsByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTeamIconResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r RemoveTeamIconResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTeamIconResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamIconResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetTeamIconResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamIconResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetTeamIconResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r SetTeamIconResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetTeamIconResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Results *string `json:"results,omitempty"`
	}
	JSON400 *BadRequest
	JSON403 *Forbidden
}

// Status returns HTTPResponse.Status
func (r ImportTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteGuestsToTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON413      *TooLarge
}

// Status returns HTTPResponse.Status
func (r InviteGuestsToTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteGuestsToTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteUsersToTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON413      *TooLarge
}

// Status returns HTTPResponse.Status
func (r InviteUsersToTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteUsersToTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamMember
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTeamMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTeamMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TeamMember
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AddTeamMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTeamMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTeamMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]TeamMember
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AddTeamMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTeamMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamMembersByIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamMember
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetTeamMembersByIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamMembersByIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTeamMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r RemoveTeamMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTeamMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamMember
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTeamMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTeamMemberRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateTeamMemberRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTeamMemberRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTeamMemberSchemeRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateTeamMemberSchemeRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTeamMemberSchemeRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamMembersMinusGroupMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r TeamMembersMinusGroupMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamMembersMinusGroupMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r PatchTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchPostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostListWithSearchMatches
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r SearchPostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchPostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTeamPrivacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateTeamPrivacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTeamPrivacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegenerateTeamInviteIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r RegenerateTeamInviteIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegenerateTeamInviteIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r RestoreTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTeamSchemeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UpdateTeamSchemeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTeamSchemeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamStats
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTeamStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTermsOfServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TermsOfService
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetTermsOfServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTermsOfServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTermsOfServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TermsOfService
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateTermsOfServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTermsOfServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestTrialLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r RequestTrialLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestTrialLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPrevTrialLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetPrevTrialLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPrevTrialLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpgradeToEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *PushNotification
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r UpgradeToEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpgradeToEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpgradeToEnterpriseStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Error Error happened during the upgrade
		Error *string `json:"error,omitempty"`

		// Percentage Current percentage of the upgrade
		Percentage *int `json:"percentage,omitempty"`
	}
	JSON403 *Forbidden
}

// Status returns HTTPResponse.Status
func (r UpgradeToEnterpriseStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpgradeToEnterpriseStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *UploadSession
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON413      *TooLarge
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CreateUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FileInfo
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON413      *TooLarge
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UploadDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostsUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostsUsage
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPostsUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostsUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStorageUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageUsage
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetStorageUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStorageUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermanentDeleteAllUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PermanentDeleteAllUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermanentDeleteAllUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
	JSON400      *BadRequest
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AutocompleteUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserAutocomplete
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r AutocompleteUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AutocompleteUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyUserEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r VerifyUserEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyUserEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendVerificationEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r SendVerificationEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendVerificationEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserByEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetUserByEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserByEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersByGroupChannelIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		LessThanCHANNELID *[]User `json:"<CHANNEL_ID>,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetUsersByGroupChannelIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersByGroupChannelIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersByIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetUsersByIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersByIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersWithInvalidEmailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetUsersWithInvalidEmailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersWithInvalidEmailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKnownUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KnownUsers
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetKnownUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKnownUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
	JSON400      *BadRequest
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginByCwsTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r LoginByCwsTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginByCwsTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SwitchAccountTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// FollowLink The link for the user to follow to login or to complete the account switching when the current service is OAuth2/SAML
		FollowLink *string `json:"follow_link,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r SwitchAccountTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SwitchAccountTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StatusOK
	JSON400      *BadRequest
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckUserMfaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// MfaRequired Value will `true` if MFA is active, `false` otherwise
		MfaRequired *bool `json:"mfa_required,omitempty"`
	}
	JSON400 *BadRequest
}

// Status returns HTTPResponse.Status
func (r CheckUserMfaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckUserMfaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrateAuthToLdapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r MigrateAuthToLdapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrateAuthToLdapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrateAuthToSamlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r MigrateAuthToSamlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrateAuthToSamlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r ResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendPasswordResetEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r SendPasswordResetEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendPasswordResetEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r SearchUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachDeviceExtraPropsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r AttachDeviceExtraPropsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachDeviceExtraPropsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeSessionsFromAllUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r RevokeSessionsFromAllUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeSessionsFromAllUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTotalUsersStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersStats
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTotalUsersStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTotalUsersStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTotalUsersStatsFilteredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersStats
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTotalUsersStatsFilteredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTotalUsersStatsFilteredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersStatusesByIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Status
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetUsersStatusesByIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersStatusesByIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserAccessTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserAccessTokenSanitized
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetUserAccessTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserAccessTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableUserAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r DisableUserAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableUserAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableUserAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r EnableUserAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableUserAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeUserAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r RevokeUserAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeUserAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUserAccessTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserAccessTokenSanitized
}

// Status returns HTTPResponse.Status
func (r SearchUserAccessTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUserAccessTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserAccessTokenSanitized
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetUserAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserByUsernameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetUserByUsernameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserByUsernameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersByUsernamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetUsersByUsernamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersByUsernamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserActiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r UpdateUserActiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserActiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserAuditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Audit
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetUserAuditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserAuditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserAuthData
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UpdateUserAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelMembersWithTeamDataForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ChannelMemberWithTeamData
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetChannelMembersWithTeamDataForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelMembersWithTeamDataForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetChannelsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostsAroundLastUnreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostList
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetPostsAroundLastUnreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostsAroundLastUnreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelUnreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelUnread
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetChannelUnreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelUnreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConvertUserToBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ConvertUserToBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConvertUserToBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelPoliciesForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RetentionPolicyForChannelList
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetChannelPoliciesForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelPoliciesForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamPoliciesForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RetentionPolicyForTeamList
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetTeamPoliciesForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamPoliciesForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DemoteUserToGuestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r DemoteUserToGuestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DemoteUserToGuestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyUserEmailWithoutTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r VerifyUserEmailWithoutTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyUserEmailWithoutTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsByUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Group
	JSON400      *BadRequest
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetGroupsByUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsByUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDefaultProfileImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r SetDefaultProfileImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDefaultProfileImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProfileImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetProfileImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProfileImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetProfileImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r SetProfileImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetProfileImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultProfileImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetDefaultProfileImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultProfileImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserMfaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r UpdateUserMfaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserMfaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateMfaSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// QrCode A base64 encoded QR code image
		QrCode *string `json:"qr_code,omitempty"`

		// Secret The MFA secret as a string
		Secret *string `json:"secret,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GenerateMfaSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateMfaSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorizedOAuthAppsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OAuthApp
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetAuthorizedOAuthAppsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorizedOAuthAppsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r UpdateUserPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r PatchUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlaggedPostsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PostList
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetFlaggedPostsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlaggedPostsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAcknowledgementForPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteAcknowledgementForPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAcknowledgementForPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveAcknowledgementForPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostAcknowledgement
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r SaveAcknowledgementForPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveAcknowledgementForPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r DeleteReactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPostReminderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r SetPostReminderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPostReminderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPostUnreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelUnreadAt
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r SetPostUnreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPostUnreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPreferencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Preference
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetPreferencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPreferencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePreferencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdatePreferencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePreferencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePreferencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r DeletePreferencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePreferencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPreferencesByCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Preference
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetPreferencesByCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPreferencesByCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPreferencesByCategoryByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preference
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetPreferencesByCategoryByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPreferencesByCategoryByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PromoteGuestToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PromoteGuestToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PromoteGuestToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r UpdateUserRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Session
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r RevokeSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeAllSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r RevokeAllSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeAllSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Status
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetUserStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Status
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UpdateUserStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnsetUserCustomStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UnsetUserCustomStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnsetUserCustomStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserCustomStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r UpdateUserCustomStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserCustomStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveRecentCustomStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r RemoveRecentCustomStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveRecentCustomStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUserRecentCustomStatusDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r PostUserRecentCustomStatusDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUserRecentCustomStatusDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetTeamsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamMembersForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamMember
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTeamMembersForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamMembersForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsUnreadForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamUnread
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetTeamsUnreadForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsUnreadForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelsForTeamForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Channel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetChannelsForTeamForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelsForTeamForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSidebarCategoriesForTeamForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrderedSidebarCategories
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetSidebarCategoriesForTeamForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSidebarCategoriesForTeamForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSidebarCategoryForTeamForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SidebarCategory
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r CreateSidebarCategoryForTeamForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSidebarCategoryForTeamForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSidebarCategoriesForTeamForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SidebarCategory
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateSidebarCategoriesForTeamForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSidebarCategoriesForTeamForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSidebarCategoryOrderForTeamForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetSidebarCategoryOrderForTeamForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSidebarCategoryOrderForTeamForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSidebarCategoryOrderForTeamForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateSidebarCategoryOrderForTeamForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSidebarCategoryOrderForTeamForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSidebarCategoryForTeamForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SidebarCategory
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r RemoveSidebarCategoryForTeamForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSidebarCategoryForTeamForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSidebarCategoryForTeamForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SidebarCategory
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetSidebarCategoryForTeamForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSidebarCategoryForTeamForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSidebarCategoryForTeamForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SidebarCategory
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateSidebarCategoryForTeamForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSidebarCategoryForTeamForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelMembersForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ChannelMember
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetChannelMembersForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelMembersForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserThreadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserThreads
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetUserThreadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserThreadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThreadMentionCountsByChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetThreadMentionCountsByChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThreadMentionCountsByChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateThreadsReadForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateThreadsReadForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateThreadsReadForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetUserThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopFollowingThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r StopFollowingThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopFollowingThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartFollowingThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r StartFollowingThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartFollowingThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateThreadReadForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateThreadReadForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateThreadReadForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetThreadUnreadByPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r SetThreadUnreadByPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetThreadUnreadByPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamUnreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamUnread
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTeamUnreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamUnreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserTermsOfServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserTermsOfService
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *AppError
}

// Status returns HTTPResponse.Status
func (r GetUserTermsOfServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserTermsOfServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterTermsOfServiceActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusOK
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r RegisterTermsOfServiceActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterTermsOfServiceActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserAccessTokensForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserAccessTokenSanitized
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r GetUserAccessTokensForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserAccessTokensForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *UserAccessToken
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r CreateUserAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublishUserTypingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
}

// Status returns HTTPResponse.Status
func (r PublishUserTypingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublishUserTypingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUploadsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UploadSession
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetUploadsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUploadsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilePublicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *AppError
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r GetFilePublicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilePublicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlaybookList
	JSON400      *N400
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetPlaybooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlaybookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Id string `json:"id"`
	}
	JSON400 *N400
	JSON403 *N403
	JSON500 *N500
}

// Status returns HTTPResponse.Status
func (r CreatePlaybookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlaybookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePlaybookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeletePlaybookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePlaybookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Playbook
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetPlaybookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePlaybookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r UpdatePlaybookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePlaybookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutoFollowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlaybookAutofollows
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetAutoFollowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutoFollowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlaybookRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlaybookRunList
	JSON400      *N400
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListPlaybookRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlaybookRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlaybookRunFromPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PlaybookRun
	JSON400      *N400
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r CreatePlaybookRunFromPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlaybookRunFromPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybookRunByChannelIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlaybookRun
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetPlaybookRunByChannelIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybookRunByChannelIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON400      *N400
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChecklistAutocompleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Helptext Always the value "Check/uncheck this item".
		Helptext string `json:"helptext"`

		// Hint The title of the corresponding item.
		Hint string `json:"hint"`

		// Item A string containing a pair of integers separated by a space. The first integer is the index of the checklist; the second is the index of the item within the checklist.
		Item string `json:"item"`
	}
	JSON500 *N500
}

// Status returns HTTPResponse.Status
func (r GetChecklistAutocompleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChecklistAutocompleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlaybookRunFromDialogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PlaybookRun
	JSON400      *N400
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r CreatePlaybookRunFromDialogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlaybookRunFromDialogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOwnersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OwnerInfo
	JSON400      *N400
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetOwnersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOwnersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybookRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlaybookRun
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetPlaybookRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybookRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePlaybookRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r UpdatePlaybookRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePlaybookRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddChecklistItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AddChecklistItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddChecklistItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ItemDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemRenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ItemRenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemRenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemSetAssigneeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ItemSetAssigneeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemSetAssigneeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TriggerIdReturn
	JSON400      *N400
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ItemRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemSetStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ItemSetStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemSetStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReoderChecklistItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ReoderChecklistItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReoderChecklistItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndPlaybookRunDialogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r EndPlaybookRunDialogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndPlaybookRunDialogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndPlaybookRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r EndPlaybookRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndPlaybookRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FinishResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r FinishResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FinishResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybookRunMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlaybookRunMetadata
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetPlaybookRunMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybookRunMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NextStageDialogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r NextStageDialogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NextStageDialogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangeOwnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ChangeOwnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangeOwnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartPlaybookRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r RestartPlaybookRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartPlaybookRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r StatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTimelineEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r RemoveTimelineEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTimelineEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// OpenInteractiveDialogWithBodyWithResponse request with arbitrary body returning *OpenInteractiveDialogResponse
func (c *ClientWithResponses) OpenInteractiveDialogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OpenInteractiveDialogResponse, error) {
	rsp, err := c.OpenInteractiveDialogWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOpenInteractiveDialogResponse(rsp)
}

func (c *ClientWithResponses) OpenInteractiveDialogWithResponse(ctx context.Context, body OpenInteractiveDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*OpenInteractiveDialogResponse, error) {
	rsp, err := c.OpenInteractiveDialog(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOpenInteractiveDialogResponse(rsp)
}

// SubmitInteractiveDialogWithBodyWithResponse request with arbitrary body returning *SubmitInteractiveDialogResponse
func (c *ClientWithResponses) SubmitInteractiveDialogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitInteractiveDialogResponse, error) {
	rsp, err := c.SubmitInteractiveDialogWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitInteractiveDialogResponse(rsp)
}

func (c *ClientWithResponses) SubmitInteractiveDialogWithResponse(ctx context.Context, body SubmitInteractiveDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitInteractiveDialogResponse, error) {
	rsp, err := c.SubmitInteractiveDialog(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitInteractiveDialogResponse(rsp)
}

// GetAnalyticsOldWithResponse request returning *GetAnalyticsOldResponse
func (c *ClientWithResponses) GetAnalyticsOldWithResponse(ctx context.Context, params *GetAnalyticsOldParams, reqEditors ...RequestEditorFn) (*GetAnalyticsOldResponse, error) {
	rsp, err := c.GetAnalyticsOld(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnalyticsOldResponse(rsp)
}

// GetAuditsWithResponse request returning *GetAuditsResponse
func (c *ClientWithResponses) GetAuditsWithResponse(ctx context.Context, params *GetAuditsParams, reqEditors ...RequestEditorFn) (*GetAuditsResponse, error) {
	rsp, err := c.GetAudits(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuditsResponse(rsp)
}

// PurgeBleveIndexesWithResponse request returning *PurgeBleveIndexesResponse
func (c *ClientWithResponses) PurgeBleveIndexesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PurgeBleveIndexesResponse, error) {
	rsp, err := c.PurgeBleveIndexes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgeBleveIndexesResponse(rsp)
}

// GetBotsWithResponse request returning *GetBotsResponse
func (c *ClientWithResponses) GetBotsWithResponse(ctx context.Context, params *GetBotsParams, reqEditors ...RequestEditorFn) (*GetBotsResponse, error) {
	rsp, err := c.GetBots(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBotsResponse(rsp)
}

// CreateBotWithBodyWithResponse request with arbitrary body returning *CreateBotResponse
func (c *ClientWithResponses) CreateBotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBotResponse, error) {
	rsp, err := c.CreateBotWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBotResponse(rsp)
}

func (c *ClientWithResponses) CreateBotWithResponse(ctx context.Context, body CreateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBotResponse, error) {
	rsp, err := c.CreateBot(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBotResponse(rsp)
}

// GetBotWithResponse request returning *GetBotResponse
func (c *ClientWithResponses) GetBotWithResponse(ctx context.Context, botUserId string, params *GetBotParams, reqEditors ...RequestEditorFn) (*GetBotResponse, error) {
	rsp, err := c.GetBot(ctx, botUserId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBotResponse(rsp)
}

// PatchBotWithBodyWithResponse request with arbitrary body returning *PatchBotResponse
func (c *ClientWithResponses) PatchBotWithBodyWithResponse(ctx context.Context, botUserId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchBotResponse, error) {
	rsp, err := c.PatchBotWithBody(ctx, botUserId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchBotResponse(rsp)
}

func (c *ClientWithResponses) PatchBotWithResponse(ctx context.Context, botUserId string, body PatchBotJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchBotResponse, error) {
	rsp, err := c.PatchBot(ctx, botUserId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchBotResponse(rsp)
}

// AssignBotWithResponse request returning *AssignBotResponse
func (c *ClientWithResponses) AssignBotWithResponse(ctx context.Context, botUserId string, userId string, reqEditors ...RequestEditorFn) (*AssignBotResponse, error) {
	rsp, err := c.AssignBot(ctx, botUserId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignBotResponse(rsp)
}

// ConvertBotToUserWithBodyWithResponse request with arbitrary body returning *ConvertBotToUserResponse
func (c *ClientWithResponses) ConvertBotToUserWithBodyWithResponse(ctx context.Context, botUserId string, params *ConvertBotToUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertBotToUserResponse, error) {
	rsp, err := c.ConvertBotToUserWithBody(ctx, botUserId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertBotToUserResponse(rsp)
}

func (c *ClientWithResponses) ConvertBotToUserWithResponse(ctx context.Context, botUserId string, params *ConvertBotToUserParams, body ConvertBotToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertBotToUserResponse, error) {
	rsp, err := c.ConvertBotToUser(ctx, botUserId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertBotToUserResponse(rsp)
}

// DisableBotWithResponse request returning *DisableBotResponse
func (c *ClientWithResponses) DisableBotWithResponse(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*DisableBotResponse, error) {
	rsp, err := c.DisableBot(ctx, botUserId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableBotResponse(rsp)
}

// EnableBotWithResponse request returning *EnableBotResponse
func (c *ClientWithResponses) EnableBotWithResponse(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*EnableBotResponse, error) {
	rsp, err := c.EnableBot(ctx, botUserId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableBotResponse(rsp)
}

// DeleteBotIconImageWithResponse request returning *DeleteBotIconImageResponse
func (c *ClientWithResponses) DeleteBotIconImageWithResponse(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*DeleteBotIconImageResponse, error) {
	rsp, err := c.DeleteBotIconImage(ctx, botUserId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBotIconImageResponse(rsp)
}

// GetBotIconImageWithResponse request returning *GetBotIconImageResponse
func (c *ClientWithResponses) GetBotIconImageWithResponse(ctx context.Context, botUserId string, reqEditors ...RequestEditorFn) (*GetBotIconImageResponse, error) {
	rsp, err := c.GetBotIconImage(ctx, botUserId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBotIconImageResponse(rsp)
}

// SetBotIconImageWithBodyWithResponse request with arbitrary body returning *SetBotIconImageResponse
func (c *ClientWithResponses) SetBotIconImageWithBodyWithResponse(ctx context.Context, botUserId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBotIconImageResponse, error) {
	rsp, err := c.SetBotIconImageWithBody(ctx, botUserId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBotIconImageResponse(rsp)
}

// DeleteBrandImageWithResponse request returning *DeleteBrandImageResponse
func (c *ClientWithResponses) DeleteBrandImageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteBrandImageResponse, error) {
	rsp, err := c.DeleteBrandImage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBrandImageResponse(rsp)
}

// GetBrandImageWithResponse request returning *GetBrandImageResponse
func (c *ClientWithResponses) GetBrandImageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBrandImageResponse, error) {
	rsp, err := c.GetBrandImage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBrandImageResponse(rsp)
}

// UploadBrandImageWithBodyWithResponse request with arbitrary body returning *UploadBrandImageResponse
func (c *ClientWithResponses) UploadBrandImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadBrandImageResponse, error) {
	rsp, err := c.UploadBrandImageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadBrandImageResponse(rsp)
}

// InvalidateCachesWithResponse request returning *InvalidateCachesResponse
func (c *ClientWithResponses) InvalidateCachesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InvalidateCachesResponse, error) {
	rsp, err := c.InvalidateCaches(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvalidateCachesResponse(rsp)
}

// GetAllChannelsWithResponse request returning *GetAllChannelsResponse
func (c *ClientWithResponses) GetAllChannelsWithResponse(ctx context.Context, params *GetAllChannelsParams, reqEditors ...RequestEditorFn) (*GetAllChannelsResponse, error) {
	rsp, err := c.GetAllChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllChannelsResponse(rsp)
}

// CreateChannelWithBodyWithResponse request with arbitrary body returning *CreateChannelResponse
func (c *ClientWithResponses) CreateChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateChannelResponse, error) {
	rsp, err := c.CreateChannelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateChannelResponse(rsp)
}

func (c *ClientWithResponses) CreateChannelWithResponse(ctx context.Context, body CreateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateChannelResponse, error) {
	rsp, err := c.CreateChannel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateChannelResponse(rsp)
}

// CreateDirectChannelWithBodyWithResponse request with arbitrary body returning *CreateDirectChannelResponse
func (c *ClientWithResponses) CreateDirectChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectChannelResponse, error) {
	rsp, err := c.CreateDirectChannelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectChannelResponse(rsp)
}

func (c *ClientWithResponses) CreateDirectChannelWithResponse(ctx context.Context, body CreateDirectChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectChannelResponse, error) {
	rsp, err := c.CreateDirectChannel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectChannelResponse(rsp)
}

// CreateGroupChannelWithBodyWithResponse request with arbitrary body returning *CreateGroupChannelResponse
func (c *ClientWithResponses) CreateGroupChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupChannelResponse, error) {
	rsp, err := c.CreateGroupChannelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupChannelResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupChannelWithResponse(ctx context.Context, body CreateGroupChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupChannelResponse, error) {
	rsp, err := c.CreateGroupChannel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupChannelResponse(rsp)
}

// SearchGroupChannelsWithBodyWithResponse request with arbitrary body returning *SearchGroupChannelsResponse
func (c *ClientWithResponses) SearchGroupChannelsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchGroupChannelsResponse, error) {
	rsp, err := c.SearchGroupChannelsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupChannelsResponse(rsp)
}

func (c *ClientWithResponses) SearchGroupChannelsWithResponse(ctx context.Context, body SearchGroupChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchGroupChannelsResponse, error) {
	rsp, err := c.SearchGroupChannels(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGroupChannelsResponse(rsp)
}

// ViewChannelWithBodyWithResponse request with arbitrary body returning *ViewChannelResponse
func (c *ClientWithResponses) ViewChannelWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ViewChannelResponse, error) {
	rsp, err := c.ViewChannelWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseViewChannelResponse(rsp)
}

func (c *ClientWithResponses) ViewChannelWithResponse(ctx context.Context, userId string, body ViewChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*ViewChannelResponse, error) {
	rsp, err := c.ViewChannel(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseViewChannelResponse(rsp)
}

// SearchAllChannelsWithBodyWithResponse request with arbitrary body returning *SearchAllChannelsResponse
func (c *ClientWithResponses) SearchAllChannelsWithBodyWithResponse(ctx context.Context, params *SearchAllChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchAllChannelsResponse, error) {
	rsp, err := c.SearchAllChannelsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchAllChannelsResponse(rsp)
}

func (c *ClientWithResponses) SearchAllChannelsWithResponse(ctx context.Context, params *SearchAllChannelsParams, body SearchAllChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchAllChannelsResponse, error) {
	rsp, err := c.SearchAllChannels(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchAllChannelsResponse(rsp)
}

// DeleteChannelWithResponse request returning *DeleteChannelResponse
func (c *ClientWithResponses) DeleteChannelWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*DeleteChannelResponse, error) {
	rsp, err := c.DeleteChannel(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteChannelResponse(rsp)
}

// GetChannelWithResponse request returning *GetChannelResponse
func (c *ClientWithResponses) GetChannelWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetChannelResponse, error) {
	rsp, err := c.GetChannel(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelResponse(rsp)
}

// UpdateChannelWithBodyWithResponse request with arbitrary body returning *UpdateChannelResponse
func (c *ClientWithResponses) UpdateChannelWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelResponse, error) {
	rsp, err := c.UpdateChannelWithBody(ctx, channelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelResponse(rsp)
}

func (c *ClientWithResponses) UpdateChannelWithResponse(ctx context.Context, channelId string, body UpdateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelResponse, error) {
	rsp, err := c.UpdateChannel(ctx, channelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelResponse(rsp)
}

// ListChannelBookmarksForChannelWithResponse request returning *ListChannelBookmarksForChannelResponse
func (c *ClientWithResponses) ListChannelBookmarksForChannelWithResponse(ctx context.Context, channelId string, params *ListChannelBookmarksForChannelParams, reqEditors ...RequestEditorFn) (*ListChannelBookmarksForChannelResponse, error) {
	rsp, err := c.ListChannelBookmarksForChannel(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListChannelBookmarksForChannelResponse(rsp)
}

// CreateChannelBookmarkWithBodyWithResponse request with arbitrary body returning *CreateChannelBookmarkResponse
func (c *ClientWithResponses) CreateChannelBookmarkWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateChannelBookmarkResponse, error) {
	rsp, err := c.CreateChannelBookmarkWithBody(ctx, channelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateChannelBookmarkResponse(rsp)
}

func (c *ClientWithResponses) CreateChannelBookmarkWithResponse(ctx context.Context, channelId string, body CreateChannelBookmarkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateChannelBookmarkResponse, error) {
	rsp, err := c.CreateChannelBookmark(ctx, channelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateChannelBookmarkResponse(rsp)
}

// DeleteChannelBookmarkWithResponse request returning *DeleteChannelBookmarkResponse
func (c *ClientWithResponses) DeleteChannelBookmarkWithResponse(ctx context.Context, channelId string, bookmarkId string, reqEditors ...RequestEditorFn) (*DeleteChannelBookmarkResponse, error) {
	rsp, err := c.DeleteChannelBookmark(ctx, channelId, bookmarkId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteChannelBookmarkResponse(rsp)
}

// UpdateChannelBookmarkWithBodyWithResponse request with arbitrary body returning *UpdateChannelBookmarkResponse
func (c *ClientWithResponses) UpdateChannelBookmarkWithBodyWithResponse(ctx context.Context, channelId string, bookmarkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelBookmarkResponse, error) {
	rsp, err := c.UpdateChannelBookmarkWithBody(ctx, channelId, bookmarkId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelBookmarkResponse(rsp)
}

func (c *ClientWithResponses) UpdateChannelBookmarkWithResponse(ctx context.Context, channelId string, bookmarkId string, body UpdateChannelBookmarkJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelBookmarkResponse, error) {
	rsp, err := c.UpdateChannelBookmark(ctx, channelId, bookmarkId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelBookmarkResponse(rsp)
}

// UpdateChannelBookmarkSortOrderWithBodyWithResponse request with arbitrary body returning *UpdateChannelBookmarkSortOrderResponse
func (c *ClientWithResponses) UpdateChannelBookmarkSortOrderWithBodyWithResponse(ctx context.Context, channelId string, bookmarkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelBookmarkSortOrderResponse, error) {
	rsp, err := c.UpdateChannelBookmarkSortOrderWithBody(ctx, channelId, bookmarkId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelBookmarkSortOrderResponse(rsp)
}

func (c *ClientWithResponses) UpdateChannelBookmarkSortOrderWithResponse(ctx context.Context, channelId string, bookmarkId string, body UpdateChannelBookmarkSortOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelBookmarkSortOrderResponse, error) {
	rsp, err := c.UpdateChannelBookmarkSortOrder(ctx, channelId, bookmarkId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelBookmarkSortOrderResponse(rsp)
}

// GetGroupsByChannelWithResponse request returning *GetGroupsByChannelResponse
func (c *ClientWithResponses) GetGroupsByChannelWithResponse(ctx context.Context, channelId string, params *GetGroupsByChannelParams, reqEditors ...RequestEditorFn) (*GetGroupsByChannelResponse, error) {
	rsp, err := c.GetGroupsByChannel(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsByChannelResponse(rsp)
}

// GetChannelMemberCountsByGroupWithResponse request returning *GetChannelMemberCountsByGroupResponse
func (c *ClientWithResponses) GetChannelMemberCountsByGroupWithResponse(ctx context.Context, channelId string, params *GetChannelMemberCountsByGroupParams, reqEditors ...RequestEditorFn) (*GetChannelMemberCountsByGroupResponse, error) {
	rsp, err := c.GetChannelMemberCountsByGroup(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelMemberCountsByGroupResponse(rsp)
}

// GetChannelMembersWithResponse request returning *GetChannelMembersResponse
func (c *ClientWithResponses) GetChannelMembersWithResponse(ctx context.Context, channelId string, params *GetChannelMembersParams, reqEditors ...RequestEditorFn) (*GetChannelMembersResponse, error) {
	rsp, err := c.GetChannelMembers(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelMembersResponse(rsp)
}

// AddChannelMemberWithBodyWithResponse request with arbitrary body returning *AddChannelMemberResponse
func (c *ClientWithResponses) AddChannelMemberWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddChannelMemberResponse, error) {
	rsp, err := c.AddChannelMemberWithBody(ctx, channelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddChannelMemberResponse(rsp)
}

func (c *ClientWithResponses) AddChannelMemberWithResponse(ctx context.Context, channelId string, body AddChannelMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*AddChannelMemberResponse, error) {
	rsp, err := c.AddChannelMember(ctx, channelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddChannelMemberResponse(rsp)
}

// GetChannelMembersByIdsWithBodyWithResponse request with arbitrary body returning *GetChannelMembersByIdsResponse
func (c *ClientWithResponses) GetChannelMembersByIdsWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetChannelMembersByIdsResponse, error) {
	rsp, err := c.GetChannelMembersByIdsWithBody(ctx, channelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelMembersByIdsResponse(rsp)
}

func (c *ClientWithResponses) GetChannelMembersByIdsWithResponse(ctx context.Context, channelId string, body GetChannelMembersByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetChannelMembersByIdsResponse, error) {
	rsp, err := c.GetChannelMembersByIds(ctx, channelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelMembersByIdsResponse(rsp)
}

// RemoveUserFromChannelWithResponse request returning *RemoveUserFromChannelResponse
func (c *ClientWithResponses) RemoveUserFromChannelWithResponse(ctx context.Context, channelId string, userId string, reqEditors ...RequestEditorFn) (*RemoveUserFromChannelResponse, error) {
	rsp, err := c.RemoveUserFromChannel(ctx, channelId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserFromChannelResponse(rsp)
}

// GetChannelMemberWithResponse request returning *GetChannelMemberResponse
func (c *ClientWithResponses) GetChannelMemberWithResponse(ctx context.Context, channelId string, userId string, reqEditors ...RequestEditorFn) (*GetChannelMemberResponse, error) {
	rsp, err := c.GetChannelMember(ctx, channelId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelMemberResponse(rsp)
}

// UpdateChannelNotifyPropsWithBodyWithResponse request with arbitrary body returning *UpdateChannelNotifyPropsResponse
func (c *ClientWithResponses) UpdateChannelNotifyPropsWithBodyWithResponse(ctx context.Context, channelId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelNotifyPropsResponse, error) {
	rsp, err := c.UpdateChannelNotifyPropsWithBody(ctx, channelId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelNotifyPropsResponse(rsp)
}

func (c *ClientWithResponses) UpdateChannelNotifyPropsWithResponse(ctx context.Context, channelId string, userId string, body UpdateChannelNotifyPropsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelNotifyPropsResponse, error) {
	rsp, err := c.UpdateChannelNotifyProps(ctx, channelId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelNotifyPropsResponse(rsp)
}

// UpdateChannelRolesWithBodyWithResponse request with arbitrary body returning *UpdateChannelRolesResponse
func (c *ClientWithResponses) UpdateChannelRolesWithBodyWithResponse(ctx context.Context, channelId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelRolesResponse, error) {
	rsp, err := c.UpdateChannelRolesWithBody(ctx, channelId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelRolesResponse(rsp)
}

func (c *ClientWithResponses) UpdateChannelRolesWithResponse(ctx context.Context, channelId string, userId string, body UpdateChannelRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelRolesResponse, error) {
	rsp, err := c.UpdateChannelRoles(ctx, channelId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelRolesResponse(rsp)
}

// UpdateChannelMemberSchemeRolesWithBodyWithResponse request with arbitrary body returning *UpdateChannelMemberSchemeRolesResponse
func (c *ClientWithResponses) UpdateChannelMemberSchemeRolesWithBodyWithResponse(ctx context.Context, channelId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelMemberSchemeRolesResponse, error) {
	rsp, err := c.UpdateChannelMemberSchemeRolesWithBody(ctx, channelId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelMemberSchemeRolesResponse(rsp)
}

func (c *ClientWithResponses) UpdateChannelMemberSchemeRolesWithResponse(ctx context.Context, channelId string, userId string, body UpdateChannelMemberSchemeRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelMemberSchemeRolesResponse, error) {
	rsp, err := c.UpdateChannelMemberSchemeRoles(ctx, channelId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelMemberSchemeRolesResponse(rsp)
}

// ChannelMembersMinusGroupMembersWithResponse request returning *ChannelMembersMinusGroupMembersResponse
func (c *ClientWithResponses) ChannelMembersMinusGroupMembersWithResponse(ctx context.Context, channelId string, params *ChannelMembersMinusGroupMembersParams, reqEditors ...RequestEditorFn) (*ChannelMembersMinusGroupMembersResponse, error) {
	rsp, err := c.ChannelMembersMinusGroupMembers(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChannelMembersMinusGroupMembersResponse(rsp)
}

// GetChannelModerationsWithResponse request returning *GetChannelModerationsResponse
func (c *ClientWithResponses) GetChannelModerationsWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetChannelModerationsResponse, error) {
	rsp, err := c.GetChannelModerations(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelModerationsResponse(rsp)
}

// PatchChannelModerationsWithBodyWithResponse request with arbitrary body returning *PatchChannelModerationsResponse
func (c *ClientWithResponses) PatchChannelModerationsWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchChannelModerationsResponse, error) {
	rsp, err := c.PatchChannelModerationsWithBody(ctx, channelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchChannelModerationsResponse(rsp)
}

func (c *ClientWithResponses) PatchChannelModerationsWithResponse(ctx context.Context, channelId string, body PatchChannelModerationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchChannelModerationsResponse, error) {
	rsp, err := c.PatchChannelModerations(ctx, channelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchChannelModerationsResponse(rsp)
}

// MoveChannelWithBodyWithResponse request with arbitrary body returning *MoveChannelResponse
func (c *ClientWithResponses) MoveChannelWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveChannelResponse, error) {
	rsp, err := c.MoveChannelWithBody(ctx, channelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveChannelResponse(rsp)
}

func (c *ClientWithResponses) MoveChannelWithResponse(ctx context.Context, channelId string, body MoveChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveChannelResponse, error) {
	rsp, err := c.MoveChannel(ctx, channelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveChannelResponse(rsp)
}

// PatchChannelWithBodyWithResponse request with arbitrary body returning *PatchChannelResponse
func (c *ClientWithResponses) PatchChannelWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchChannelResponse, error) {
	rsp, err := c.PatchChannelWithBody(ctx, channelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchChannelResponse(rsp)
}

func (c *ClientWithResponses) PatchChannelWithResponse(ctx context.Context, channelId string, body PatchChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchChannelResponse, error) {
	rsp, err := c.PatchChannel(ctx, channelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchChannelResponse(rsp)
}

// GetPinnedPostsWithResponse request returning *GetPinnedPostsResponse
func (c *ClientWithResponses) GetPinnedPostsWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetPinnedPostsResponse, error) {
	rsp, err := c.GetPinnedPosts(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPinnedPostsResponse(rsp)
}

// GetPostsForChannelWithResponse request returning *GetPostsForChannelResponse
func (c *ClientWithResponses) GetPostsForChannelWithResponse(ctx context.Context, channelId string, params *GetPostsForChannelParams, reqEditors ...RequestEditorFn) (*GetPostsForChannelResponse, error) {
	rsp, err := c.GetPostsForChannel(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostsForChannelResponse(rsp)
}

// UpdateChannelPrivacyWithBodyWithResponse request with arbitrary body returning *UpdateChannelPrivacyResponse
func (c *ClientWithResponses) UpdateChannelPrivacyWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelPrivacyResponse, error) {
	rsp, err := c.UpdateChannelPrivacyWithBody(ctx, channelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelPrivacyResponse(rsp)
}

func (c *ClientWithResponses) UpdateChannelPrivacyWithResponse(ctx context.Context, channelId string, body UpdateChannelPrivacyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelPrivacyResponse, error) {
	rsp, err := c.UpdateChannelPrivacy(ctx, channelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelPrivacyResponse(rsp)
}

// RestoreChannelWithResponse request returning *RestoreChannelResponse
func (c *ClientWithResponses) RestoreChannelWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*RestoreChannelResponse, error) {
	rsp, err := c.RestoreChannel(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreChannelResponse(rsp)
}

// UpdateChannelSchemeWithBodyWithResponse request with arbitrary body returning *UpdateChannelSchemeResponse
func (c *ClientWithResponses) UpdateChannelSchemeWithBodyWithResponse(ctx context.Context, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelSchemeResponse, error) {
	rsp, err := c.UpdateChannelSchemeWithBody(ctx, channelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelSchemeResponse(rsp)
}

func (c *ClientWithResponses) UpdateChannelSchemeWithResponse(ctx context.Context, channelId string, body UpdateChannelSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelSchemeResponse, error) {
	rsp, err := c.UpdateChannelScheme(ctx, channelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelSchemeResponse(rsp)
}

// GetChannelStatsWithResponse request returning *GetChannelStatsResponse
func (c *ClientWithResponses) GetChannelStatsWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetChannelStatsResponse, error) {
	rsp, err := c.GetChannelStats(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelStatsResponse(rsp)
}

// GetChannelMembersTimezonesWithResponse request returning *GetChannelMembersTimezonesResponse
func (c *ClientWithResponses) GetChannelMembersTimezonesWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetChannelMembersTimezonesResponse, error) {
	rsp, err := c.GetChannelMembersTimezones(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelMembersTimezonesResponse(rsp)
}

// SubmitPerformanceReportWithBodyWithResponse request with arbitrary body returning *SubmitPerformanceReportResponse
func (c *ClientWithResponses) SubmitPerformanceReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitPerformanceReportResponse, error) {
	rsp, err := c.SubmitPerformanceReportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitPerformanceReportResponse(rsp)
}

func (c *ClientWithResponses) SubmitPerformanceReportWithResponse(ctx context.Context, body SubmitPerformanceReportJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitPerformanceReportResponse, error) {
	rsp, err := c.SubmitPerformanceReport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitPerformanceReportResponse(rsp)
}

// GetCloudCustomerWithResponse request returning *GetCloudCustomerResponse
func (c *ClientWithResponses) GetCloudCustomerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCloudCustomerResponse, error) {
	rsp, err := c.GetCloudCustomer(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCloudCustomerResponse(rsp)
}

// UpdateCloudCustomerWithBodyWithResponse request with arbitrary body returning *UpdateCloudCustomerResponse
func (c *ClientWithResponses) UpdateCloudCustomerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCloudCustomerResponse, error) {
	rsp, err := c.UpdateCloudCustomerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCloudCustomerResponse(rsp)
}

func (c *ClientWithResponses) UpdateCloudCustomerWithResponse(ctx context.Context, body UpdateCloudCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCloudCustomerResponse, error) {
	rsp, err := c.UpdateCloudCustomer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCloudCustomerResponse(rsp)
}

// UpdateCloudCustomerAddressWithBodyWithResponse request with arbitrary body returning *UpdateCloudCustomerAddressResponse
func (c *ClientWithResponses) UpdateCloudCustomerAddressWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCloudCustomerAddressResponse, error) {
	rsp, err := c.UpdateCloudCustomerAddressWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCloudCustomerAddressResponse(rsp)
}

func (c *ClientWithResponses) UpdateCloudCustomerAddressWithResponse(ctx context.Context, body UpdateCloudCustomerAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCloudCustomerAddressResponse, error) {
	rsp, err := c.UpdateCloudCustomerAddress(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCloudCustomerAddressResponse(rsp)
}

// GetEndpointForInstallationInformationWithResponse request returning *GetEndpointForInstallationInformationResponse
func (c *ClientWithResponses) GetEndpointForInstallationInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEndpointForInstallationInformationResponse, error) {
	rsp, err := c.GetEndpointForInstallationInformation(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEndpointForInstallationInformationResponse(rsp)
}

// GetCloudLimitsWithResponse request returning *GetCloudLimitsResponse
func (c *ClientWithResponses) GetCloudLimitsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCloudLimitsResponse, error) {
	rsp, err := c.GetCloudLimits(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCloudLimitsResponse(rsp)
}

// CreateCustomerPaymentWithResponse request returning *CreateCustomerPaymentResponse
func (c *ClientWithResponses) CreateCustomerPaymentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateCustomerPaymentResponse, error) {
	rsp, err := c.CreateCustomerPayment(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomerPaymentResponse(rsp)
}

// ConfirmCustomerPaymentWithBodyWithResponse request with arbitrary body returning *ConfirmCustomerPaymentResponse
func (c *ClientWithResponses) ConfirmCustomerPaymentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmCustomerPaymentResponse, error) {
	rsp, err := c.ConfirmCustomerPaymentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmCustomerPaymentResponse(rsp)
}

// GetCloudProductsWithResponse request returning *GetCloudProductsResponse
func (c *ClientWithResponses) GetCloudProductsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCloudProductsResponse, error) {
	rsp, err := c.GetCloudProducts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCloudProductsResponse(rsp)
}

// GetSubscriptionWithResponse request returning *GetSubscriptionResponse
func (c *ClientWithResponses) GetSubscriptionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSubscriptionResponse, error) {
	rsp, err := c.GetSubscription(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionResponse(rsp)
}

// GetInvoicesForSubscriptionWithResponse request returning *GetInvoicesForSubscriptionResponse
func (c *ClientWithResponses) GetInvoicesForSubscriptionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInvoicesForSubscriptionResponse, error) {
	rsp, err := c.GetInvoicesForSubscription(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesForSubscriptionResponse(rsp)
}

// GetInvoiceForSubscriptionAsPdfWithResponse request returning *GetInvoiceForSubscriptionAsPdfResponse
func (c *ClientWithResponses) GetInvoiceForSubscriptionAsPdfWithResponse(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*GetInvoiceForSubscriptionAsPdfResponse, error) {
	rsp, err := c.GetInvoiceForSubscriptionAsPdf(ctx, invoiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoiceForSubscriptionAsPdfResponse(rsp)
}

// PostEndpointForCwsWebhooksWithResponse request returning *PostEndpointForCwsWebhooksResponse
func (c *ClientWithResponses) PostEndpointForCwsWebhooksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostEndpointForCwsWebhooksResponse, error) {
	rsp, err := c.PostEndpointForCwsWebhooks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEndpointForCwsWebhooksResponse(rsp)
}

// GetClusterStatusWithResponse request returning *GetClusterStatusResponse
func (c *ClientWithResponses) GetClusterStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterStatusResponse, error) {
	rsp, err := c.GetClusterStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterStatusResponse(rsp)
}

// ListCommandsWithResponse request returning *ListCommandsResponse
func (c *ClientWithResponses) ListCommandsWithResponse(ctx context.Context, params *ListCommandsParams, reqEditors ...RequestEditorFn) (*ListCommandsResponse, error) {
	rsp, err := c.ListCommands(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCommandsResponse(rsp)
}

// CreateCommandWithBodyWithResponse request with arbitrary body returning *CreateCommandResponse
func (c *ClientWithResponses) CreateCommandWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommandResponse, error) {
	rsp, err := c.CreateCommandWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommandResponse(rsp)
}

func (c *ClientWithResponses) CreateCommandWithResponse(ctx context.Context, body CreateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommandResponse, error) {
	rsp, err := c.CreateCommand(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommandResponse(rsp)
}

// ExecuteCommandWithBodyWithResponse request with arbitrary body returning *ExecuteCommandResponse
func (c *ClientWithResponses) ExecuteCommandWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteCommandResponse, error) {
	rsp, err := c.ExecuteCommandWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteCommandResponse(rsp)
}

func (c *ClientWithResponses) ExecuteCommandWithResponse(ctx context.Context, body ExecuteCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteCommandResponse, error) {
	rsp, err := c.ExecuteCommand(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteCommandResponse(rsp)
}

// DeleteCommandWithResponse request returning *DeleteCommandResponse
func (c *ClientWithResponses) DeleteCommandWithResponse(ctx context.Context, commandId string, reqEditors ...RequestEditorFn) (*DeleteCommandResponse, error) {
	rsp, err := c.DeleteCommand(ctx, commandId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCommandResponse(rsp)
}

// GetCommandByIdWithResponse request returning *GetCommandByIdResponse
func (c *ClientWithResponses) GetCommandByIdWithResponse(ctx context.Context, commandId string, reqEditors ...RequestEditorFn) (*GetCommandByIdResponse, error) {
	rsp, err := c.GetCommandById(ctx, commandId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommandByIdResponse(rsp)
}

// UpdateCommandWithBodyWithResponse request with arbitrary body returning *UpdateCommandResponse
func (c *ClientWithResponses) UpdateCommandWithBodyWithResponse(ctx context.Context, commandId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCommandResponse, error) {
	rsp, err := c.UpdateCommandWithBody(ctx, commandId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCommandResponse(rsp)
}

func (c *ClientWithResponses) UpdateCommandWithResponse(ctx context.Context, commandId string, body UpdateCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCommandResponse, error) {
	rsp, err := c.UpdateCommand(ctx, commandId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCommandResponse(rsp)
}

// MoveCommandWithBodyWithResponse request with arbitrary body returning *MoveCommandResponse
func (c *ClientWithResponses) MoveCommandWithBodyWithResponse(ctx context.Context, commandId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveCommandResponse, error) {
	rsp, err := c.MoveCommandWithBody(ctx, commandId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveCommandResponse(rsp)
}

func (c *ClientWithResponses) MoveCommandWithResponse(ctx context.Context, commandId string, body MoveCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveCommandResponse, error) {
	rsp, err := c.MoveCommand(ctx, commandId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveCommandResponse(rsp)
}

// RegenCommandTokenWithResponse request returning *RegenCommandTokenResponse
func (c *ClientWithResponses) RegenCommandTokenWithResponse(ctx context.Context, commandId string, reqEditors ...RequestEditorFn) (*RegenCommandTokenResponse, error) {
	rsp, err := c.RegenCommandToken(ctx, commandId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegenCommandTokenResponse(rsp)
}

// GetComplianceReportsWithResponse request returning *GetComplianceReportsResponse
func (c *ClientWithResponses) GetComplianceReportsWithResponse(ctx context.Context, params *GetComplianceReportsParams, reqEditors ...RequestEditorFn) (*GetComplianceReportsResponse, error) {
	rsp, err := c.GetComplianceReports(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComplianceReportsResponse(rsp)
}

// CreateComplianceReportWithResponse request returning *CreateComplianceReportResponse
func (c *ClientWithResponses) CreateComplianceReportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateComplianceReportResponse, error) {
	rsp, err := c.CreateComplianceReport(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateComplianceReportResponse(rsp)
}

// GetComplianceReportWithResponse request returning *GetComplianceReportResponse
func (c *ClientWithResponses) GetComplianceReportWithResponse(ctx context.Context, reportId string, reqEditors ...RequestEditorFn) (*GetComplianceReportResponse, error) {
	rsp, err := c.GetComplianceReport(ctx, reportId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComplianceReportResponse(rsp)
}

// DownloadComplianceReportWithResponse request returning *DownloadComplianceReportResponse
func (c *ClientWithResponses) DownloadComplianceReportWithResponse(ctx context.Context, reportId string, reqEditors ...RequestEditorFn) (*DownloadComplianceReportResponse, error) {
	rsp, err := c.DownloadComplianceReport(ctx, reportId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadComplianceReportResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// UpdateConfigWithBodyWithResponse request with arbitrary body returning *UpdateConfigResponse
func (c *ClientWithResponses) UpdateConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateConfigWithResponse(ctx context.Context, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

// GetClientConfigWithResponse request returning *GetClientConfigResponse
func (c *ClientWithResponses) GetClientConfigWithResponse(ctx context.Context, params *GetClientConfigParams, reqEditors ...RequestEditorFn) (*GetClientConfigResponse, error) {
	rsp, err := c.GetClientConfig(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientConfigResponse(rsp)
}

// GetEnvironmentConfigWithResponse request returning *GetEnvironmentConfigResponse
func (c *ClientWithResponses) GetEnvironmentConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEnvironmentConfigResponse, error) {
	rsp, err := c.GetEnvironmentConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentConfigResponse(rsp)
}

// PatchConfigWithBodyWithResponse request with arbitrary body returning *PatchConfigResponse
func (c *ClientWithResponses) PatchConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchConfigResponse, error) {
	rsp, err := c.PatchConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchConfigResponse(rsp)
}

func (c *ClientWithResponses) PatchConfigWithResponse(ctx context.Context, body PatchConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchConfigResponse, error) {
	rsp, err := c.PatchConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchConfigResponse(rsp)
}

// ReloadConfigWithResponse request returning *ReloadConfigResponse
func (c *ClientWithResponses) ReloadConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReloadConfigResponse, error) {
	rsp, err := c.ReloadConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReloadConfigResponse(rsp)
}

// GetDataRetentionPoliciesWithResponse request returning *GetDataRetentionPoliciesResponse
func (c *ClientWithResponses) GetDataRetentionPoliciesWithResponse(ctx context.Context, params *GetDataRetentionPoliciesParams, reqEditors ...RequestEditorFn) (*GetDataRetentionPoliciesResponse, error) {
	rsp, err := c.GetDataRetentionPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataRetentionPoliciesResponse(rsp)
}

// CreateDataRetentionPolicyWithBodyWithResponse request with arbitrary body returning *CreateDataRetentionPolicyResponse
func (c *ClientWithResponses) CreateDataRetentionPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDataRetentionPolicyResponse, error) {
	rsp, err := c.CreateDataRetentionPolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDataRetentionPolicyResponse(rsp)
}

func (c *ClientWithResponses) CreateDataRetentionPolicyWithResponse(ctx context.Context, body CreateDataRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDataRetentionPolicyResponse, error) {
	rsp, err := c.CreateDataRetentionPolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDataRetentionPolicyResponse(rsp)
}

// DeleteDataRetentionPolicyWithResponse request returning *DeleteDataRetentionPolicyResponse
func (c *ClientWithResponses) DeleteDataRetentionPolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*DeleteDataRetentionPolicyResponse, error) {
	rsp, err := c.DeleteDataRetentionPolicy(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDataRetentionPolicyResponse(rsp)
}

// GetDataRetentionPolicyByIDWithResponse request returning *GetDataRetentionPolicyByIDResponse
func (c *ClientWithResponses) GetDataRetentionPolicyByIDWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetDataRetentionPolicyByIDResponse, error) {
	rsp, err := c.GetDataRetentionPolicyByID(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataRetentionPolicyByIDResponse(rsp)
}

// PatchDataRetentionPolicyWithBodyWithResponse request with arbitrary body returning *PatchDataRetentionPolicyResponse
func (c *ClientWithResponses) PatchDataRetentionPolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchDataRetentionPolicyResponse, error) {
	rsp, err := c.PatchDataRetentionPolicyWithBody(ctx, policyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchDataRetentionPolicyResponse(rsp)
}

func (c *ClientWithResponses) PatchDataRetentionPolicyWithResponse(ctx context.Context, policyId string, body PatchDataRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchDataRetentionPolicyResponse, error) {
	rsp, err := c.PatchDataRetentionPolicy(ctx, policyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchDataRetentionPolicyResponse(rsp)
}

// RemoveChannelsFromRetentionPolicyWithBodyWithResponse request with arbitrary body returning *RemoveChannelsFromRetentionPolicyResponse
func (c *ClientWithResponses) RemoveChannelsFromRetentionPolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveChannelsFromRetentionPolicyResponse, error) {
	rsp, err := c.RemoveChannelsFromRetentionPolicyWithBody(ctx, policyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveChannelsFromRetentionPolicyResponse(rsp)
}

func (c *ClientWithResponses) RemoveChannelsFromRetentionPolicyWithResponse(ctx context.Context, policyId string, body RemoveChannelsFromRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveChannelsFromRetentionPolicyResponse, error) {
	rsp, err := c.RemoveChannelsFromRetentionPolicy(ctx, policyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveChannelsFromRetentionPolicyResponse(rsp)
}

// GetChannelsForRetentionPolicyWithResponse request returning *GetChannelsForRetentionPolicyResponse
func (c *ClientWithResponses) GetChannelsForRetentionPolicyWithResponse(ctx context.Context, policyId string, params *GetChannelsForRetentionPolicyParams, reqEditors ...RequestEditorFn) (*GetChannelsForRetentionPolicyResponse, error) {
	rsp, err := c.GetChannelsForRetentionPolicy(ctx, policyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelsForRetentionPolicyResponse(rsp)
}

// AddChannelsToRetentionPolicyWithBodyWithResponse request with arbitrary body returning *AddChannelsToRetentionPolicyResponse
func (c *ClientWithResponses) AddChannelsToRetentionPolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddChannelsToRetentionPolicyResponse, error) {
	rsp, err := c.AddChannelsToRetentionPolicyWithBody(ctx, policyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddChannelsToRetentionPolicyResponse(rsp)
}

func (c *ClientWithResponses) AddChannelsToRetentionPolicyWithResponse(ctx context.Context, policyId string, body AddChannelsToRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddChannelsToRetentionPolicyResponse, error) {
	rsp, err := c.AddChannelsToRetentionPolicy(ctx, policyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddChannelsToRetentionPolicyResponse(rsp)
}

// SearchChannelsForRetentionPolicyWithBodyWithResponse request with arbitrary body returning *SearchChannelsForRetentionPolicyResponse
func (c *ClientWithResponses) SearchChannelsForRetentionPolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchChannelsForRetentionPolicyResponse, error) {
	rsp, err := c.SearchChannelsForRetentionPolicyWithBody(ctx, policyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchChannelsForRetentionPolicyResponse(rsp)
}

func (c *ClientWithResponses) SearchChannelsForRetentionPolicyWithResponse(ctx context.Context, policyId string, body SearchChannelsForRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchChannelsForRetentionPolicyResponse, error) {
	rsp, err := c.SearchChannelsForRetentionPolicy(ctx, policyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchChannelsForRetentionPolicyResponse(rsp)
}

// RemoveTeamsFromRetentionPolicyWithBodyWithResponse request with arbitrary body returning *RemoveTeamsFromRetentionPolicyResponse
func (c *ClientWithResponses) RemoveTeamsFromRetentionPolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTeamsFromRetentionPolicyResponse, error) {
	rsp, err := c.RemoveTeamsFromRetentionPolicyWithBody(ctx, policyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTeamsFromRetentionPolicyResponse(rsp)
}

func (c *ClientWithResponses) RemoveTeamsFromRetentionPolicyWithResponse(ctx context.Context, policyId string, body RemoveTeamsFromRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTeamsFromRetentionPolicyResponse, error) {
	rsp, err := c.RemoveTeamsFromRetentionPolicy(ctx, policyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTeamsFromRetentionPolicyResponse(rsp)
}

// GetTeamsForRetentionPolicyWithResponse request returning *GetTeamsForRetentionPolicyResponse
func (c *ClientWithResponses) GetTeamsForRetentionPolicyWithResponse(ctx context.Context, policyId string, params *GetTeamsForRetentionPolicyParams, reqEditors ...RequestEditorFn) (*GetTeamsForRetentionPolicyResponse, error) {
	rsp, err := c.GetTeamsForRetentionPolicy(ctx, policyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsForRetentionPolicyResponse(rsp)
}

// AddTeamsToRetentionPolicyWithBodyWithResponse request with arbitrary body returning *AddTeamsToRetentionPolicyResponse
func (c *ClientWithResponses) AddTeamsToRetentionPolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTeamsToRetentionPolicyResponse, error) {
	rsp, err := c.AddTeamsToRetentionPolicyWithBody(ctx, policyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTeamsToRetentionPolicyResponse(rsp)
}

func (c *ClientWithResponses) AddTeamsToRetentionPolicyWithResponse(ctx context.Context, policyId string, body AddTeamsToRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTeamsToRetentionPolicyResponse, error) {
	rsp, err := c.AddTeamsToRetentionPolicy(ctx, policyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTeamsToRetentionPolicyResponse(rsp)
}

// SearchTeamsForRetentionPolicyWithBodyWithResponse request with arbitrary body returning *SearchTeamsForRetentionPolicyResponse
func (c *ClientWithResponses) SearchTeamsForRetentionPolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchTeamsForRetentionPolicyResponse, error) {
	rsp, err := c.SearchTeamsForRetentionPolicyWithBody(ctx, policyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTeamsForRetentionPolicyResponse(rsp)
}

func (c *ClientWithResponses) SearchTeamsForRetentionPolicyWithResponse(ctx context.Context, policyId string, body SearchTeamsForRetentionPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchTeamsForRetentionPolicyResponse, error) {
	rsp, err := c.SearchTeamsForRetentionPolicy(ctx, policyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTeamsForRetentionPolicyResponse(rsp)
}

// GetDataRetentionPoliciesCountWithResponse request returning *GetDataRetentionPoliciesCountResponse
func (c *ClientWithResponses) GetDataRetentionPoliciesCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDataRetentionPoliciesCountResponse, error) {
	rsp, err := c.GetDataRetentionPoliciesCount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataRetentionPoliciesCountResponse(rsp)
}

// GetDataRetentionPolicyWithResponse request returning *GetDataRetentionPolicyResponse
func (c *ClientWithResponses) GetDataRetentionPolicyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDataRetentionPolicyResponse, error) {
	rsp, err := c.GetDataRetentionPolicy(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataRetentionPolicyResponse(rsp)
}

// DatabaseRecycleWithResponse request returning *DatabaseRecycleResponse
func (c *ClientWithResponses) DatabaseRecycleWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DatabaseRecycleResponse, error) {
	rsp, err := c.DatabaseRecycle(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDatabaseRecycleResponse(rsp)
}

// PurgeElasticsearchIndexesWithResponse request returning *PurgeElasticsearchIndexesResponse
func (c *ClientWithResponses) PurgeElasticsearchIndexesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PurgeElasticsearchIndexesResponse, error) {
	rsp, err := c.PurgeElasticsearchIndexes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgeElasticsearchIndexesResponse(rsp)
}

// TestElasticsearchWithResponse request returning *TestElasticsearchResponse
func (c *ClientWithResponses) TestElasticsearchWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TestElasticsearchResponse, error) {
	rsp, err := c.TestElasticsearch(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestElasticsearchResponse(rsp)
}

// TestEmailWithBodyWithResponse request with arbitrary body returning *TestEmailResponse
func (c *ClientWithResponses) TestEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestEmailResponse, error) {
	rsp, err := c.TestEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestEmailResponse(rsp)
}

func (c *ClientWithResponses) TestEmailWithResponse(ctx context.Context, body TestEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*TestEmailResponse, error) {
	rsp, err := c.TestEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestEmailResponse(rsp)
}

// GetEmojiListWithResponse request returning *GetEmojiListResponse
func (c *ClientWithResponses) GetEmojiListWithResponse(ctx context.Context, params *GetEmojiListParams, reqEditors ...RequestEditorFn) (*GetEmojiListResponse, error) {
	rsp, err := c.GetEmojiList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmojiListResponse(rsp)
}

// CreateEmojiWithBodyWithResponse request with arbitrary body returning *CreateEmojiResponse
func (c *ClientWithResponses) CreateEmojiWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEmojiResponse, error) {
	rsp, err := c.CreateEmojiWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEmojiResponse(rsp)
}

// AutocompleteEmojiWithResponse request returning *AutocompleteEmojiResponse
func (c *ClientWithResponses) AutocompleteEmojiWithResponse(ctx context.Context, params *AutocompleteEmojiParams, reqEditors ...RequestEditorFn) (*AutocompleteEmojiResponse, error) {
	rsp, err := c.AutocompleteEmoji(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutocompleteEmojiResponse(rsp)
}

// GetEmojiByNameWithResponse request returning *GetEmojiByNameResponse
func (c *ClientWithResponses) GetEmojiByNameWithResponse(ctx context.Context, emojiName string, reqEditors ...RequestEditorFn) (*GetEmojiByNameResponse, error) {
	rsp, err := c.GetEmojiByName(ctx, emojiName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmojiByNameResponse(rsp)
}

// GetEmojisByNamesWithBodyWithResponse request with arbitrary body returning *GetEmojisByNamesResponse
func (c *ClientWithResponses) GetEmojisByNamesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetEmojisByNamesResponse, error) {
	rsp, err := c.GetEmojisByNamesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmojisByNamesResponse(rsp)
}

func (c *ClientWithResponses) GetEmojisByNamesWithResponse(ctx context.Context, body GetEmojisByNamesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetEmojisByNamesResponse, error) {
	rsp, err := c.GetEmojisByNames(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmojisByNamesResponse(rsp)
}

// SearchEmojiWithBodyWithResponse request with arbitrary body returning *SearchEmojiResponse
func (c *ClientWithResponses) SearchEmojiWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchEmojiResponse, error) {
	rsp, err := c.SearchEmojiWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchEmojiResponse(rsp)
}

func (c *ClientWithResponses) SearchEmojiWithResponse(ctx context.Context, body SearchEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchEmojiResponse, error) {
	rsp, err := c.SearchEmoji(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchEmojiResponse(rsp)
}

// DeleteEmojiWithResponse request returning *DeleteEmojiResponse
func (c *ClientWithResponses) DeleteEmojiWithResponse(ctx context.Context, emojiId string, reqEditors ...RequestEditorFn) (*DeleteEmojiResponse, error) {
	rsp, err := c.DeleteEmoji(ctx, emojiId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEmojiResponse(rsp)
}

// GetEmojiWithResponse request returning *GetEmojiResponse
func (c *ClientWithResponses) GetEmojiWithResponse(ctx context.Context, emojiId string, reqEditors ...RequestEditorFn) (*GetEmojiResponse, error) {
	rsp, err := c.GetEmoji(ctx, emojiId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmojiResponse(rsp)
}

// GetEmojiImageWithResponse request returning *GetEmojiImageResponse
func (c *ClientWithResponses) GetEmojiImageWithResponse(ctx context.Context, emojiId string, reqEditors ...RequestEditorFn) (*GetEmojiImageResponse, error) {
	rsp, err := c.GetEmojiImage(ctx, emojiId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmojiImageResponse(rsp)
}

// ListExportsWithResponse request returning *ListExportsResponse
func (c *ClientWithResponses) ListExportsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListExportsResponse, error) {
	rsp, err := c.ListExports(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExportsResponse(rsp)
}

// DeleteExportWithResponse request returning *DeleteExportResponse
func (c *ClientWithResponses) DeleteExportWithResponse(ctx context.Context, exportName string, reqEditors ...RequestEditorFn) (*DeleteExportResponse, error) {
	rsp, err := c.DeleteExport(ctx, exportName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExportResponse(rsp)
}

// DownloadExportWithResponse request returning *DownloadExportResponse
func (c *ClientWithResponses) DownloadExportWithResponse(ctx context.Context, exportName string, reqEditors ...RequestEditorFn) (*DownloadExportResponse, error) {
	rsp, err := c.DownloadExport(ctx, exportName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadExportResponse(rsp)
}

// TestS3ConnectionWithBodyWithResponse request with arbitrary body returning *TestS3ConnectionResponse
func (c *ClientWithResponses) TestS3ConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestS3ConnectionResponse, error) {
	rsp, err := c.TestS3ConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestS3ConnectionResponse(rsp)
}

func (c *ClientWithResponses) TestS3ConnectionWithResponse(ctx context.Context, body TestS3ConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TestS3ConnectionResponse, error) {
	rsp, err := c.TestS3Connection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestS3ConnectionResponse(rsp)
}

// UploadFileWithBodyWithResponse request with arbitrary body returning *UploadFileResponse
func (c *ClientWithResponses) UploadFileWithBodyWithResponse(ctx context.Context, params *UploadFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileResponse, error) {
	rsp, err := c.UploadFileWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadFileResponse(rsp)
}

// SearchFilesWithBodyWithResponse request with arbitrary body returning *SearchFilesResponse
func (c *ClientWithResponses) SearchFilesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchFilesResponse, error) {
	rsp, err := c.SearchFilesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchFilesResponse(rsp)
}

// GetFileWithResponse request returning *GetFileResponse
func (c *ClientWithResponses) GetFileWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*GetFileResponse, error) {
	rsp, err := c.GetFile(ctx, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFileResponse(rsp)
}

// GetFileInfoWithResponse request returning *GetFileInfoResponse
func (c *ClientWithResponses) GetFileInfoWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*GetFileInfoResponse, error) {
	rsp, err := c.GetFileInfo(ctx, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFileInfoResponse(rsp)
}

// GetFileLinkWithResponse request returning *GetFileLinkResponse
func (c *ClientWithResponses) GetFileLinkWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*GetFileLinkResponse, error) {
	rsp, err := c.GetFileLink(ctx, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFileLinkResponse(rsp)
}

// GetFilePreviewWithResponse request returning *GetFilePreviewResponse
func (c *ClientWithResponses) GetFilePreviewWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*GetFilePreviewResponse, error) {
	rsp, err := c.GetFilePreview(ctx, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilePreviewResponse(rsp)
}

// GetFileThumbnailWithResponse request returning *GetFileThumbnailResponse
func (c *ClientWithResponses) GetFileThumbnailWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*GetFileThumbnailResponse, error) {
	rsp, err := c.GetFileThumbnail(ctx, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFileThumbnailResponse(rsp)
}

// GetGroupsWithResponse request returning *GetGroupsResponse
func (c *ClientWithResponses) GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error) {
	rsp, err := c.GetGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// GetGroupSyncablesChannelsWithResponse request returning *GetGroupSyncablesChannelsResponse
func (c *ClientWithResponses) GetGroupSyncablesChannelsWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupSyncablesChannelsResponse, error) {
	rsp, err := c.GetGroupSyncablesChannels(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupSyncablesChannelsResponse(rsp)
}

// GetGroupSyncableForChannelIdWithResponse request returning *GetGroupSyncableForChannelIdResponse
func (c *ClientWithResponses) GetGroupSyncableForChannelIdWithResponse(ctx context.Context, groupId string, channelId string, reqEditors ...RequestEditorFn) (*GetGroupSyncableForChannelIdResponse, error) {
	rsp, err := c.GetGroupSyncableForChannelId(ctx, groupId, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupSyncableForChannelIdResponse(rsp)
}

// UnlinkGroupSyncableForChannelWithResponse request returning *UnlinkGroupSyncableForChannelResponse
func (c *ClientWithResponses) UnlinkGroupSyncableForChannelWithResponse(ctx context.Context, groupId string, channelId string, reqEditors ...RequestEditorFn) (*UnlinkGroupSyncableForChannelResponse, error) {
	rsp, err := c.UnlinkGroupSyncableForChannel(ctx, groupId, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkGroupSyncableForChannelResponse(rsp)
}

// LinkGroupSyncableForChannelWithResponse request returning *LinkGroupSyncableForChannelResponse
func (c *ClientWithResponses) LinkGroupSyncableForChannelWithResponse(ctx context.Context, groupId string, channelId string, reqEditors ...RequestEditorFn) (*LinkGroupSyncableForChannelResponse, error) {
	rsp, err := c.LinkGroupSyncableForChannel(ctx, groupId, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkGroupSyncableForChannelResponse(rsp)
}

// PatchGroupSyncableForChannelWithBodyWithResponse request with arbitrary body returning *PatchGroupSyncableForChannelResponse
func (c *ClientWithResponses) PatchGroupSyncableForChannelWithBodyWithResponse(ctx context.Context, groupId string, channelId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchGroupSyncableForChannelResponse, error) {
	rsp, err := c.PatchGroupSyncableForChannelWithBody(ctx, groupId, channelId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchGroupSyncableForChannelResponse(rsp)
}

func (c *ClientWithResponses) PatchGroupSyncableForChannelWithResponse(ctx context.Context, groupId string, channelId string, body PatchGroupSyncableForChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchGroupSyncableForChannelResponse, error) {
	rsp, err := c.PatchGroupSyncableForChannel(ctx, groupId, channelId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchGroupSyncableForChannelResponse(rsp)
}

// DeleteGroupMembersWithBodyWithResponse request with arbitrary body returning *DeleteGroupMembersResponse
func (c *ClientWithResponses) DeleteGroupMembersWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGroupMembersResponse, error) {
	rsp, err := c.DeleteGroupMembersWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupMembersResponse(rsp)
}

func (c *ClientWithResponses) DeleteGroupMembersWithResponse(ctx context.Context, groupId string, body DeleteGroupMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGroupMembersResponse, error) {
	rsp, err := c.DeleteGroupMembers(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupMembersResponse(rsp)
}

// GetGroupUsersWithResponse request returning *GetGroupUsersResponse
func (c *ClientWithResponses) GetGroupUsersWithResponse(ctx context.Context, groupId string, params *GetGroupUsersParams, reqEditors ...RequestEditorFn) (*GetGroupUsersResponse, error) {
	rsp, err := c.GetGroupUsers(ctx, groupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupUsersResponse(rsp)
}

// AddGroupMembersWithBodyWithResponse request with arbitrary body returning *AddGroupMembersResponse
func (c *ClientWithResponses) AddGroupMembersWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddGroupMembersResponse, error) {
	rsp, err := c.AddGroupMembersWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGroupMembersResponse(rsp)
}

func (c *ClientWithResponses) AddGroupMembersWithResponse(ctx context.Context, groupId string, body AddGroupMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*AddGroupMembersResponse, error) {
	rsp, err := c.AddGroupMembers(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGroupMembersResponse(rsp)
}

// PatchGroupWithBodyWithResponse request with arbitrary body returning *PatchGroupResponse
func (c *ClientWithResponses) PatchGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchGroupResponse, error) {
	rsp, err := c.PatchGroupWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchGroupResponse(rsp)
}

func (c *ClientWithResponses) PatchGroupWithResponse(ctx context.Context, groupId string, body PatchGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchGroupResponse, error) {
	rsp, err := c.PatchGroup(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchGroupResponse(rsp)
}

// RestoreGroupWithResponse request returning *RestoreGroupResponse
func (c *ClientWithResponses) RestoreGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*RestoreGroupResponse, error) {
	rsp, err := c.RestoreGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreGroupResponse(rsp)
}

// GetGroupStatsWithResponse request returning *GetGroupStatsResponse
func (c *ClientWithResponses) GetGroupStatsWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupStatsResponse, error) {
	rsp, err := c.GetGroupStats(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupStatsResponse(rsp)
}

// GetGroupSyncablesTeamsWithResponse request returning *GetGroupSyncablesTeamsResponse
func (c *ClientWithResponses) GetGroupSyncablesTeamsWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupSyncablesTeamsResponse, error) {
	rsp, err := c.GetGroupSyncablesTeams(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupSyncablesTeamsResponse(rsp)
}

// GetGroupSyncableForTeamIdWithResponse request returning *GetGroupSyncableForTeamIdResponse
func (c *ClientWithResponses) GetGroupSyncableForTeamIdWithResponse(ctx context.Context, groupId string, teamId string, reqEditors ...RequestEditorFn) (*GetGroupSyncableForTeamIdResponse, error) {
	rsp, err := c.GetGroupSyncableForTeamId(ctx, groupId, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupSyncableForTeamIdResponse(rsp)
}

// UnlinkGroupSyncableForTeamWithResponse request returning *UnlinkGroupSyncableForTeamResponse
func (c *ClientWithResponses) UnlinkGroupSyncableForTeamWithResponse(ctx context.Context, groupId string, teamId string, reqEditors ...RequestEditorFn) (*UnlinkGroupSyncableForTeamResponse, error) {
	rsp, err := c.UnlinkGroupSyncableForTeam(ctx, groupId, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkGroupSyncableForTeamResponse(rsp)
}

// LinkGroupSyncableForTeamWithResponse request returning *LinkGroupSyncableForTeamResponse
func (c *ClientWithResponses) LinkGroupSyncableForTeamWithResponse(ctx context.Context, groupId string, teamId string, reqEditors ...RequestEditorFn) (*LinkGroupSyncableForTeamResponse, error) {
	rsp, err := c.LinkGroupSyncableForTeam(ctx, groupId, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkGroupSyncableForTeamResponse(rsp)
}

// PatchGroupSyncableForTeamWithBodyWithResponse request with arbitrary body returning *PatchGroupSyncableForTeamResponse
func (c *ClientWithResponses) PatchGroupSyncableForTeamWithBodyWithResponse(ctx context.Context, groupId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchGroupSyncableForTeamResponse, error) {
	rsp, err := c.PatchGroupSyncableForTeamWithBody(ctx, groupId, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchGroupSyncableForTeamResponse(rsp)
}

func (c *ClientWithResponses) PatchGroupSyncableForTeamWithResponse(ctx context.Context, groupId string, teamId string, body PatchGroupSyncableForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchGroupSyncableForTeamResponse, error) {
	rsp, err := c.PatchGroupSyncableForTeam(ctx, groupId, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchGroupSyncableForTeamResponse(rsp)
}

// GetIncomingWebhooksWithResponse request returning *GetIncomingWebhooksResponse
func (c *ClientWithResponses) GetIncomingWebhooksWithResponse(ctx context.Context, params *GetIncomingWebhooksParams, reqEditors ...RequestEditorFn) (*GetIncomingWebhooksResponse, error) {
	rsp, err := c.GetIncomingWebhooks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIncomingWebhooksResponse(rsp)
}

// CreateIncomingWebhookWithBodyWithResponse request with arbitrary body returning *CreateIncomingWebhookResponse
func (c *ClientWithResponses) CreateIncomingWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIncomingWebhookResponse, error) {
	rsp, err := c.CreateIncomingWebhookWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIncomingWebhookResponse(rsp)
}

func (c *ClientWithResponses) CreateIncomingWebhookWithResponse(ctx context.Context, body CreateIncomingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIncomingWebhookResponse, error) {
	rsp, err := c.CreateIncomingWebhook(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIncomingWebhookResponse(rsp)
}

// DeleteIncomingWebhookWithResponse request returning *DeleteIncomingWebhookResponse
func (c *ClientWithResponses) DeleteIncomingWebhookWithResponse(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*DeleteIncomingWebhookResponse, error) {
	rsp, err := c.DeleteIncomingWebhook(ctx, hookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIncomingWebhookResponse(rsp)
}

// GetIncomingWebhookWithResponse request returning *GetIncomingWebhookResponse
func (c *ClientWithResponses) GetIncomingWebhookWithResponse(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*GetIncomingWebhookResponse, error) {
	rsp, err := c.GetIncomingWebhook(ctx, hookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIncomingWebhookResponse(rsp)
}

// UpdateIncomingWebhookWithBodyWithResponse request with arbitrary body returning *UpdateIncomingWebhookResponse
func (c *ClientWithResponses) UpdateIncomingWebhookWithBodyWithResponse(ctx context.Context, hookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIncomingWebhookResponse, error) {
	rsp, err := c.UpdateIncomingWebhookWithBody(ctx, hookId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIncomingWebhookResponse(rsp)
}

func (c *ClientWithResponses) UpdateIncomingWebhookWithResponse(ctx context.Context, hookId string, body UpdateIncomingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIncomingWebhookResponse, error) {
	rsp, err := c.UpdateIncomingWebhook(ctx, hookId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIncomingWebhookResponse(rsp)
}

// GetOutgoingWebhooksWithResponse request returning *GetOutgoingWebhooksResponse
func (c *ClientWithResponses) GetOutgoingWebhooksWithResponse(ctx context.Context, params *GetOutgoingWebhooksParams, reqEditors ...RequestEditorFn) (*GetOutgoingWebhooksResponse, error) {
	rsp, err := c.GetOutgoingWebhooks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutgoingWebhooksResponse(rsp)
}

// CreateOutgoingWebhookWithBodyWithResponse request with arbitrary body returning *CreateOutgoingWebhookResponse
func (c *ClientWithResponses) CreateOutgoingWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOutgoingWebhookResponse, error) {
	rsp, err := c.CreateOutgoingWebhookWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOutgoingWebhookResponse(rsp)
}

func (c *ClientWithResponses) CreateOutgoingWebhookWithResponse(ctx context.Context, body CreateOutgoingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOutgoingWebhookResponse, error) {
	rsp, err := c.CreateOutgoingWebhook(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOutgoingWebhookResponse(rsp)
}

// DeleteOutgoingWebhookWithResponse request returning *DeleteOutgoingWebhookResponse
func (c *ClientWithResponses) DeleteOutgoingWebhookWithResponse(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*DeleteOutgoingWebhookResponse, error) {
	rsp, err := c.DeleteOutgoingWebhook(ctx, hookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOutgoingWebhookResponse(rsp)
}

// GetOutgoingWebhookWithResponse request returning *GetOutgoingWebhookResponse
func (c *ClientWithResponses) GetOutgoingWebhookWithResponse(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*GetOutgoingWebhookResponse, error) {
	rsp, err := c.GetOutgoingWebhook(ctx, hookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutgoingWebhookResponse(rsp)
}

// UpdateOutgoingWebhookWithBodyWithResponse request with arbitrary body returning *UpdateOutgoingWebhookResponse
func (c *ClientWithResponses) UpdateOutgoingWebhookWithBodyWithResponse(ctx context.Context, hookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOutgoingWebhookResponse, error) {
	rsp, err := c.UpdateOutgoingWebhookWithBody(ctx, hookId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOutgoingWebhookResponse(rsp)
}

func (c *ClientWithResponses) UpdateOutgoingWebhookWithResponse(ctx context.Context, hookId string, body UpdateOutgoingWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOutgoingWebhookResponse, error) {
	rsp, err := c.UpdateOutgoingWebhook(ctx, hookId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOutgoingWebhookResponse(rsp)
}

// RegenOutgoingHookTokenWithResponse request returning *RegenOutgoingHookTokenResponse
func (c *ClientWithResponses) RegenOutgoingHookTokenWithResponse(ctx context.Context, hookId string, reqEditors ...RequestEditorFn) (*RegenOutgoingHookTokenResponse, error) {
	rsp, err := c.RegenOutgoingHookToken(ctx, hookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegenOutgoingHookTokenResponse(rsp)
}

// GetImageByUrlWithResponse request returning *GetImageByUrlResponse
func (c *ClientWithResponses) GetImageByUrlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetImageByUrlResponse, error) {
	rsp, err := c.GetImageByUrl(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImageByUrlResponse(rsp)
}

// ListImportsWithResponse request returning *ListImportsResponse
func (c *ClientWithResponses) ListImportsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListImportsResponse, error) {
	rsp, err := c.ListImports(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListImportsResponse(rsp)
}

// CheckIntegrityWithResponse request returning *CheckIntegrityResponse
func (c *ClientWithResponses) CheckIntegrityWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CheckIntegrityResponse, error) {
	rsp, err := c.CheckIntegrity(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckIntegrityResponse(rsp)
}

// GetIPFiltersWithResponse request returning *GetIPFiltersResponse
func (c *ClientWithResponses) GetIPFiltersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetIPFiltersResponse, error) {
	rsp, err := c.GetIPFilters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIPFiltersResponse(rsp)
}

// ApplyIPFiltersWithBodyWithResponse request with arbitrary body returning *ApplyIPFiltersResponse
func (c *ClientWithResponses) ApplyIPFiltersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplyIPFiltersResponse, error) {
	rsp, err := c.ApplyIPFiltersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApplyIPFiltersResponse(rsp)
}

func (c *ClientWithResponses) ApplyIPFiltersWithResponse(ctx context.Context, body ApplyIPFiltersJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplyIPFiltersResponse, error) {
	rsp, err := c.ApplyIPFilters(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApplyIPFiltersResponse(rsp)
}

// MyIPWithResponse request returning *MyIPResponse
func (c *ClientWithResponses) MyIPWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MyIPResponse, error) {
	rsp, err := c.MyIP(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMyIPResponse(rsp)
}

// GetJobsWithResponse request returning *GetJobsResponse
func (c *ClientWithResponses) GetJobsWithResponse(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*GetJobsResponse, error) {
	rsp, err := c.GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobsResponse(rsp)
}

// CreateJobWithBodyWithResponse request with arbitrary body returning *CreateJobResponse
func (c *ClientWithResponses) CreateJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobResponse, error) {
	rsp, err := c.CreateJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobResponse(rsp)
}

func (c *ClientWithResponses) CreateJobWithResponse(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobResponse, error) {
	rsp, err := c.CreateJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobResponse(rsp)
}

// GetJobsByTypeWithResponse request returning *GetJobsByTypeResponse
func (c *ClientWithResponses) GetJobsByTypeWithResponse(ctx context.Context, pType string, params *GetJobsByTypeParams, reqEditors ...RequestEditorFn) (*GetJobsByTypeResponse, error) {
	rsp, err := c.GetJobsByType(ctx, pType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobsByTypeResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// CancelJobWithResponse request returning *CancelJobResponse
func (c *ClientWithResponses) CancelJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*CancelJobResponse, error) {
	rsp, err := c.CancelJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelJobResponse(rsp)
}

// DownloadJobWithResponse request returning *DownloadJobResponse
func (c *ClientWithResponses) DownloadJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*DownloadJobResponse, error) {
	rsp, err := c.DownloadJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadJobResponse(rsp)
}

// UpdateJobStatusWithBodyWithResponse request with arbitrary body returning *UpdateJobStatusResponse
func (c *ClientWithResponses) UpdateJobStatusWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobStatusResponse, error) {
	rsp, err := c.UpdateJobStatusWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobStatusResponse(rsp)
}

func (c *ClientWithResponses) UpdateJobStatusWithResponse(ctx context.Context, jobId string, body UpdateJobStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobStatusResponse, error) {
	rsp, err := c.UpdateJobStatus(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobStatusResponse(rsp)
}

// DeleteLdapPrivateCertificateWithResponse request returning *DeleteLdapPrivateCertificateResponse
func (c *ClientWithResponses) DeleteLdapPrivateCertificateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteLdapPrivateCertificateResponse, error) {
	rsp, err := c.DeleteLdapPrivateCertificate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLdapPrivateCertificateResponse(rsp)
}

// UploadLdapPrivateCertificateWithBodyWithResponse request with arbitrary body returning *UploadLdapPrivateCertificateResponse
func (c *ClientWithResponses) UploadLdapPrivateCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadLdapPrivateCertificateResponse, error) {
	rsp, err := c.UploadLdapPrivateCertificateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadLdapPrivateCertificateResponse(rsp)
}

// DeleteLdapPublicCertificateWithResponse request returning *DeleteLdapPublicCertificateResponse
func (c *ClientWithResponses) DeleteLdapPublicCertificateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteLdapPublicCertificateResponse, error) {
	rsp, err := c.DeleteLdapPublicCertificate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLdapPublicCertificateResponse(rsp)
}

// UploadLdapPublicCertificateWithBodyWithResponse request with arbitrary body returning *UploadLdapPublicCertificateResponse
func (c *ClientWithResponses) UploadLdapPublicCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadLdapPublicCertificateResponse, error) {
	rsp, err := c.UploadLdapPublicCertificateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadLdapPublicCertificateResponse(rsp)
}

// GetLdapGroupsWithResponse request returning *GetLdapGroupsResponse
func (c *ClientWithResponses) GetLdapGroupsWithResponse(ctx context.Context, params *GetLdapGroupsParams, reqEditors ...RequestEditorFn) (*GetLdapGroupsResponse, error) {
	rsp, err := c.GetLdapGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLdapGroupsResponse(rsp)
}

// UnlinkLdapGroupWithResponse request returning *UnlinkLdapGroupResponse
func (c *ClientWithResponses) UnlinkLdapGroupWithResponse(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*UnlinkLdapGroupResponse, error) {
	rsp, err := c.UnlinkLdapGroup(ctx, remoteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkLdapGroupResponse(rsp)
}

// LinkLdapGroupWithResponse request returning *LinkLdapGroupResponse
func (c *ClientWithResponses) LinkLdapGroupWithResponse(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*LinkLdapGroupResponse, error) {
	rsp, err := c.LinkLdapGroup(ctx, remoteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkLdapGroupResponse(rsp)
}

// MigrateIdLdapWithBodyWithResponse request with arbitrary body returning *MigrateIdLdapResponse
func (c *ClientWithResponses) MigrateIdLdapWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateIdLdapResponse, error) {
	rsp, err := c.MigrateIdLdapWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateIdLdapResponse(rsp)
}

func (c *ClientWithResponses) MigrateIdLdapWithResponse(ctx context.Context, body MigrateIdLdapJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateIdLdapResponse, error) {
	rsp, err := c.MigrateIdLdap(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateIdLdapResponse(rsp)
}

// SyncLdapWithResponse request returning *SyncLdapResponse
func (c *ClientWithResponses) SyncLdapWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SyncLdapResponse, error) {
	rsp, err := c.SyncLdap(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncLdapResponse(rsp)
}

// TestLdapWithResponse request returning *TestLdapResponse
func (c *ClientWithResponses) TestLdapWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TestLdapResponse, error) {
	rsp, err := c.TestLdap(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestLdapResponse(rsp)
}

// AddUserToGroupSyncablesWithResponse request returning *AddUserToGroupSyncablesResponse
func (c *ClientWithResponses) AddUserToGroupSyncablesWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*AddUserToGroupSyncablesResponse, error) {
	rsp, err := c.AddUserToGroupSyncables(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToGroupSyncablesResponse(rsp)
}

// RemoveLicenseFileWithResponse request returning *RemoveLicenseFileResponse
func (c *ClientWithResponses) RemoveLicenseFileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RemoveLicenseFileResponse, error) {
	rsp, err := c.RemoveLicenseFile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveLicenseFileResponse(rsp)
}

// UploadLicenseFileWithBodyWithResponse request with arbitrary body returning *UploadLicenseFileResponse
func (c *ClientWithResponses) UploadLicenseFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadLicenseFileResponse, error) {
	rsp, err := c.UploadLicenseFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadLicenseFileResponse(rsp)
}

// GetClientLicenseWithResponse request returning *GetClientLicenseResponse
func (c *ClientWithResponses) GetClientLicenseWithResponse(ctx context.Context, params *GetClientLicenseParams, reqEditors ...RequestEditorFn) (*GetClientLicenseResponse, error) {
	rsp, err := c.GetClientLicense(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientLicenseResponse(rsp)
}

// RequestLicenseRenewalLinkWithResponse request returning *RequestLicenseRenewalLinkResponse
func (c *ClientWithResponses) RequestLicenseRenewalLinkWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RequestLicenseRenewalLinkResponse, error) {
	rsp, err := c.RequestLicenseRenewalLink(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestLicenseRenewalLinkResponse(rsp)
}

// GetServerLimitsWithResponse request returning *GetServerLimitsResponse
func (c *ClientWithResponses) GetServerLimitsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServerLimitsResponse, error) {
	rsp, err := c.GetServerLimits(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerLimitsResponse(rsp)
}

// GetLogsWithResponse request returning *GetLogsResponse
func (c *ClientWithResponses) GetLogsWithResponse(ctx context.Context, params *GetLogsParams, reqEditors ...RequestEditorFn) (*GetLogsResponse, error) {
	rsp, err := c.GetLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogsResponse(rsp)
}

// PostLogWithBodyWithResponse request with arbitrary body returning *PostLogResponse
func (c *ClientWithResponses) PostLogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLogResponse, error) {
	rsp, err := c.PostLogWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLogResponse(rsp)
}

func (c *ClientWithResponses) PostLogWithResponse(ctx context.Context, body PostLogJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLogResponse, error) {
	rsp, err := c.PostLog(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLogResponse(rsp)
}

// DownloadSystemLogsWithResponse request returning *DownloadSystemLogsResponse
func (c *ClientWithResponses) DownloadSystemLogsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DownloadSystemLogsResponse, error) {
	rsp, err := c.DownloadSystemLogs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadSystemLogsResponse(rsp)
}

// AcknowledgeNotificationWithResponse request returning *AcknowledgeNotificationResponse
func (c *ClientWithResponses) AcknowledgeNotificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AcknowledgeNotificationResponse, error) {
	rsp, err := c.AcknowledgeNotification(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcknowledgeNotificationResponse(rsp)
}

// TestNotificationWithResponse request returning *TestNotificationResponse
func (c *ClientWithResponses) TestNotificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TestNotificationResponse, error) {
	rsp, err := c.TestNotification(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestNotificationResponse(rsp)
}

// GetOAuthAppsWithResponse request returning *GetOAuthAppsResponse
func (c *ClientWithResponses) GetOAuthAppsWithResponse(ctx context.Context, params *GetOAuthAppsParams, reqEditors ...RequestEditorFn) (*GetOAuthAppsResponse, error) {
	rsp, err := c.GetOAuthApps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthAppsResponse(rsp)
}

// CreateOAuthAppWithBodyWithResponse request with arbitrary body returning *CreateOAuthAppResponse
func (c *ClientWithResponses) CreateOAuthAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOAuthAppResponse, error) {
	rsp, err := c.CreateOAuthAppWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOAuthAppResponse(rsp)
}

func (c *ClientWithResponses) CreateOAuthAppWithResponse(ctx context.Context, body CreateOAuthAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOAuthAppResponse, error) {
	rsp, err := c.CreateOAuthApp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOAuthAppResponse(rsp)
}

// DeleteOAuthAppWithResponse request returning *DeleteOAuthAppResponse
func (c *ClientWithResponses) DeleteOAuthAppWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*DeleteOAuthAppResponse, error) {
	rsp, err := c.DeleteOAuthApp(ctx, appId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOAuthAppResponse(rsp)
}

// GetOAuthAppWithResponse request returning *GetOAuthAppResponse
func (c *ClientWithResponses) GetOAuthAppWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetOAuthAppResponse, error) {
	rsp, err := c.GetOAuthApp(ctx, appId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthAppResponse(rsp)
}

// UpdateOAuthAppWithBodyWithResponse request with arbitrary body returning *UpdateOAuthAppResponse
func (c *ClientWithResponses) UpdateOAuthAppWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOAuthAppResponse, error) {
	rsp, err := c.UpdateOAuthAppWithBody(ctx, appId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOAuthAppResponse(rsp)
}

func (c *ClientWithResponses) UpdateOAuthAppWithResponse(ctx context.Context, appId string, body UpdateOAuthAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOAuthAppResponse, error) {
	rsp, err := c.UpdateOAuthApp(ctx, appId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOAuthAppResponse(rsp)
}

// GetOAuthAppInfoWithResponse request returning *GetOAuthAppInfoResponse
func (c *ClientWithResponses) GetOAuthAppInfoWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetOAuthAppInfoResponse, error) {
	rsp, err := c.GetOAuthAppInfo(ctx, appId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthAppInfoResponse(rsp)
}

// RegenerateOAuthAppSecretWithResponse request returning *RegenerateOAuthAppSecretResponse
func (c *ClientWithResponses) RegenerateOAuthAppSecretWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*RegenerateOAuthAppSecretResponse, error) {
	rsp, err := c.RegenerateOAuthAppSecret(ctx, appId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegenerateOAuthAppSecretResponse(rsp)
}

// ListOutgoingOAuthConnectionsWithResponse request returning *ListOutgoingOAuthConnectionsResponse
func (c *ClientWithResponses) ListOutgoingOAuthConnectionsWithResponse(ctx context.Context, params *ListOutgoingOAuthConnectionsParams, reqEditors ...RequestEditorFn) (*ListOutgoingOAuthConnectionsResponse, error) {
	rsp, err := c.ListOutgoingOAuthConnections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOutgoingOAuthConnectionsResponse(rsp)
}

// CreateOutgoingOAuthConnectionWithBodyWithResponse request with arbitrary body returning *CreateOutgoingOAuthConnectionResponse
func (c *ClientWithResponses) CreateOutgoingOAuthConnectionWithBodyWithResponse(ctx context.Context, params *CreateOutgoingOAuthConnectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOutgoingOAuthConnectionResponse, error) {
	rsp, err := c.CreateOutgoingOAuthConnectionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOutgoingOAuthConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateOutgoingOAuthConnectionWithResponse(ctx context.Context, params *CreateOutgoingOAuthConnectionParams, body CreateOutgoingOAuthConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOutgoingOAuthConnectionResponse, error) {
	rsp, err := c.CreateOutgoingOAuthConnection(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOutgoingOAuthConnectionResponse(rsp)
}

// ValidateOutgoingOAuthConnectionWithBodyWithResponse request with arbitrary body returning *ValidateOutgoingOAuthConnectionResponse
func (c *ClientWithResponses) ValidateOutgoingOAuthConnectionWithBodyWithResponse(ctx context.Context, params *ValidateOutgoingOAuthConnectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateOutgoingOAuthConnectionResponse, error) {
	rsp, err := c.ValidateOutgoingOAuthConnectionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateOutgoingOAuthConnectionResponse(rsp)
}

func (c *ClientWithResponses) ValidateOutgoingOAuthConnectionWithResponse(ctx context.Context, params *ValidateOutgoingOAuthConnectionParams, body ValidateOutgoingOAuthConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateOutgoingOAuthConnectionResponse, error) {
	rsp, err := c.ValidateOutgoingOAuthConnection(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateOutgoingOAuthConnectionResponse(rsp)
}

// DeleteOutgoingOAuthConnectionWithResponse request returning *DeleteOutgoingOAuthConnectionResponse
func (c *ClientWithResponses) DeleteOutgoingOAuthConnectionWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*DeleteOutgoingOAuthConnectionResponse, error) {
	rsp, err := c.DeleteOutgoingOAuthConnection(ctx, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOutgoingOAuthConnectionResponse(rsp)
}

// GetOutgoingOAuthConnectionWithResponse request returning *GetOutgoingOAuthConnectionResponse
func (c *ClientWithResponses) GetOutgoingOAuthConnectionWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*GetOutgoingOAuthConnectionResponse, error) {
	rsp, err := c.GetOutgoingOAuthConnection(ctx, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutgoingOAuthConnectionResponse(rsp)
}

// UpdateOutgoingOAuthConnectionWithBodyWithResponse request with arbitrary body returning *UpdateOutgoingOAuthConnectionResponse
func (c *ClientWithResponses) UpdateOutgoingOAuthConnectionWithBodyWithResponse(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOutgoingOAuthConnectionResponse, error) {
	rsp, err := c.UpdateOutgoingOAuthConnectionWithBody(ctx, connectionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOutgoingOAuthConnectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateOutgoingOAuthConnectionWithResponse(ctx context.Context, connectionId string, body UpdateOutgoingOAuthConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOutgoingOAuthConnectionResponse, error) {
	rsp, err := c.UpdateOutgoingOAuthConnection(ctx, connectionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOutgoingOAuthConnectionResponse(rsp)
}

// GetAncillaryPermissionsPostWithBodyWithResponse request with arbitrary body returning *GetAncillaryPermissionsPostResponse
func (c *ClientWithResponses) GetAncillaryPermissionsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetAncillaryPermissionsPostResponse, error) {
	rsp, err := c.GetAncillaryPermissionsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAncillaryPermissionsPostResponse(rsp)
}

func (c *ClientWithResponses) GetAncillaryPermissionsPostWithResponse(ctx context.Context, body GetAncillaryPermissionsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GetAncillaryPermissionsPostResponse, error) {
	rsp, err := c.GetAncillaryPermissionsPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAncillaryPermissionsPostResponse(rsp)
}

// GetPluginsWithResponse request returning *GetPluginsResponse
func (c *ClientWithResponses) GetPluginsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPluginsResponse, error) {
	rsp, err := c.GetPlugins(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginsResponse(rsp)
}

// UploadPluginWithBodyWithResponse request with arbitrary body returning *UploadPluginResponse
func (c *ClientWithResponses) UploadPluginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadPluginResponse, error) {
	rsp, err := c.UploadPluginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPluginResponse(rsp)
}

// InstallPluginFromUrlWithResponse request returning *InstallPluginFromUrlResponse
func (c *ClientWithResponses) InstallPluginFromUrlWithResponse(ctx context.Context, params *InstallPluginFromUrlParams, reqEditors ...RequestEditorFn) (*InstallPluginFromUrlResponse, error) {
	rsp, err := c.InstallPluginFromUrl(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallPluginFromUrlResponse(rsp)
}

// GetMarketplacePluginsWithResponse request returning *GetMarketplacePluginsResponse
func (c *ClientWithResponses) GetMarketplacePluginsWithResponse(ctx context.Context, params *GetMarketplacePluginsParams, reqEditors ...RequestEditorFn) (*GetMarketplacePluginsResponse, error) {
	rsp, err := c.GetMarketplacePlugins(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMarketplacePluginsResponse(rsp)
}

// InstallMarketplacePluginWithBodyWithResponse request with arbitrary body returning *InstallMarketplacePluginResponse
func (c *ClientWithResponses) InstallMarketplacePluginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallMarketplacePluginResponse, error) {
	rsp, err := c.InstallMarketplacePluginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallMarketplacePluginResponse(rsp)
}

func (c *ClientWithResponses) InstallMarketplacePluginWithResponse(ctx context.Context, body InstallMarketplacePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallMarketplacePluginResponse, error) {
	rsp, err := c.InstallMarketplacePlugin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallMarketplacePluginResponse(rsp)
}

// GetMarketplaceVisitedByAdminWithResponse request returning *GetMarketplaceVisitedByAdminResponse
func (c *ClientWithResponses) GetMarketplaceVisitedByAdminWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMarketplaceVisitedByAdminResponse, error) {
	rsp, err := c.GetMarketplaceVisitedByAdmin(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMarketplaceVisitedByAdminResponse(rsp)
}

// UpdateMarketplaceVisitedByAdminWithBodyWithResponse request with arbitrary body returning *UpdateMarketplaceVisitedByAdminResponse
func (c *ClientWithResponses) UpdateMarketplaceVisitedByAdminWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMarketplaceVisitedByAdminResponse, error) {
	rsp, err := c.UpdateMarketplaceVisitedByAdminWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMarketplaceVisitedByAdminResponse(rsp)
}

func (c *ClientWithResponses) UpdateMarketplaceVisitedByAdminWithResponse(ctx context.Context, body UpdateMarketplaceVisitedByAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMarketplaceVisitedByAdminResponse, error) {
	rsp, err := c.UpdateMarketplaceVisitedByAdmin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMarketplaceVisitedByAdminResponse(rsp)
}

// GetPluginStatusesWithResponse request returning *GetPluginStatusesResponse
func (c *ClientWithResponses) GetPluginStatusesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPluginStatusesResponse, error) {
	rsp, err := c.GetPluginStatuses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginStatusesResponse(rsp)
}

// GetWebappPluginsWithResponse request returning *GetWebappPluginsResponse
func (c *ClientWithResponses) GetWebappPluginsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebappPluginsResponse, error) {
	rsp, err := c.GetWebappPlugins(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebappPluginsResponse(rsp)
}

// RemovePluginWithResponse request returning *RemovePluginResponse
func (c *ClientWithResponses) RemovePluginWithResponse(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*RemovePluginResponse, error) {
	rsp, err := c.RemovePlugin(ctx, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePluginResponse(rsp)
}

// DisablePluginWithResponse request returning *DisablePluginResponse
func (c *ClientWithResponses) DisablePluginWithResponse(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*DisablePluginResponse, error) {
	rsp, err := c.DisablePlugin(ctx, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisablePluginResponse(rsp)
}

// EnablePluginWithResponse request returning *EnablePluginResponse
func (c *ClientWithResponses) EnablePluginWithResponse(ctx context.Context, pluginId string, reqEditors ...RequestEditorFn) (*EnablePluginResponse, error) {
	rsp, err := c.EnablePlugin(ctx, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnablePluginResponse(rsp)
}

// CreatePostWithBodyWithResponse request with arbitrary body returning *CreatePostResponse
func (c *ClientWithResponses) CreatePostWithBodyWithResponse(ctx context.Context, params *CreatePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostResponse, error) {
	rsp, err := c.CreatePostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostResponse(rsp)
}

func (c *ClientWithResponses) CreatePostWithResponse(ctx context.Context, params *CreatePostParams, body CreatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostResponse, error) {
	rsp, err := c.CreatePost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostResponse(rsp)
}

// CreatePostEphemeralWithBodyWithResponse request with arbitrary body returning *CreatePostEphemeralResponse
func (c *ClientWithResponses) CreatePostEphemeralWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostEphemeralResponse, error) {
	rsp, err := c.CreatePostEphemeralWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostEphemeralResponse(rsp)
}

func (c *ClientWithResponses) CreatePostEphemeralWithResponse(ctx context.Context, body CreatePostEphemeralJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostEphemeralResponse, error) {
	rsp, err := c.CreatePostEphemeral(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostEphemeralResponse(rsp)
}

// GetPostsByIdsWithBodyWithResponse request with arbitrary body returning *GetPostsByIdsResponse
func (c *ClientWithResponses) GetPostsByIdsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPostsByIdsResponse, error) {
	rsp, err := c.GetPostsByIdsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostsByIdsResponse(rsp)
}

func (c *ClientWithResponses) GetPostsByIdsWithResponse(ctx context.Context, body GetPostsByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPostsByIdsResponse, error) {
	rsp, err := c.GetPostsByIds(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostsByIdsResponse(rsp)
}

// GetBulkReactionsWithBodyWithResponse request with arbitrary body returning *GetBulkReactionsResponse
func (c *ClientWithResponses) GetBulkReactionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetBulkReactionsResponse, error) {
	rsp, err := c.GetBulkReactionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBulkReactionsResponse(rsp)
}

func (c *ClientWithResponses) GetBulkReactionsWithResponse(ctx context.Context, body GetBulkReactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBulkReactionsResponse, error) {
	rsp, err := c.GetBulkReactions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBulkReactionsResponse(rsp)
}

// CreateScheduledPostWithBodyWithResponse request with arbitrary body returning *CreateScheduledPostResponse
func (c *ClientWithResponses) CreateScheduledPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScheduledPostResponse, error) {
	rsp, err := c.CreateScheduledPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScheduledPostResponse(rsp)
}

func (c *ClientWithResponses) CreateScheduledPostWithResponse(ctx context.Context, body CreateScheduledPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScheduledPostResponse, error) {
	rsp, err := c.CreateScheduledPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScheduledPostResponse(rsp)
}

// DeleteScheduledPostWithResponse request returning *DeleteScheduledPostResponse
func (c *ClientWithResponses) DeleteScheduledPostWithResponse(ctx context.Context, scheduledPostId string, reqEditors ...RequestEditorFn) (*DeleteScheduledPostResponse, error) {
	rsp, err := c.DeleteScheduledPost(ctx, scheduledPostId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScheduledPostResponse(rsp)
}

// UpdateScheduledPostWithBodyWithResponse request with arbitrary body returning *UpdateScheduledPostResponse
func (c *ClientWithResponses) UpdateScheduledPostWithBodyWithResponse(ctx context.Context, scheduledPostId string, params *UpdateScheduledPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScheduledPostResponse, error) {
	rsp, err := c.UpdateScheduledPostWithBody(ctx, scheduledPostId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScheduledPostResponse(rsp)
}

func (c *ClientWithResponses) UpdateScheduledPostWithResponse(ctx context.Context, scheduledPostId string, params *UpdateScheduledPostParams, body UpdateScheduledPostJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScheduledPostResponse, error) {
	rsp, err := c.UpdateScheduledPost(ctx, scheduledPostId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScheduledPostResponse(rsp)
}

// GetUserScheduledPostsWithResponse request returning *GetUserScheduledPostsResponse
func (c *ClientWithResponses) GetUserScheduledPostsWithResponse(ctx context.Context, teamId string, params *GetUserScheduledPostsParams, reqEditors ...RequestEditorFn) (*GetUserScheduledPostsResponse, error) {
	rsp, err := c.GetUserScheduledPosts(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserScheduledPostsResponse(rsp)
}

// DeletePostWithResponse request returning *DeletePostResponse
func (c *ClientWithResponses) DeletePostWithResponse(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*DeletePostResponse, error) {
	rsp, err := c.DeletePost(ctx, postId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePostResponse(rsp)
}

// GetPostWithResponse request returning *GetPostResponse
func (c *ClientWithResponses) GetPostWithResponse(ctx context.Context, postId string, params *GetPostParams, reqEditors ...RequestEditorFn) (*GetPostResponse, error) {
	rsp, err := c.GetPost(ctx, postId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostResponse(rsp)
}

// UpdatePostWithBodyWithResponse request with arbitrary body returning *UpdatePostResponse
func (c *ClientWithResponses) UpdatePostWithBodyWithResponse(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePostResponse, error) {
	rsp, err := c.UpdatePostWithBody(ctx, postId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePostResponse(rsp)
}

func (c *ClientWithResponses) UpdatePostWithResponse(ctx context.Context, postId string, body UpdatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePostResponse, error) {
	rsp, err := c.UpdatePost(ctx, postId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePostResponse(rsp)
}

// DoPostActionWithResponse request returning *DoPostActionResponse
func (c *ClientWithResponses) DoPostActionWithResponse(ctx context.Context, postId string, actionId string, reqEditors ...RequestEditorFn) (*DoPostActionResponse, error) {
	rsp, err := c.DoPostAction(ctx, postId, actionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDoPostActionResponse(rsp)
}

// GetFileInfosForPostWithResponse request returning *GetFileInfosForPostResponse
func (c *ClientWithResponses) GetFileInfosForPostWithResponse(ctx context.Context, postId string, params *GetFileInfosForPostParams, reqEditors ...RequestEditorFn) (*GetFileInfosForPostResponse, error) {
	rsp, err := c.GetFileInfosForPost(ctx, postId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFileInfosForPostResponse(rsp)
}

// MoveThreadWithBodyWithResponse request with arbitrary body returning *MoveThreadResponse
func (c *ClientWithResponses) MoveThreadWithBodyWithResponse(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveThreadResponse, error) {
	rsp, err := c.MoveThreadWithBody(ctx, postId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveThreadResponse(rsp)
}

func (c *ClientWithResponses) MoveThreadWithResponse(ctx context.Context, postId string, body MoveThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveThreadResponse, error) {
	rsp, err := c.MoveThread(ctx, postId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveThreadResponse(rsp)
}

// PatchPostWithBodyWithResponse request with arbitrary body returning *PatchPostResponse
func (c *ClientWithResponses) PatchPostWithBodyWithResponse(ctx context.Context, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPostResponse, error) {
	rsp, err := c.PatchPostWithBody(ctx, postId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPostResponse(rsp)
}

func (c *ClientWithResponses) PatchPostWithResponse(ctx context.Context, postId string, body PatchPostJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPostResponse, error) {
	rsp, err := c.PatchPost(ctx, postId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPostResponse(rsp)
}

// PinPostWithResponse request returning *PinPostResponse
func (c *ClientWithResponses) PinPostWithResponse(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*PinPostResponse, error) {
	rsp, err := c.PinPost(ctx, postId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePinPostResponse(rsp)
}

// GetReactionsWithResponse request returning *GetReactionsResponse
func (c *ClientWithResponses) GetReactionsWithResponse(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*GetReactionsResponse, error) {
	rsp, err := c.GetReactions(ctx, postId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReactionsResponse(rsp)
}

// GetPostThreadWithResponse request returning *GetPostThreadResponse
func (c *ClientWithResponses) GetPostThreadWithResponse(ctx context.Context, postId string, params *GetPostThreadParams, reqEditors ...RequestEditorFn) (*GetPostThreadResponse, error) {
	rsp, err := c.GetPostThread(ctx, postId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostThreadResponse(rsp)
}

// UnpinPostWithResponse request returning *UnpinPostResponse
func (c *ClientWithResponses) UnpinPostWithResponse(ctx context.Context, postId string, reqEditors ...RequestEditorFn) (*UnpinPostResponse, error) {
	rsp, err := c.UnpinPost(ctx, postId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnpinPostResponse(rsp)
}

// SaveReactionWithBodyWithResponse request with arbitrary body returning *SaveReactionResponse
func (c *ClientWithResponses) SaveReactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveReactionResponse, error) {
	rsp, err := c.SaveReactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveReactionResponse(rsp)
}

func (c *ClientWithResponses) SaveReactionWithResponse(ctx context.Context, body SaveReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveReactionResponse, error) {
	rsp, err := c.SaveReaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveReactionResponse(rsp)
}

// GetRedirectLocationWithResponse request returning *GetRedirectLocationResponse
func (c *ClientWithResponses) GetRedirectLocationWithResponse(ctx context.Context, params *GetRedirectLocationParams, reqEditors ...RequestEditorFn) (*GetRedirectLocationResponse, error) {
	rsp, err := c.GetRedirectLocation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRedirectLocationResponse(rsp)
}

// GetRemoteClustersWithResponse request returning *GetRemoteClustersResponse
func (c *ClientWithResponses) GetRemoteClustersWithResponse(ctx context.Context, params *GetRemoteClustersParams, reqEditors ...RequestEditorFn) (*GetRemoteClustersResponse, error) {
	rsp, err := c.GetRemoteClusters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRemoteClustersResponse(rsp)
}

// CreateRemoteClusterWithBodyWithResponse request with arbitrary body returning *CreateRemoteClusterResponse
func (c *ClientWithResponses) CreateRemoteClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRemoteClusterResponse, error) {
	rsp, err := c.CreateRemoteClusterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRemoteClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateRemoteClusterWithResponse(ctx context.Context, body CreateRemoteClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRemoteClusterResponse, error) {
	rsp, err := c.CreateRemoteCluster(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRemoteClusterResponse(rsp)
}

// AcceptRemoteClusterInviteWithBodyWithResponse request with arbitrary body returning *AcceptRemoteClusterInviteResponse
func (c *ClientWithResponses) AcceptRemoteClusterInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptRemoteClusterInviteResponse, error) {
	rsp, err := c.AcceptRemoteClusterInviteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptRemoteClusterInviteResponse(rsp)
}

func (c *ClientWithResponses) AcceptRemoteClusterInviteWithResponse(ctx context.Context, body AcceptRemoteClusterInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptRemoteClusterInviteResponse, error) {
	rsp, err := c.AcceptRemoteClusterInvite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptRemoteClusterInviteResponse(rsp)
}

// DeleteRemoteClusterWithResponse request returning *DeleteRemoteClusterResponse
func (c *ClientWithResponses) DeleteRemoteClusterWithResponse(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*DeleteRemoteClusterResponse, error) {
	rsp, err := c.DeleteRemoteCluster(ctx, remoteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRemoteClusterResponse(rsp)
}

// GetRemoteClusterWithResponse request returning *GetRemoteClusterResponse
func (c *ClientWithResponses) GetRemoteClusterWithResponse(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*GetRemoteClusterResponse, error) {
	rsp, err := c.GetRemoteCluster(ctx, remoteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRemoteClusterResponse(rsp)
}

// PatchRemoteClusterWithBodyWithResponse request with arbitrary body returning *PatchRemoteClusterResponse
func (c *ClientWithResponses) PatchRemoteClusterWithBodyWithResponse(ctx context.Context, remoteId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRemoteClusterResponse, error) {
	rsp, err := c.PatchRemoteClusterWithBody(ctx, remoteId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRemoteClusterResponse(rsp)
}

func (c *ClientWithResponses) PatchRemoteClusterWithResponse(ctx context.Context, remoteId string, body PatchRemoteClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRemoteClusterResponse, error) {
	rsp, err := c.PatchRemoteCluster(ctx, remoteId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRemoteClusterResponse(rsp)
}

// InviteRemoteClusterToChannelWithResponse request returning *InviteRemoteClusterToChannelResponse
func (c *ClientWithResponses) InviteRemoteClusterToChannelWithResponse(ctx context.Context, remoteId string, channelId string, reqEditors ...RequestEditorFn) (*InviteRemoteClusterToChannelResponse, error) {
	rsp, err := c.InviteRemoteClusterToChannel(ctx, remoteId, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteRemoteClusterToChannelResponse(rsp)
}

// UninviteRemoteClusterToChannelWithResponse request returning *UninviteRemoteClusterToChannelResponse
func (c *ClientWithResponses) UninviteRemoteClusterToChannelWithResponse(ctx context.Context, remoteId string, channelId string, reqEditors ...RequestEditorFn) (*UninviteRemoteClusterToChannelResponse, error) {
	rsp, err := c.UninviteRemoteClusterToChannel(ctx, remoteId, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUninviteRemoteClusterToChannelResponse(rsp)
}

// GetSharedChannelRemotesByRemoteClusterWithResponse request returning *GetSharedChannelRemotesByRemoteClusterResponse
func (c *ClientWithResponses) GetSharedChannelRemotesByRemoteClusterWithResponse(ctx context.Context, remoteId string, params *GetSharedChannelRemotesByRemoteClusterParams, reqEditors ...RequestEditorFn) (*GetSharedChannelRemotesByRemoteClusterResponse, error) {
	rsp, err := c.GetSharedChannelRemotesByRemoteCluster(ctx, remoteId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSharedChannelRemotesByRemoteClusterResponse(rsp)
}

// GetUsersForReportingWithResponse request returning *GetUsersForReportingResponse
func (c *ClientWithResponses) GetUsersForReportingWithResponse(ctx context.Context, params *GetUsersForReportingParams, reqEditors ...RequestEditorFn) (*GetUsersForReportingResponse, error) {
	rsp, err := c.GetUsersForReporting(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersForReportingResponse(rsp)
}

// GetUserCountForReportingWithResponse request returning *GetUserCountForReportingResponse
func (c *ClientWithResponses) GetUserCountForReportingWithResponse(ctx context.Context, params *GetUserCountForReportingParams, reqEditors ...RequestEditorFn) (*GetUserCountForReportingResponse, error) {
	rsp, err := c.GetUserCountForReporting(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserCountForReportingResponse(rsp)
}

// StartBatchUsersExportWithResponse request returning *StartBatchUsersExportResponse
func (c *ClientWithResponses) StartBatchUsersExportWithResponse(ctx context.Context, params *StartBatchUsersExportParams, reqEditors ...RequestEditorFn) (*StartBatchUsersExportResponse, error) {
	rsp, err := c.StartBatchUsersExport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartBatchUsersExportResponse(rsp)
}

// RestartServerWithResponse request returning *RestartServerResponse
func (c *ClientWithResponses) RestartServerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RestartServerResponse, error) {
	rsp, err := c.RestartServer(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartServerResponse(rsp)
}

// GetAllRolesWithResponse request returning *GetAllRolesResponse
func (c *ClientWithResponses) GetAllRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllRolesResponse, error) {
	rsp, err := c.GetAllRoles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllRolesResponse(rsp)
}

// GetRoleByNameWithResponse request returning *GetRoleByNameResponse
func (c *ClientWithResponses) GetRoleByNameWithResponse(ctx context.Context, roleName string, reqEditors ...RequestEditorFn) (*GetRoleByNameResponse, error) {
	rsp, err := c.GetRoleByName(ctx, roleName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleByNameResponse(rsp)
}

// GetRolesByNamesWithBodyWithResponse request with arbitrary body returning *GetRolesByNamesResponse
func (c *ClientWithResponses) GetRolesByNamesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetRolesByNamesResponse, error) {
	rsp, err := c.GetRolesByNamesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolesByNamesResponse(rsp)
}

func (c *ClientWithResponses) GetRolesByNamesWithResponse(ctx context.Context, body GetRolesByNamesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetRolesByNamesResponse, error) {
	rsp, err := c.GetRolesByNames(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolesByNamesResponse(rsp)
}

// GetRoleWithResponse request returning *GetRoleResponse
func (c *ClientWithResponses) GetRoleWithResponse(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error) {
	rsp, err := c.GetRole(ctx, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleResponse(rsp)
}

// PatchRoleWithBodyWithResponse request with arbitrary body returning *PatchRoleResponse
func (c *ClientWithResponses) PatchRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRoleResponse, error) {
	rsp, err := c.PatchRoleWithBody(ctx, roleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRoleResponse(rsp)
}

func (c *ClientWithResponses) PatchRoleWithResponse(ctx context.Context, roleId string, body PatchRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRoleResponse, error) {
	rsp, err := c.PatchRole(ctx, roleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRoleResponse(rsp)
}

// DeleteSamlIdpCertificateWithResponse request returning *DeleteSamlIdpCertificateResponse
func (c *ClientWithResponses) DeleteSamlIdpCertificateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteSamlIdpCertificateResponse, error) {
	rsp, err := c.DeleteSamlIdpCertificate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSamlIdpCertificateResponse(rsp)
}

// UploadSamlIdpCertificateWithBodyWithResponse request with arbitrary body returning *UploadSamlIdpCertificateResponse
func (c *ClientWithResponses) UploadSamlIdpCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadSamlIdpCertificateResponse, error) {
	rsp, err := c.UploadSamlIdpCertificateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadSamlIdpCertificateResponse(rsp)
}

// DeleteSamlPrivateCertificateWithResponse request returning *DeleteSamlPrivateCertificateResponse
func (c *ClientWithResponses) DeleteSamlPrivateCertificateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteSamlPrivateCertificateResponse, error) {
	rsp, err := c.DeleteSamlPrivateCertificate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSamlPrivateCertificateResponse(rsp)
}

// UploadSamlPrivateCertificateWithBodyWithResponse request with arbitrary body returning *UploadSamlPrivateCertificateResponse
func (c *ClientWithResponses) UploadSamlPrivateCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadSamlPrivateCertificateResponse, error) {
	rsp, err := c.UploadSamlPrivateCertificateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadSamlPrivateCertificateResponse(rsp)
}

// DeleteSamlPublicCertificateWithResponse request returning *DeleteSamlPublicCertificateResponse
func (c *ClientWithResponses) DeleteSamlPublicCertificateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteSamlPublicCertificateResponse, error) {
	rsp, err := c.DeleteSamlPublicCertificate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSamlPublicCertificateResponse(rsp)
}

// UploadSamlPublicCertificateWithBodyWithResponse request with arbitrary body returning *UploadSamlPublicCertificateResponse
func (c *ClientWithResponses) UploadSamlPublicCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadSamlPublicCertificateResponse, error) {
	rsp, err := c.UploadSamlPublicCertificateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadSamlPublicCertificateResponse(rsp)
}

// GetSamlCertificateStatusWithResponse request returning *GetSamlCertificateStatusResponse
func (c *ClientWithResponses) GetSamlCertificateStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSamlCertificateStatusResponse, error) {
	rsp, err := c.GetSamlCertificateStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamlCertificateStatusResponse(rsp)
}

// GetSamlMetadataWithResponse request returning *GetSamlMetadataResponse
func (c *ClientWithResponses) GetSamlMetadataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSamlMetadataResponse, error) {
	rsp, err := c.GetSamlMetadata(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamlMetadataResponse(rsp)
}

// GetSamlMetadataFromIdpWithBodyWithResponse request with arbitrary body returning *GetSamlMetadataFromIdpResponse
func (c *ClientWithResponses) GetSamlMetadataFromIdpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetSamlMetadataFromIdpResponse, error) {
	rsp, err := c.GetSamlMetadataFromIdpWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamlMetadataFromIdpResponse(rsp)
}

func (c *ClientWithResponses) GetSamlMetadataFromIdpWithResponse(ctx context.Context, body GetSamlMetadataFromIdpJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSamlMetadataFromIdpResponse, error) {
	rsp, err := c.GetSamlMetadataFromIdp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamlMetadataFromIdpResponse(rsp)
}

// ResetSamlAuthDataToEmailWithBodyWithResponse request with arbitrary body returning *ResetSamlAuthDataToEmailResponse
func (c *ClientWithResponses) ResetSamlAuthDataToEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetSamlAuthDataToEmailResponse, error) {
	rsp, err := c.ResetSamlAuthDataToEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetSamlAuthDataToEmailResponse(rsp)
}

func (c *ClientWithResponses) ResetSamlAuthDataToEmailWithResponse(ctx context.Context, body ResetSamlAuthDataToEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetSamlAuthDataToEmailResponse, error) {
	rsp, err := c.ResetSamlAuthDataToEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetSamlAuthDataToEmailResponse(rsp)
}

// GetSchemesWithResponse request returning *GetSchemesResponse
func (c *ClientWithResponses) GetSchemesWithResponse(ctx context.Context, params *GetSchemesParams, reqEditors ...RequestEditorFn) (*GetSchemesResponse, error) {
	rsp, err := c.GetSchemes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemesResponse(rsp)
}

// CreateSchemeWithBodyWithResponse request with arbitrary body returning *CreateSchemeResponse
func (c *ClientWithResponses) CreateSchemeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSchemeResponse, error) {
	rsp, err := c.CreateSchemeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSchemeResponse(rsp)
}

func (c *ClientWithResponses) CreateSchemeWithResponse(ctx context.Context, body CreateSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSchemeResponse, error) {
	rsp, err := c.CreateScheme(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSchemeResponse(rsp)
}

// DeleteSchemeWithResponse request returning *DeleteSchemeResponse
func (c *ClientWithResponses) DeleteSchemeWithResponse(ctx context.Context, schemeId string, reqEditors ...RequestEditorFn) (*DeleteSchemeResponse, error) {
	rsp, err := c.DeleteScheme(ctx, schemeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSchemeResponse(rsp)
}

// GetSchemeWithResponse request returning *GetSchemeResponse
func (c *ClientWithResponses) GetSchemeWithResponse(ctx context.Context, schemeId string, reqEditors ...RequestEditorFn) (*GetSchemeResponse, error) {
	rsp, err := c.GetScheme(ctx, schemeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemeResponse(rsp)
}

// GetChannelsForSchemeWithResponse request returning *GetChannelsForSchemeResponse
func (c *ClientWithResponses) GetChannelsForSchemeWithResponse(ctx context.Context, schemeId string, params *GetChannelsForSchemeParams, reqEditors ...RequestEditorFn) (*GetChannelsForSchemeResponse, error) {
	rsp, err := c.GetChannelsForScheme(ctx, schemeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelsForSchemeResponse(rsp)
}

// PatchSchemeWithBodyWithResponse request with arbitrary body returning *PatchSchemeResponse
func (c *ClientWithResponses) PatchSchemeWithBodyWithResponse(ctx context.Context, schemeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSchemeResponse, error) {
	rsp, err := c.PatchSchemeWithBody(ctx, schemeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSchemeResponse(rsp)
}

func (c *ClientWithResponses) PatchSchemeWithResponse(ctx context.Context, schemeId string, body PatchSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSchemeResponse, error) {
	rsp, err := c.PatchScheme(ctx, schemeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSchemeResponse(rsp)
}

// GetTeamsForSchemeWithResponse request returning *GetTeamsForSchemeResponse
func (c *ClientWithResponses) GetTeamsForSchemeWithResponse(ctx context.Context, schemeId string, params *GetTeamsForSchemeParams, reqEditors ...RequestEditorFn) (*GetTeamsForSchemeResponse, error) {
	rsp, err := c.GetTeamsForScheme(ctx, schemeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsForSchemeResponse(rsp)
}

// ClearServerBusyWithResponse request returning *ClearServerBusyResponse
func (c *ClientWithResponses) ClearServerBusyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClearServerBusyResponse, error) {
	rsp, err := c.ClearServerBusy(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearServerBusyResponse(rsp)
}

// GetServerBusyExpiresWithResponse request returning *GetServerBusyExpiresResponse
func (c *ClientWithResponses) GetServerBusyExpiresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServerBusyExpiresResponse, error) {
	rsp, err := c.GetServerBusyExpires(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerBusyExpiresResponse(rsp)
}

// SetServerBusyWithResponse request returning *SetServerBusyResponse
func (c *ClientWithResponses) SetServerBusyWithResponse(ctx context.Context, params *SetServerBusyParams, reqEditors ...RequestEditorFn) (*SetServerBusyResponse, error) {
	rsp, err := c.SetServerBusy(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetServerBusyResponse(rsp)
}

// GetRemoteClusterInfoWithResponse request returning *GetRemoteClusterInfoResponse
func (c *ClientWithResponses) GetRemoteClusterInfoWithResponse(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*GetRemoteClusterInfoResponse, error) {
	rsp, err := c.GetRemoteClusterInfo(ctx, remoteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRemoteClusterInfoResponse(rsp)
}

// GetAllSharedChannelsWithResponse request returning *GetAllSharedChannelsResponse
func (c *ClientWithResponses) GetAllSharedChannelsWithResponse(ctx context.Context, teamId string, params *GetAllSharedChannelsParams, reqEditors ...RequestEditorFn) (*GetAllSharedChannelsResponse, error) {
	rsp, err := c.GetAllSharedChannels(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSharedChannelsResponse(rsp)
}

// TestSiteURLWithBodyWithResponse request with arbitrary body returning *TestSiteURLResponse
func (c *ClientWithResponses) TestSiteURLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestSiteURLResponse, error) {
	rsp, err := c.TestSiteURLWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestSiteURLResponse(rsp)
}

func (c *ClientWithResponses) TestSiteURLWithResponse(ctx context.Context, body TestSiteURLJSONRequestBody, reqEditors ...RequestEditorFn) (*TestSiteURLResponse, error) {
	rsp, err := c.TestSiteURL(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestSiteURLResponse(rsp)
}

// MarkNoticesViewedWithBodyWithResponse request with arbitrary body returning *MarkNoticesViewedResponse
func (c *ClientWithResponses) MarkNoticesViewedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkNoticesViewedResponse, error) {
	rsp, err := c.MarkNoticesViewedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkNoticesViewedResponse(rsp)
}

func (c *ClientWithResponses) MarkNoticesViewedWithResponse(ctx context.Context, body MarkNoticesViewedJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkNoticesViewedResponse, error) {
	rsp, err := c.MarkNoticesViewed(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkNoticesViewedResponse(rsp)
}

// GetNoticesWithResponse request returning *GetNoticesResponse
func (c *ClientWithResponses) GetNoticesWithResponse(ctx context.Context, teamId string, params *GetNoticesParams, reqEditors ...RequestEditorFn) (*GetNoticesResponse, error) {
	rsp, err := c.GetNotices(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNoticesResponse(rsp)
}

// GetPingWithResponse request returning *GetPingResponse
func (c *ClientWithResponses) GetPingWithResponse(ctx context.Context, params *GetPingParams, reqEditors ...RequestEditorFn) (*GetPingResponse, error) {
	rsp, err := c.GetPing(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPingResponse(rsp)
}

// GenerateSupportPacketWithResponse request returning *GenerateSupportPacketResponse
func (c *ClientWithResponses) GenerateSupportPacketWithResponse(ctx context.Context, params *GenerateSupportPacketParams, reqEditors ...RequestEditorFn) (*GenerateSupportPacketResponse, error) {
	rsp, err := c.GenerateSupportPacket(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateSupportPacketResponse(rsp)
}

// GetSupportedTimezoneWithResponse request returning *GetSupportedTimezoneResponse
func (c *ClientWithResponses) GetSupportedTimezoneWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSupportedTimezoneResponse, error) {
	rsp, err := c.GetSupportedTimezone(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSupportedTimezoneResponse(rsp)
}

// GetAllTeamsWithResponse request returning *GetAllTeamsResponse
func (c *ClientWithResponses) GetAllTeamsWithResponse(ctx context.Context, params *GetAllTeamsParams, reqEditors ...RequestEditorFn) (*GetAllTeamsResponse, error) {
	rsp, err := c.GetAllTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTeamsResponse(rsp)
}

// CreateTeamWithBodyWithResponse request with arbitrary body returning *CreateTeamResponse
func (c *ClientWithResponses) CreateTeamWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error) {
	rsp, err := c.CreateTeamWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamResponse(rsp)
}

func (c *ClientWithResponses) CreateTeamWithResponse(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error) {
	rsp, err := c.CreateTeam(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamResponse(rsp)
}

// GetTeamInviteInfoWithResponse request returning *GetTeamInviteInfoResponse
func (c *ClientWithResponses) GetTeamInviteInfoWithResponse(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*GetTeamInviteInfoResponse, error) {
	rsp, err := c.GetTeamInviteInfo(ctx, inviteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamInviteInfoResponse(rsp)
}

// InvalidateEmailInvitesWithResponse request returning *InvalidateEmailInvitesResponse
func (c *ClientWithResponses) InvalidateEmailInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InvalidateEmailInvitesResponse, error) {
	rsp, err := c.InvalidateEmailInvites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvalidateEmailInvitesResponse(rsp)
}

// AddTeamMemberFromInviteWithResponse request returning *AddTeamMemberFromInviteResponse
func (c *ClientWithResponses) AddTeamMemberFromInviteWithResponse(ctx context.Context, params *AddTeamMemberFromInviteParams, reqEditors ...RequestEditorFn) (*AddTeamMemberFromInviteResponse, error) {
	rsp, err := c.AddTeamMemberFromInvite(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTeamMemberFromInviteResponse(rsp)
}

// GetTeamByNameWithResponse request returning *GetTeamByNameResponse
func (c *ClientWithResponses) GetTeamByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetTeamByNameResponse, error) {
	rsp, err := c.GetTeamByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamByNameResponse(rsp)
}

// TeamExistsWithResponse request returning *TeamExistsResponse
func (c *ClientWithResponses) TeamExistsWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*TeamExistsResponse, error) {
	rsp, err := c.TeamExists(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamExistsResponse(rsp)
}

// GetChannelByNameForTeamNameWithResponse request returning *GetChannelByNameForTeamNameResponse
func (c *ClientWithResponses) GetChannelByNameForTeamNameWithResponse(ctx context.Context, teamName string, channelName string, params *GetChannelByNameForTeamNameParams, reqEditors ...RequestEditorFn) (*GetChannelByNameForTeamNameResponse, error) {
	rsp, err := c.GetChannelByNameForTeamName(ctx, teamName, channelName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelByNameForTeamNameResponse(rsp)
}

// SearchTeamsWithBodyWithResponse request with arbitrary body returning *SearchTeamsResponse
func (c *ClientWithResponses) SearchTeamsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchTeamsResponse, error) {
	rsp, err := c.SearchTeamsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTeamsResponse(rsp)
}

func (c *ClientWithResponses) SearchTeamsWithResponse(ctx context.Context, body SearchTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchTeamsResponse, error) {
	rsp, err := c.SearchTeams(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTeamsResponse(rsp)
}

// SoftDeleteTeamWithResponse request returning *SoftDeleteTeamResponse
func (c *ClientWithResponses) SoftDeleteTeamWithResponse(ctx context.Context, teamId string, params *SoftDeleteTeamParams, reqEditors ...RequestEditorFn) (*SoftDeleteTeamResponse, error) {
	rsp, err := c.SoftDeleteTeam(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSoftDeleteTeamResponse(rsp)
}

// GetTeamWithResponse request returning *GetTeamResponse
func (c *ClientWithResponses) GetTeamWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*GetTeamResponse, error) {
	rsp, err := c.GetTeam(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamResponse(rsp)
}

// UpdateTeamWithBodyWithResponse request with arbitrary body returning *UpdateTeamResponse
func (c *ClientWithResponses) UpdateTeamWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error) {
	rsp, err := c.UpdateTeamWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamResponse(rsp)
}

func (c *ClientWithResponses) UpdateTeamWithResponse(ctx context.Context, teamId string, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error) {
	rsp, err := c.UpdateTeam(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamResponse(rsp)
}

// GetPublicChannelsForTeamWithResponse request returning *GetPublicChannelsForTeamResponse
func (c *ClientWithResponses) GetPublicChannelsForTeamWithResponse(ctx context.Context, teamId string, params *GetPublicChannelsForTeamParams, reqEditors ...RequestEditorFn) (*GetPublicChannelsForTeamResponse, error) {
	rsp, err := c.GetPublicChannelsForTeam(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicChannelsForTeamResponse(rsp)
}

// AutocompleteChannelsForTeamWithResponse request returning *AutocompleteChannelsForTeamResponse
func (c *ClientWithResponses) AutocompleteChannelsForTeamWithResponse(ctx context.Context, teamId string, params *AutocompleteChannelsForTeamParams, reqEditors ...RequestEditorFn) (*AutocompleteChannelsForTeamResponse, error) {
	rsp, err := c.AutocompleteChannelsForTeam(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutocompleteChannelsForTeamResponse(rsp)
}

// GetDeletedChannelsForTeamWithResponse request returning *GetDeletedChannelsForTeamResponse
func (c *ClientWithResponses) GetDeletedChannelsForTeamWithResponse(ctx context.Context, teamId string, params *GetDeletedChannelsForTeamParams, reqEditors ...RequestEditorFn) (*GetDeletedChannelsForTeamResponse, error) {
	rsp, err := c.GetDeletedChannelsForTeam(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeletedChannelsForTeamResponse(rsp)
}

// GetPublicChannelsByIdsForTeamWithBodyWithResponse request with arbitrary body returning *GetPublicChannelsByIdsForTeamResponse
func (c *ClientWithResponses) GetPublicChannelsByIdsForTeamWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPublicChannelsByIdsForTeamResponse, error) {
	rsp, err := c.GetPublicChannelsByIdsForTeamWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicChannelsByIdsForTeamResponse(rsp)
}

func (c *ClientWithResponses) GetPublicChannelsByIdsForTeamWithResponse(ctx context.Context, teamId string, body GetPublicChannelsByIdsForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPublicChannelsByIdsForTeamResponse, error) {
	rsp, err := c.GetPublicChannelsByIdsForTeam(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicChannelsByIdsForTeamResponse(rsp)
}

// GetChannelByNameWithResponse request returning *GetChannelByNameResponse
func (c *ClientWithResponses) GetChannelByNameWithResponse(ctx context.Context, teamId string, channelName string, params *GetChannelByNameParams, reqEditors ...RequestEditorFn) (*GetChannelByNameResponse, error) {
	rsp, err := c.GetChannelByName(ctx, teamId, channelName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelByNameResponse(rsp)
}

// GetPrivateChannelsForTeamWithResponse request returning *GetPrivateChannelsForTeamResponse
func (c *ClientWithResponses) GetPrivateChannelsForTeamWithResponse(ctx context.Context, teamId string, params *GetPrivateChannelsForTeamParams, reqEditors ...RequestEditorFn) (*GetPrivateChannelsForTeamResponse, error) {
	rsp, err := c.GetPrivateChannelsForTeam(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPrivateChannelsForTeamResponse(rsp)
}

// SearchChannelsWithBodyWithResponse request with arbitrary body returning *SearchChannelsResponse
func (c *ClientWithResponses) SearchChannelsWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchChannelsResponse, error) {
	rsp, err := c.SearchChannelsWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchChannelsResponse(rsp)
}

func (c *ClientWithResponses) SearchChannelsWithResponse(ctx context.Context, teamId string, body SearchChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchChannelsResponse, error) {
	rsp, err := c.SearchChannels(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchChannelsResponse(rsp)
}

// SearchArchivedChannelsWithBodyWithResponse request with arbitrary body returning *SearchArchivedChannelsResponse
func (c *ClientWithResponses) SearchArchivedChannelsWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchArchivedChannelsResponse, error) {
	rsp, err := c.SearchArchivedChannelsWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchArchivedChannelsResponse(rsp)
}

func (c *ClientWithResponses) SearchArchivedChannelsWithResponse(ctx context.Context, teamId string, body SearchArchivedChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchArchivedChannelsResponse, error) {
	rsp, err := c.SearchArchivedChannels(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchArchivedChannelsResponse(rsp)
}

// AutocompleteChannelsForTeamForSearchWithResponse request returning *AutocompleteChannelsForTeamForSearchResponse
func (c *ClientWithResponses) AutocompleteChannelsForTeamForSearchWithResponse(ctx context.Context, teamId string, params *AutocompleteChannelsForTeamForSearchParams, reqEditors ...RequestEditorFn) (*AutocompleteChannelsForTeamForSearchResponse, error) {
	rsp, err := c.AutocompleteChannelsForTeamForSearch(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutocompleteChannelsForTeamForSearchResponse(rsp)
}

// ListAutocompleteCommandsWithResponse request returning *ListAutocompleteCommandsResponse
func (c *ClientWithResponses) ListAutocompleteCommandsWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*ListAutocompleteCommandsResponse, error) {
	rsp, err := c.ListAutocompleteCommands(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAutocompleteCommandsResponse(rsp)
}

// ListCommandAutocompleteSuggestionsWithResponse request returning *ListCommandAutocompleteSuggestionsResponse
func (c *ClientWithResponses) ListCommandAutocompleteSuggestionsWithResponse(ctx context.Context, teamId string, params *ListCommandAutocompleteSuggestionsParams, reqEditors ...RequestEditorFn) (*ListCommandAutocompleteSuggestionsResponse, error) {
	rsp, err := c.ListCommandAutocompleteSuggestions(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCommandAutocompleteSuggestionsResponse(rsp)
}

// SearchFilesWithBodyWithResponse request with arbitrary body returning *SearchFilesResponse
func (c *ClientWithResponses) SearchFilesWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchFilesResponse, error) {
	rsp, err := c.SearchFilesWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchFilesResponse(rsp)
}

// GetGroupsByTeamWithResponse request returning *GetGroupsByTeamResponse
func (c *ClientWithResponses) GetGroupsByTeamWithResponse(ctx context.Context, teamId string, params *GetGroupsByTeamParams, reqEditors ...RequestEditorFn) (*GetGroupsByTeamResponse, error) {
	rsp, err := c.GetGroupsByTeam(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsByTeamResponse(rsp)
}

// GetGroupsAssociatedToChannelsByTeamWithResponse request returning *GetGroupsAssociatedToChannelsByTeamResponse
func (c *ClientWithResponses) GetGroupsAssociatedToChannelsByTeamWithResponse(ctx context.Context, teamId string, params *GetGroupsAssociatedToChannelsByTeamParams, reqEditors ...RequestEditorFn) (*GetGroupsAssociatedToChannelsByTeamResponse, error) {
	rsp, err := c.GetGroupsAssociatedToChannelsByTeam(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsAssociatedToChannelsByTeamResponse(rsp)
}

// RemoveTeamIconWithResponse request returning *RemoveTeamIconResponse
func (c *ClientWithResponses) RemoveTeamIconWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*RemoveTeamIconResponse, error) {
	rsp, err := c.RemoveTeamIcon(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTeamIconResponse(rsp)
}

// GetTeamIconWithResponse request returning *GetTeamIconResponse
func (c *ClientWithResponses) GetTeamIconWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*GetTeamIconResponse, error) {
	rsp, err := c.GetTeamIcon(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamIconResponse(rsp)
}

// SetTeamIconWithBodyWithResponse request with arbitrary body returning *SetTeamIconResponse
func (c *ClientWithResponses) SetTeamIconWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetTeamIconResponse, error) {
	rsp, err := c.SetTeamIconWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetTeamIconResponse(rsp)
}

// ImportTeamWithBodyWithResponse request with arbitrary body returning *ImportTeamResponse
func (c *ClientWithResponses) ImportTeamWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportTeamResponse, error) {
	rsp, err := c.ImportTeamWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportTeamResponse(rsp)
}

// InviteGuestsToTeamWithBodyWithResponse request with arbitrary body returning *InviteGuestsToTeamResponse
func (c *ClientWithResponses) InviteGuestsToTeamWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteGuestsToTeamResponse, error) {
	rsp, err := c.InviteGuestsToTeamWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteGuestsToTeamResponse(rsp)
}

func (c *ClientWithResponses) InviteGuestsToTeamWithResponse(ctx context.Context, teamId string, body InviteGuestsToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteGuestsToTeamResponse, error) {
	rsp, err := c.InviteGuestsToTeam(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteGuestsToTeamResponse(rsp)
}

// InviteUsersToTeamWithBodyWithResponse request with arbitrary body returning *InviteUsersToTeamResponse
func (c *ClientWithResponses) InviteUsersToTeamWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUsersToTeamResponse, error) {
	rsp, err := c.InviteUsersToTeamWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUsersToTeamResponse(rsp)
}

func (c *ClientWithResponses) InviteUsersToTeamWithResponse(ctx context.Context, teamId string, body InviteUsersToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUsersToTeamResponse, error) {
	rsp, err := c.InviteUsersToTeam(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUsersToTeamResponse(rsp)
}

// GetTeamMembersWithResponse request returning *GetTeamMembersResponse
func (c *ClientWithResponses) GetTeamMembersWithResponse(ctx context.Context, teamId string, params *GetTeamMembersParams, reqEditors ...RequestEditorFn) (*GetTeamMembersResponse, error) {
	rsp, err := c.GetTeamMembers(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamMembersResponse(rsp)
}

// AddTeamMemberWithBodyWithResponse request with arbitrary body returning *AddTeamMemberResponse
func (c *ClientWithResponses) AddTeamMemberWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTeamMemberResponse, error) {
	rsp, err := c.AddTeamMemberWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTeamMemberResponse(rsp)
}

func (c *ClientWithResponses) AddTeamMemberWithResponse(ctx context.Context, teamId string, body AddTeamMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTeamMemberResponse, error) {
	rsp, err := c.AddTeamMember(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTeamMemberResponse(rsp)
}

// AddTeamMembersWithBodyWithResponse request with arbitrary body returning *AddTeamMembersResponse
func (c *ClientWithResponses) AddTeamMembersWithBodyWithResponse(ctx context.Context, teamId string, params *AddTeamMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTeamMembersResponse, error) {
	rsp, err := c.AddTeamMembersWithBody(ctx, teamId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTeamMembersResponse(rsp)
}

func (c *ClientWithResponses) AddTeamMembersWithResponse(ctx context.Context, teamId string, params *AddTeamMembersParams, body AddTeamMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTeamMembersResponse, error) {
	rsp, err := c.AddTeamMembers(ctx, teamId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTeamMembersResponse(rsp)
}

// GetTeamMembersByIdsWithBodyWithResponse request with arbitrary body returning *GetTeamMembersByIdsResponse
func (c *ClientWithResponses) GetTeamMembersByIdsWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetTeamMembersByIdsResponse, error) {
	rsp, err := c.GetTeamMembersByIdsWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamMembersByIdsResponse(rsp)
}

func (c *ClientWithResponses) GetTeamMembersByIdsWithResponse(ctx context.Context, teamId string, body GetTeamMembersByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTeamMembersByIdsResponse, error) {
	rsp, err := c.GetTeamMembersByIds(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamMembersByIdsResponse(rsp)
}

// RemoveTeamMemberWithResponse request returning *RemoveTeamMemberResponse
func (c *ClientWithResponses) RemoveTeamMemberWithResponse(ctx context.Context, teamId string, userId string, reqEditors ...RequestEditorFn) (*RemoveTeamMemberResponse, error) {
	rsp, err := c.RemoveTeamMember(ctx, teamId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTeamMemberResponse(rsp)
}

// GetTeamMemberWithResponse request returning *GetTeamMemberResponse
func (c *ClientWithResponses) GetTeamMemberWithResponse(ctx context.Context, teamId string, userId string, reqEditors ...RequestEditorFn) (*GetTeamMemberResponse, error) {
	rsp, err := c.GetTeamMember(ctx, teamId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamMemberResponse(rsp)
}

// UpdateTeamMemberRolesWithBodyWithResponse request with arbitrary body returning *UpdateTeamMemberRolesResponse
func (c *ClientWithResponses) UpdateTeamMemberRolesWithBodyWithResponse(ctx context.Context, teamId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamMemberRolesResponse, error) {
	rsp, err := c.UpdateTeamMemberRolesWithBody(ctx, teamId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamMemberRolesResponse(rsp)
}

func (c *ClientWithResponses) UpdateTeamMemberRolesWithResponse(ctx context.Context, teamId string, userId string, body UpdateTeamMemberRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamMemberRolesResponse, error) {
	rsp, err := c.UpdateTeamMemberRoles(ctx, teamId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamMemberRolesResponse(rsp)
}

// UpdateTeamMemberSchemeRolesWithBodyWithResponse request with arbitrary body returning *UpdateTeamMemberSchemeRolesResponse
func (c *ClientWithResponses) UpdateTeamMemberSchemeRolesWithBodyWithResponse(ctx context.Context, teamId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamMemberSchemeRolesResponse, error) {
	rsp, err := c.UpdateTeamMemberSchemeRolesWithBody(ctx, teamId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamMemberSchemeRolesResponse(rsp)
}

func (c *ClientWithResponses) UpdateTeamMemberSchemeRolesWithResponse(ctx context.Context, teamId string, userId string, body UpdateTeamMemberSchemeRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamMemberSchemeRolesResponse, error) {
	rsp, err := c.UpdateTeamMemberSchemeRoles(ctx, teamId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamMemberSchemeRolesResponse(rsp)
}

// TeamMembersMinusGroupMembersWithResponse request returning *TeamMembersMinusGroupMembersResponse
func (c *ClientWithResponses) TeamMembersMinusGroupMembersWithResponse(ctx context.Context, teamId string, params *TeamMembersMinusGroupMembersParams, reqEditors ...RequestEditorFn) (*TeamMembersMinusGroupMembersResponse, error) {
	rsp, err := c.TeamMembersMinusGroupMembers(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamMembersMinusGroupMembersResponse(rsp)
}

// PatchTeamWithBodyWithResponse request with arbitrary body returning *PatchTeamResponse
func (c *ClientWithResponses) PatchTeamWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchTeamResponse, error) {
	rsp, err := c.PatchTeamWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchTeamResponse(rsp)
}

func (c *ClientWithResponses) PatchTeamWithResponse(ctx context.Context, teamId string, body PatchTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchTeamResponse, error) {
	rsp, err := c.PatchTeam(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchTeamResponse(rsp)
}

// SearchPostsWithBodyWithResponse request with arbitrary body returning *SearchPostsResponse
func (c *ClientWithResponses) SearchPostsWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchPostsResponse, error) {
	rsp, err := c.SearchPostsWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchPostsResponse(rsp)
}

func (c *ClientWithResponses) SearchPostsWithResponse(ctx context.Context, teamId string, body SearchPostsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchPostsResponse, error) {
	rsp, err := c.SearchPosts(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchPostsResponse(rsp)
}

// UpdateTeamPrivacyWithBodyWithResponse request with arbitrary body returning *UpdateTeamPrivacyResponse
func (c *ClientWithResponses) UpdateTeamPrivacyWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamPrivacyResponse, error) {
	rsp, err := c.UpdateTeamPrivacyWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamPrivacyResponse(rsp)
}

func (c *ClientWithResponses) UpdateTeamPrivacyWithResponse(ctx context.Context, teamId string, body UpdateTeamPrivacyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamPrivacyResponse, error) {
	rsp, err := c.UpdateTeamPrivacy(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamPrivacyResponse(rsp)
}

// RegenerateTeamInviteIdWithResponse request returning *RegenerateTeamInviteIdResponse
func (c *ClientWithResponses) RegenerateTeamInviteIdWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*RegenerateTeamInviteIdResponse, error) {
	rsp, err := c.RegenerateTeamInviteId(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegenerateTeamInviteIdResponse(rsp)
}

// RestoreTeamWithResponse request returning *RestoreTeamResponse
func (c *ClientWithResponses) RestoreTeamWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*RestoreTeamResponse, error) {
	rsp, err := c.RestoreTeam(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreTeamResponse(rsp)
}

// UpdateTeamSchemeWithBodyWithResponse request with arbitrary body returning *UpdateTeamSchemeResponse
func (c *ClientWithResponses) UpdateTeamSchemeWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamSchemeResponse, error) {
	rsp, err := c.UpdateTeamSchemeWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamSchemeResponse(rsp)
}

func (c *ClientWithResponses) UpdateTeamSchemeWithResponse(ctx context.Context, teamId string, body UpdateTeamSchemeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamSchemeResponse, error) {
	rsp, err := c.UpdateTeamScheme(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamSchemeResponse(rsp)
}

// GetTeamStatsWithResponse request returning *GetTeamStatsResponse
func (c *ClientWithResponses) GetTeamStatsWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*GetTeamStatsResponse, error) {
	rsp, err := c.GetTeamStats(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamStatsResponse(rsp)
}

// GetTermsOfServiceWithResponse request returning *GetTermsOfServiceResponse
func (c *ClientWithResponses) GetTermsOfServiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTermsOfServiceResponse, error) {
	rsp, err := c.GetTermsOfService(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTermsOfServiceResponse(rsp)
}

// CreateTermsOfServiceWithResponse request returning *CreateTermsOfServiceResponse
func (c *ClientWithResponses) CreateTermsOfServiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateTermsOfServiceResponse, error) {
	rsp, err := c.CreateTermsOfService(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTermsOfServiceResponse(rsp)
}

// RequestTrialLicenseWithBodyWithResponse request with arbitrary body returning *RequestTrialLicenseResponse
func (c *ClientWithResponses) RequestTrialLicenseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestTrialLicenseResponse, error) {
	rsp, err := c.RequestTrialLicenseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestTrialLicenseResponse(rsp)
}

func (c *ClientWithResponses) RequestTrialLicenseWithResponse(ctx context.Context, body RequestTrialLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestTrialLicenseResponse, error) {
	rsp, err := c.RequestTrialLicense(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestTrialLicenseResponse(rsp)
}

// GetPrevTrialLicenseWithResponse request returning *GetPrevTrialLicenseResponse
func (c *ClientWithResponses) GetPrevTrialLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPrevTrialLicenseResponse, error) {
	rsp, err := c.GetPrevTrialLicense(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPrevTrialLicenseResponse(rsp)
}

// UpgradeToEnterpriseWithResponse request returning *UpgradeToEnterpriseResponse
func (c *ClientWithResponses) UpgradeToEnterpriseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpgradeToEnterpriseResponse, error) {
	rsp, err := c.UpgradeToEnterprise(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpgradeToEnterpriseResponse(rsp)
}

// UpgradeToEnterpriseStatusWithResponse request returning *UpgradeToEnterpriseStatusResponse
func (c *ClientWithResponses) UpgradeToEnterpriseStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpgradeToEnterpriseStatusResponse, error) {
	rsp, err := c.UpgradeToEnterpriseStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpgradeToEnterpriseStatusResponse(rsp)
}

// CreateUploadWithBodyWithResponse request with arbitrary body returning *CreateUploadResponse
func (c *ClientWithResponses) CreateUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUploadResponse, error) {
	rsp, err := c.CreateUploadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUploadResponse(rsp)
}

func (c *ClientWithResponses) CreateUploadWithResponse(ctx context.Context, body CreateUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUploadResponse, error) {
	rsp, err := c.CreateUpload(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUploadResponse(rsp)
}

// GetUploadWithResponse request returning *GetUploadResponse
func (c *ClientWithResponses) GetUploadWithResponse(ctx context.Context, uploadId string, reqEditors ...RequestEditorFn) (*GetUploadResponse, error) {
	rsp, err := c.GetUpload(ctx, uploadId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUploadResponse(rsp)
}

// UploadDataWithBodyWithResponse request with arbitrary body returning *UploadDataResponse
func (c *ClientWithResponses) UploadDataWithBodyWithResponse(ctx context.Context, uploadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadDataResponse, error) {
	rsp, err := c.UploadDataWithBody(ctx, uploadId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadDataResponse(rsp)
}

func (c *ClientWithResponses) UploadDataWithFormdataBodyWithResponse(ctx context.Context, uploadId string, body UploadDataFormdataRequestBody, reqEditors ...RequestEditorFn) (*UploadDataResponse, error) {
	rsp, err := c.UploadDataWithFormdataBody(ctx, uploadId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadDataResponse(rsp)
}

// GetPostsUsageWithResponse request returning *GetPostsUsageResponse
func (c *ClientWithResponses) GetPostsUsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPostsUsageResponse, error) {
	rsp, err := c.GetPostsUsage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostsUsageResponse(rsp)
}

// GetStorageUsageWithResponse request returning *GetStorageUsageResponse
func (c *ClientWithResponses) GetStorageUsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageUsageResponse, error) {
	rsp, err := c.GetStorageUsage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageUsageResponse(rsp)
}

// PermanentDeleteAllUsersWithResponse request returning *PermanentDeleteAllUsersResponse
func (c *ClientWithResponses) PermanentDeleteAllUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PermanentDeleteAllUsersResponse, error) {
	rsp, err := c.PermanentDeleteAllUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermanentDeleteAllUsersResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// AutocompleteUsersWithResponse request returning *AutocompleteUsersResponse
func (c *ClientWithResponses) AutocompleteUsersWithResponse(ctx context.Context, params *AutocompleteUsersParams, reqEditors ...RequestEditorFn) (*AutocompleteUsersResponse, error) {
	rsp, err := c.AutocompleteUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutocompleteUsersResponse(rsp)
}

// VerifyUserEmailWithBodyWithResponse request with arbitrary body returning *VerifyUserEmailResponse
func (c *ClientWithResponses) VerifyUserEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyUserEmailResponse, error) {
	rsp, err := c.VerifyUserEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyUserEmailResponse(rsp)
}

func (c *ClientWithResponses) VerifyUserEmailWithResponse(ctx context.Context, body VerifyUserEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyUserEmailResponse, error) {
	rsp, err := c.VerifyUserEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyUserEmailResponse(rsp)
}

// SendVerificationEmailWithBodyWithResponse request with arbitrary body returning *SendVerificationEmailResponse
func (c *ClientWithResponses) SendVerificationEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendVerificationEmailResponse, error) {
	rsp, err := c.SendVerificationEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendVerificationEmailResponse(rsp)
}

func (c *ClientWithResponses) SendVerificationEmailWithResponse(ctx context.Context, body SendVerificationEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*SendVerificationEmailResponse, error) {
	rsp, err := c.SendVerificationEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendVerificationEmailResponse(rsp)
}

// GetUserByEmailWithResponse request returning *GetUserByEmailResponse
func (c *ClientWithResponses) GetUserByEmailWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*GetUserByEmailResponse, error) {
	rsp, err := c.GetUserByEmail(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserByEmailResponse(rsp)
}

// GetUsersByGroupChannelIdsWithBodyWithResponse request with arbitrary body returning *GetUsersByGroupChannelIdsResponse
func (c *ClientWithResponses) GetUsersByGroupChannelIdsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUsersByGroupChannelIdsResponse, error) {
	rsp, err := c.GetUsersByGroupChannelIdsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersByGroupChannelIdsResponse(rsp)
}

func (c *ClientWithResponses) GetUsersByGroupChannelIdsWithResponse(ctx context.Context, body GetUsersByGroupChannelIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUsersByGroupChannelIdsResponse, error) {
	rsp, err := c.GetUsersByGroupChannelIds(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersByGroupChannelIdsResponse(rsp)
}

// GetUsersByIdsWithBodyWithResponse request with arbitrary body returning *GetUsersByIdsResponse
func (c *ClientWithResponses) GetUsersByIdsWithBodyWithResponse(ctx context.Context, params *GetUsersByIdsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUsersByIdsResponse, error) {
	rsp, err := c.GetUsersByIdsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersByIdsResponse(rsp)
}

func (c *ClientWithResponses) GetUsersByIdsWithResponse(ctx context.Context, params *GetUsersByIdsParams, body GetUsersByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUsersByIdsResponse, error) {
	rsp, err := c.GetUsersByIds(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersByIdsResponse(rsp)
}

// GetUsersWithInvalidEmailsWithResponse request returning *GetUsersWithInvalidEmailsResponse
func (c *ClientWithResponses) GetUsersWithInvalidEmailsWithResponse(ctx context.Context, params *GetUsersWithInvalidEmailsParams, reqEditors ...RequestEditorFn) (*GetUsersWithInvalidEmailsResponse, error) {
	rsp, err := c.GetUsersWithInvalidEmails(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersWithInvalidEmailsResponse(rsp)
}

// GetKnownUsersWithResponse request returning *GetKnownUsersResponse
func (c *ClientWithResponses) GetKnownUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKnownUsersResponse, error) {
	rsp, err := c.GetKnownUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKnownUsersResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// LoginByCwsTokenWithBodyWithResponse request with arbitrary body returning *LoginByCwsTokenResponse
func (c *ClientWithResponses) LoginByCwsTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginByCwsTokenResponse, error) {
	rsp, err := c.LoginByCwsTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginByCwsTokenResponse(rsp)
}

func (c *ClientWithResponses) LoginByCwsTokenWithResponse(ctx context.Context, body LoginByCwsTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginByCwsTokenResponse, error) {
	rsp, err := c.LoginByCwsToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginByCwsTokenResponse(rsp)
}

// SwitchAccountTypeWithBodyWithResponse request with arbitrary body returning *SwitchAccountTypeResponse
func (c *ClientWithResponses) SwitchAccountTypeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SwitchAccountTypeResponse, error) {
	rsp, err := c.SwitchAccountTypeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSwitchAccountTypeResponse(rsp)
}

func (c *ClientWithResponses) SwitchAccountTypeWithResponse(ctx context.Context, body SwitchAccountTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*SwitchAccountTypeResponse, error) {
	rsp, err := c.SwitchAccountType(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSwitchAccountTypeResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// CheckUserMfaWithBodyWithResponse request with arbitrary body returning *CheckUserMfaResponse
func (c *ClientWithResponses) CheckUserMfaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckUserMfaResponse, error) {
	rsp, err := c.CheckUserMfaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckUserMfaResponse(rsp)
}

func (c *ClientWithResponses) CheckUserMfaWithResponse(ctx context.Context, body CheckUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckUserMfaResponse, error) {
	rsp, err := c.CheckUserMfa(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckUserMfaResponse(rsp)
}

// MigrateAuthToLdapWithBodyWithResponse request with arbitrary body returning *MigrateAuthToLdapResponse
func (c *ClientWithResponses) MigrateAuthToLdapWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateAuthToLdapResponse, error) {
	rsp, err := c.MigrateAuthToLdapWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateAuthToLdapResponse(rsp)
}

func (c *ClientWithResponses) MigrateAuthToLdapWithResponse(ctx context.Context, body MigrateAuthToLdapJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateAuthToLdapResponse, error) {
	rsp, err := c.MigrateAuthToLdap(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateAuthToLdapResponse(rsp)
}

// MigrateAuthToSamlWithBodyWithResponse request with arbitrary body returning *MigrateAuthToSamlResponse
func (c *ClientWithResponses) MigrateAuthToSamlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrateAuthToSamlResponse, error) {
	rsp, err := c.MigrateAuthToSamlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateAuthToSamlResponse(rsp)
}

func (c *ClientWithResponses) MigrateAuthToSamlWithResponse(ctx context.Context, body MigrateAuthToSamlJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrateAuthToSamlResponse, error) {
	rsp, err := c.MigrateAuthToSaml(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrateAuthToSamlResponse(rsp)
}

// ResetPasswordWithBodyWithResponse request with arbitrary body returning *ResetPasswordResponse
func (c *ClientWithResponses) ResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

func (c *ClientWithResponses) ResetPasswordWithResponse(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

// SendPasswordResetEmailWithBodyWithResponse request with arbitrary body returning *SendPasswordResetEmailResponse
func (c *ClientWithResponses) SendPasswordResetEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendPasswordResetEmailResponse, error) {
	rsp, err := c.SendPasswordResetEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendPasswordResetEmailResponse(rsp)
}

func (c *ClientWithResponses) SendPasswordResetEmailWithResponse(ctx context.Context, body SendPasswordResetEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*SendPasswordResetEmailResponse, error) {
	rsp, err := c.SendPasswordResetEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendPasswordResetEmailResponse(rsp)
}

// SearchUsersWithBodyWithResponse request with arbitrary body returning *SearchUsersResponse
func (c *ClientWithResponses) SearchUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUsersResponse, error) {
	rsp, err := c.SearchUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersResponse(rsp)
}

func (c *ClientWithResponses) SearchUsersWithResponse(ctx context.Context, body SearchUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUsersResponse, error) {
	rsp, err := c.SearchUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersResponse(rsp)
}

// AttachDeviceExtraPropsWithBodyWithResponse request with arbitrary body returning *AttachDeviceExtraPropsResponse
func (c *ClientWithResponses) AttachDeviceExtraPropsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachDeviceExtraPropsResponse, error) {
	rsp, err := c.AttachDeviceExtraPropsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachDeviceExtraPropsResponse(rsp)
}

func (c *ClientWithResponses) AttachDeviceExtraPropsWithResponse(ctx context.Context, body AttachDeviceExtraPropsJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachDeviceExtraPropsResponse, error) {
	rsp, err := c.AttachDeviceExtraProps(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachDeviceExtraPropsResponse(rsp)
}

// RevokeSessionsFromAllUsersWithResponse request returning *RevokeSessionsFromAllUsersResponse
func (c *ClientWithResponses) RevokeSessionsFromAllUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RevokeSessionsFromAllUsersResponse, error) {
	rsp, err := c.RevokeSessionsFromAllUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeSessionsFromAllUsersResponse(rsp)
}

// GetTotalUsersStatsWithResponse request returning *GetTotalUsersStatsResponse
func (c *ClientWithResponses) GetTotalUsersStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTotalUsersStatsResponse, error) {
	rsp, err := c.GetTotalUsersStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTotalUsersStatsResponse(rsp)
}

// GetTotalUsersStatsFilteredWithResponse request returning *GetTotalUsersStatsFilteredResponse
func (c *ClientWithResponses) GetTotalUsersStatsFilteredWithResponse(ctx context.Context, params *GetTotalUsersStatsFilteredParams, reqEditors ...RequestEditorFn) (*GetTotalUsersStatsFilteredResponse, error) {
	rsp, err := c.GetTotalUsersStatsFiltered(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTotalUsersStatsFilteredResponse(rsp)
}

// GetUsersStatusesByIdsWithBodyWithResponse request with arbitrary body returning *GetUsersStatusesByIdsResponse
func (c *ClientWithResponses) GetUsersStatusesByIdsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUsersStatusesByIdsResponse, error) {
	rsp, err := c.GetUsersStatusesByIdsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersStatusesByIdsResponse(rsp)
}

func (c *ClientWithResponses) GetUsersStatusesByIdsWithResponse(ctx context.Context, body GetUsersStatusesByIdsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUsersStatusesByIdsResponse, error) {
	rsp, err := c.GetUsersStatusesByIds(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersStatusesByIdsResponse(rsp)
}

// GetUserAccessTokensWithResponse request returning *GetUserAccessTokensResponse
func (c *ClientWithResponses) GetUserAccessTokensWithResponse(ctx context.Context, params *GetUserAccessTokensParams, reqEditors ...RequestEditorFn) (*GetUserAccessTokensResponse, error) {
	rsp, err := c.GetUserAccessTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserAccessTokensResponse(rsp)
}

// DisableUserAccessTokenWithBodyWithResponse request with arbitrary body returning *DisableUserAccessTokenResponse
func (c *ClientWithResponses) DisableUserAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableUserAccessTokenResponse, error) {
	rsp, err := c.DisableUserAccessTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableUserAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) DisableUserAccessTokenWithResponse(ctx context.Context, body DisableUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableUserAccessTokenResponse, error) {
	rsp, err := c.DisableUserAccessToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableUserAccessTokenResponse(rsp)
}

// EnableUserAccessTokenWithBodyWithResponse request with arbitrary body returning *EnableUserAccessTokenResponse
func (c *ClientWithResponses) EnableUserAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableUserAccessTokenResponse, error) {
	rsp, err := c.EnableUserAccessTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableUserAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) EnableUserAccessTokenWithResponse(ctx context.Context, body EnableUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableUserAccessTokenResponse, error) {
	rsp, err := c.EnableUserAccessToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableUserAccessTokenResponse(rsp)
}

// RevokeUserAccessTokenWithBodyWithResponse request with arbitrary body returning *RevokeUserAccessTokenResponse
func (c *ClientWithResponses) RevokeUserAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeUserAccessTokenResponse, error) {
	rsp, err := c.RevokeUserAccessTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeUserAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) RevokeUserAccessTokenWithResponse(ctx context.Context, body RevokeUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeUserAccessTokenResponse, error) {
	rsp, err := c.RevokeUserAccessToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeUserAccessTokenResponse(rsp)
}

// SearchUserAccessTokensWithBodyWithResponse request with arbitrary body returning *SearchUserAccessTokensResponse
func (c *ClientWithResponses) SearchUserAccessTokensWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUserAccessTokensResponse, error) {
	rsp, err := c.SearchUserAccessTokensWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUserAccessTokensResponse(rsp)
}

func (c *ClientWithResponses) SearchUserAccessTokensWithResponse(ctx context.Context, body SearchUserAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUserAccessTokensResponse, error) {
	rsp, err := c.SearchUserAccessTokens(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUserAccessTokensResponse(rsp)
}

// GetUserAccessTokenWithResponse request returning *GetUserAccessTokenResponse
func (c *ClientWithResponses) GetUserAccessTokenWithResponse(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*GetUserAccessTokenResponse, error) {
	rsp, err := c.GetUserAccessToken(ctx, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserAccessTokenResponse(rsp)
}

// GetUserByUsernameWithResponse request returning *GetUserByUsernameResponse
func (c *ClientWithResponses) GetUserByUsernameWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserByUsernameResponse, error) {
	rsp, err := c.GetUserByUsername(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserByUsernameResponse(rsp)
}

// GetUsersByUsernamesWithBodyWithResponse request with arbitrary body returning *GetUsersByUsernamesResponse
func (c *ClientWithResponses) GetUsersByUsernamesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUsersByUsernamesResponse, error) {
	rsp, err := c.GetUsersByUsernamesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersByUsernamesResponse(rsp)
}

func (c *ClientWithResponses) GetUsersByUsernamesWithResponse(ctx context.Context, body GetUsersByUsernamesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUsersByUsernamesResponse, error) {
	rsp, err := c.GetUsersByUsernames(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersByUsernamesResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// UpdateUserActiveWithBodyWithResponse request with arbitrary body returning *UpdateUserActiveResponse
func (c *ClientWithResponses) UpdateUserActiveWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserActiveResponse, error) {
	rsp, err := c.UpdateUserActiveWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserActiveResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserActiveWithResponse(ctx context.Context, userId string, body UpdateUserActiveJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserActiveResponse, error) {
	rsp, err := c.UpdateUserActive(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserActiveResponse(rsp)
}

// GetUserAuditsWithResponse request returning *GetUserAuditsResponse
func (c *ClientWithResponses) GetUserAuditsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserAuditsResponse, error) {
	rsp, err := c.GetUserAudits(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserAuditsResponse(rsp)
}

// UpdateUserAuthWithBodyWithResponse request with arbitrary body returning *UpdateUserAuthResponse
func (c *ClientWithResponses) UpdateUserAuthWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserAuthResponse, error) {
	rsp, err := c.UpdateUserAuthWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserAuthResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserAuthWithResponse(ctx context.Context, userId string, body UpdateUserAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserAuthResponse, error) {
	rsp, err := c.UpdateUserAuth(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserAuthResponse(rsp)
}

// GetChannelMembersWithTeamDataForUserWithResponse request returning *GetChannelMembersWithTeamDataForUserResponse
func (c *ClientWithResponses) GetChannelMembersWithTeamDataForUserWithResponse(ctx context.Context, userId string, params *GetChannelMembersWithTeamDataForUserParams, reqEditors ...RequestEditorFn) (*GetChannelMembersWithTeamDataForUserResponse, error) {
	rsp, err := c.GetChannelMembersWithTeamDataForUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelMembersWithTeamDataForUserResponse(rsp)
}

// GetChannelsForUserWithResponse request returning *GetChannelsForUserResponse
func (c *ClientWithResponses) GetChannelsForUserWithResponse(ctx context.Context, userId string, params *GetChannelsForUserParams, reqEditors ...RequestEditorFn) (*GetChannelsForUserResponse, error) {
	rsp, err := c.GetChannelsForUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelsForUserResponse(rsp)
}

// GetPostsAroundLastUnreadWithResponse request returning *GetPostsAroundLastUnreadResponse
func (c *ClientWithResponses) GetPostsAroundLastUnreadWithResponse(ctx context.Context, userId string, channelId string, params *GetPostsAroundLastUnreadParams, reqEditors ...RequestEditorFn) (*GetPostsAroundLastUnreadResponse, error) {
	rsp, err := c.GetPostsAroundLastUnread(ctx, userId, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostsAroundLastUnreadResponse(rsp)
}

// GetChannelUnreadWithResponse request returning *GetChannelUnreadResponse
func (c *ClientWithResponses) GetChannelUnreadWithResponse(ctx context.Context, userId string, channelId string, reqEditors ...RequestEditorFn) (*GetChannelUnreadResponse, error) {
	rsp, err := c.GetChannelUnread(ctx, userId, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelUnreadResponse(rsp)
}

// ConvertUserToBotWithResponse request returning *ConvertUserToBotResponse
func (c *ClientWithResponses) ConvertUserToBotWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*ConvertUserToBotResponse, error) {
	rsp, err := c.ConvertUserToBot(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertUserToBotResponse(rsp)
}

// GetChannelPoliciesForUserWithResponse request returning *GetChannelPoliciesForUserResponse
func (c *ClientWithResponses) GetChannelPoliciesForUserWithResponse(ctx context.Context, userId string, params *GetChannelPoliciesForUserParams, reqEditors ...RequestEditorFn) (*GetChannelPoliciesForUserResponse, error) {
	rsp, err := c.GetChannelPoliciesForUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelPoliciesForUserResponse(rsp)
}

// GetTeamPoliciesForUserWithResponse request returning *GetTeamPoliciesForUserResponse
func (c *ClientWithResponses) GetTeamPoliciesForUserWithResponse(ctx context.Context, userId string, params *GetTeamPoliciesForUserParams, reqEditors ...RequestEditorFn) (*GetTeamPoliciesForUserResponse, error) {
	rsp, err := c.GetTeamPoliciesForUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamPoliciesForUserResponse(rsp)
}

// DemoteUserToGuestWithResponse request returning *DemoteUserToGuestResponse
func (c *ClientWithResponses) DemoteUserToGuestWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DemoteUserToGuestResponse, error) {
	rsp, err := c.DemoteUserToGuest(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDemoteUserToGuestResponse(rsp)
}

// VerifyUserEmailWithoutTokenWithResponse request returning *VerifyUserEmailWithoutTokenResponse
func (c *ClientWithResponses) VerifyUserEmailWithoutTokenWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*VerifyUserEmailWithoutTokenResponse, error) {
	rsp, err := c.VerifyUserEmailWithoutToken(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyUserEmailWithoutTokenResponse(rsp)
}

// GetGroupsByUserIdWithResponse request returning *GetGroupsByUserIdResponse
func (c *ClientWithResponses) GetGroupsByUserIdWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetGroupsByUserIdResponse, error) {
	rsp, err := c.GetGroupsByUserId(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsByUserIdResponse(rsp)
}

// SetDefaultProfileImageWithResponse request returning *SetDefaultProfileImageResponse
func (c *ClientWithResponses) SetDefaultProfileImageWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*SetDefaultProfileImageResponse, error) {
	rsp, err := c.SetDefaultProfileImage(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultProfileImageResponse(rsp)
}

// GetProfileImageWithResponse request returning *GetProfileImageResponse
func (c *ClientWithResponses) GetProfileImageWithResponse(ctx context.Context, userId string, params *GetProfileImageParams, reqEditors ...RequestEditorFn) (*GetProfileImageResponse, error) {
	rsp, err := c.GetProfileImage(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProfileImageResponse(rsp)
}

// SetProfileImageWithBodyWithResponse request with arbitrary body returning *SetProfileImageResponse
func (c *ClientWithResponses) SetProfileImageWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetProfileImageResponse, error) {
	rsp, err := c.SetProfileImageWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetProfileImageResponse(rsp)
}

// GetDefaultProfileImageWithResponse request returning *GetDefaultProfileImageResponse
func (c *ClientWithResponses) GetDefaultProfileImageWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetDefaultProfileImageResponse, error) {
	rsp, err := c.GetDefaultProfileImage(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultProfileImageResponse(rsp)
}

// UpdateUserMfaWithBodyWithResponse request with arbitrary body returning *UpdateUserMfaResponse
func (c *ClientWithResponses) UpdateUserMfaWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserMfaResponse, error) {
	rsp, err := c.UpdateUserMfaWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserMfaResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserMfaWithResponse(ctx context.Context, userId string, body UpdateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserMfaResponse, error) {
	rsp, err := c.UpdateUserMfa(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserMfaResponse(rsp)
}

// GenerateMfaSecretWithResponse request returning *GenerateMfaSecretResponse
func (c *ClientWithResponses) GenerateMfaSecretWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GenerateMfaSecretResponse, error) {
	rsp, err := c.GenerateMfaSecret(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateMfaSecretResponse(rsp)
}

// GetAuthorizedOAuthAppsForUserWithResponse request returning *GetAuthorizedOAuthAppsForUserResponse
func (c *ClientWithResponses) GetAuthorizedOAuthAppsForUserWithResponse(ctx context.Context, userId string, params *GetAuthorizedOAuthAppsForUserParams, reqEditors ...RequestEditorFn) (*GetAuthorizedOAuthAppsForUserResponse, error) {
	rsp, err := c.GetAuthorizedOAuthAppsForUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorizedOAuthAppsForUserResponse(rsp)
}

// UpdateUserPasswordWithBodyWithResponse request with arbitrary body returning *UpdateUserPasswordResponse
func (c *ClientWithResponses) UpdateUserPasswordWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error) {
	rsp, err := c.UpdateUserPasswordWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPasswordResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserPasswordWithResponse(ctx context.Context, userId string, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error) {
	rsp, err := c.UpdateUserPassword(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPasswordResponse(rsp)
}

// PatchUserWithBodyWithResponse request with arbitrary body returning *PatchUserResponse
func (c *ClientWithResponses) PatchUserWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserResponse, error) {
	rsp, err := c.PatchUserWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserResponse(rsp)
}

func (c *ClientWithResponses) PatchUserWithResponse(ctx context.Context, userId string, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserResponse, error) {
	rsp, err := c.PatchUser(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserResponse(rsp)
}

// GetFlaggedPostsForUserWithResponse request returning *GetFlaggedPostsForUserResponse
func (c *ClientWithResponses) GetFlaggedPostsForUserWithResponse(ctx context.Context, userId string, params *GetFlaggedPostsForUserParams, reqEditors ...RequestEditorFn) (*GetFlaggedPostsForUserResponse, error) {
	rsp, err := c.GetFlaggedPostsForUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlaggedPostsForUserResponse(rsp)
}

// DeleteAcknowledgementForPostWithResponse request returning *DeleteAcknowledgementForPostResponse
func (c *ClientWithResponses) DeleteAcknowledgementForPostWithResponse(ctx context.Context, userId string, postId string, reqEditors ...RequestEditorFn) (*DeleteAcknowledgementForPostResponse, error) {
	rsp, err := c.DeleteAcknowledgementForPost(ctx, userId, postId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAcknowledgementForPostResponse(rsp)
}

// SaveAcknowledgementForPostWithResponse request returning *SaveAcknowledgementForPostResponse
func (c *ClientWithResponses) SaveAcknowledgementForPostWithResponse(ctx context.Context, userId string, postId string, reqEditors ...RequestEditorFn) (*SaveAcknowledgementForPostResponse, error) {
	rsp, err := c.SaveAcknowledgementForPost(ctx, userId, postId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveAcknowledgementForPostResponse(rsp)
}

// DeleteReactionWithResponse request returning *DeleteReactionResponse
func (c *ClientWithResponses) DeleteReactionWithResponse(ctx context.Context, userId string, postId string, emojiName string, reqEditors ...RequestEditorFn) (*DeleteReactionResponse, error) {
	rsp, err := c.DeleteReaction(ctx, userId, postId, emojiName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReactionResponse(rsp)
}

// SetPostReminderWithBodyWithResponse request with arbitrary body returning *SetPostReminderResponse
func (c *ClientWithResponses) SetPostReminderWithBodyWithResponse(ctx context.Context, userId string, postId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPostReminderResponse, error) {
	rsp, err := c.SetPostReminderWithBody(ctx, userId, postId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPostReminderResponse(rsp)
}

func (c *ClientWithResponses) SetPostReminderWithResponse(ctx context.Context, userId string, postId string, body SetPostReminderJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPostReminderResponse, error) {
	rsp, err := c.SetPostReminder(ctx, userId, postId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPostReminderResponse(rsp)
}

// SetPostUnreadWithResponse request returning *SetPostUnreadResponse
func (c *ClientWithResponses) SetPostUnreadWithResponse(ctx context.Context, userId string, postId string, reqEditors ...RequestEditorFn) (*SetPostUnreadResponse, error) {
	rsp, err := c.SetPostUnread(ctx, userId, postId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPostUnreadResponse(rsp)
}

// GetPreferencesWithResponse request returning *GetPreferencesResponse
func (c *ClientWithResponses) GetPreferencesWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetPreferencesResponse, error) {
	rsp, err := c.GetPreferences(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPreferencesResponse(rsp)
}

// UpdatePreferencesWithBodyWithResponse request with arbitrary body returning *UpdatePreferencesResponse
func (c *ClientWithResponses) UpdatePreferencesWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePreferencesResponse, error) {
	rsp, err := c.UpdatePreferencesWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePreferencesResponse(rsp)
}

func (c *ClientWithResponses) UpdatePreferencesWithResponse(ctx context.Context, userId string, body UpdatePreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePreferencesResponse, error) {
	rsp, err := c.UpdatePreferences(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePreferencesResponse(rsp)
}

// DeletePreferencesWithBodyWithResponse request with arbitrary body returning *DeletePreferencesResponse
func (c *ClientWithResponses) DeletePreferencesWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePreferencesResponse, error) {
	rsp, err := c.DeletePreferencesWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePreferencesResponse(rsp)
}

func (c *ClientWithResponses) DeletePreferencesWithResponse(ctx context.Context, userId string, body DeletePreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePreferencesResponse, error) {
	rsp, err := c.DeletePreferences(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePreferencesResponse(rsp)
}

// GetPreferencesByCategoryWithResponse request returning *GetPreferencesByCategoryResponse
func (c *ClientWithResponses) GetPreferencesByCategoryWithResponse(ctx context.Context, userId string, category string, reqEditors ...RequestEditorFn) (*GetPreferencesByCategoryResponse, error) {
	rsp, err := c.GetPreferencesByCategory(ctx, userId, category, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPreferencesByCategoryResponse(rsp)
}

// GetPreferencesByCategoryByNameWithResponse request returning *GetPreferencesByCategoryByNameResponse
func (c *ClientWithResponses) GetPreferencesByCategoryByNameWithResponse(ctx context.Context, userId string, category string, preferenceName string, reqEditors ...RequestEditorFn) (*GetPreferencesByCategoryByNameResponse, error) {
	rsp, err := c.GetPreferencesByCategoryByName(ctx, userId, category, preferenceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPreferencesByCategoryByNameResponse(rsp)
}

// PromoteGuestToUserWithResponse request returning *PromoteGuestToUserResponse
func (c *ClientWithResponses) PromoteGuestToUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*PromoteGuestToUserResponse, error) {
	rsp, err := c.PromoteGuestToUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePromoteGuestToUserResponse(rsp)
}

// UpdateUserRolesWithBodyWithResponse request with arbitrary body returning *UpdateUserRolesResponse
func (c *ClientWithResponses) UpdateUserRolesWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserRolesResponse, error) {
	rsp, err := c.UpdateUserRolesWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserRolesResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserRolesWithResponse(ctx context.Context, userId string, body UpdateUserRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserRolesResponse, error) {
	rsp, err := c.UpdateUserRoles(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserRolesResponse(rsp)
}

// GetSessionsWithResponse request returning *GetSessionsResponse
func (c *ClientWithResponses) GetSessionsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetSessionsResponse, error) {
	rsp, err := c.GetSessions(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionsResponse(rsp)
}

// RevokeSessionWithBodyWithResponse request with arbitrary body returning *RevokeSessionResponse
func (c *ClientWithResponses) RevokeSessionWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeSessionResponse, error) {
	rsp, err := c.RevokeSessionWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeSessionResponse(rsp)
}

func (c *ClientWithResponses) RevokeSessionWithResponse(ctx context.Context, userId string, body RevokeSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeSessionResponse, error) {
	rsp, err := c.RevokeSession(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeSessionResponse(rsp)
}

// RevokeAllSessionsWithResponse request returning *RevokeAllSessionsResponse
func (c *ClientWithResponses) RevokeAllSessionsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*RevokeAllSessionsResponse, error) {
	rsp, err := c.RevokeAllSessions(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeAllSessionsResponse(rsp)
}

// GetUserStatusWithResponse request returning *GetUserStatusResponse
func (c *ClientWithResponses) GetUserStatusWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserStatusResponse, error) {
	rsp, err := c.GetUserStatus(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserStatusResponse(rsp)
}

// UpdateUserStatusWithBodyWithResponse request with arbitrary body returning *UpdateUserStatusResponse
func (c *ClientWithResponses) UpdateUserStatusWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserStatusResponse, error) {
	rsp, err := c.UpdateUserStatusWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserStatusResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserStatusWithResponse(ctx context.Context, userId string, body UpdateUserStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserStatusResponse, error) {
	rsp, err := c.UpdateUserStatus(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserStatusResponse(rsp)
}

// UnsetUserCustomStatusWithResponse request returning *UnsetUserCustomStatusResponse
func (c *ClientWithResponses) UnsetUserCustomStatusWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*UnsetUserCustomStatusResponse, error) {
	rsp, err := c.UnsetUserCustomStatus(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnsetUserCustomStatusResponse(rsp)
}

// UpdateUserCustomStatusWithBodyWithResponse request with arbitrary body returning *UpdateUserCustomStatusResponse
func (c *ClientWithResponses) UpdateUserCustomStatusWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserCustomStatusResponse, error) {
	rsp, err := c.UpdateUserCustomStatusWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserCustomStatusResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserCustomStatusWithResponse(ctx context.Context, userId string, body UpdateUserCustomStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserCustomStatusResponse, error) {
	rsp, err := c.UpdateUserCustomStatus(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserCustomStatusResponse(rsp)
}

// RemoveRecentCustomStatusWithBodyWithResponse request with arbitrary body returning *RemoveRecentCustomStatusResponse
func (c *ClientWithResponses) RemoveRecentCustomStatusWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveRecentCustomStatusResponse, error) {
	rsp, err := c.RemoveRecentCustomStatusWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRecentCustomStatusResponse(rsp)
}

func (c *ClientWithResponses) RemoveRecentCustomStatusWithResponse(ctx context.Context, userId string, body RemoveRecentCustomStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveRecentCustomStatusResponse, error) {
	rsp, err := c.RemoveRecentCustomStatus(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRecentCustomStatusResponse(rsp)
}

// PostUserRecentCustomStatusDeleteWithBodyWithResponse request with arbitrary body returning *PostUserRecentCustomStatusDeleteResponse
func (c *ClientWithResponses) PostUserRecentCustomStatusDeleteWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserRecentCustomStatusDeleteResponse, error) {
	rsp, err := c.PostUserRecentCustomStatusDeleteWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserRecentCustomStatusDeleteResponse(rsp)
}

func (c *ClientWithResponses) PostUserRecentCustomStatusDeleteWithResponse(ctx context.Context, userId string, body PostUserRecentCustomStatusDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUserRecentCustomStatusDeleteResponse, error) {
	rsp, err := c.PostUserRecentCustomStatusDelete(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserRecentCustomStatusDeleteResponse(rsp)
}

// GetTeamsForUserWithResponse request returning *GetTeamsForUserResponse
func (c *ClientWithResponses) GetTeamsForUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetTeamsForUserResponse, error) {
	rsp, err := c.GetTeamsForUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsForUserResponse(rsp)
}

// GetTeamMembersForUserWithResponse request returning *GetTeamMembersForUserResponse
func (c *ClientWithResponses) GetTeamMembersForUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetTeamMembersForUserResponse, error) {
	rsp, err := c.GetTeamMembersForUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamMembersForUserResponse(rsp)
}

// GetTeamsUnreadForUserWithResponse request returning *GetTeamsUnreadForUserResponse
func (c *ClientWithResponses) GetTeamsUnreadForUserWithResponse(ctx context.Context, userId string, params *GetTeamsUnreadForUserParams, reqEditors ...RequestEditorFn) (*GetTeamsUnreadForUserResponse, error) {
	rsp, err := c.GetTeamsUnreadForUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsUnreadForUserResponse(rsp)
}

// GetChannelsForTeamForUserWithResponse request returning *GetChannelsForTeamForUserResponse
func (c *ClientWithResponses) GetChannelsForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, params *GetChannelsForTeamForUserParams, reqEditors ...RequestEditorFn) (*GetChannelsForTeamForUserResponse, error) {
	rsp, err := c.GetChannelsForTeamForUser(ctx, userId, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelsForTeamForUserResponse(rsp)
}

// GetSidebarCategoriesForTeamForUserWithResponse request returning *GetSidebarCategoriesForTeamForUserResponse
func (c *ClientWithResponses) GetSidebarCategoriesForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*GetSidebarCategoriesForTeamForUserResponse, error) {
	rsp, err := c.GetSidebarCategoriesForTeamForUser(ctx, userId, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSidebarCategoriesForTeamForUserResponse(rsp)
}

// CreateSidebarCategoryForTeamForUserWithBodyWithResponse request with arbitrary body returning *CreateSidebarCategoryForTeamForUserResponse
func (c *ClientWithResponses) CreateSidebarCategoryForTeamForUserWithBodyWithResponse(ctx context.Context, userId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSidebarCategoryForTeamForUserResponse, error) {
	rsp, err := c.CreateSidebarCategoryForTeamForUserWithBody(ctx, userId, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSidebarCategoryForTeamForUserResponse(rsp)
}

func (c *ClientWithResponses) CreateSidebarCategoryForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, body CreateSidebarCategoryForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSidebarCategoryForTeamForUserResponse, error) {
	rsp, err := c.CreateSidebarCategoryForTeamForUser(ctx, userId, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSidebarCategoryForTeamForUserResponse(rsp)
}

// UpdateSidebarCategoriesForTeamForUserWithBodyWithResponse request with arbitrary body returning *UpdateSidebarCategoriesForTeamForUserResponse
func (c *ClientWithResponses) UpdateSidebarCategoriesForTeamForUserWithBodyWithResponse(ctx context.Context, userId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSidebarCategoriesForTeamForUserResponse, error) {
	rsp, err := c.UpdateSidebarCategoriesForTeamForUserWithBody(ctx, userId, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSidebarCategoriesForTeamForUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateSidebarCategoriesForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, body UpdateSidebarCategoriesForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSidebarCategoriesForTeamForUserResponse, error) {
	rsp, err := c.UpdateSidebarCategoriesForTeamForUser(ctx, userId, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSidebarCategoriesForTeamForUserResponse(rsp)
}

// GetSidebarCategoryOrderForTeamForUserWithResponse request returning *GetSidebarCategoryOrderForTeamForUserResponse
func (c *ClientWithResponses) GetSidebarCategoryOrderForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*GetSidebarCategoryOrderForTeamForUserResponse, error) {
	rsp, err := c.GetSidebarCategoryOrderForTeamForUser(ctx, userId, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSidebarCategoryOrderForTeamForUserResponse(rsp)
}

// UpdateSidebarCategoryOrderForTeamForUserWithBodyWithResponse request with arbitrary body returning *UpdateSidebarCategoryOrderForTeamForUserResponse
func (c *ClientWithResponses) UpdateSidebarCategoryOrderForTeamForUserWithBodyWithResponse(ctx context.Context, userId string, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSidebarCategoryOrderForTeamForUserResponse, error) {
	rsp, err := c.UpdateSidebarCategoryOrderForTeamForUserWithBody(ctx, userId, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSidebarCategoryOrderForTeamForUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateSidebarCategoryOrderForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, body UpdateSidebarCategoryOrderForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSidebarCategoryOrderForTeamForUserResponse, error) {
	rsp, err := c.UpdateSidebarCategoryOrderForTeamForUser(ctx, userId, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSidebarCategoryOrderForTeamForUserResponse(rsp)
}

// RemoveSidebarCategoryForTeamForUserWithResponse request returning *RemoveSidebarCategoryForTeamForUserResponse
func (c *ClientWithResponses) RemoveSidebarCategoryForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, categoryId string, reqEditors ...RequestEditorFn) (*RemoveSidebarCategoryForTeamForUserResponse, error) {
	rsp, err := c.RemoveSidebarCategoryForTeamForUser(ctx, userId, teamId, categoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSidebarCategoryForTeamForUserResponse(rsp)
}

// GetSidebarCategoryForTeamForUserWithResponse request returning *GetSidebarCategoryForTeamForUserResponse
func (c *ClientWithResponses) GetSidebarCategoryForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, categoryId string, reqEditors ...RequestEditorFn) (*GetSidebarCategoryForTeamForUserResponse, error) {
	rsp, err := c.GetSidebarCategoryForTeamForUser(ctx, userId, teamId, categoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSidebarCategoryForTeamForUserResponse(rsp)
}

// UpdateSidebarCategoryForTeamForUserWithBodyWithResponse request with arbitrary body returning *UpdateSidebarCategoryForTeamForUserResponse
func (c *ClientWithResponses) UpdateSidebarCategoryForTeamForUserWithBodyWithResponse(ctx context.Context, userId string, teamId string, categoryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSidebarCategoryForTeamForUserResponse, error) {
	rsp, err := c.UpdateSidebarCategoryForTeamForUserWithBody(ctx, userId, teamId, categoryId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSidebarCategoryForTeamForUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateSidebarCategoryForTeamForUserWithResponse(ctx context.Context, userId string, teamId string, categoryId string, body UpdateSidebarCategoryForTeamForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSidebarCategoryForTeamForUserResponse, error) {
	rsp, err := c.UpdateSidebarCategoryForTeamForUser(ctx, userId, teamId, categoryId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSidebarCategoryForTeamForUserResponse(rsp)
}

// GetChannelMembersForUserWithResponse request returning *GetChannelMembersForUserResponse
func (c *ClientWithResponses) GetChannelMembersForUserWithResponse(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*GetChannelMembersForUserResponse, error) {
	rsp, err := c.GetChannelMembersForUser(ctx, userId, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelMembersForUserResponse(rsp)
}

// GetUserThreadsWithResponse request returning *GetUserThreadsResponse
func (c *ClientWithResponses) GetUserThreadsWithResponse(ctx context.Context, userId string, teamId string, params *GetUserThreadsParams, reqEditors ...RequestEditorFn) (*GetUserThreadsResponse, error) {
	rsp, err := c.GetUserThreads(ctx, userId, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserThreadsResponse(rsp)
}

// GetThreadMentionCountsByChannelWithResponse request returning *GetThreadMentionCountsByChannelResponse
func (c *ClientWithResponses) GetThreadMentionCountsByChannelWithResponse(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*GetThreadMentionCountsByChannelResponse, error) {
	rsp, err := c.GetThreadMentionCountsByChannel(ctx, userId, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThreadMentionCountsByChannelResponse(rsp)
}

// UpdateThreadsReadForUserWithResponse request returning *UpdateThreadsReadForUserResponse
func (c *ClientWithResponses) UpdateThreadsReadForUserWithResponse(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*UpdateThreadsReadForUserResponse, error) {
	rsp, err := c.UpdateThreadsReadForUser(ctx, userId, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThreadsReadForUserResponse(rsp)
}

// GetUserThreadWithResponse request returning *GetUserThreadResponse
func (c *ClientWithResponses) GetUserThreadWithResponse(ctx context.Context, userId string, teamId string, threadId string, reqEditors ...RequestEditorFn) (*GetUserThreadResponse, error) {
	rsp, err := c.GetUserThread(ctx, userId, teamId, threadId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserThreadResponse(rsp)
}

// StopFollowingThreadWithResponse request returning *StopFollowingThreadResponse
func (c *ClientWithResponses) StopFollowingThreadWithResponse(ctx context.Context, userId string, teamId string, threadId string, reqEditors ...RequestEditorFn) (*StopFollowingThreadResponse, error) {
	rsp, err := c.StopFollowingThread(ctx, userId, teamId, threadId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopFollowingThreadResponse(rsp)
}

// StartFollowingThreadWithResponse request returning *StartFollowingThreadResponse
func (c *ClientWithResponses) StartFollowingThreadWithResponse(ctx context.Context, userId string, teamId string, threadId string, reqEditors ...RequestEditorFn) (*StartFollowingThreadResponse, error) {
	rsp, err := c.StartFollowingThread(ctx, userId, teamId, threadId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartFollowingThreadResponse(rsp)
}

// UpdateThreadReadForUserWithResponse request returning *UpdateThreadReadForUserResponse
func (c *ClientWithResponses) UpdateThreadReadForUserWithResponse(ctx context.Context, userId string, teamId string, threadId string, timestamp string, reqEditors ...RequestEditorFn) (*UpdateThreadReadForUserResponse, error) {
	rsp, err := c.UpdateThreadReadForUser(ctx, userId, teamId, threadId, timestamp, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThreadReadForUserResponse(rsp)
}

// SetThreadUnreadByPostIdWithResponse request returning *SetThreadUnreadByPostIdResponse
func (c *ClientWithResponses) SetThreadUnreadByPostIdWithResponse(ctx context.Context, userId string, teamId string, threadId string, postId string, reqEditors ...RequestEditorFn) (*SetThreadUnreadByPostIdResponse, error) {
	rsp, err := c.SetThreadUnreadByPostId(ctx, userId, teamId, threadId, postId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetThreadUnreadByPostIdResponse(rsp)
}

// GetTeamUnreadWithResponse request returning *GetTeamUnreadResponse
func (c *ClientWithResponses) GetTeamUnreadWithResponse(ctx context.Context, userId string, teamId string, reqEditors ...RequestEditorFn) (*GetTeamUnreadResponse, error) {
	rsp, err := c.GetTeamUnread(ctx, userId, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamUnreadResponse(rsp)
}

// GetUserTermsOfServiceWithResponse request returning *GetUserTermsOfServiceResponse
func (c *ClientWithResponses) GetUserTermsOfServiceWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserTermsOfServiceResponse, error) {
	rsp, err := c.GetUserTermsOfService(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserTermsOfServiceResponse(rsp)
}

// RegisterTermsOfServiceActionWithBodyWithResponse request with arbitrary body returning *RegisterTermsOfServiceActionResponse
func (c *ClientWithResponses) RegisterTermsOfServiceActionWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterTermsOfServiceActionResponse, error) {
	rsp, err := c.RegisterTermsOfServiceActionWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterTermsOfServiceActionResponse(rsp)
}

func (c *ClientWithResponses) RegisterTermsOfServiceActionWithResponse(ctx context.Context, userId string, body RegisterTermsOfServiceActionJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterTermsOfServiceActionResponse, error) {
	rsp, err := c.RegisterTermsOfServiceAction(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterTermsOfServiceActionResponse(rsp)
}

// GetUserAccessTokensForUserWithResponse request returning *GetUserAccessTokensForUserResponse
func (c *ClientWithResponses) GetUserAccessTokensForUserWithResponse(ctx context.Context, userId string, params *GetUserAccessTokensForUserParams, reqEditors ...RequestEditorFn) (*GetUserAccessTokensForUserResponse, error) {
	rsp, err := c.GetUserAccessTokensForUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserAccessTokensForUserResponse(rsp)
}

// CreateUserAccessTokenWithBodyWithResponse request with arbitrary body returning *CreateUserAccessTokenResponse
func (c *ClientWithResponses) CreateUserAccessTokenWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserAccessTokenResponse, error) {
	rsp, err := c.CreateUserAccessTokenWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateUserAccessTokenWithResponse(ctx context.Context, userId string, body CreateUserAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserAccessTokenResponse, error) {
	rsp, err := c.CreateUserAccessToken(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserAccessTokenResponse(rsp)
}

// PublishUserTypingWithBodyWithResponse request with arbitrary body returning *PublishUserTypingResponse
func (c *ClientWithResponses) PublishUserTypingWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PublishUserTypingResponse, error) {
	rsp, err := c.PublishUserTypingWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishUserTypingResponse(rsp)
}

func (c *ClientWithResponses) PublishUserTypingWithResponse(ctx context.Context, userId string, body PublishUserTypingJSONRequestBody, reqEditors ...RequestEditorFn) (*PublishUserTypingResponse, error) {
	rsp, err := c.PublishUserTyping(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishUserTypingResponse(rsp)
}

// GetUploadsForUserWithResponse request returning *GetUploadsForUserResponse
func (c *ClientWithResponses) GetUploadsForUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUploadsForUserResponse, error) {
	rsp, err := c.GetUploadsForUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUploadsForUserResponse(rsp)
}

// GetFilePublicWithResponse request returning *GetFilePublicResponse
func (c *ClientWithResponses) GetFilePublicWithResponse(ctx context.Context, fileId string, params *GetFilePublicParams, reqEditors ...RequestEditorFn) (*GetFilePublicResponse, error) {
	rsp, err := c.GetFilePublic(ctx, fileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilePublicResponse(rsp)
}

// GetPlaybooksWithResponse request returning *GetPlaybooksResponse
func (c *ClientWithResponses) GetPlaybooksWithResponse(ctx context.Context, params *GetPlaybooksParams, reqEditors ...RequestEditorFn) (*GetPlaybooksResponse, error) {
	rsp, err := c.GetPlaybooks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybooksResponse(rsp)
}

// CreatePlaybookWithBodyWithResponse request with arbitrary body returning *CreatePlaybookResponse
func (c *ClientWithResponses) CreatePlaybookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlaybookResponse, error) {
	rsp, err := c.CreatePlaybookWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlaybookResponse(rsp)
}

func (c *ClientWithResponses) CreatePlaybookWithResponse(ctx context.Context, body CreatePlaybookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlaybookResponse, error) {
	rsp, err := c.CreatePlaybook(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlaybookResponse(rsp)
}

// DeletePlaybookWithResponse request returning *DeletePlaybookResponse
func (c *ClientWithResponses) DeletePlaybookWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePlaybookResponse, error) {
	rsp, err := c.DeletePlaybook(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePlaybookResponse(rsp)
}

// GetPlaybookWithResponse request returning *GetPlaybookResponse
func (c *ClientWithResponses) GetPlaybookWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPlaybookResponse, error) {
	rsp, err := c.GetPlaybook(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybookResponse(rsp)
}

// UpdatePlaybookWithBodyWithResponse request with arbitrary body returning *UpdatePlaybookResponse
func (c *ClientWithResponses) UpdatePlaybookWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlaybookResponse, error) {
	rsp, err := c.UpdatePlaybookWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlaybookResponse(rsp)
}

func (c *ClientWithResponses) UpdatePlaybookWithResponse(ctx context.Context, id string, body UpdatePlaybookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlaybookResponse, error) {
	rsp, err := c.UpdatePlaybook(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlaybookResponse(rsp)
}

// GetAutoFollowsWithResponse request returning *GetAutoFollowsResponse
func (c *ClientWithResponses) GetAutoFollowsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAutoFollowsResponse, error) {
	rsp, err := c.GetAutoFollows(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutoFollowsResponse(rsp)
}

// ListPlaybookRunsWithResponse request returning *ListPlaybookRunsResponse
func (c *ClientWithResponses) ListPlaybookRunsWithResponse(ctx context.Context, params *ListPlaybookRunsParams, reqEditors ...RequestEditorFn) (*ListPlaybookRunsResponse, error) {
	rsp, err := c.ListPlaybookRuns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlaybookRunsResponse(rsp)
}

// CreatePlaybookRunFromPostWithBodyWithResponse request with arbitrary body returning *CreatePlaybookRunFromPostResponse
func (c *ClientWithResponses) CreatePlaybookRunFromPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlaybookRunFromPostResponse, error) {
	rsp, err := c.CreatePlaybookRunFromPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlaybookRunFromPostResponse(rsp)
}

func (c *ClientWithResponses) CreatePlaybookRunFromPostWithResponse(ctx context.Context, body CreatePlaybookRunFromPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlaybookRunFromPostResponse, error) {
	rsp, err := c.CreatePlaybookRunFromPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlaybookRunFromPostResponse(rsp)
}

// GetPlaybookRunByChannelIdWithResponse request returning *GetPlaybookRunByChannelIdResponse
func (c *ClientWithResponses) GetPlaybookRunByChannelIdWithResponse(ctx context.Context, channelId string, reqEditors ...RequestEditorFn) (*GetPlaybookRunByChannelIdResponse, error) {
	rsp, err := c.GetPlaybookRunByChannelId(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybookRunByChannelIdResponse(rsp)
}

// GetChannelsWithResponse request returning *GetChannelsResponse
func (c *ClientWithResponses) GetChannelsWithResponse(ctx context.Context, params *GetChannelsParams, reqEditors ...RequestEditorFn) (*GetChannelsResponse, error) {
	rsp, err := c.GetChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelsResponse(rsp)
}

// GetChecklistAutocompleteWithResponse request returning *GetChecklistAutocompleteResponse
func (c *ClientWithResponses) GetChecklistAutocompleteWithResponse(ctx context.Context, params *GetChecklistAutocompleteParams, reqEditors ...RequestEditorFn) (*GetChecklistAutocompleteResponse, error) {
	rsp, err := c.GetChecklistAutocomplete(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChecklistAutocompleteResponse(rsp)
}

// CreatePlaybookRunFromDialogWithBodyWithResponse request with arbitrary body returning *CreatePlaybookRunFromDialogResponse
func (c *ClientWithResponses) CreatePlaybookRunFromDialogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlaybookRunFromDialogResponse, error) {
	rsp, err := c.CreatePlaybookRunFromDialogWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlaybookRunFromDialogResponse(rsp)
}

func (c *ClientWithResponses) CreatePlaybookRunFromDialogWithResponse(ctx context.Context, body CreatePlaybookRunFromDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlaybookRunFromDialogResponse, error) {
	rsp, err := c.CreatePlaybookRunFromDialog(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlaybookRunFromDialogResponse(rsp)
}

// GetOwnersWithResponse request returning *GetOwnersResponse
func (c *ClientWithResponses) GetOwnersWithResponse(ctx context.Context, params *GetOwnersParams, reqEditors ...RequestEditorFn) (*GetOwnersResponse, error) {
	rsp, err := c.GetOwners(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOwnersResponse(rsp)
}

// GetPlaybookRunWithResponse request returning *GetPlaybookRunResponse
func (c *ClientWithResponses) GetPlaybookRunWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPlaybookRunResponse, error) {
	rsp, err := c.GetPlaybookRun(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybookRunResponse(rsp)
}

// UpdatePlaybookRunWithBodyWithResponse request with arbitrary body returning *UpdatePlaybookRunResponse
func (c *ClientWithResponses) UpdatePlaybookRunWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlaybookRunResponse, error) {
	rsp, err := c.UpdatePlaybookRunWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlaybookRunResponse(rsp)
}

func (c *ClientWithResponses) UpdatePlaybookRunWithResponse(ctx context.Context, id string, body UpdatePlaybookRunJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlaybookRunResponse, error) {
	rsp, err := c.UpdatePlaybookRun(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlaybookRunResponse(rsp)
}

// AddChecklistItemWithBodyWithResponse request with arbitrary body returning *AddChecklistItemResponse
func (c *ClientWithResponses) AddChecklistItemWithBodyWithResponse(ctx context.Context, id string, checklist int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddChecklistItemResponse, error) {
	rsp, err := c.AddChecklistItemWithBody(ctx, id, checklist, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddChecklistItemResponse(rsp)
}

func (c *ClientWithResponses) AddChecklistItemWithResponse(ctx context.Context, id string, checklist int, body AddChecklistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddChecklistItemResponse, error) {
	rsp, err := c.AddChecklistItem(ctx, id, checklist, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddChecklistItemResponse(rsp)
}

// ItemDeleteWithResponse request returning *ItemDeleteResponse
func (c *ClientWithResponses) ItemDeleteWithResponse(ctx context.Context, id string, checklist int, item int, reqEditors ...RequestEditorFn) (*ItemDeleteResponse, error) {
	rsp, err := c.ItemDelete(ctx, id, checklist, item, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemDeleteResponse(rsp)
}

// ItemRenameWithBodyWithResponse request with arbitrary body returning *ItemRenameResponse
func (c *ClientWithResponses) ItemRenameWithBodyWithResponse(ctx context.Context, id string, checklist int, item int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemRenameResponse, error) {
	rsp, err := c.ItemRenameWithBody(ctx, id, checklist, item, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemRenameResponse(rsp)
}

func (c *ClientWithResponses) ItemRenameWithResponse(ctx context.Context, id string, checklist int, item int, body ItemRenameJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemRenameResponse, error) {
	rsp, err := c.ItemRename(ctx, id, checklist, item, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemRenameResponse(rsp)
}

// ItemSetAssigneeWithBodyWithResponse request with arbitrary body returning *ItemSetAssigneeResponse
func (c *ClientWithResponses) ItemSetAssigneeWithBodyWithResponse(ctx context.Context, id string, checklist int, item int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemSetAssigneeResponse, error) {
	rsp, err := c.ItemSetAssigneeWithBody(ctx, id, checklist, item, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemSetAssigneeResponse(rsp)
}

func (c *ClientWithResponses) ItemSetAssigneeWithResponse(ctx context.Context, id string, checklist int, item int, body ItemSetAssigneeJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemSetAssigneeResponse, error) {
	rsp, err := c.ItemSetAssignee(ctx, id, checklist, item, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemSetAssigneeResponse(rsp)
}

// ItemRunWithResponse request returning *ItemRunResponse
func (c *ClientWithResponses) ItemRunWithResponse(ctx context.Context, id string, checklist int, item int, reqEditors ...RequestEditorFn) (*ItemRunResponse, error) {
	rsp, err := c.ItemRun(ctx, id, checklist, item, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemRunResponse(rsp)
}

// ItemSetStateWithBodyWithResponse request with arbitrary body returning *ItemSetStateResponse
func (c *ClientWithResponses) ItemSetStateWithBodyWithResponse(ctx context.Context, id string, checklist int, item int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemSetStateResponse, error) {
	rsp, err := c.ItemSetStateWithBody(ctx, id, checklist, item, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemSetStateResponse(rsp)
}

func (c *ClientWithResponses) ItemSetStateWithResponse(ctx context.Context, id string, checklist int, item int, body ItemSetStateJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemSetStateResponse, error) {
	rsp, err := c.ItemSetState(ctx, id, checklist, item, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemSetStateResponse(rsp)
}

// ReoderChecklistItemWithBodyWithResponse request with arbitrary body returning *ReoderChecklistItemResponse
func (c *ClientWithResponses) ReoderChecklistItemWithBodyWithResponse(ctx context.Context, id string, checklist int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReoderChecklistItemResponse, error) {
	rsp, err := c.ReoderChecklistItemWithBody(ctx, id, checklist, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReoderChecklistItemResponse(rsp)
}

func (c *ClientWithResponses) ReoderChecklistItemWithResponse(ctx context.Context, id string, checklist int, body ReoderChecklistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*ReoderChecklistItemResponse, error) {
	rsp, err := c.ReoderChecklistItem(ctx, id, checklist, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReoderChecklistItemResponse(rsp)
}

// EndPlaybookRunDialogWithResponse request returning *EndPlaybookRunDialogResponse
func (c *ClientWithResponses) EndPlaybookRunDialogWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*EndPlaybookRunDialogResponse, error) {
	rsp, err := c.EndPlaybookRunDialog(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndPlaybookRunDialogResponse(rsp)
}

// EndPlaybookRunWithResponse request returning *EndPlaybookRunResponse
func (c *ClientWithResponses) EndPlaybookRunWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*EndPlaybookRunResponse, error) {
	rsp, err := c.EndPlaybookRun(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndPlaybookRunResponse(rsp)
}

// FinishWithResponse request returning *FinishResponse
func (c *ClientWithResponses) FinishWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FinishResponse, error) {
	rsp, err := c.Finish(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFinishResponse(rsp)
}

// GetPlaybookRunMetadataWithResponse request returning *GetPlaybookRunMetadataResponse
func (c *ClientWithResponses) GetPlaybookRunMetadataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPlaybookRunMetadataResponse, error) {
	rsp, err := c.GetPlaybookRunMetadata(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybookRunMetadataResponse(rsp)
}

// NextStageDialogWithBodyWithResponse request with arbitrary body returning *NextStageDialogResponse
func (c *ClientWithResponses) NextStageDialogWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NextStageDialogResponse, error) {
	rsp, err := c.NextStageDialogWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNextStageDialogResponse(rsp)
}

func (c *ClientWithResponses) NextStageDialogWithResponse(ctx context.Context, id string, body NextStageDialogJSONRequestBody, reqEditors ...RequestEditorFn) (*NextStageDialogResponse, error) {
	rsp, err := c.NextStageDialog(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNextStageDialogResponse(rsp)
}

// ChangeOwnerWithBodyWithResponse request with arbitrary body returning *ChangeOwnerResponse
func (c *ClientWithResponses) ChangeOwnerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeOwnerResponse, error) {
	rsp, err := c.ChangeOwnerWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeOwnerResponse(rsp)
}

func (c *ClientWithResponses) ChangeOwnerWithResponse(ctx context.Context, id string, body ChangeOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeOwnerResponse, error) {
	rsp, err := c.ChangeOwner(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeOwnerResponse(rsp)
}

// RestartPlaybookRunWithResponse request returning *RestartPlaybookRunResponse
func (c *ClientWithResponses) RestartPlaybookRunWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RestartPlaybookRunResponse, error) {
	rsp, err := c.RestartPlaybookRun(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartPlaybookRunResponse(rsp)
}

// StatusWithBodyWithResponse request with arbitrary body returning *StatusResponse
func (c *ClientWithResponses) StatusWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StatusResponse, error) {
	rsp, err := c.StatusWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatusResponse(rsp)
}

func (c *ClientWithResponses) StatusWithResponse(ctx context.Context, id string, body StatusJSONRequestBody, reqEditors ...RequestEditorFn) (*StatusResponse, error) {
	rsp, err := c.Status(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatusResponse(rsp)
}

// RemoveTimelineEventWithResponse request returning *RemoveTimelineEventResponse
func (c *ClientWithResponses) RemoveTimelineEventWithResponse(ctx context.Context, id string, eventId string, reqEditors ...RequestEditorFn) (*RemoveTimelineEventResponse, error) {
	rsp, err := c.RemoveTimelineEvent(ctx, id, eventId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTimelineEventResponse(rsp)
}

// ParseOpenInteractiveDialogResponse parses an HTTP response from a OpenInteractiveDialogWithResponse call
func ParseOpenInteractiveDialogResponse(rsp *http.Response) (*OpenInteractiveDialogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OpenInteractiveDialogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSubmitInteractiveDialogResponse parses an HTTP response from a SubmitInteractiveDialogWithResponse call
func ParseSubmitInteractiveDialogResponse(rsp *http.Response) (*SubmitInteractiveDialogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitInteractiveDialogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetAnalyticsOldResponse parses an HTTP response from a GetAnalyticsOldWithResponse call
func ParseGetAnalyticsOldResponse(rsp *http.Response) (*GetAnalyticsOldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnalyticsOldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetAuditsResponse parses an HTTP response from a GetAuditsWithResponse call
func ParseGetAuditsResponse(rsp *http.Response) (*GetAuditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Audit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePurgeBleveIndexesResponse parses an HTTP response from a PurgeBleveIndexesWithResponse call
func ParsePurgeBleveIndexesResponse(rsp *http.Response) (*PurgeBleveIndexesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PurgeBleveIndexesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetBotsResponse parses an HTTP response from a GetBotsWithResponse call
func ParseGetBotsResponse(rsp *http.Response) (*GetBotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Bot
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateBotResponse parses an HTTP response from a CreateBotWithResponse call
func ParseCreateBotResponse(rsp *http.Response) (*CreateBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Bot
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBotResponse parses an HTTP response from a GetBotWithResponse call
func ParseGetBotResponse(rsp *http.Response) (*GetBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bot
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePatchBotResponse parses an HTTP response from a PatchBotWithResponse call
func ParsePatchBotResponse(rsp *http.Response) (*PatchBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bot
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAssignBotResponse parses an HTTP response from a AssignBotWithResponse call
func ParseAssignBotResponse(rsp *http.Response) (*AssignBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bot
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseConvertBotToUserResponse parses an HTTP response from a ConvertBotToUserWithResponse call
func ParseConvertBotToUserResponse(rsp *http.Response) (*ConvertBotToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConvertBotToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDisableBotResponse parses an HTTP response from a DisableBotWithResponse call
func ParseDisableBotResponse(rsp *http.Response) (*DisableBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bot
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEnableBotResponse parses an HTTP response from a EnableBotWithResponse call
func ParseEnableBotResponse(rsp *http.Response) (*EnableBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bot
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteBotIconImageResponse parses an HTTP response from a DeleteBotIconImageWithResponse call
func ParseDeleteBotIconImageResponse(rsp *http.Response) (*DeleteBotIconImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBotIconImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetBotIconImageResponse parses an HTTP response from a GetBotIconImageWithResponse call
func ParseGetBotIconImageResponse(rsp *http.Response) (*GetBotIconImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBotIconImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseSetBotIconImageResponse parses an HTTP response from a SetBotIconImageWithResponse call
func ParseSetBotIconImageResponse(rsp *http.Response) (*SetBotIconImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetBotIconImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest TooLarge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDeleteBrandImageResponse parses an HTTP response from a DeleteBrandImageWithResponse call
func ParseDeleteBrandImageResponse(rsp *http.Response) (*DeleteBrandImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBrandImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetBrandImageResponse parses an HTTP response from a GetBrandImageWithResponse call
func ParseGetBrandImageResponse(rsp *http.Response) (*GetBrandImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBrandImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUploadBrandImageResponse parses an HTTP response from a UploadBrandImageWithResponse call
func ParseUploadBrandImageResponse(rsp *http.Response) (*UploadBrandImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadBrandImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest TooLarge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseInvalidateCachesResponse parses an HTTP response from a InvalidateCachesWithResponse call
func ParseInvalidateCachesResponse(rsp *http.Response) (*InvalidateCachesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InvalidateCachesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetAllChannelsResponse parses an HTTP response from a GetAllChannelsWithResponse call
func ParseGetAllChannelsResponse(rsp *http.Response) (*GetAllChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelListWithTeamData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateChannelResponse parses an HTTP response from a CreateChannelWithResponse call
func ParseCreateChannelResponse(rsp *http.Response) (*CreateChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateDirectChannelResponse parses an HTTP response from a CreateDirectChannelWithResponse call
func ParseCreateDirectChannelResponse(rsp *http.Response) (*CreateDirectChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDirectChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateGroupChannelResponse parses an HTTP response from a CreateGroupChannelWithResponse call
func ParseCreateGroupChannelResponse(rsp *http.Response) (*CreateGroupChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSearchGroupChannelsResponse parses an HTTP response from a SearchGroupChannelsWithResponse call
func ParseSearchGroupChannelsResponse(rsp *http.Response) (*SearchGroupChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchGroupChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseViewChannelResponse parses an HTTP response from a ViewChannelWithResponse call
func ParseViewChannelResponse(rsp *http.Response) (*ViewChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ViewChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// LastViewedAtTimes A JSON object mapping channel IDs to the channel view times
			LastViewedAtTimes *map[string]interface{} `json:"last_viewed_at_times,omitempty"`

			// Status Value should be "OK" if successful
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSearchAllChannelsResponse parses an HTTP response from a SearchAllChannelsWithResponse call
func ParseSearchAllChannelsResponse(rsp *http.Response) (*SearchAllChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchAllChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Channels The channels that matched the query.
			Channels *[]Channel `json:"channels,omitempty"`

			// TotalCount The total number of results, regardless of page and per_page requested.
			TotalCount *float32 `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteChannelResponse parses an HTTP response from a DeleteChannelWithResponse call
func ParseDeleteChannelResponse(rsp *http.Response) (*DeleteChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetChannelResponse parses an HTTP response from a GetChannelWithResponse call
func ParseGetChannelResponse(rsp *http.Response) (*GetChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateChannelResponse parses an HTTP response from a UpdateChannelWithResponse call
func ParseUpdateChannelResponse(rsp *http.Response) (*UpdateChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListChannelBookmarksForChannelResponse parses an HTTP response from a ListChannelBookmarksForChannelWithResponse call
func ParseListChannelBookmarksForChannelResponse(rsp *http.Response) (*ListChannelBookmarksForChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListChannelBookmarksForChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []ChannelBookmarkWithFileInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateChannelBookmarkResponse parses an HTTP response from a CreateChannelBookmarkWithResponse call
func ParseCreateChannelBookmarkResponse(rsp *http.Response) (*CreateChannelBookmarkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateChannelBookmarkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ChannelBookmarkWithFileInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteChannelBookmarkResponse parses an HTTP response from a DeleteChannelBookmarkWithResponse call
func ParseDeleteChannelBookmarkResponse(rsp *http.Response) (*DeleteChannelBookmarkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteChannelBookmarkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelBookmarkWithFileInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateChannelBookmarkResponse parses an HTTP response from a UpdateChannelBookmarkWithResponse call
func ParseUpdateChannelBookmarkResponse(rsp *http.Response) (*UpdateChannelBookmarkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateChannelBookmarkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateChannelBookmarkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateChannelBookmarkSortOrderResponse parses an HTTP response from a UpdateChannelBookmarkSortOrderWithResponse call
func ParseUpdateChannelBookmarkSortOrderResponse(rsp *http.Response) (*UpdateChannelBookmarkSortOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateChannelBookmarkSortOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ChannelBookmarkWithFileInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetGroupsByChannelResponse parses an HTTP response from a GetGroupsByChannelWithResponse call
func ParseGetGroupsByChannelResponse(rsp *http.Response) (*GetGroupsByChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsByChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetChannelMemberCountsByGroupResponse parses an HTTP response from a GetChannelMemberCountsByGroupWithResponse call
func ParseGetChannelMemberCountsByGroupResponse(rsp *http.Response) (*GetChannelMemberCountsByGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelMemberCountsByGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetChannelMembersResponse parses an HTTP response from a GetChannelMembersWithResponse call
func ParseGetChannelMembersResponse(rsp *http.Response) (*GetChannelMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ChannelMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAddChannelMemberResponse parses an HTTP response from a AddChannelMemberWithResponse call
func ParseAddChannelMemberResponse(rsp *http.Response) (*AddChannelMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddChannelMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ChannelMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetChannelMembersByIdsResponse parses an HTTP response from a GetChannelMembersByIdsWithResponse call
func ParseGetChannelMembersByIdsResponse(rsp *http.Response) (*GetChannelMembersByIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelMembersByIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ChannelMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRemoveUserFromChannelResponse parses an HTTP response from a RemoveUserFromChannelWithResponse call
func ParseRemoveUserFromChannelResponse(rsp *http.Response) (*RemoveUserFromChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserFromChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetChannelMemberResponse parses an HTTP response from a GetChannelMemberWithResponse call
func ParseGetChannelMemberResponse(rsp *http.Response) (*GetChannelMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateChannelNotifyPropsResponse parses an HTTP response from a UpdateChannelNotifyPropsWithResponse call
func ParseUpdateChannelNotifyPropsResponse(rsp *http.Response) (*UpdateChannelNotifyPropsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateChannelNotifyPropsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateChannelRolesResponse parses an HTTP response from a UpdateChannelRolesWithResponse call
func ParseUpdateChannelRolesResponse(rsp *http.Response) (*UpdateChannelRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateChannelRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateChannelMemberSchemeRolesResponse parses an HTTP response from a UpdateChannelMemberSchemeRolesWithResponse call
func ParseUpdateChannelMemberSchemeRolesResponse(rsp *http.Response) (*UpdateChannelMemberSchemeRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateChannelMemberSchemeRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseChannelMembersMinusGroupMembersResponse parses an HTTP response from a ChannelMembersMinusGroupMembersWithResponse call
func ParseChannelMembersMinusGroupMembersResponse(rsp *http.Response) (*ChannelMembersMinusGroupMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChannelMembersMinusGroupMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetChannelModerationsResponse parses an HTTP response from a GetChannelModerationsWithResponse call
func ParseGetChannelModerationsResponse(rsp *http.Response) (*GetChannelModerationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelModerationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ChannelModeration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePatchChannelModerationsResponse parses an HTTP response from a PatchChannelModerationsWithResponse call
func ParsePatchChannelModerationsResponse(rsp *http.Response) (*PatchChannelModerationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchChannelModerationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ChannelModeration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseMoveChannelResponse parses an HTTP response from a MoveChannelWithResponse call
func ParseMoveChannelResponse(rsp *http.Response) (*MoveChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MoveChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchChannelResponse parses an HTTP response from a PatchChannelWithResponse call
func ParsePatchChannelResponse(rsp *http.Response) (*PatchChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPinnedPostsResponse parses an HTTP response from a GetPinnedPostsWithResponse call
func ParseGetPinnedPostsResponse(rsp *http.Response) (*GetPinnedPostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPinnedPostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPostsForChannelResponse parses an HTTP response from a GetPostsForChannelWithResponse call
func ParseGetPostsForChannelResponse(rsp *http.Response) (*GetPostsForChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostsForChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateChannelPrivacyResponse parses an HTTP response from a UpdateChannelPrivacyWithResponse call
func ParseUpdateChannelPrivacyResponse(rsp *http.Response) (*UpdateChannelPrivacyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateChannelPrivacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRestoreChannelResponse parses an HTTP response from a RestoreChannelWithResponse call
func ParseRestoreChannelResponse(rsp *http.Response) (*RestoreChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateChannelSchemeResponse parses an HTTP response from a UpdateChannelSchemeWithResponse call
func ParseUpdateChannelSchemeResponse(rsp *http.Response) (*UpdateChannelSchemeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateChannelSchemeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetChannelStatsResponse parses an HTTP response from a GetChannelStatsWithResponse call
func ParseGetChannelStatsResponse(rsp *http.Response) (*GetChannelStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetChannelMembersTimezonesResponse parses an HTTP response from a GetChannelMembersTimezonesWithResponse call
func ParseGetChannelMembersTimezonesResponse(rsp *http.Response) (*GetChannelMembersTimezonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelMembersTimezonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSubmitPerformanceReportResponse parses an HTTP response from a SubmitPerformanceReportWithResponse call
func ParseSubmitPerformanceReportResponse(rsp *http.Response) (*SubmitPerformanceReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitPerformanceReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCloudCustomerResponse parses an HTTP response from a GetCloudCustomerWithResponse call
func ParseGetCloudCustomerResponse(rsp *http.Response) (*GetCloudCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCloudCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloudCustomer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUpdateCloudCustomerResponse parses an HTTP response from a UpdateCloudCustomerWithResponse call
func ParseUpdateCloudCustomerResponse(rsp *http.Response) (*UpdateCloudCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCloudCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloudCustomer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUpdateCloudCustomerAddressResponse parses an HTTP response from a UpdateCloudCustomerAddressWithResponse call
func ParseUpdateCloudCustomerAddressResponse(rsp *http.Response) (*UpdateCloudCustomerAddressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCloudCustomerAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloudCustomer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetEndpointForInstallationInformationResponse parses an HTTP response from a GetEndpointForInstallationInformationWithResponse call
func ParseGetEndpointForInstallationInformationResponse(rsp *http.Response) (*GetEndpointForInstallationInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEndpointForInstallationInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Installation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetCloudLimitsResponse parses an HTTP response from a GetCloudLimitsWithResponse call
func ParseGetCloudLimitsResponse(rsp *http.Response) (*GetCloudLimitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCloudLimitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductLimits
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseCreateCustomerPaymentResponse parses an HTTP response from a CreateCustomerPaymentWithResponse call
func ParseCreateCustomerPaymentResponse(rsp *http.Response) (*CreateCustomerPaymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomerPaymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PaymentSetupIntent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseConfirmCustomerPaymentResponse parses an HTTP response from a ConfirmCustomerPaymentWithResponse call
func ParseConfirmCustomerPaymentResponse(rsp *http.Response) (*ConfirmCustomerPaymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmCustomerPaymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetCloudProductsResponse parses an HTTP response from a GetCloudProductsWithResponse call
func ParseGetCloudProductsResponse(rsp *http.Response) (*GetCloudProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCloudProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Product
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetSubscriptionResponse parses an HTTP response from a GetSubscriptionWithResponse call
func ParseGetSubscriptionResponse(rsp *http.Response) (*GetSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetInvoicesForSubscriptionResponse parses an HTTP response from a GetInvoicesForSubscriptionWithResponse call
func ParseGetInvoicesForSubscriptionResponse(rsp *http.Response) (*GetInvoicesForSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesForSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Invoice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetInvoiceForSubscriptionAsPdfResponse parses an HTTP response from a GetInvoiceForSubscriptionAsPdfWithResponse call
func ParseGetInvoiceForSubscriptionAsPdfResponse(rsp *http.Response) (*GetInvoiceForSubscriptionAsPdfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoiceForSubscriptionAsPdfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParsePostEndpointForCwsWebhooksResponse parses an HTTP response from a PostEndpointForCwsWebhooksWithResponse call
func ParsePostEndpointForCwsWebhooksResponse(rsp *http.Response) (*PostEndpointForCwsWebhooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEndpointForCwsWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetClusterStatusResponse parses an HTTP response from a GetClusterStatusWithResponse call
func ParseGetClusterStatusResponse(rsp *http.Response) (*GetClusterStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClusterInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListCommandsResponse parses an HTTP response from a ListCommandsWithResponse call
func ParseListCommandsResponse(rsp *http.Response) (*ListCommandsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCommandsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Command
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseCreateCommandResponse parses an HTTP response from a CreateCommandWithResponse call
func ParseCreateCommandResponse(rsp *http.Response) (*CreateCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Command
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseExecuteCommandResponse parses an HTTP response from a ExecuteCommandWithResponse call
func ParseExecuteCommandResponse(rsp *http.Response) (*ExecuteCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommandResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDeleteCommandResponse parses an HTTP response from a DeleteCommandWithResponse call
func ParseDeleteCommandResponse(rsp *http.Response) (*DeleteCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCommandByIdResponse parses an HTTP response from a GetCommandByIdWithResponse call
func ParseGetCommandByIdResponse(rsp *http.Response) (*GetCommandByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommandByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Command
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateCommandResponse parses an HTTP response from a UpdateCommandWithResponse call
func ParseUpdateCommandResponse(rsp *http.Response) (*UpdateCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Command
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseMoveCommandResponse parses an HTTP response from a MoveCommandWithResponse call
func ParseMoveCommandResponse(rsp *http.Response) (*MoveCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MoveCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRegenCommandTokenResponse parses an HTTP response from a RegenCommandTokenWithResponse call
func ParseRegenCommandTokenResponse(rsp *http.Response) (*RegenCommandTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegenCommandTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Token The new token
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetComplianceReportsResponse parses an HTTP response from a GetComplianceReportsWithResponse call
func ParseGetComplianceReportsResponse(rsp *http.Response) (*GetComplianceReportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComplianceReportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Compliance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseCreateComplianceReportResponse parses an HTTP response from a CreateComplianceReportWithResponse call
func ParseCreateComplianceReportResponse(rsp *http.Response) (*CreateComplianceReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateComplianceReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Compliance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetComplianceReportResponse parses an HTTP response from a GetComplianceReportWithResponse call
func ParseGetComplianceReportResponse(rsp *http.Response) (*GetComplianceReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComplianceReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Compliance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDownloadComplianceReportResponse parses an HTTP response from a DownloadComplianceReportWithResponse call
func ParseDownloadComplianceReportResponse(rsp *http.Response) (*DownloadComplianceReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadComplianceReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateConfigResponse parses an HTTP response from a UpdateConfigWithResponse call
func ParseUpdateConfigResponse(rsp *http.Response) (*UpdateConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetClientConfigResponse parses an HTTP response from a GetClientConfigWithResponse call
func ParseGetClientConfigResponse(rsp *http.Response) (*GetClientConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetEnvironmentConfigResponse parses an HTTP response from a GetEnvironmentConfigWithResponse call
func ParseGetEnvironmentConfigResponse(rsp *http.Response) (*GetEnvironmentConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnvironmentConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePatchConfigResponse parses an HTTP response from a PatchConfigWithResponse call
func ParsePatchConfigResponse(rsp *http.Response) (*PatchConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseReloadConfigResponse parses an HTTP response from a ReloadConfigWithResponse call
func ParseReloadConfigResponse(rsp *http.Response) (*ReloadConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReloadConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetDataRetentionPoliciesResponse parses an HTTP response from a GetDataRetentionPoliciesWithResponse call
func ParseGetDataRetentionPoliciesResponse(rsp *http.Response) (*GetDataRetentionPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataRetentionPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DataRetentionPolicyWithTeamAndChannelCounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseCreateDataRetentionPolicyResponse parses an HTTP response from a CreateDataRetentionPolicyWithResponse call
func ParseCreateDataRetentionPolicyResponse(rsp *http.Response) (*CreateDataRetentionPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDataRetentionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DataRetentionPolicyWithTeamAndChannelCounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDeleteDataRetentionPolicyResponse parses an HTTP response from a DeleteDataRetentionPolicyWithResponse call
func ParseDeleteDataRetentionPolicyResponse(rsp *http.Response) (*DeleteDataRetentionPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDataRetentionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetDataRetentionPolicyByIDResponse parses an HTTP response from a GetDataRetentionPolicyByIDWithResponse call
func ParseGetDataRetentionPolicyByIDResponse(rsp *http.Response) (*GetDataRetentionPolicyByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataRetentionPolicyByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataRetentionPolicyWithTeamAndChannelCounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParsePatchDataRetentionPolicyResponse parses an HTTP response from a PatchDataRetentionPolicyWithResponse call
func ParsePatchDataRetentionPolicyResponse(rsp *http.Response) (*PatchDataRetentionPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchDataRetentionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataRetentionPolicyWithTeamAndChannelCounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseRemoveChannelsFromRetentionPolicyResponse parses an HTTP response from a RemoveChannelsFromRetentionPolicyWithResponse call
func ParseRemoveChannelsFromRetentionPolicyResponse(rsp *http.Response) (*RemoveChannelsFromRetentionPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveChannelsFromRetentionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetChannelsForRetentionPolicyResponse parses an HTTP response from a GetChannelsForRetentionPolicyWithResponse call
func ParseGetChannelsForRetentionPolicyResponse(rsp *http.Response) (*GetChannelsForRetentionPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelsForRetentionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelListWithTeamData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseAddChannelsToRetentionPolicyResponse parses an HTTP response from a AddChannelsToRetentionPolicyWithResponse call
func ParseAddChannelsToRetentionPolicyResponse(rsp *http.Response) (*AddChannelsToRetentionPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddChannelsToRetentionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseSearchChannelsForRetentionPolicyResponse parses an HTTP response from a SearchChannelsForRetentionPolicyWithResponse call
func ParseSearchChannelsForRetentionPolicyResponse(rsp *http.Response) (*SearchChannelsForRetentionPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchChannelsForRetentionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelListWithTeamData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseRemoveTeamsFromRetentionPolicyResponse parses an HTTP response from a RemoveTeamsFromRetentionPolicyWithResponse call
func ParseRemoveTeamsFromRetentionPolicyResponse(rsp *http.Response) (*RemoveTeamsFromRetentionPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTeamsFromRetentionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetTeamsForRetentionPolicyResponse parses an HTTP response from a GetTeamsForRetentionPolicyWithResponse call
func ParseGetTeamsForRetentionPolicyResponse(rsp *http.Response) (*GetTeamsForRetentionPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsForRetentionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseAddTeamsToRetentionPolicyResponse parses an HTTP response from a AddTeamsToRetentionPolicyWithResponse call
func ParseAddTeamsToRetentionPolicyResponse(rsp *http.Response) (*AddTeamsToRetentionPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTeamsToRetentionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseSearchTeamsForRetentionPolicyResponse parses an HTTP response from a SearchTeamsForRetentionPolicyWithResponse call
func ParseSearchTeamsForRetentionPolicyResponse(rsp *http.Response) (*SearchTeamsForRetentionPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchTeamsForRetentionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetDataRetentionPoliciesCountResponse parses an HTTP response from a GetDataRetentionPoliciesCountWithResponse call
func ParseGetDataRetentionPoliciesCountResponse(rsp *http.Response) (*GetDataRetentionPoliciesCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataRetentionPoliciesCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TotalCount The number of granular retention policies.
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetDataRetentionPolicyResponse parses an HTTP response from a GetDataRetentionPolicyWithResponse call
func ParseGetDataRetentionPolicyResponse(rsp *http.Response) (*GetDataRetentionPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataRetentionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalDataRetentionPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDatabaseRecycleResponse parses an HTTP response from a DatabaseRecycleWithResponse call
func ParseDatabaseRecycleResponse(rsp *http.Response) (*DatabaseRecycleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DatabaseRecycleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePurgeElasticsearchIndexesResponse parses an HTTP response from a PurgeElasticsearchIndexesWithResponse call
func ParsePurgeElasticsearchIndexesResponse(rsp *http.Response) (*PurgeElasticsearchIndexesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PurgeElasticsearchIndexesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseTestElasticsearchResponse parses an HTTP response from a TestElasticsearchWithResponse call
func ParseTestElasticsearchResponse(rsp *http.Response) (*TestElasticsearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestElasticsearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseTestEmailResponse parses an HTTP response from a TestEmailWithResponse call
func ParseTestEmailResponse(rsp *http.Response) (*TestEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEmojiListResponse parses an HTTP response from a GetEmojiListWithResponse call
func ParseGetEmojiListResponse(rsp *http.Response) (*GetEmojiListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmojiListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Emoji
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseCreateEmojiResponse parses an HTTP response from a CreateEmojiWithResponse call
func ParseCreateEmojiResponse(rsp *http.Response) (*CreateEmojiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEmojiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Emoji
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest TooLarge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseAutocompleteEmojiResponse parses an HTTP response from a AutocompleteEmojiWithResponse call
func ParseAutocompleteEmojiResponse(rsp *http.Response) (*AutocompleteEmojiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AutocompleteEmojiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Emoji
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetEmojiByNameResponse parses an HTTP response from a GetEmojiByNameWithResponse call
func ParseGetEmojiByNameResponse(rsp *http.Response) (*GetEmojiByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmojiByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Emoji
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetEmojisByNamesResponse parses an HTTP response from a GetEmojisByNamesWithResponse call
func ParseGetEmojisByNamesResponse(rsp *http.Response) (*GetEmojisByNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmojisByNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseSearchEmojiResponse parses an HTTP response from a SearchEmojiWithResponse call
func ParseSearchEmojiResponse(rsp *http.Response) (*SearchEmojiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchEmojiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Emoji
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDeleteEmojiResponse parses an HTTP response from a DeleteEmojiWithResponse call
func ParseDeleteEmojiResponse(rsp *http.Response) (*DeleteEmojiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEmojiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Emoji
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetEmojiResponse parses an HTTP response from a GetEmojiWithResponse call
func ParseGetEmojiResponse(rsp *http.Response) (*GetEmojiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmojiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Emoji
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetEmojiImageResponse parses an HTTP response from a GetEmojiImageWithResponse call
func ParseGetEmojiImageResponse(rsp *http.Response) (*GetEmojiImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmojiImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseListExportsResponse parses an HTTP response from a ListExportsWithResponse call
func ParseListExportsResponse(rsp *http.Response) (*ListExportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteExportResponse parses an HTTP response from a DeleteExportWithResponse call
func ParseDeleteExportResponse(rsp *http.Response) (*DeleteExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadExportResponse parses an HTTP response from a DownloadExportWithResponse call
func ParseDownloadExportResponse(rsp *http.Response) (*DownloadExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTestS3ConnectionResponse parses an HTTP response from a TestS3ConnectionWithResponse call
func ParseTestS3ConnectionResponse(rsp *http.Response) (*TestS3ConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestS3ConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadFileResponse parses an HTTP response from a UploadFileWithResponse call
func ParseUploadFileResponse(rsp *http.Response) (*UploadFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// ClientIds A list of the client_ids that were provided in the request
			ClientIds *[]string `json:"client_ids,omitempty"`

			// FileInfos A list of file metadata that has been stored in the database
			FileInfos *[]FileInfo `json:"file_infos,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest TooLarge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseSearchFilesResponse parses an HTTP response from a SearchFilesWithResponse call
func ParseSearchFilesResponse(rsp *http.Response) (*SearchFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileInfoList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetFileResponse parses an HTTP response from a GetFileWithResponse call
func ParseGetFileResponse(rsp *http.Response) (*GetFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetFileInfoResponse parses an HTTP response from a GetFileInfoWithResponse call
func ParseGetFileInfoResponse(rsp *http.Response) (*GetFileInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFileInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetFileLinkResponse parses an HTTP response from a GetFileLinkWithResponse call
func ParseGetFileLinkResponse(rsp *http.Response) (*GetFileLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFileLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Link *string `json:"link,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetFilePreviewResponse parses an HTTP response from a GetFilePreviewWithResponse call
func ParseGetFilePreviewResponse(rsp *http.Response) (*GetFilePreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilePreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetFileThumbnailResponse parses an HTTP response from a GetFileThumbnailWithResponse call
func ParseGetFileThumbnailResponse(rsp *http.Response) (*GetFileThumbnailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFileThumbnailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetGroupsResponse parses an HTTP response from a GetGroupsWithResponse call
func ParseGetGroupsResponse(rsp *http.Response) (*GetGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetGroupSyncablesChannelsResponse parses an HTTP response from a GetGroupSyncablesChannelsWithResponse call
func ParseGetGroupSyncablesChannelsResponse(rsp *http.Response) (*GetGroupSyncablesChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupSyncablesChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GroupSyncableChannels
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetGroupSyncableForChannelIdResponse parses an HTTP response from a GetGroupSyncableForChannelIdWithResponse call
func ParseGetGroupSyncableForChannelIdResponse(rsp *http.Response) (*GetGroupSyncableForChannelIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupSyncableForChannelIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupSyncableChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUnlinkGroupSyncableForChannelResponse parses an HTTP response from a UnlinkGroupSyncableForChannelWithResponse call
func ParseUnlinkGroupSyncableForChannelResponse(rsp *http.Response) (*UnlinkGroupSyncableForChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkGroupSyncableForChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseLinkGroupSyncableForChannelResponse parses an HTTP response from a LinkGroupSyncableForChannelWithResponse call
func ParseLinkGroupSyncableForChannelResponse(rsp *http.Response) (*LinkGroupSyncableForChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkGroupSyncableForChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GroupSyncableChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParsePatchGroupSyncableForChannelResponse parses an HTTP response from a PatchGroupSyncableForChannelWithResponse call
func ParsePatchGroupSyncableForChannelResponse(rsp *http.Response) (*PatchGroupSyncableForChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchGroupSyncableForChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupSyncableChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDeleteGroupMembersResponse parses an HTTP response from a DeleteGroupMembersWithResponse call
func ParseDeleteGroupMembersResponse(rsp *http.Response) (*DeleteGroupMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GroupMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetGroupUsersResponse parses an HTTP response from a GetGroupUsersWithResponse call
func ParseGetGroupUsersResponse(rsp *http.Response) (*GetGroupUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Members          *[]User `json:"members,omitempty"`
			TotalMemberCount *int    `json:"total_member_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseAddGroupMembersResponse parses an HTTP response from a AddGroupMembersWithResponse call
func ParseAddGroupMembersResponse(rsp *http.Response) (*AddGroupMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddGroupMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GroupMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePatchGroupResponse parses an HTTP response from a PatchGroupWithResponse call
func ParsePatchGroupResponse(rsp *http.Response) (*PatchGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseRestoreGroupResponse parses an HTTP response from a RestoreGroupWithResponse call
func ParseRestoreGroupResponse(rsp *http.Response) (*RestoreGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetGroupStatsResponse parses an HTTP response from a GetGroupStatsWithResponse call
func ParseGetGroupStatsResponse(rsp *http.Response) (*GetGroupStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			GroupId          *string `json:"group_id,omitempty"`
			TotalMemberCount *int    `json:"total_member_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetGroupSyncablesTeamsResponse parses an HTTP response from a GetGroupSyncablesTeamsWithResponse call
func ParseGetGroupSyncablesTeamsResponse(rsp *http.Response) (*GetGroupSyncablesTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupSyncablesTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GroupSyncableTeams
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetGroupSyncableForTeamIdResponse parses an HTTP response from a GetGroupSyncableForTeamIdWithResponse call
func ParseGetGroupSyncableForTeamIdResponse(rsp *http.Response) (*GetGroupSyncableForTeamIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupSyncableForTeamIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupSyncableTeam
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUnlinkGroupSyncableForTeamResponse parses an HTTP response from a UnlinkGroupSyncableForTeamWithResponse call
func ParseUnlinkGroupSyncableForTeamResponse(rsp *http.Response) (*UnlinkGroupSyncableForTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkGroupSyncableForTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseLinkGroupSyncableForTeamResponse parses an HTTP response from a LinkGroupSyncableForTeamWithResponse call
func ParseLinkGroupSyncableForTeamResponse(rsp *http.Response) (*LinkGroupSyncableForTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkGroupSyncableForTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GroupSyncableTeam
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParsePatchGroupSyncableForTeamResponse parses an HTTP response from a PatchGroupSyncableForTeamWithResponse call
func ParsePatchGroupSyncableForTeamResponse(rsp *http.Response) (*PatchGroupSyncableForTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchGroupSyncableForTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupSyncableTeam
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetIncomingWebhooksResponse parses an HTTP response from a GetIncomingWebhooksWithResponse call
func ParseGetIncomingWebhooksResponse(rsp *http.Response) (*GetIncomingWebhooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIncomingWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IncomingWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateIncomingWebhookResponse parses an HTTP response from a CreateIncomingWebhookWithResponse call
func ParseCreateIncomingWebhookResponse(rsp *http.Response) (*CreateIncomingWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIncomingWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IncomingWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteIncomingWebhookResponse parses an HTTP response from a DeleteIncomingWebhookWithResponse call
func ParseDeleteIncomingWebhookResponse(rsp *http.Response) (*DeleteIncomingWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIncomingWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetIncomingWebhookResponse parses an HTTP response from a GetIncomingWebhookWithResponse call
func ParseGetIncomingWebhookResponse(rsp *http.Response) (*GetIncomingWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIncomingWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncomingWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateIncomingWebhookResponse parses an HTTP response from a UpdateIncomingWebhookWithResponse call
func ParseUpdateIncomingWebhookResponse(rsp *http.Response) (*UpdateIncomingWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateIncomingWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IncomingWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetOutgoingWebhooksResponse parses an HTTP response from a GetOutgoingWebhooksWithResponse call
func ParseGetOutgoingWebhooksResponse(rsp *http.Response) (*GetOutgoingWebhooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOutgoingWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OutgoingWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateOutgoingWebhookResponse parses an HTTP response from a CreateOutgoingWebhookWithResponse call
func ParseCreateOutgoingWebhookResponse(rsp *http.Response) (*CreateOutgoingWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOutgoingWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OutgoingWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteOutgoingWebhookResponse parses an HTTP response from a DeleteOutgoingWebhookWithResponse call
func ParseDeleteOutgoingWebhookResponse(rsp *http.Response) (*DeleteOutgoingWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOutgoingWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetOutgoingWebhookResponse parses an HTTP response from a GetOutgoingWebhookWithResponse call
func ParseGetOutgoingWebhookResponse(rsp *http.Response) (*GetOutgoingWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOutgoingWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OutgoingWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateOutgoingWebhookResponse parses an HTTP response from a UpdateOutgoingWebhookWithResponse call
func ParseUpdateOutgoingWebhookResponse(rsp *http.Response) (*UpdateOutgoingWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOutgoingWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OutgoingWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRegenOutgoingHookTokenResponse parses an HTTP response from a RegenOutgoingHookTokenWithResponse call
func ParseRegenOutgoingHookTokenResponse(rsp *http.Response) (*RegenOutgoingHookTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegenOutgoingHookTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetImageByUrlResponse parses an HTTP response from a GetImageByUrlWithResponse call
func ParseGetImageByUrlResponse(rsp *http.Response) (*GetImageByUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImageByUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListImportsResponse parses an HTTP response from a ListImportsWithResponse call
func ParseListImportsResponse(rsp *http.Response) (*ListImportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListImportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCheckIntegrityResponse parses an HTTP response from a CheckIntegrityWithResponse call
func ParseCheckIntegrityResponse(rsp *http.Response) (*CheckIntegrityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckIntegrityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IntegrityCheckResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIPFiltersResponse parses an HTTP response from a GetIPFiltersWithResponse call
func ParseGetIPFiltersResponse(rsp *http.Response) (*GetIPFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIPFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AllowedIPRange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseApplyIPFiltersResponse parses an HTTP response from a ApplyIPFiltersWithResponse call
func ParseApplyIPFiltersResponse(rsp *http.Response) (*ApplyIPFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApplyIPFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AllowedIPRange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseMyIPResponse parses an HTTP response from a MyIPWithResponse call
func ParseMyIPResponse(rsp *http.Response) (*MyIPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MyIPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Ip Your current IP address
			Ip *string `json:"ip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetJobsResponse parses an HTTP response from a GetJobsWithResponse call
func ParseGetJobsResponse(rsp *http.Response) (*GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateJobResponse parses an HTTP response from a CreateJobWithResponse call
func ParseCreateJobResponse(rsp *http.Response) (*CreateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetJobsByTypeResponse parses an HTTP response from a GetJobsByTypeWithResponse call
func ParseGetJobsByTypeResponse(rsp *http.Response) (*GetJobsByTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobsByTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCancelJobResponse parses an HTTP response from a CancelJobWithResponse call
func ParseCancelJobResponse(rsp *http.Response) (*CancelJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDownloadJobResponse parses an HTTP response from a DownloadJobWithResponse call
func ParseDownloadJobResponse(rsp *http.Response) (*DownloadJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateJobStatusResponse parses an HTTP response from a UpdateJobStatusWithResponse call
func ParseUpdateJobStatusResponse(rsp *http.Response) (*UpdateJobStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateJobStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteLdapPrivateCertificateResponse parses an HTTP response from a DeleteLdapPrivateCertificateWithResponse call
func ParseDeleteLdapPrivateCertificateResponse(rsp *http.Response) (*DeleteLdapPrivateCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLdapPrivateCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUploadLdapPrivateCertificateResponse parses an HTTP response from a UploadLdapPrivateCertificateWithResponse call
func ParseUploadLdapPrivateCertificateResponse(rsp *http.Response) (*UploadLdapPrivateCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadLdapPrivateCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDeleteLdapPublicCertificateResponse parses an HTTP response from a DeleteLdapPublicCertificateWithResponse call
func ParseDeleteLdapPublicCertificateResponse(rsp *http.Response) (*DeleteLdapPublicCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLdapPublicCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUploadLdapPublicCertificateResponse parses an HTTP response from a UploadLdapPublicCertificateWithResponse call
func ParseUploadLdapPublicCertificateResponse(rsp *http.Response) (*UploadLdapPublicCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadLdapPublicCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetLdapGroupsResponse parses an HTTP response from a GetLdapGroupsWithResponse call
func ParseGetLdapGroupsResponse(rsp *http.Response) (*GetLdapGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLdapGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LDAPGroupsPaged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUnlinkLdapGroupResponse parses an HTTP response from a UnlinkLdapGroupWithResponse call
func ParseUnlinkLdapGroupResponse(rsp *http.Response) (*UnlinkLdapGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkLdapGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseLinkLdapGroupResponse parses an HTTP response from a LinkLdapGroupWithResponse call
func ParseLinkLdapGroupResponse(rsp *http.Response) (*LinkLdapGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkLdapGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseMigrateIdLdapResponse parses an HTTP response from a MigrateIdLdapWithResponse call
func ParseMigrateIdLdapResponse(rsp *http.Response) (*MigrateIdLdapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrateIdLdapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseSyncLdapResponse parses an HTTP response from a SyncLdapWithResponse call
func ParseSyncLdapResponse(rsp *http.Response) (*SyncLdapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncLdapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseTestLdapResponse parses an HTTP response from a TestLdapWithResponse call
func ParseTestLdapResponse(rsp *http.Response) (*TestLdapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestLdapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseAddUserToGroupSyncablesResponse parses an HTTP response from a AddUserToGroupSyncablesWithResponse call
func ParseAddUserToGroupSyncablesResponse(rsp *http.Response) (*AddUserToGroupSyncablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserToGroupSyncablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseRemoveLicenseFileResponse parses an HTTP response from a RemoveLicenseFileWithResponse call
func ParseRemoveLicenseFileResponse(rsp *http.Response) (*RemoveLicenseFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveLicenseFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUploadLicenseFileResponse parses an HTTP response from a UploadLicenseFileWithResponse call
func ParseUploadLicenseFileResponse(rsp *http.Response) (*UploadLicenseFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadLicenseFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest TooLarge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseGetClientLicenseResponse parses an HTTP response from a GetClientLicenseWithResponse call
func ParseGetClientLicenseResponse(rsp *http.Response) (*GetClientLicenseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseRequestLicenseRenewalLinkResponse parses an HTTP response from a RequestLicenseRenewalLinkWithResponse call
func ParseRequestLicenseRenewalLinkResponse(rsp *http.Response) (*RequestLicenseRenewalLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestLicenseRenewalLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LicenseRenewalLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetServerLimitsResponse parses an HTTP response from a GetServerLimitsWithResponse call
func ParseGetServerLimitsResponse(rsp *http.Response) (*GetServerLimitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerLimitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ServerLimits
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLogsResponse parses an HTTP response from a GetLogsWithResponse call
func ParseGetLogsResponse(rsp *http.Response) (*GetLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePostLogResponse parses an HTTP response from a PostLogWithResponse call
func ParsePostLogResponse(rsp *http.Response) (*PostLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDownloadSystemLogsResponse parses an HTTP response from a DownloadSystemLogsWithResponse call
func ParseDownloadSystemLogsResponse(rsp *http.Response) (*DownloadSystemLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadSystemLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAcknowledgeNotificationResponse parses an HTTP response from a AcknowledgeNotificationWithResponse call
func ParseAcknowledgeNotificationResponse(rsp *http.Response) (*AcknowledgeNotificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcknowledgeNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PushNotification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTestNotificationResponse parses an HTTP response from a TestNotificationWithResponse call
func ParseTestNotificationResponse(rsp *http.Response) (*TestNotificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOAuthAppsResponse parses an HTTP response from a GetOAuthAppsWithResponse call
func ParseGetOAuthAppsResponse(rsp *http.Response) (*GetOAuthAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOAuthAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OAuthApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseCreateOAuthAppResponse parses an HTTP response from a CreateOAuthAppWithResponse call
func ParseCreateOAuthAppResponse(rsp *http.Response) (*CreateOAuthAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOAuthAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OAuthApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDeleteOAuthAppResponse parses an HTTP response from a DeleteOAuthAppWithResponse call
func ParseDeleteOAuthAppResponse(rsp *http.Response) (*DeleteOAuthAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOAuthAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetOAuthAppResponse parses an HTTP response from a GetOAuthAppWithResponse call
func ParseGetOAuthAppResponse(rsp *http.Response) (*GetOAuthAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOAuthAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUpdateOAuthAppResponse parses an HTTP response from a UpdateOAuthAppWithResponse call
func ParseUpdateOAuthAppResponse(rsp *http.Response) (*UpdateOAuthAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOAuthAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetOAuthAppInfoResponse parses an HTTP response from a GetOAuthAppInfoWithResponse call
func ParseGetOAuthAppInfoResponse(rsp *http.Response) (*GetOAuthAppInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOAuthAppInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseRegenerateOAuthAppSecretResponse parses an HTTP response from a RegenerateOAuthAppSecretWithResponse call
func ParseRegenerateOAuthAppSecretResponse(rsp *http.Response) (*RegenerateOAuthAppSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegenerateOAuthAppSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseListOutgoingOAuthConnectionsResponse parses an HTTP response from a ListOutgoingOAuthConnectionsWithResponse call
func ParseListOutgoingOAuthConnectionsResponse(rsp *http.Response) (*ListOutgoingOAuthConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOutgoingOAuthConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OutgoingOAuthConnectionGetItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseCreateOutgoingOAuthConnectionResponse parses an HTTP response from a CreateOutgoingOAuthConnectionWithResponse call
func ParseCreateOutgoingOAuthConnectionResponse(rsp *http.Response) (*CreateOutgoingOAuthConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOutgoingOAuthConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OutgoingOAuthConnectionGetItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseValidateOutgoingOAuthConnectionResponse parses an HTTP response from a ValidateOutgoingOAuthConnectionWithResponse call
func ParseValidateOutgoingOAuthConnectionResponse(rsp *http.Response) (*ValidateOutgoingOAuthConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateOutgoingOAuthConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseDeleteOutgoingOAuthConnectionResponse parses an HTTP response from a DeleteOutgoingOAuthConnectionWithResponse call
func ParseDeleteOutgoingOAuthConnectionResponse(rsp *http.Response) (*DeleteOutgoingOAuthConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOutgoingOAuthConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetOutgoingOAuthConnectionResponse parses an HTTP response from a GetOutgoingOAuthConnectionWithResponse call
func ParseGetOutgoingOAuthConnectionResponse(rsp *http.Response) (*GetOutgoingOAuthConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOutgoingOAuthConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OutgoingOAuthConnectionGetItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUpdateOutgoingOAuthConnectionResponse parses an HTTP response from a UpdateOutgoingOAuthConnectionWithResponse call
func ParseUpdateOutgoingOAuthConnectionResponse(rsp *http.Response) (*UpdateOutgoingOAuthConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOutgoingOAuthConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OutgoingOAuthConnectionGetItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetAncillaryPermissionsPostResponse parses an HTTP response from a GetAncillaryPermissionsPostWithResponse call
func ParseGetAncillaryPermissionsPostResponse(rsp *http.Response) (*GetAncillaryPermissionsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAncillaryPermissionsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPluginsResponse parses an HTTP response from a GetPluginsWithResponse call
func ParseGetPluginsResponse(rsp *http.Response) (*GetPluginsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Active   *[]PluginManifest `json:"active,omitempty"`
			Inactive *[]PluginManifest `json:"inactive,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUploadPluginResponse parses an HTTP response from a UploadPluginWithResponse call
func ParseUploadPluginResponse(rsp *http.Response) (*UploadPluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadPluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest TooLarge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseInstallPluginFromUrlResponse parses an HTTP response from a InstallPluginFromUrlWithResponse call
func ParseInstallPluginFromUrlResponse(rsp *http.Response) (*InstallPluginFromUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallPluginFromUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetMarketplacePluginsResponse parses an HTTP response from a GetMarketplacePluginsWithResponse call
func ParseGetMarketplacePluginsResponse(rsp *http.Response) (*GetMarketplacePluginsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMarketplacePluginsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MarketplacePlugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseInstallMarketplacePluginResponse parses an HTTP response from a InstallMarketplacePluginWithResponse call
func ParseInstallMarketplacePluginResponse(rsp *http.Response) (*InstallMarketplacePluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallMarketplacePluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginManifest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetMarketplaceVisitedByAdminResponse parses an HTTP response from a GetMarketplaceVisitedByAdminWithResponse call
func ParseGetMarketplaceVisitedByAdminResponse(rsp *http.Response) (*GetMarketplaceVisitedByAdminResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMarketplaceVisitedByAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest System
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateMarketplaceVisitedByAdminResponse parses an HTTP response from a UpdateMarketplaceVisitedByAdminWithResponse call
func ParseUpdateMarketplaceVisitedByAdminResponse(rsp *http.Response) (*UpdateMarketplaceVisitedByAdminResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMarketplaceVisitedByAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPluginStatusesResponse parses an HTTP response from a GetPluginStatusesWithResponse call
func ParseGetPluginStatusesResponse(rsp *http.Response) (*GetPluginStatusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PluginStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetWebappPluginsResponse parses an HTTP response from a GetWebappPluginsWithResponse call
func ParseGetWebappPluginsResponse(rsp *http.Response) (*GetWebappPluginsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebappPluginsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PluginManifestWebapp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseRemovePluginResponse parses an HTTP response from a RemovePluginWithResponse call
func ParseRemovePluginResponse(rsp *http.Response) (*RemovePluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDisablePluginResponse parses an HTTP response from a DisablePluginWithResponse call
func ParseDisablePluginResponse(rsp *http.Response) (*DisablePluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisablePluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseEnablePluginResponse parses an HTTP response from a EnablePluginWithResponse call
func ParseEnablePluginResponse(rsp *http.Response) (*EnablePluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnablePluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseCreatePostResponse parses an HTTP response from a CreatePostWithResponse call
func ParseCreatePostResponse(rsp *http.Response) (*CreatePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Post
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreatePostEphemeralResponse parses an HTTP response from a CreatePostEphemeralWithResponse call
func ParseCreatePostEphemeralResponse(rsp *http.Response) (*CreatePostEphemeralResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePostEphemeralResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Post
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPostsByIdsResponse parses an HTTP response from a GetPostsByIdsWithResponse call
func ParseGetPostsByIdsResponse(rsp *http.Response) (*GetPostsByIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostsByIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Post
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBulkReactionsResponse parses an HTTP response from a GetBulkReactionsWithResponse call
func ParseGetBulkReactionsResponse(rsp *http.Response) (*GetBulkReactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBulkReactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostIdToReactionsMap
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateScheduledPostResponse parses an HTTP response from a CreateScheduledPostWithResponse call
func ParseCreateScheduledPostResponse(rsp *http.Response) (*CreateScheduledPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateScheduledPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteScheduledPostResponse parses an HTTP response from a DeleteScheduledPostWithResponse call
func ParseDeleteScheduledPostResponse(rsp *http.Response) (*DeleteScheduledPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScheduledPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateScheduledPostResponse parses an HTTP response from a UpdateScheduledPostWithResponse call
func ParseUpdateScheduledPostResponse(rsp *http.Response) (*UpdateScheduledPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateScheduledPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserScheduledPostsResponse parses an HTTP response from a GetUserScheduledPostsWithResponse call
func ParseGetUserScheduledPostsResponse(rsp *http.Response) (*GetUserScheduledPostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserScheduledPostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string][]ScheduledPost
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePostResponse parses an HTTP response from a DeletePostWithResponse call
func ParseDeletePostResponse(rsp *http.Response) (*DeletePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPostResponse parses an HTTP response from a GetPostWithResponse call
func ParseGetPostResponse(rsp *http.Response) (*GetPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Post
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdatePostResponse parses an HTTP response from a UpdatePostWithResponse call
func ParseUpdatePostResponse(rsp *http.Response) (*UpdatePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Post
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDoPostActionResponse parses an HTTP response from a DoPostActionWithResponse call
func ParseDoPostActionResponse(rsp *http.Response) (*DoPostActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DoPostActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetFileInfosForPostResponse parses an HTTP response from a GetFileInfosForPostWithResponse call
func ParseGetFileInfosForPostResponse(rsp *http.Response) (*GetFileInfosForPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFileInfosForPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FileInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseMoveThreadResponse parses an HTTP response from a MoveThreadWithResponse call
func ParseMoveThreadResponse(rsp *http.Response) (*MoveThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MoveThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParsePatchPostResponse parses an HTTP response from a PatchPostWithResponse call
func ParsePatchPostResponse(rsp *http.Response) (*PatchPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Post
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePinPostResponse parses an HTTP response from a PinPostWithResponse call
func ParsePinPostResponse(rsp *http.Response) (*PinPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PinPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetReactionsResponse parses an HTTP response from a GetReactionsWithResponse call
func ParseGetReactionsResponse(rsp *http.Response) (*GetReactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPostThreadResponse parses an HTTP response from a GetPostThreadWithResponse call
func ParseGetPostThreadResponse(rsp *http.Response) (*GetPostThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUnpinPostResponse parses an HTTP response from a UnpinPostWithResponse call
func ParseUnpinPostResponse(rsp *http.Response) (*UnpinPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnpinPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSaveReactionResponse parses an HTTP response from a SaveReactionWithResponse call
func ParseSaveReactionResponse(rsp *http.Response) (*SaveReactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveReactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetRedirectLocationResponse parses an HTTP response from a GetRedirectLocationWithResponse call
func ParseGetRedirectLocationResponse(rsp *http.Response) (*GetRedirectLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRedirectLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRemoteClustersResponse parses an HTTP response from a GetRemoteClustersWithResponse call
func ParseGetRemoteClustersResponse(rsp *http.Response) (*GetRemoteClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRemoteClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RemoteCluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateRemoteClusterResponse parses an HTTP response from a CreateRemoteClusterWithResponse call
func ParseCreateRemoteClusterResponse(rsp *http.Response) (*CreateRemoteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRemoteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Invite The encrypted invite for the newly created remote cluster
			Invite *string `json:"invite,omitempty"`

			// Password The password generated by the server if none was
			// sent on the create request
			Password      *string        `json:"password,omitempty"`
			RemoteCluster *RemoteCluster `json:"remote_cluster,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAcceptRemoteClusterInviteResponse parses an HTTP response from a AcceptRemoteClusterInviteWithResponse call
func ParseAcceptRemoteClusterInviteResponse(rsp *http.Response) (*AcceptRemoteClusterInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptRemoteClusterInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RemoteCluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteRemoteClusterResponse parses an HTTP response from a DeleteRemoteClusterWithResponse call
func ParseDeleteRemoteClusterResponse(rsp *http.Response) (*DeleteRemoteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRemoteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRemoteClusterResponse parses an HTTP response from a GetRemoteClusterWithResponse call
func ParseGetRemoteClusterResponse(rsp *http.Response) (*GetRemoteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRemoteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RemoteCluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchRemoteClusterResponse parses an HTTP response from a PatchRemoteClusterWithResponse call
func ParsePatchRemoteClusterResponse(rsp *http.Response) (*PatchRemoteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchRemoteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RemoteCluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInviteRemoteClusterToChannelResponse parses an HTTP response from a InviteRemoteClusterToChannelWithResponse call
func ParseInviteRemoteClusterToChannelResponse(rsp *http.Response) (*InviteRemoteClusterToChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteRemoteClusterToChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUninviteRemoteClusterToChannelResponse parses an HTTP response from a UninviteRemoteClusterToChannelWithResponse call
func ParseUninviteRemoteClusterToChannelResponse(rsp *http.Response) (*UninviteRemoteClusterToChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UninviteRemoteClusterToChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetSharedChannelRemotesByRemoteClusterResponse parses an HTTP response from a GetSharedChannelRemotesByRemoteClusterWithResponse call
func ParseGetSharedChannelRemotesByRemoteClusterResponse(rsp *http.Response) (*GetSharedChannelRemotesByRemoteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSharedChannelRemotesByRemoteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SharedChannelRemote
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetUsersForReportingResponse parses an HTTP response from a GetUsersForReportingWithResponse call
func ParseGetUsersForReportingResponse(rsp *http.Response) (*GetUsersForReportingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersForReportingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserReport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserCountForReportingResponse parses an HTTP response from a GetUserCountForReportingWithResponse call
func ParseGetUserCountForReportingResponse(rsp *http.Response) (*GetUserCountForReportingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserCountForReportingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest float32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStartBatchUsersExportResponse parses an HTTP response from a StartBatchUsersExportWithResponse call
func ParseStartBatchUsersExportResponse(rsp *http.Response) (*StartBatchUsersExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartBatchUsersExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserReport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRestartServerResponse parses an HTTP response from a RestartServerWithResponse call
func ParseRestartServerResponse(rsp *http.Response) (*RestartServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestartServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetAllRolesResponse parses an HTTP response from a GetAllRolesWithResponse call
func ParseGetAllRolesResponse(rsp *http.Response) (*GetAllRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetRoleByNameResponse parses an HTTP response from a GetRoleByNameWithResponse call
func ParseGetRoleByNameResponse(rsp *http.Response) (*GetRoleByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRolesByNamesResponse parses an HTTP response from a GetRolesByNamesWithResponse call
func ParseGetRolesByNamesResponse(rsp *http.Response) (*GetRolesByNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolesByNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRoleResponse parses an HTTP response from a GetRoleWithResponse call
func ParseGetRoleResponse(rsp *http.Response) (*GetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchRoleResponse parses an HTTP response from a PatchRoleWithResponse call
func ParsePatchRoleResponse(rsp *http.Response) (*PatchRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteSamlIdpCertificateResponse parses an HTTP response from a DeleteSamlIdpCertificateWithResponse call
func ParseDeleteSamlIdpCertificateResponse(rsp *http.Response) (*DeleteSamlIdpCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSamlIdpCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUploadSamlIdpCertificateResponse parses an HTTP response from a UploadSamlIdpCertificateWithResponse call
func ParseUploadSamlIdpCertificateResponse(rsp *http.Response) (*UploadSamlIdpCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadSamlIdpCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDeleteSamlPrivateCertificateResponse parses an HTTP response from a DeleteSamlPrivateCertificateWithResponse call
func ParseDeleteSamlPrivateCertificateResponse(rsp *http.Response) (*DeleteSamlPrivateCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSamlPrivateCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUploadSamlPrivateCertificateResponse parses an HTTP response from a UploadSamlPrivateCertificateWithResponse call
func ParseUploadSamlPrivateCertificateResponse(rsp *http.Response) (*UploadSamlPrivateCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadSamlPrivateCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDeleteSamlPublicCertificateResponse parses an HTTP response from a DeleteSamlPublicCertificateWithResponse call
func ParseDeleteSamlPublicCertificateResponse(rsp *http.Response) (*DeleteSamlPublicCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSamlPublicCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUploadSamlPublicCertificateResponse parses an HTTP response from a UploadSamlPublicCertificateWithResponse call
func ParseUploadSamlPublicCertificateResponse(rsp *http.Response) (*UploadSamlPublicCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadSamlPublicCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetSamlCertificateStatusResponse parses an HTTP response from a GetSamlCertificateStatusWithResponse call
func ParseGetSamlCertificateStatusResponse(rsp *http.Response) (*GetSamlCertificateStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSamlCertificateStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SamlCertificateStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetSamlMetadataResponse parses an HTTP response from a GetSamlMetadataWithResponse call
func ParseGetSamlMetadataResponse(rsp *http.Response) (*GetSamlMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSamlMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetSamlMetadataFromIdpResponse parses an HTTP response from a GetSamlMetadataFromIdpWithResponse call
func ParseGetSamlMetadataFromIdpResponse(rsp *http.Response) (*GetSamlMetadataFromIdpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSamlMetadataFromIdpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseResetSamlAuthDataToEmailResponse parses an HTTP response from a ResetSamlAuthDataToEmailWithResponse call
func ParseResetSamlAuthDataToEmailResponse(rsp *http.Response) (*ResetSamlAuthDataToEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetSamlAuthDataToEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NumAffected The number of users whose AuthData field was reset.
			NumAffected *int `json:"num_affected,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetSchemesResponse parses an HTTP response from a GetSchemesWithResponse call
func ParseGetSchemesResponse(rsp *http.Response) (*GetSchemesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Scheme
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateSchemeResponse parses an HTTP response from a CreateSchemeWithResponse call
func ParseCreateSchemeResponse(rsp *http.Response) (*CreateSchemeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSchemeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Scheme
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDeleteSchemeResponse parses an HTTP response from a DeleteSchemeWithResponse call
func ParseDeleteSchemeResponse(rsp *http.Response) (*DeleteSchemeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSchemeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetSchemeResponse parses an HTTP response from a GetSchemeWithResponse call
func ParseGetSchemeResponse(rsp *http.Response) (*GetSchemeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Scheme
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetChannelsForSchemeResponse parses an HTTP response from a GetChannelsForSchemeWithResponse call
func ParseGetChannelsForSchemeResponse(rsp *http.Response) (*GetChannelsForSchemeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelsForSchemeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchSchemeResponse parses an HTTP response from a PatchSchemeWithResponse call
func ParsePatchSchemeResponse(rsp *http.Response) (*PatchSchemeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSchemeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Scheme
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetTeamsForSchemeResponse parses an HTTP response from a GetTeamsForSchemeWithResponse call
func ParseGetTeamsForSchemeResponse(rsp *http.Response) (*GetTeamsForSchemeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsForSchemeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseClearServerBusyResponse parses an HTTP response from a ClearServerBusyWithResponse call
func ParseClearServerBusyResponse(rsp *http.Response) (*ClearServerBusyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearServerBusyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetServerBusyExpiresResponse parses an HTTP response from a GetServerBusyExpiresWithResponse call
func ParseGetServerBusyExpiresResponse(rsp *http.Response) (*GetServerBusyExpiresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerBusyExpiresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerBusy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSetServerBusyResponse parses an HTTP response from a SetServerBusyWithResponse call
func ParseSetServerBusyResponse(rsp *http.Response) (*SetServerBusyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetServerBusyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetRemoteClusterInfoResponse parses an HTTP response from a GetRemoteClusterInfoWithResponse call
func ParseGetRemoteClusterInfoResponse(rsp *http.Response) (*GetRemoteClusterInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRemoteClusterInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RemoteClusterInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAllSharedChannelsResponse parses an HTTP response from a GetAllSharedChannelsWithResponse call
func ParseGetAllSharedChannelsResponse(rsp *http.Response) (*GetAllSharedChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSharedChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SharedChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTestSiteURLResponse parses an HTTP response from a TestSiteURLWithResponse call
func ParseTestSiteURLResponse(rsp *http.Response) (*TestSiteURLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestSiteURLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMarkNoticesViewedResponse parses an HTTP response from a MarkNoticesViewedWithResponse call
func ParseMarkNoticesViewedResponse(rsp *http.Response) (*MarkNoticesViewedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkNoticesViewedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNoticesResponse parses an HTTP response from a GetNoticesWithResponse call
func ParseGetNoticesResponse(rsp *http.Response) (*GetNoticesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNoticesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Notice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPingResponse parses an HTTP response from a GetPingWithResponse call
func ParseGetPingResponse(rsp *http.Response) (*GetPingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SystemStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenerateSupportPacketResponse parses an HTTP response from a GenerateSupportPacketWithResponse call
func ParseGenerateSupportPacketResponse(rsp *http.Response) (*GenerateSupportPacketResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateSupportPacketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSupportedTimezoneResponse parses an HTTP response from a GetSupportedTimezoneWithResponse call
func ParseGetSupportedTimezoneResponse(rsp *http.Response) (*GetSupportedTimezoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSupportedTimezoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllTeamsResponse parses an HTTP response from a GetAllTeamsWithResponse call
func ParseGetAllTeamsResponse(rsp *http.Response) (*GetAllTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateTeamResponse parses an HTTP response from a CreateTeamWithResponse call
func ParseCreateTeamResponse(rsp *http.Response) (*CreateTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTeamInviteInfoResponse parses an HTTP response from a GetTeamInviteInfoWithResponse call
func ParseGetTeamInviteInfoResponse(rsp *http.Response) (*GetTeamInviteInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamInviteInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Description *string `json:"description,omitempty"`
			DisplayName *string `json:"display_name,omitempty"`
			Id          *string `json:"id,omitempty"`
			Name        *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseInvalidateEmailInvitesResponse parses an HTTP response from a InvalidateEmailInvitesWithResponse call
func ParseInvalidateEmailInvitesResponse(rsp *http.Response) (*InvalidateEmailInvitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InvalidateEmailInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAddTeamMemberFromInviteResponse parses an HTTP response from a AddTeamMemberFromInviteWithResponse call
func ParseAddTeamMemberFromInviteResponse(rsp *http.Response) (*AddTeamMemberFromInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTeamMemberFromInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TeamMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTeamByNameResponse parses an HTTP response from a GetTeamByNameWithResponse call
func ParseGetTeamByNameResponse(rsp *http.Response) (*GetTeamByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTeamExistsResponse parses an HTTP response from a TeamExistsWithResponse call
func ParseTeamExistsResponse(rsp *http.Response) (*TeamExistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamExistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetChannelByNameForTeamNameResponse parses an HTTP response from a GetChannelByNameForTeamNameWithResponse call
func ParseGetChannelByNameForTeamNameResponse(rsp *http.Response) (*GetChannelByNameForTeamNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelByNameForTeamNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSearchTeamsResponse parses an HTTP response from a SearchTeamsWithResponse call
func ParseSearchTeamsResponse(rsp *http.Response) (*SearchTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Teams The teams that matched the query.
			Teams *[]Team `json:"teams,omitempty"`

			// TotalCount The total number of results, regardless of page and per_page requested.
			TotalCount *float32 `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSoftDeleteTeamResponse parses an HTTP response from a SoftDeleteTeamWithResponse call
func ParseSoftDeleteTeamResponse(rsp *http.Response) (*SoftDeleteTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SoftDeleteTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTeamResponse parses an HTTP response from a GetTeamWithResponse call
func ParseGetTeamResponse(rsp *http.Response) (*GetTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateTeamResponse parses an HTTP response from a UpdateTeamWithResponse call
func ParseUpdateTeamResponse(rsp *http.Response) (*UpdateTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPublicChannelsForTeamResponse parses an HTTP response from a GetPublicChannelsForTeamWithResponse call
func ParseGetPublicChannelsForTeamResponse(rsp *http.Response) (*GetPublicChannelsForTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicChannelsForTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAutocompleteChannelsForTeamResponse parses an HTTP response from a AutocompleteChannelsForTeamWithResponse call
func ParseAutocompleteChannelsForTeamResponse(rsp *http.Response) (*AutocompleteChannelsForTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AutocompleteChannelsForTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDeletedChannelsForTeamResponse parses an HTTP response from a GetDeletedChannelsForTeamWithResponse call
func ParseGetDeletedChannelsForTeamResponse(rsp *http.Response) (*GetDeletedChannelsForTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeletedChannelsForTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPublicChannelsByIdsForTeamResponse parses an HTTP response from a GetPublicChannelsByIdsForTeamWithResponse call
func ParseGetPublicChannelsByIdsForTeamResponse(rsp *http.Response) (*GetPublicChannelsByIdsForTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicChannelsByIdsForTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetChannelByNameResponse parses an HTTP response from a GetChannelByNameWithResponse call
func ParseGetChannelByNameResponse(rsp *http.Response) (*GetChannelByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPrivateChannelsForTeamResponse parses an HTTP response from a GetPrivateChannelsForTeamWithResponse call
func ParseGetPrivateChannelsForTeamResponse(rsp *http.Response) (*GetPrivateChannelsForTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPrivateChannelsForTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSearchChannelsResponse parses an HTTP response from a SearchChannelsWithResponse call
func ParseSearchChannelsResponse(rsp *http.Response) (*SearchChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSearchArchivedChannelsResponse parses an HTTP response from a SearchArchivedChannelsWithResponse call
func ParseSearchArchivedChannelsResponse(rsp *http.Response) (*SearchArchivedChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchArchivedChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAutocompleteChannelsForTeamForSearchResponse parses an HTTP response from a AutocompleteChannelsForTeamForSearchWithResponse call
func ParseAutocompleteChannelsForTeamForSearchResponse(rsp *http.Response) (*AutocompleteChannelsForTeamForSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AutocompleteChannelsForTeamForSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListAutocompleteCommandsResponse parses an HTTP response from a ListAutocompleteCommandsWithResponse call
func ParseListAutocompleteCommandsResponse(rsp *http.Response) (*ListAutocompleteCommandsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAutocompleteCommandsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Command
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListCommandAutocompleteSuggestionsResponse parses an HTTP response from a ListCommandAutocompleteSuggestionsWithResponse call
func ParseListCommandAutocompleteSuggestionsResponse(rsp *http.Response) (*ListCommandAutocompleteSuggestionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCommandAutocompleteSuggestionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AutocompleteSuggestion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSearchFilesResponse parses an HTTP response from a SearchFilesWithResponse call
func ParseSearchFilesResponse(rsp *http.Response) (*SearchFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileInfoList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetGroupsByTeamResponse parses an HTTP response from a GetGroupsByTeamWithResponse call
func ParseGetGroupsByTeamResponse(rsp *http.Response) (*GetGroupsByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetGroupsAssociatedToChannelsByTeamResponse parses an HTTP response from a GetGroupsAssociatedToChannelsByTeamWithResponse call
func ParseGetGroupsAssociatedToChannelsByTeamResponse(rsp *http.Response) (*GetGroupsAssociatedToChannelsByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsAssociatedToChannelsByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseRemoveTeamIconResponse parses an HTTP response from a RemoveTeamIconWithResponse call
func ParseRemoveTeamIconResponse(rsp *http.Response) (*RemoveTeamIconResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTeamIconResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetTeamIconResponse parses an HTTP response from a GetTeamIconWithResponse call
func ParseGetTeamIconResponse(rsp *http.Response) (*GetTeamIconResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamIconResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseSetTeamIconResponse parses an HTTP response from a SetTeamIconWithResponse call
func ParseSetTeamIconResponse(rsp *http.Response) (*SetTeamIconResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetTeamIconResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseImportTeamResponse parses an HTTP response from a ImportTeamWithResponse call
func ParseImportTeamResponse(rsp *http.Response) (*ImportTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Results *string `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseInviteGuestsToTeamResponse parses an HTTP response from a InviteGuestsToTeamWithResponse call
func ParseInviteGuestsToTeamResponse(rsp *http.Response) (*InviteGuestsToTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteGuestsToTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest TooLarge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseInviteUsersToTeamResponse parses an HTTP response from a InviteUsersToTeamWithResponse call
func ParseInviteUsersToTeamResponse(rsp *http.Response) (*InviteUsersToTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteUsersToTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest TooLarge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseGetTeamMembersResponse parses an HTTP response from a GetTeamMembersWithResponse call
func ParseGetTeamMembersResponse(rsp *http.Response) (*GetTeamMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddTeamMemberResponse parses an HTTP response from a AddTeamMemberWithResponse call
func ParseAddTeamMemberResponse(rsp *http.Response) (*AddTeamMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTeamMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TeamMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddTeamMembersResponse parses an HTTP response from a AddTeamMembersWithResponse call
func ParseAddTeamMembersResponse(rsp *http.Response) (*AddTeamMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTeamMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []TeamMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTeamMembersByIdsResponse parses an HTTP response from a GetTeamMembersByIdsWithResponse call
func ParseGetTeamMembersByIdsResponse(rsp *http.Response) (*GetTeamMembersByIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamMembersByIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRemoveTeamMemberResponse parses an HTTP response from a RemoveTeamMemberWithResponse call
func ParseRemoveTeamMemberResponse(rsp *http.Response) (*RemoveTeamMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTeamMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTeamMemberResponse parses an HTTP response from a GetTeamMemberWithResponse call
func ParseGetTeamMemberResponse(rsp *http.Response) (*GetTeamMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateTeamMemberRolesResponse parses an HTTP response from a UpdateTeamMemberRolesWithResponse call
func ParseUpdateTeamMemberRolesResponse(rsp *http.Response) (*UpdateTeamMemberRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTeamMemberRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateTeamMemberSchemeRolesResponse parses an HTTP response from a UpdateTeamMemberSchemeRolesWithResponse call
func ParseUpdateTeamMemberSchemeRolesResponse(rsp *http.Response) (*UpdateTeamMemberSchemeRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTeamMemberSchemeRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTeamMembersMinusGroupMembersResponse parses an HTTP response from a TeamMembersMinusGroupMembersWithResponse call
func ParseTeamMembersMinusGroupMembersResponse(rsp *http.Response) (*TeamMembersMinusGroupMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamMembersMinusGroupMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePatchTeamResponse parses an HTTP response from a PatchTeamWithResponse call
func ParsePatchTeamResponse(rsp *http.Response) (*PatchTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSearchPostsResponse parses an HTTP response from a SearchPostsWithResponse call
func ParseSearchPostsResponse(rsp *http.Response) (*SearchPostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchPostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostListWithSearchMatches
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateTeamPrivacyResponse parses an HTTP response from a UpdateTeamPrivacyWithResponse call
func ParseUpdateTeamPrivacyResponse(rsp *http.Response) (*UpdateTeamPrivacyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTeamPrivacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRegenerateTeamInviteIdResponse parses an HTTP response from a RegenerateTeamInviteIdWithResponse call
func ParseRegenerateTeamInviteIdResponse(rsp *http.Response) (*RegenerateTeamInviteIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegenerateTeamInviteIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRestoreTeamResponse parses an HTTP response from a RestoreTeamWithResponse call
func ParseRestoreTeamResponse(rsp *http.Response) (*RestoreTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateTeamSchemeResponse parses an HTTP response from a UpdateTeamSchemeWithResponse call
func ParseUpdateTeamSchemeResponse(rsp *http.Response) (*UpdateTeamSchemeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTeamSchemeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetTeamStatsResponse parses an HTTP response from a GetTeamStatsWithResponse call
func ParseGetTeamStatsResponse(rsp *http.Response) (*GetTeamStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTermsOfServiceResponse parses an HTTP response from a GetTermsOfServiceWithResponse call
func ParseGetTermsOfServiceResponse(rsp *http.Response) (*GetTermsOfServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTermsOfServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TermsOfService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateTermsOfServiceResponse parses an HTTP response from a CreateTermsOfServiceWithResponse call
func ParseCreateTermsOfServiceResponse(rsp *http.Response) (*CreateTermsOfServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTermsOfServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TermsOfService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRequestTrialLicenseResponse parses an HTTP response from a RequestTrialLicenseWithResponse call
func ParseRequestTrialLicenseResponse(rsp *http.Response) (*RequestTrialLicenseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestTrialLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPrevTrialLicenseResponse parses an HTTP response from a GetPrevTrialLicenseWithResponse call
func ParseGetPrevTrialLicenseResponse(rsp *http.Response) (*GetPrevTrialLicenseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPrevTrialLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpgradeToEnterpriseResponse parses an HTTP response from a UpgradeToEnterpriseWithResponse call
func ParseUpgradeToEnterpriseResponse(rsp *http.Response) (*UpgradeToEnterpriseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpgradeToEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PushNotification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUpgradeToEnterpriseStatusResponse parses an HTTP response from a UpgradeToEnterpriseStatusWithResponse call
func ParseUpgradeToEnterpriseStatusResponse(rsp *http.Response) (*UpgradeToEnterpriseStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpgradeToEnterpriseStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Error Error happened during the upgrade
			Error *string `json:"error,omitempty"`

			// Percentage Current percentage of the upgrade
			Percentage *int `json:"percentage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateUploadResponse parses an HTTP response from a CreateUploadWithResponse call
func ParseCreateUploadResponse(rsp *http.Response) (*CreateUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UploadSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest TooLarge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetUploadResponse parses an HTTP response from a GetUploadWithResponse call
func ParseGetUploadResponse(rsp *http.Response) (*GetUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUploadDataResponse parses an HTTP response from a UploadDataWithResponse call
func ParseUploadDataResponse(rsp *http.Response) (*UploadDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FileInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest TooLarge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetPostsUsageResponse parses an HTTP response from a GetPostsUsageWithResponse call
func ParseGetPostsUsageResponse(rsp *http.Response) (*GetPostsUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostsUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostsUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStorageUsageResponse parses an HTTP response from a GetStorageUsageWithResponse call
func ParseGetStorageUsageResponse(rsp *http.Response) (*GetStorageUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStorageUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermanentDeleteAllUsersResponse parses an HTTP response from a PermanentDeleteAllUsersWithResponse call
func ParsePermanentDeleteAllUsersResponse(rsp *http.Response) (*PermanentDeleteAllUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermanentDeleteAllUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAutocompleteUsersResponse parses an HTTP response from a AutocompleteUsersWithResponse call
func ParseAutocompleteUsersResponse(rsp *http.Response) (*AutocompleteUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AutocompleteUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserAutocomplete
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseVerifyUserEmailResponse parses an HTTP response from a VerifyUserEmailWithResponse call
func ParseVerifyUserEmailResponse(rsp *http.Response) (*VerifyUserEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyUserEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSendVerificationEmailResponse parses an HTTP response from a SendVerificationEmailWithResponse call
func ParseSendVerificationEmailResponse(rsp *http.Response) (*SendVerificationEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendVerificationEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetUserByEmailResponse parses an HTTP response from a GetUserByEmailWithResponse call
func ParseGetUserByEmailResponse(rsp *http.Response) (*GetUserByEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserByEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUsersByGroupChannelIdsResponse parses an HTTP response from a GetUsersByGroupChannelIdsWithResponse call
func ParseGetUsersByGroupChannelIdsResponse(rsp *http.Response) (*GetUsersByGroupChannelIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersByGroupChannelIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			LessThanCHANNELID *[]User `json:"<CHANNEL_ID>,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUsersByIdsResponse parses an HTTP response from a GetUsersByIdsWithResponse call
func ParseGetUsersByIdsResponse(rsp *http.Response) (*GetUsersByIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersByIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUsersWithInvalidEmailsResponse parses an HTTP response from a GetUsersWithInvalidEmailsWithResponse call
func ParseGetUsersWithInvalidEmailsResponse(rsp *http.Response) (*GetUsersWithInvalidEmailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersWithInvalidEmailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetKnownUsersResponse parses an HTTP response from a GetKnownUsersWithResponse call
func ParseGetKnownUsersResponse(rsp *http.Response) (*GetKnownUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKnownUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KnownUsers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseLoginByCwsTokenResponse parses an HTTP response from a LoginByCwsTokenWithResponse call
func ParseLoginByCwsTokenResponse(rsp *http.Response) (*LoginByCwsTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginByCwsTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSwitchAccountTypeResponse parses an HTTP response from a SwitchAccountTypeWithResponse call
func ParseSwitchAccountTypeResponse(rsp *http.Response) (*SwitchAccountTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SwitchAccountTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// FollowLink The link for the user to follow to login or to complete the account switching when the current service is OAuth2/SAML
			FollowLink *string `json:"follow_link,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCheckUserMfaResponse parses an HTTP response from a CheckUserMfaWithResponse call
func ParseCheckUserMfaResponse(rsp *http.Response) (*CheckUserMfaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckUserMfaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// MfaRequired Value will `true` if MFA is active, `false` otherwise
			MfaRequired *bool `json:"mfa_required,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMigrateAuthToLdapResponse parses an HTTP response from a MigrateAuthToLdapWithResponse call
func ParseMigrateAuthToLdapResponse(rsp *http.Response) (*MigrateAuthToLdapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrateAuthToLdapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseMigrateAuthToSamlResponse parses an HTTP response from a MigrateAuthToSamlWithResponse call
func ParseMigrateAuthToSamlResponse(rsp *http.Response) (*MigrateAuthToSamlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrateAuthToSamlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseResetPasswordResponse parses an HTTP response from a ResetPasswordWithResponse call
func ParseResetPasswordResponse(rsp *http.Response) (*ResetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSendPasswordResetEmailResponse parses an HTTP response from a SendPasswordResetEmailWithResponse call
func ParseSendPasswordResetEmailResponse(rsp *http.Response) (*SendPasswordResetEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendPasswordResetEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSearchUsersResponse parses an HTTP response from a SearchUsersWithResponse call
func ParseSearchUsersResponse(rsp *http.Response) (*SearchUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAttachDeviceExtraPropsResponse parses an HTTP response from a AttachDeviceExtraPropsWithResponse call
func ParseAttachDeviceExtraPropsResponse(rsp *http.Response) (*AttachDeviceExtraPropsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachDeviceExtraPropsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRevokeSessionsFromAllUsersResponse parses an HTTP response from a RevokeSessionsFromAllUsersWithResponse call
func ParseRevokeSessionsFromAllUsersResponse(rsp *http.Response) (*RevokeSessionsFromAllUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeSessionsFromAllUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTotalUsersStatsResponse parses an HTTP response from a GetTotalUsersStatsWithResponse call
func ParseGetTotalUsersStatsResponse(rsp *http.Response) (*GetTotalUsersStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTotalUsersStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTotalUsersStatsFilteredResponse parses an HTTP response from a GetTotalUsersStatsFilteredWithResponse call
func ParseGetTotalUsersStatsFilteredResponse(rsp *http.Response) (*GetTotalUsersStatsFilteredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTotalUsersStatsFilteredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUsersStatusesByIdsResponse parses an HTTP response from a GetUsersStatusesByIdsWithResponse call
func ParseGetUsersStatusesByIdsResponse(rsp *http.Response) (*GetUsersStatusesByIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersStatusesByIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetUserAccessTokensResponse parses an HTTP response from a GetUserAccessTokensWithResponse call
func ParseGetUserAccessTokensResponse(rsp *http.Response) (*GetUserAccessTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserAccessTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserAccessTokenSanitized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDisableUserAccessTokenResponse parses an HTTP response from a DisableUserAccessTokenWithResponse call
func ParseDisableUserAccessTokenResponse(rsp *http.Response) (*DisableUserAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableUserAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEnableUserAccessTokenResponse parses an HTTP response from a EnableUserAccessTokenWithResponse call
func ParseEnableUserAccessTokenResponse(rsp *http.Response) (*EnableUserAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableUserAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRevokeUserAccessTokenResponse parses an HTTP response from a RevokeUserAccessTokenWithResponse call
func ParseRevokeUserAccessTokenResponse(rsp *http.Response) (*RevokeUserAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeUserAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSearchUserAccessTokensResponse parses an HTTP response from a SearchUserAccessTokensWithResponse call
func ParseSearchUserAccessTokensResponse(rsp *http.Response) (*SearchUserAccessTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUserAccessTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserAccessTokenSanitized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserAccessTokenResponse parses an HTTP response from a GetUserAccessTokenWithResponse call
func ParseGetUserAccessTokenResponse(rsp *http.Response) (*GetUserAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserAccessTokenSanitized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUserByUsernameResponse parses an HTTP response from a GetUserByUsernameWithResponse call
func ParseGetUserByUsernameResponse(rsp *http.Response) (*GetUserByUsernameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserByUsernameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUsersByUsernamesResponse parses an HTTP response from a GetUsersByUsernamesWithResponse call
func ParseGetUsersByUsernamesResponse(rsp *http.Response) (*GetUsersByUsernamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersByUsernamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateUserActiveResponse parses an HTTP response from a UpdateUserActiveWithResponse call
func ParseUpdateUserActiveResponse(rsp *http.Response) (*UpdateUserActiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserActiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetUserAuditsResponse parses an HTTP response from a GetUserAuditsWithResponse call
func ParseGetUserAuditsResponse(rsp *http.Response) (*GetUserAuditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserAuditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Audit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateUserAuthResponse parses an HTTP response from a UpdateUserAuthWithResponse call
func ParseUpdateUserAuthResponse(rsp *http.Response) (*UpdateUserAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserAuthData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetChannelMembersWithTeamDataForUserResponse parses an HTTP response from a GetChannelMembersWithTeamDataForUserWithResponse call
func ParseGetChannelMembersWithTeamDataForUserResponse(rsp *http.Response) (*GetChannelMembersWithTeamDataForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelMembersWithTeamDataForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ChannelMemberWithTeamData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetChannelsForUserResponse parses an HTTP response from a GetChannelsForUserWithResponse call
func ParseGetChannelsForUserResponse(rsp *http.Response) (*GetChannelsForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPostsAroundLastUnreadResponse parses an HTTP response from a GetPostsAroundLastUnreadWithResponse call
func ParseGetPostsAroundLastUnreadResponse(rsp *http.Response) (*GetPostsAroundLastUnreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostsAroundLastUnreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetChannelUnreadResponse parses an HTTP response from a GetChannelUnreadWithResponse call
func ParseGetChannelUnreadResponse(rsp *http.Response) (*GetChannelUnreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelUnreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelUnread
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseConvertUserToBotResponse parses an HTTP response from a ConvertUserToBotWithResponse call
func ParseConvertUserToBotResponse(rsp *http.Response) (*ConvertUserToBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConvertUserToBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetChannelPoliciesForUserResponse parses an HTTP response from a GetChannelPoliciesForUserWithResponse call
func ParseGetChannelPoliciesForUserResponse(rsp *http.Response) (*GetChannelPoliciesForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelPoliciesForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RetentionPolicyForChannelList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetTeamPoliciesForUserResponse parses an HTTP response from a GetTeamPoliciesForUserWithResponse call
func ParseGetTeamPoliciesForUserResponse(rsp *http.Response) (*GetTeamPoliciesForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamPoliciesForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RetentionPolicyForTeamList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDemoteUserToGuestResponse parses an HTTP response from a DemoteUserToGuestWithResponse call
func ParseDemoteUserToGuestResponse(rsp *http.Response) (*DemoteUserToGuestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DemoteUserToGuestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseVerifyUserEmailWithoutTokenResponse parses an HTTP response from a VerifyUserEmailWithoutTokenWithResponse call
func ParseVerifyUserEmailWithoutTokenResponse(rsp *http.Response) (*VerifyUserEmailWithoutTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyUserEmailWithoutTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetGroupsByUserIdResponse parses an HTTP response from a GetGroupsByUserIdWithResponse call
func ParseGetGroupsByUserIdResponse(rsp *http.Response) (*GetGroupsByUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsByUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseSetDefaultProfileImageResponse parses an HTTP response from a SetDefaultProfileImageWithResponse call
func ParseSetDefaultProfileImageResponse(rsp *http.Response) (*SetDefaultProfileImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDefaultProfileImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetProfileImageResponse parses an HTTP response from a GetProfileImageWithResponse call
func ParseGetProfileImageResponse(rsp *http.Response) (*GetProfileImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProfileImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseSetProfileImageResponse parses an HTTP response from a SetProfileImageWithResponse call
func ParseSetProfileImageResponse(rsp *http.Response) (*SetProfileImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetProfileImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetDefaultProfileImageResponse parses an HTTP response from a GetDefaultProfileImageWithResponse call
func ParseGetDefaultProfileImageResponse(rsp *http.Response) (*GetDefaultProfileImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultProfileImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUpdateUserMfaResponse parses an HTTP response from a UpdateUserMfaWithResponse call
func ParseUpdateUserMfaResponse(rsp *http.Response) (*UpdateUserMfaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserMfaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGenerateMfaSecretResponse parses an HTTP response from a GenerateMfaSecretWithResponse call
func ParseGenerateMfaSecretResponse(rsp *http.Response) (*GenerateMfaSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateMfaSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// QrCode A base64 encoded QR code image
			QrCode *string `json:"qr_code,omitempty"`

			// Secret The MFA secret as a string
			Secret *string `json:"secret,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetAuthorizedOAuthAppsForUserResponse parses an HTTP response from a GetAuthorizedOAuthAppsForUserWithResponse call
func ParseGetAuthorizedOAuthAppsForUserResponse(rsp *http.Response) (*GetAuthorizedOAuthAppsForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorizedOAuthAppsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OAuthApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUpdateUserPasswordResponse parses an HTTP response from a UpdateUserPasswordWithResponse call
func ParseUpdateUserPasswordResponse(rsp *http.Response) (*UpdateUserPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePatchUserResponse parses an HTTP response from a PatchUserWithResponse call
func ParsePatchUserResponse(rsp *http.Response) (*PatchUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetFlaggedPostsForUserResponse parses an HTTP response from a GetFlaggedPostsForUserWithResponse call
func ParseGetFlaggedPostsForUserResponse(rsp *http.Response) (*GetFlaggedPostsForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlaggedPostsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PostList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteAcknowledgementForPostResponse parses an HTTP response from a DeleteAcknowledgementForPostWithResponse call
func ParseDeleteAcknowledgementForPostResponse(rsp *http.Response) (*DeleteAcknowledgementForPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAcknowledgementForPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSaveAcknowledgementForPostResponse parses an HTTP response from a SaveAcknowledgementForPostWithResponse call
func ParseSaveAcknowledgementForPostResponse(rsp *http.Response) (*SaveAcknowledgementForPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveAcknowledgementForPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostAcknowledgement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteReactionResponse parses an HTTP response from a DeleteReactionWithResponse call
func ParseDeleteReactionResponse(rsp *http.Response) (*DeleteReactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSetPostReminderResponse parses an HTTP response from a SetPostReminderWithResponse call
func ParseSetPostReminderResponse(rsp *http.Response) (*SetPostReminderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPostReminderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetPostUnreadResponse parses an HTTP response from a SetPostUnreadWithResponse call
func ParseSetPostUnreadResponse(rsp *http.Response) (*SetPostUnreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPostUnreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelUnreadAt
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPreferencesResponse parses an HTTP response from a GetPreferencesWithResponse call
func ParseGetPreferencesResponse(rsp *http.Response) (*GetPreferencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPreferencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Preference
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdatePreferencesResponse parses an HTTP response from a UpdatePreferencesWithResponse call
func ParseUpdatePreferencesResponse(rsp *http.Response) (*UpdatePreferencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePreferencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeletePreferencesResponse parses an HTTP response from a DeletePreferencesWithResponse call
func ParseDeletePreferencesResponse(rsp *http.Response) (*DeletePreferencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePreferencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPreferencesByCategoryResponse parses an HTTP response from a GetPreferencesByCategoryWithResponse call
func ParseGetPreferencesByCategoryResponse(rsp *http.Response) (*GetPreferencesByCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPreferencesByCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Preference
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPreferencesByCategoryByNameResponse parses an HTTP response from a GetPreferencesByCategoryByNameWithResponse call
func ParseGetPreferencesByCategoryByNameResponse(rsp *http.Response) (*GetPreferencesByCategoryByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPreferencesByCategoryByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preference
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePromoteGuestToUserResponse parses an HTTP response from a PromoteGuestToUserWithResponse call
func ParsePromoteGuestToUserResponse(rsp *http.Response) (*PromoteGuestToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PromoteGuestToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUpdateUserRolesResponse parses an HTTP response from a UpdateUserRolesWithResponse call
func ParseUpdateUserRolesResponse(rsp *http.Response) (*UpdateUserRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetSessionsResponse parses an HTTP response from a GetSessionsWithResponse call
func ParseGetSessionsResponse(rsp *http.Response) (*GetSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Session
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRevokeSessionResponse parses an HTTP response from a RevokeSessionWithResponse call
func ParseRevokeSessionResponse(rsp *http.Response) (*RevokeSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRevokeAllSessionsResponse parses an HTTP response from a RevokeAllSessionsWithResponse call
func ParseRevokeAllSessionsResponse(rsp *http.Response) (*RevokeAllSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeAllSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetUserStatusResponse parses an HTTP response from a GetUserStatusWithResponse call
func ParseGetUserStatusResponse(rsp *http.Response) (*GetUserStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateUserStatusResponse parses an HTTP response from a UpdateUserStatusWithResponse call
func ParseUpdateUserStatusResponse(rsp *http.Response) (*UpdateUserStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUnsetUserCustomStatusResponse parses an HTTP response from a UnsetUserCustomStatusWithResponse call
func ParseUnsetUserCustomStatusResponse(rsp *http.Response) (*UnsetUserCustomStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnsetUserCustomStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateUserCustomStatusResponse parses an HTTP response from a UpdateUserCustomStatusWithResponse call
func ParseUpdateUserCustomStatusResponse(rsp *http.Response) (*UpdateUserCustomStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserCustomStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRemoveRecentCustomStatusResponse parses an HTTP response from a RemoveRecentCustomStatusWithResponse call
func ParseRemoveRecentCustomStatusResponse(rsp *http.Response) (*RemoveRecentCustomStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveRecentCustomStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePostUserRecentCustomStatusDeleteResponse parses an HTTP response from a PostUserRecentCustomStatusDeleteWithResponse call
func ParsePostUserRecentCustomStatusDeleteResponse(rsp *http.Response) (*PostUserRecentCustomStatusDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUserRecentCustomStatusDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetTeamsForUserResponse parses an HTTP response from a GetTeamsForUserWithResponse call
func ParseGetTeamsForUserResponse(rsp *http.Response) (*GetTeamsForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetTeamMembersForUserResponse parses an HTTP response from a GetTeamMembersForUserWithResponse call
func ParseGetTeamMembersForUserResponse(rsp *http.Response) (*GetTeamMembersForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamMembersForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTeamsUnreadForUserResponse parses an HTTP response from a GetTeamsUnreadForUserWithResponse call
func ParseGetTeamsUnreadForUserResponse(rsp *http.Response) (*GetTeamsUnreadForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsUnreadForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamUnread
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetChannelsForTeamForUserResponse parses an HTTP response from a GetChannelsForTeamForUserWithResponse call
func ParseGetChannelsForTeamForUserResponse(rsp *http.Response) (*GetChannelsForTeamForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelsForTeamForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Channel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSidebarCategoriesForTeamForUserResponse parses an HTTP response from a GetSidebarCategoriesForTeamForUserWithResponse call
func ParseGetSidebarCategoriesForTeamForUserResponse(rsp *http.Response) (*GetSidebarCategoriesForTeamForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSidebarCategoriesForTeamForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrderedSidebarCategories
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateSidebarCategoryForTeamForUserResponse parses an HTTP response from a CreateSidebarCategoryForTeamForUserWithResponse call
func ParseCreateSidebarCategoryForTeamForUserResponse(rsp *http.Response) (*CreateSidebarCategoryForTeamForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSidebarCategoryForTeamForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SidebarCategory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateSidebarCategoriesForTeamForUserResponse parses an HTTP response from a UpdateSidebarCategoriesForTeamForUserWithResponse call
func ParseUpdateSidebarCategoriesForTeamForUserResponse(rsp *http.Response) (*UpdateSidebarCategoriesForTeamForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSidebarCategoriesForTeamForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SidebarCategory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSidebarCategoryOrderForTeamForUserResponse parses an HTTP response from a GetSidebarCategoryOrderForTeamForUserWithResponse call
func ParseGetSidebarCategoryOrderForTeamForUserResponse(rsp *http.Response) (*GetSidebarCategoryOrderForTeamForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSidebarCategoryOrderForTeamForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateSidebarCategoryOrderForTeamForUserResponse parses an HTTP response from a UpdateSidebarCategoryOrderForTeamForUserWithResponse call
func ParseUpdateSidebarCategoryOrderForTeamForUserResponse(rsp *http.Response) (*UpdateSidebarCategoryOrderForTeamForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSidebarCategoryOrderForTeamForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRemoveSidebarCategoryForTeamForUserResponse parses an HTTP response from a RemoveSidebarCategoryForTeamForUserWithResponse call
func ParseRemoveSidebarCategoryForTeamForUserResponse(rsp *http.Response) (*RemoveSidebarCategoryForTeamForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSidebarCategoryForTeamForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SidebarCategory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSidebarCategoryForTeamForUserResponse parses an HTTP response from a GetSidebarCategoryForTeamForUserWithResponse call
func ParseGetSidebarCategoryForTeamForUserResponse(rsp *http.Response) (*GetSidebarCategoryForTeamForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSidebarCategoryForTeamForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SidebarCategory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateSidebarCategoryForTeamForUserResponse parses an HTTP response from a UpdateSidebarCategoryForTeamForUserWithResponse call
func ParseUpdateSidebarCategoryForTeamForUserResponse(rsp *http.Response) (*UpdateSidebarCategoryForTeamForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSidebarCategoryForTeamForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SidebarCategory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetChannelMembersForUserResponse parses an HTTP response from a GetChannelMembersForUserWithResponse call
func ParseGetChannelMembersForUserResponse(rsp *http.Response) (*GetChannelMembersForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelMembersForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ChannelMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetUserThreadsResponse parses an HTTP response from a GetUserThreadsWithResponse call
func ParseGetUserThreadsResponse(rsp *http.Response) (*GetUserThreadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserThreadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserThreads
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetThreadMentionCountsByChannelResponse parses an HTTP response from a GetThreadMentionCountsByChannelWithResponse call
func ParseGetThreadMentionCountsByChannelResponse(rsp *http.Response) (*GetThreadMentionCountsByChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThreadMentionCountsByChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateThreadsReadForUserResponse parses an HTTP response from a UpdateThreadsReadForUserWithResponse call
func ParseUpdateThreadsReadForUserResponse(rsp *http.Response) (*UpdateThreadsReadForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateThreadsReadForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUserThreadResponse parses an HTTP response from a GetUserThreadWithResponse call
func ParseGetUserThreadResponse(rsp *http.Response) (*GetUserThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStopFollowingThreadResponse parses an HTTP response from a StopFollowingThreadWithResponse call
func ParseStopFollowingThreadResponse(rsp *http.Response) (*StopFollowingThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopFollowingThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStartFollowingThreadResponse parses an HTTP response from a StartFollowingThreadWithResponse call
func ParseStartFollowingThreadResponse(rsp *http.Response) (*StartFollowingThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartFollowingThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateThreadReadForUserResponse parses an HTTP response from a UpdateThreadReadForUserWithResponse call
func ParseUpdateThreadReadForUserResponse(rsp *http.Response) (*UpdateThreadReadForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateThreadReadForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetThreadUnreadByPostIdResponse parses an HTTP response from a SetThreadUnreadByPostIdWithResponse call
func ParseSetThreadUnreadByPostIdResponse(rsp *http.Response) (*SetThreadUnreadByPostIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetThreadUnreadByPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTeamUnreadResponse parses an HTTP response from a GetTeamUnreadWithResponse call
func ParseGetTeamUnreadResponse(rsp *http.Response) (*GetTeamUnreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamUnreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamUnread
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUserTermsOfServiceResponse parses an HTTP response from a GetUserTermsOfServiceWithResponse call
func ParseGetUserTermsOfServiceResponse(rsp *http.Response) (*GetUserTermsOfServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserTermsOfServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserTermsOfService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AppError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRegisterTermsOfServiceActionResponse parses an HTTP response from a RegisterTermsOfServiceActionWithResponse call
func ParseRegisterTermsOfServiceActionResponse(rsp *http.Response) (*RegisterTermsOfServiceActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterTermsOfServiceActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusOK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetUserAccessTokensForUserResponse parses an HTTP response from a GetUserAccessTokensForUserWithResponse call
func ParseGetUserAccessTokensForUserResponse(rsp *http.Response) (*GetUserAccessTokensForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserAccessTokensForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserAccessTokenSanitized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateUserAccessTokenResponse parses an HTTP response from a CreateUserAccessTokenWithResponse call
func ParseCreateUserAccessTokenResponse(rsp *http.Response) (*CreateUserAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UserAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePublishUserTypingResponse parses an HTTP response from a PublishUserTypingWithResponse call
func ParsePublishUserTypingResponse(rsp *http.Response) (*PublishUserTypingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublishUserTypingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetUploadsForUserResponse parses an HTTP response from a GetUploadsForUserWithResponse call
func ParseGetUploadsForUserResponse(rsp *http.Response) (*GetUploadsForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUploadsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UploadSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetFilePublicResponse parses an HTTP response from a GetFilePublicWithResponse call
func ParseGetFilePublicResponse(rsp *http.Response) (*GetFilePublicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilePublicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AppError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetPlaybooksResponse parses an HTTP response from a GetPlaybooksWithResponse call
func ParseGetPlaybooksResponse(rsp *http.Response) (*GetPlaybooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlaybookList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePlaybookResponse parses an HTTP response from a CreatePlaybookWithResponse call
func ParseCreatePlaybookResponse(rsp *http.Response) (*CreatePlaybookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlaybookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePlaybookResponse parses an HTTP response from a DeletePlaybookWithResponse call
func ParseDeletePlaybookResponse(rsp *http.Response) (*DeletePlaybookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePlaybookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPlaybookResponse parses an HTTP response from a GetPlaybookWithResponse call
func ParseGetPlaybookResponse(rsp *http.Response) (*GetPlaybookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Playbook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdatePlaybookResponse parses an HTTP response from a UpdatePlaybookWithResponse call
func ParseUpdatePlaybookResponse(rsp *http.Response) (*UpdatePlaybookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePlaybookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAutoFollowsResponse parses an HTTP response from a GetAutoFollowsWithResponse call
func ParseGetAutoFollowsResponse(rsp *http.Response) (*GetAutoFollowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutoFollowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlaybookAutofollows
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPlaybookRunsResponse parses an HTTP response from a ListPlaybookRunsWithResponse call
func ParseListPlaybookRunsResponse(rsp *http.Response) (*ListPlaybookRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlaybookRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlaybookRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePlaybookRunFromPostResponse parses an HTTP response from a CreatePlaybookRunFromPostWithResponse call
func ParseCreatePlaybookRunFromPostResponse(rsp *http.Response) (*CreatePlaybookRunFromPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlaybookRunFromPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PlaybookRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPlaybookRunByChannelIdResponse parses an HTTP response from a GetPlaybookRunByChannelIdWithResponse call
func ParseGetPlaybookRunByChannelIdResponse(rsp *http.Response) (*GetPlaybookRunByChannelIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybookRunByChannelIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlaybookRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetChannelsResponse parses an HTTP response from a GetChannelsWithResponse call
func ParseGetChannelsResponse(rsp *http.Response) (*GetChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetChecklistAutocompleteResponse parses an HTTP response from a GetChecklistAutocompleteWithResponse call
func ParseGetChecklistAutocompleteResponse(rsp *http.Response) (*GetChecklistAutocompleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChecklistAutocompleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Helptext Always the value "Check/uncheck this item".
			Helptext string `json:"helptext"`

			// Hint The title of the corresponding item.
			Hint string `json:"hint"`

			// Item A string containing a pair of integers separated by a space. The first integer is the index of the checklist; the second is the index of the item within the checklist.
			Item string `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePlaybookRunFromDialogResponse parses an HTTP response from a CreatePlaybookRunFromDialogWithResponse call
func ParseCreatePlaybookRunFromDialogResponse(rsp *http.Response) (*CreatePlaybookRunFromDialogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlaybookRunFromDialogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PlaybookRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOwnersResponse parses an HTTP response from a GetOwnersWithResponse call
func ParseGetOwnersResponse(rsp *http.Response) (*GetOwnersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOwnersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OwnerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPlaybookRunResponse parses an HTTP response from a GetPlaybookRunWithResponse call
func ParseGetPlaybookRunResponse(rsp *http.Response) (*GetPlaybookRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybookRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlaybookRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdatePlaybookRunResponse parses an HTTP response from a UpdatePlaybookRunWithResponse call
func ParseUpdatePlaybookRunResponse(rsp *http.Response) (*UpdatePlaybookRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePlaybookRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddChecklistItemResponse parses an HTTP response from a AddChecklistItemWithResponse call
func ParseAddChecklistItemResponse(rsp *http.Response) (*AddChecklistItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddChecklistItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseItemDeleteResponse parses an HTTP response from a ItemDeleteWithResponse call
func ParseItemDeleteResponse(rsp *http.Response) (*ItemDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseItemRenameResponse parses an HTTP response from a ItemRenameWithResponse call
func ParseItemRenameResponse(rsp *http.Response) (*ItemRenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemRenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseItemSetAssigneeResponse parses an HTTP response from a ItemSetAssigneeWithResponse call
func ParseItemSetAssigneeResponse(rsp *http.Response) (*ItemSetAssigneeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemSetAssigneeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseItemRunResponse parses an HTTP response from a ItemRunWithResponse call
func ParseItemRunResponse(rsp *http.Response) (*ItemRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TriggerIdReturn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseItemSetStateResponse parses an HTTP response from a ItemSetStateWithResponse call
func ParseItemSetStateResponse(rsp *http.Response) (*ItemSetStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemSetStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReoderChecklistItemResponse parses an HTTP response from a ReoderChecklistItemWithResponse call
func ParseReoderChecklistItemResponse(rsp *http.Response) (*ReoderChecklistItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReoderChecklistItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEndPlaybookRunDialogResponse parses an HTTP response from a EndPlaybookRunDialogWithResponse call
func ParseEndPlaybookRunDialogResponse(rsp *http.Response) (*EndPlaybookRunDialogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndPlaybookRunDialogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEndPlaybookRunResponse parses an HTTP response from a EndPlaybookRunWithResponse call
func ParseEndPlaybookRunResponse(rsp *http.Response) (*EndPlaybookRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndPlaybookRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFinishResponse parses an HTTP response from a FinishWithResponse call
func ParseFinishResponse(rsp *http.Response) (*FinishResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FinishResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPlaybookRunMetadataResponse parses an HTTP response from a GetPlaybookRunMetadataWithResponse call
func ParseGetPlaybookRunMetadataResponse(rsp *http.Response) (*GetPlaybookRunMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybookRunMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlaybookRunMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseNextStageDialogResponse parses an HTTP response from a NextStageDialogWithResponse call
func ParseNextStageDialogResponse(rsp *http.Response) (*NextStageDialogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NextStageDialogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseChangeOwnerResponse parses an HTTP response from a ChangeOwnerWithResponse call
func ParseChangeOwnerResponse(rsp *http.Response) (*ChangeOwnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangeOwnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRestartPlaybookRunResponse parses an HTTP response from a RestartPlaybookRunWithResponse call
func ParseRestartPlaybookRunResponse(rsp *http.Response) (*RestartPlaybookRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestartPlaybookRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStatusResponse parses an HTTP response from a StatusWithResponse call
func ParseStatusResponse(rsp *http.Response) (*StatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveTimelineEventResponse parses an HTTP response from a RemoveTimelineEventWithResponse call
func ParseRemoveTimelineEventResponse(rsp *http.Response) (*RemoveTimelineEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTimelineEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
