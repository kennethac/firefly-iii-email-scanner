// Package firefly provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package firefly

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Firefly_iii_authScopes  = "firefly_iii_auth.Scopes"
	Local_bearer_authScopes = "local_bearer_auth.Scopes"
)

// Defines values for AccountRoleProperty.
const (
	AccountRolePropertyCashWalletAsset AccountRoleProperty = "cashWalletAsset"
	AccountRolePropertyCcAsset         AccountRoleProperty = "ccAsset"
	AccountRolePropertyDefaultAsset    AccountRoleProperty = "defaultAsset"
	AccountRolePropertyLessThannil     AccountRoleProperty = "<nil>"
	AccountRolePropertySavingAsset     AccountRoleProperty = "savingAsset"
	AccountRolePropertySharedAsset     AccountRoleProperty = "sharedAsset"
)

// Defines values for AccountSearchFieldFilter.
const (
	AccountSearchFieldFilterAll    AccountSearchFieldFilter = "all"
	AccountSearchFieldFilterIban   AccountSearchFieldFilter = "iban"
	AccountSearchFieldFilterId     AccountSearchFieldFilter = "id"
	AccountSearchFieldFilterName   AccountSearchFieldFilter = "name"
	AccountSearchFieldFilterNumber AccountSearchFieldFilter = "number"
)

// Defines values for AccountTypeFilter.
const (
	AccountTypeFilterAll                   AccountTypeFilter = "all"
	AccountTypeFilterAsset                 AccountTypeFilter = "asset"
	AccountTypeFilterAssetAccount          AccountTypeFilter = "Asset account"
	AccountTypeFilterBeneficiaryAccount    AccountTypeFilter = "Beneficiary account"
	AccountTypeFilterCash                  AccountTypeFilter = "cash"
	AccountTypeFilterCashAccount           AccountTypeFilter = "Cash account"
	AccountTypeFilterDebt                  AccountTypeFilter = "Debt"
	AccountTypeFilterDefaultAccount        AccountTypeFilter = "Default account"
	AccountTypeFilterExpense               AccountTypeFilter = "expense"
	AccountTypeFilterExpenseAccount        AccountTypeFilter = "Expense account"
	AccountTypeFilterHidden                AccountTypeFilter = "hidden"
	AccountTypeFilterImportAccount         AccountTypeFilter = "Import account"
	AccountTypeFilterInitialBalanceAccount AccountTypeFilter = "Initial balance account"
	AccountTypeFilterLiabilities           AccountTypeFilter = "liabilities"
	AccountTypeFilterLiability             AccountTypeFilter = "liability"
	AccountTypeFilterLoan                  AccountTypeFilter = "Loan"
	AccountTypeFilterMortgage              AccountTypeFilter = "Mortgage"
	AccountTypeFilterReconciliationAccount AccountTypeFilter = "Reconciliation account"
	AccountTypeFilterRevenue               AccountTypeFilter = "revenue"
	AccountTypeFilterRevenueAccount        AccountTypeFilter = "Revenue account"
	AccountTypeFilterSpecial               AccountTypeFilter = "special"
)

// Defines values for AccountTypeProperty.
const (
	AccountTypePropertyAssetAccount          AccountTypeProperty = "Asset account"
	AccountTypePropertyBeneficiaryAccount    AccountTypeProperty = "Beneficiary account"
	AccountTypePropertyCashAccount           AccountTypeProperty = "Cash account"
	AccountTypePropertyDebt                  AccountTypeProperty = "Debt"
	AccountTypePropertyDefaultAccount        AccountTypeProperty = "Default account"
	AccountTypePropertyExpenseAccount        AccountTypeProperty = "Expense account"
	AccountTypePropertyImportAccount         AccountTypeProperty = "Import account"
	AccountTypePropertyInitialBalanceAccount AccountTypeProperty = "Initial balance account"
	AccountTypePropertyLoan                  AccountTypeProperty = "Loan"
	AccountTypePropertyMortgage              AccountTypeProperty = "Mortgage"
	AccountTypePropertyReconciliationAccount AccountTypeProperty = "Reconciliation account"
	AccountTypePropertyRevenueAccount        AccountTypeProperty = "Revenue account"
)

// Defines values for AttachableType.
const (
	AttachableTypeAccount            AttachableType = "Account"
	AttachableTypeBill               AttachableType = "Bill"
	AttachableTypeBudget             AttachableType = "Budget"
	AttachableTypePiggyBank          AttachableType = "PiggyBank"
	AttachableTypeTag                AttachableType = "Tag"
	AttachableTypeTransactionJournal AttachableType = "TransactionJournal"
)

// Defines values for AutoBudgetPeriod.
const (
	AutoBudgetPeriodDaily       AutoBudgetPeriod = "daily"
	AutoBudgetPeriodHalfYear    AutoBudgetPeriod = "half-year"
	AutoBudgetPeriodLessThannil AutoBudgetPeriod = "<nil>"
	AutoBudgetPeriodMonthly     AutoBudgetPeriod = "monthly"
	AutoBudgetPeriodQuarterly   AutoBudgetPeriod = "quarterly"
	AutoBudgetPeriodWeekly      AutoBudgetPeriod = "weekly"
	AutoBudgetPeriodYearly      AutoBudgetPeriod = "yearly"
)

// Defines values for AutoBudgetType.
const (
	AutoBudgetTypeLessThannil AutoBudgetType = "<nil>"
	AutoBudgetTypeNone        AutoBudgetType = "none"
	AutoBudgetTypeReset       AutoBudgetType = "reset"
	AutoBudgetTypeRollover    AutoBudgetType = "rollover"
)

// Defines values for BillRepeatFrequency.
const (
	BillRepeatFrequencyHalfYear  BillRepeatFrequency = "half-year"
	BillRepeatFrequencyMonthly   BillRepeatFrequency = "monthly"
	BillRepeatFrequencyQuarterly BillRepeatFrequency = "quarterly"
	BillRepeatFrequencyWeekly    BillRepeatFrequency = "weekly"
	BillRepeatFrequencyYearly    BillRepeatFrequency = "yearly"
)

// Defines values for ConfigValueFilter.
const (
	ConfigValueFilterAppTimezone                        ConfigValueFilter = "app.timezone"
	ConfigValueFilterConfigurationIsDemoSite            ConfigValueFilter = "configuration.is_demo_site"
	ConfigValueFilterConfigurationLastUpdateCheck       ConfigValueFilter = "configuration.last_update_check"
	ConfigValueFilterConfigurationPermissionUpdateCheck ConfigValueFilter = "configuration.permission_update_check"
	ConfigValueFilterConfigurationSingleUserMode        ConfigValueFilter = "configuration.single_user_mode"
	ConfigValueFilterFireflyAccountRoles                ConfigValueFilter = "firefly.accountRoles"
	ConfigValueFilterFireflyAccountToTransaction        ConfigValueFilter = "firefly.account_to_transaction"
	ConfigValueFilterFireflyAllowedOpposingTypes        ConfigValueFilter = "firefly.allowed_opposing_types"
	ConfigValueFilterFireflyBillPeriods                 ConfigValueFilter = "firefly.bill_periods"
	ConfigValueFilterFireflyCreditCardTypes             ConfigValueFilter = "firefly.credit_card_types"
	ConfigValueFilterFireflyDefaultLocation             ConfigValueFilter = "firefly.default_location"
	ConfigValueFilterFireflyEnableExternalMap           ConfigValueFilter = "firefly.enable_external_map"
	ConfigValueFilterFireflyExpectedSourceTypes         ConfigValueFilter = "firefly.expected_source_types"
	ConfigValueFilterFireflyInterestPeriods             ConfigValueFilter = "firefly.interest_periods"
	ConfigValueFilterFireflyLanguages                   ConfigValueFilter = "firefly.languages"
	ConfigValueFilterFireflyValidLiabilities            ConfigValueFilter = "firefly.valid_liabilities"
	ConfigValueFilterFireflyValidViewRanges             ConfigValueFilter = "firefly.valid_view_ranges"
	ConfigValueFilterFireflyVersion                     ConfigValueFilter = "firefly.version"
)

// Defines values for ConfigValueUpdateFilter.
const (
	ConfigValueUpdateFilterConfigurationIsDemoSite            ConfigValueUpdateFilter = "configuration.is_demo_site"
	ConfigValueUpdateFilterConfigurationLastUpdateCheck       ConfigValueUpdateFilter = "configuration.last_update_check"
	ConfigValueUpdateFilterConfigurationPermissionUpdateCheck ConfigValueUpdateFilter = "configuration.permission_update_check"
	ConfigValueUpdateFilterConfigurationSingleUserMode        ConfigValueUpdateFilter = "configuration.single_user_mode"
)

// Defines values for CreditCardTypeProperty.
const (
	CreditCardTypePropertyLessThannil CreditCardTypeProperty = "<nil>"
	CreditCardTypePropertyMonthlyFull CreditCardTypeProperty = "monthlyFull"
)

// Defines values for CurrencyUpdateDefault.
const (
	True CurrencyUpdateDefault = true
)

// Defines values for DataDestroyObject.
const (
	DataDestroyObjectAccounts             DataDestroyObject = "accounts"
	DataDestroyObjectAssetAccounts        DataDestroyObject = "asset_accounts"
	DataDestroyObjectBills                DataDestroyObject = "bills"
	DataDestroyObjectBudgets              DataDestroyObject = "budgets"
	DataDestroyObjectCategories           DataDestroyObject = "categories"
	DataDestroyObjectDeposits             DataDestroyObject = "deposits"
	DataDestroyObjectExpenseAccounts      DataDestroyObject = "expense_accounts"
	DataDestroyObjectLiabilities          DataDestroyObject = "liabilities"
	DataDestroyObjectNotAssetsLiabilities DataDestroyObject = "not_assets_liabilities"
	DataDestroyObjectObjectGroups         DataDestroyObject = "object_groups"
	DataDestroyObjectPiggyBanks           DataDestroyObject = "piggy_banks"
	DataDestroyObjectRecurring            DataDestroyObject = "recurring"
	DataDestroyObjectRevenueAccounts      DataDestroyObject = "revenue_accounts"
	DataDestroyObjectRules                DataDestroyObject = "rules"
	DataDestroyObjectTags                 DataDestroyObject = "tags"
	DataDestroyObjectTransactions         DataDestroyObject = "transactions"
	DataDestroyObjectTransfers            DataDestroyObject = "transfers"
	DataDestroyObjectWithdrawals          DataDestroyObject = "withdrawals"
)

// Defines values for ExportFileFilter.
const (
	Csv ExportFileFilter = "csv"
)

// Defines values for InterestPeriodProperty.
const (
	InterestPeriodPropertyHalfYear    InterestPeriodProperty = "half-year"
	InterestPeriodPropertyLessThannil InterestPeriodProperty = "<nil>"
	InterestPeriodPropertyMonthly     InterestPeriodProperty = "monthly"
	InterestPeriodPropertyQuarterly   InterestPeriodProperty = "quarterly"
	InterestPeriodPropertyWeekly      InterestPeriodProperty = "weekly"
	InterestPeriodPropertyYearly      InterestPeriodProperty = "yearly"
)

// Defines values for LiabilityDirectionProperty.
const (
	LiabilityDirectionPropertyCredit      LiabilityDirectionProperty = "credit"
	LiabilityDirectionPropertyDebit       LiabilityDirectionProperty = "debit"
	LiabilityDirectionPropertyLessThannil LiabilityDirectionProperty = "<nil>"
)

// Defines values for LiabilityTypeProperty.
const (
	LiabilityTypePropertyDebt        LiabilityTypeProperty = "debt"
	LiabilityTypePropertyLessThannil LiabilityTypeProperty = "<nil>"
	LiabilityTypePropertyLoan        LiabilityTypeProperty = "loan"
	LiabilityTypePropertyMortgage    LiabilityTypeProperty = "mortgage"
)

// Defines values for RecurrenceRepetitionType.
const (
	Daily   RecurrenceRepetitionType = "daily"
	Monthly RecurrenceRepetitionType = "monthly"
	Ndom    RecurrenceRepetitionType = "ndom"
	Weekly  RecurrenceRepetitionType = "weekly"
	Yearly  RecurrenceRepetitionType = "yearly"
)

// Defines values for RecurrenceTransactionType.
const (
	RecurrenceTransactionTypeDeposit    RecurrenceTransactionType = "deposit"
	RecurrenceTransactionTypeTransfer   RecurrenceTransactionType = "transfer"
	RecurrenceTransactionTypeWithdrawal RecurrenceTransactionType = "withdrawal"
)

// Defines values for RuleActionKeyword.
const (
	AddTag                RuleActionKeyword = "add_tag"
	AppendDescription     RuleActionKeyword = "append_description"
	AppendNotes           RuleActionKeyword = "append_notes"
	ClearBudget           RuleActionKeyword = "clear_budget"
	ClearCategory         RuleActionKeyword = "clear_category"
	ClearNotes            RuleActionKeyword = "clear_notes"
	ConvertDeposit        RuleActionKeyword = "convert_deposit"
	ConvertTransfer       RuleActionKeyword = "convert_transfer"
	ConvertWithdrawal     RuleActionKeyword = "convert_withdrawal"
	DeleteTransaction     RuleActionKeyword = "delete_transaction"
	LinkToBill            RuleActionKeyword = "link_to_bill"
	PrependDescription    RuleActionKeyword = "prepend_description"
	PrependNotes          RuleActionKeyword = "prepend_notes"
	RemoveAllTags         RuleActionKeyword = "remove_all_tags"
	RemoveTag             RuleActionKeyword = "remove_tag"
	SetBudget             RuleActionKeyword = "set_budget"
	SetCategory           RuleActionKeyword = "set_category"
	SetDescription        RuleActionKeyword = "set_description"
	SetDestinationAccount RuleActionKeyword = "set_destination_account"
	SetNotes              RuleActionKeyword = "set_notes"
	SetSourceAccount      RuleActionKeyword = "set_source_account"
	UserAction            RuleActionKeyword = "user_action"
)

// Defines values for RuleTriggerKeyword.
const (
	AmountExactly        RuleTriggerKeyword = "amount_exactly"
	AmountLess           RuleTriggerKeyword = "amount_less"
	AmountMore           RuleTriggerKeyword = "amount_more"
	AnyNotes             RuleTriggerKeyword = "any_notes"
	BudgetIs             RuleTriggerKeyword = "budget_is"
	CategoryIs           RuleTriggerKeyword = "category_is"
	CurrencyIs           RuleTriggerKeyword = "currency_is"
	DescriptionContains  RuleTriggerKeyword = "description_contains"
	DescriptionEnds      RuleTriggerKeyword = "description_ends"
	DescriptionIs        RuleTriggerKeyword = "description_is"
	DescriptionStarts    RuleTriggerKeyword = "description_starts"
	DestinationAccountIs RuleTriggerKeyword = "destination_account_is"
	FromAccountContains  RuleTriggerKeyword = "from_account_contains"
	FromAccountEnds      RuleTriggerKeyword = "from_account_ends"
	FromAccountIs        RuleTriggerKeyword = "from_account_is"
	FromAccountStarts    RuleTriggerKeyword = "from_account_starts"
	HasAnyBudget         RuleTriggerKeyword = "has_any_budget"
	HasAnyCategory       RuleTriggerKeyword = "has_any_category"
	HasAnyTag            RuleTriggerKeyword = "has_any_tag"
	HasAttachments       RuleTriggerKeyword = "has_attachments"
	HasNoBudget          RuleTriggerKeyword = "has_no_budget"
	HasNoCategory        RuleTriggerKeyword = "has_no_category"
	HasNoTag             RuleTriggerKeyword = "has_no_tag"
	NoNotes              RuleTriggerKeyword = "no_notes"
	NotesAre             RuleTriggerKeyword = "notes_are"
	NotesContains        RuleTriggerKeyword = "notes_contains"
	NotesEnd             RuleTriggerKeyword = "notes_end"
	NotesStart           RuleTriggerKeyword = "notes_start"
	SourceAccountIs      RuleTriggerKeyword = "source_account_is"
	SourceAccountStarts  RuleTriggerKeyword = "source_account_starts"
	TagIs                RuleTriggerKeyword = "tag_is"
	ToAccountContains    RuleTriggerKeyword = "to_account_contains"
	ToAccountEnds        RuleTriggerKeyword = "to_account_ends"
	ToAccountIs          RuleTriggerKeyword = "to_account_is"
	ToAccountStarts      RuleTriggerKeyword = "to_account_starts"
	TransactionType      RuleTriggerKeyword = "transaction_type"
)

// Defines values for RuleTriggerType.
const (
	StoreJournal  RuleTriggerType = "store-journal"
	UpdateJournal RuleTriggerType = "update-journal"
)

// Defines values for ShortAccountTypeProperty.
const (
	ShortAccountTypePropertyAsset          ShortAccountTypeProperty = "asset"
	ShortAccountTypePropertyCash           ShortAccountTypeProperty = "cash"
	ShortAccountTypePropertyExpense        ShortAccountTypeProperty = "expense"
	ShortAccountTypePropertyImport         ShortAccountTypeProperty = "import"
	ShortAccountTypePropertyInitialBalance ShortAccountTypeProperty = "initial-balance"
	ShortAccountTypePropertyLiabilities    ShortAccountTypeProperty = "liabilities"
	ShortAccountTypePropertyLiability      ShortAccountTypeProperty = "liability"
	ShortAccountTypePropertyReconciliation ShortAccountTypeProperty = "reconciliation"
	ShortAccountTypePropertyRevenue        ShortAccountTypeProperty = "revenue"
)

// Defines values for TransactionTypeFilter.
const (
	TransactionTypeFilterAll            TransactionTypeFilter = "all"
	TransactionTypeFilterDefault        TransactionTypeFilter = "default"
	TransactionTypeFilterDeposit        TransactionTypeFilter = "deposit"
	TransactionTypeFilterDeposits       TransactionTypeFilter = "deposits"
	TransactionTypeFilterExpense        TransactionTypeFilter = "expense"
	TransactionTypeFilterIncome         TransactionTypeFilter = "income"
	TransactionTypeFilterOpeningBalance TransactionTypeFilter = "opening_balance"
	TransactionTypeFilterReconciliation TransactionTypeFilter = "reconciliation"
	TransactionTypeFilterSpecial        TransactionTypeFilter = "special"
	TransactionTypeFilterSpecials       TransactionTypeFilter = "specials"
	TransactionTypeFilterTransfer       TransactionTypeFilter = "transfer"
	TransactionTypeFilterTransfers      TransactionTypeFilter = "transfers"
	TransactionTypeFilterWithdrawal     TransactionTypeFilter = "withdrawal"
	TransactionTypeFilterWithdrawals    TransactionTypeFilter = "withdrawals"
)

// Defines values for TransactionTypeProperty.
const (
	Deposit        TransactionTypeProperty = "deposit"
	OpeningBalance TransactionTypeProperty = "opening balance"
	Reconciliation TransactionTypeProperty = "reconciliation"
	Transfer       TransactionTypeProperty = "transfer"
	Withdrawal     TransactionTypeProperty = "withdrawal"
)

// Defines values for UserBlockedCodeProperty.
const (
	UserBlockedCodePropertyEmailChanged UserBlockedCodeProperty = "email_changed"
	UserBlockedCodePropertyLessThannil  UserBlockedCodeProperty = "<nil>"
)

// Defines values for UserRoleProperty.
const (
	Demo        UserRoleProperty = "demo"
	LessThannil UserRoleProperty = "<nil>"
	Owner       UserRoleProperty = "owner"
)

// Defines values for WebhookDelivery.
const (
	JSON WebhookDelivery = "JSON"
)

// Defines values for WebhookResponse.
const (
	ACCOUNTS     WebhookResponse = "ACCOUNTS"
	NONE         WebhookResponse = "NONE"
	TRANSACTIONS WebhookResponse = "TRANSACTIONS"
)

// Defines values for WebhookTrigger.
const (
	DESTROYTRANSACTION WebhookTrigger = "DESTROY_TRANSACTION"
	STORETRANSACTION   WebhookTrigger = "STORE_TRANSACTION"
	UPDATETRANSACTION  WebhookTrigger = "UPDATE_TRANSACTION"
)

// Account defines model for Account.
type Account struct {
	AccountNumber *string `json:"account_number"`

	// AccountRole Is only mandatory when the type is asset.
	AccountRole *AccountRoleProperty `json:"account_role"`

	// Active If omitted, defaults to true.
	Active    *bool      `json:"active,omitempty"`
	Bic       *string    `json:"bic"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CreditCardType Mandatory when the account_role is ccAsset. Can only be monthlyFull or null.
	CreditCardType *CreditCardTypeProperty `json:"credit_card_type"`

	// CurrencyCode Use either currency_id or currency_code. Defaults to the user's default currency.
	CurrencyCode          *string `json:"currency_code,omitempty"`
	CurrencyDecimalPlaces *int32  `json:"currency_decimal_places,omitempty"`

	// CurrencyId Use either currency_id or currency_code. Defaults to the user's default currency.
	CurrencyId     *string `json:"currency_id,omitempty"`
	CurrencySymbol *string `json:"currency_symbol,omitempty"`
	CurrentBalance *string `json:"current_balance,omitempty"`

	// CurrentBalanceDate The timestamp for this date is always 23:59:59, to indicate it's the balance at the very END of that particular day.
	CurrentBalanceDate *time.Time `json:"current_balance_date,omitempty"`

	// CurrentDebt Represents the current debt for liabilities.
	CurrentDebt *string `json:"current_debt"`
	Iban        *string `json:"iban"`

	// IncludeNetWorth If omitted, defaults to true.
	IncludeNetWorth *bool `json:"include_net_worth,omitempty"`

	// Interest Mandatory when type is liability. Interest percentage.
	Interest *string `json:"interest"`

	// InterestPeriod Mandatory when type is liability. Period over which the interest is calculated.
	InterestPeriod *InterestPeriodProperty `json:"interest_period"`

	// Latitude Latitude of the accounts's location, if applicable. Can be used to draw a map.
	Latitude *float64 `json:"latitude"`

	// LiabilityDirection 'credit' indicates somebody owes you the liability. 'debit' Indicates you owe this debt yourself. Works only for liabiltiies.
	LiabilityDirection *LiabilityDirectionProperty `json:"liability_direction"`

	// LiabilityType Mandatory when type is liability. Specifies the exact type.
	LiabilityType *LiabilityTypeProperty `json:"liability_type"`

	// Longitude Latitude of the accounts's location, if applicable. Can be used to draw a map.
	Longitude *float64 `json:"longitude"`

	// MonthlyPaymentDate Mandatory when the account_role is ccAsset. Moment at which CC payment installments are asked for by the bank.
	MonthlyPaymentDate *time.Time `json:"monthly_payment_date"`
	Name               string     `json:"name"`
	Notes              *string    `json:"notes"`

	// OpeningBalance Represents the opening balance, the initial amount this account holds.
	OpeningBalance *string `json:"opening_balance,omitempty"`

	// OpeningBalanceDate Represents the date of the opening balance.
	OpeningBalanceDate *time.Time `json:"opening_balance_date"`

	// Order Order of the account. Is NULL if account is not asset or liability.
	Order *int32 `json:"order"`

	// Type Can only be one one these account types. import, initial-balance and reconciliation cannot be set manually.
	Type           ShortAccountTypeProperty `json:"type"`
	UpdatedAt      *time.Time               `json:"updated_at,omitempty"`
	VirtualBalance *string                  `json:"virtual_balance,omitempty"`

	// ZoomLevel Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
	ZoomLevel *int32 `json:"zoom_level"`
}

// AccountArray defines model for AccountArray.
type AccountArray struct {
	Data []AccountRead `json:"data"`
	Meta Meta          `json:"meta"`
}

// AccountRead defines model for AccountRead.
type AccountRead struct {
	Attributes Account `json:"attributes"`
	Id         string  `json:"id"`

	// Type Immutable value
	Type string `json:"type"`
}

// AccountRoleProperty Is only mandatory when the type is asset.
type AccountRoleProperty string

// AccountSearchFieldFilter defines model for AccountSearchFieldFilter.
type AccountSearchFieldFilter string

// AccountSingle defines model for AccountSingle.
type AccountSingle struct {
	Data AccountRead `json:"data"`
}

// AccountStore defines model for AccountStore.
type AccountStore struct {
	AccountNumber *string `json:"account_number"`

	// AccountRole Is only mandatory when the type is asset.
	AccountRole *AccountRoleProperty `json:"account_role"`

	// Active If omitted, defaults to true.
	Active *bool   `json:"active,omitempty"`
	Bic    *string `json:"bic"`

	// CreditCardType Mandatory when the account_role is ccAsset. Can only be monthlyFull or null.
	CreditCardType *CreditCardTypeProperty `json:"credit_card_type"`

	// CurrencyCode Use either currency_id or currency_code. Defaults to the user's default currency.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyId Use either currency_id or currency_code. Defaults to the user's default currency.
	CurrencyId *string `json:"currency_id,omitempty"`
	Iban       *string `json:"iban"`

	// IncludeNetWorth If omitted, defaults to true.
	IncludeNetWorth *bool `json:"include_net_worth,omitempty"`

	// Interest Mandatory when type is liability. Interest percentage.
	Interest *string `json:"interest"`

	// InterestPeriod Mandatory when type is liability. Period over which the interest is calculated.
	InterestPeriod *InterestPeriodProperty `json:"interest_period"`

	// Latitude Latitude of the accounts's location, if applicable. Can be used to draw a map.
	Latitude *float64 `json:"latitude"`

	// LiabilityDirection 'credit' indicates somebody owes you the liability. 'debit' Indicates you owe this debt yourself. Works only for liabiltiies.
	LiabilityDirection *LiabilityDirectionProperty `json:"liability_direction"`

	// LiabilityType Mandatory when type is liability. Specifies the exact type.
	LiabilityType *LiabilityTypeProperty `json:"liability_type"`

	// Longitude Latitude of the accounts's location, if applicable. Can be used to draw a map.
	Longitude *float64 `json:"longitude"`

	// MonthlyPaymentDate Mandatory when the account_role is ccAsset. Moment at which CC payment installments are asked for by the bank.
	MonthlyPaymentDate *time.Time `json:"monthly_payment_date"`
	Name               string     `json:"name"`
	Notes              *string    `json:"notes"`

	// OpeningBalance Represents the opening balance, the initial amount this account holds.
	OpeningBalance *string `json:"opening_balance,omitempty"`

	// OpeningBalanceDate Represents the date of the opening balance.
	OpeningBalanceDate *time.Time `json:"opening_balance_date"`

	// Order Order of the account
	Order *int32 `json:"order,omitempty"`

	// Type Can only be one one these account types. import, initial-balance and reconciliation cannot be set manually.
	Type           ShortAccountTypeProperty `json:"type"`
	VirtualBalance *string                  `json:"virtual_balance,omitempty"`

	// ZoomLevel Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
	ZoomLevel *int32 `json:"zoom_level"`
}

// AccountTypeFilter defines model for AccountTypeFilter.
type AccountTypeFilter string

// AccountTypeProperty defines model for AccountTypeProperty.
type AccountTypeProperty string

// AccountUpdate defines model for AccountUpdate.
type AccountUpdate struct {
	AccountNumber *string `json:"account_number"`

	// AccountRole Is only mandatory when the type is asset.
	AccountRole *AccountRoleProperty `json:"account_role"`

	// Active If omitted, defaults to true.
	Active *bool   `json:"active,omitempty"`
	Bic    *string `json:"bic"`

	// CreditCardType Mandatory when the account_role is ccAsset. Can only be monthlyFull or null.
	CreditCardType *CreditCardTypeProperty `json:"credit_card_type"`

	// CurrencyCode Use either currency_id or currency_code. Defaults to the user's default currency.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyId Use either currency_id or currency_code. Defaults to the user's default currency.
	CurrencyId *string `json:"currency_id,omitempty"`
	Iban       *string `json:"iban"`

	// IncludeNetWorth If omitted, defaults to true.
	IncludeNetWorth *bool `json:"include_net_worth,omitempty"`

	// Interest Mandatory when type is liability. Interest percentage.
	Interest *string `json:"interest"`

	// InterestPeriod Mandatory when type is liability. Period over which the interest is calculated.
	InterestPeriod *InterestPeriodProperty `json:"interest_period"`

	// Latitude Latitude of the account's location, if applicable. Can be used to draw a map. If omitted, the existing location will be kept. If submitted as NULL, the current location will be removed.
	Latitude *float64 `json:"latitude"`

	// LiabilityType Mandatory when type is liability. Specifies the exact type.
	LiabilityType *LiabilityTypeProperty `json:"liability_type"`

	// Longitude Latitude of the account's location, if applicable. Can be used to draw a map. If omitted, the existing location will be kept. If submitted as NULL, the current location will be removed.
	Longitude *float64 `json:"longitude"`

	// MonthlyPaymentDate Mandatory when the account_role is ccAsset. Moment at which CC payment installments are asked for by the bank.
	MonthlyPaymentDate *time.Time `json:"monthly_payment_date"`
	Name               string     `json:"name"`
	Notes              *string    `json:"notes"`
	OpeningBalance     *string    `json:"opening_balance,omitempty"`
	OpeningBalanceDate *time.Time `json:"opening_balance_date"`

	// Order Order of the account
	Order          *int32  `json:"order,omitempty"`
	VirtualBalance *string `json:"virtual_balance,omitempty"`

	// ZoomLevel Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels. If omitted, the existing location will be kept. If submitted as NULL, the current location will be removed.
	ZoomLevel *int32 `json:"zoom_level"`
}

// AttachableType The object class to which the attachment must be linked.
type AttachableType string

// Attachment defines model for Attachment.
type Attachment struct {
	// AttachableId ID of the model this attachment is linked to.
	AttachableId string `json:"attachable_id"`

	// AttachableType The object class to which the attachment must be linked.
	AttachableType AttachableType `json:"attachable_type"`
	CreatedAt      *time.Time     `json:"created_at,omitempty"`
	DownloadUrl    *string        `json:"download_url,omitempty"`
	Filename       string         `json:"filename"`

	// Md5 MD5 hash of the file for basic duplicate detection.
	Md5       *string    `json:"md5,omitempty"`
	Mime      *string    `json:"mime,omitempty"`
	Notes     *string    `json:"notes"`
	Size      *int32     `json:"size,omitempty"`
	Title     *string    `json:"title"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	UploadUrl *string    `json:"upload_url,omitempty"`
}

// AttachmentArray defines model for AttachmentArray.
type AttachmentArray struct {
	Data []AttachmentRead `json:"data"`
	Meta Meta             `json:"meta"`
}

// AttachmentRead defines model for AttachmentRead.
type AttachmentRead struct {
	Attributes Attachment `json:"attributes"`
	Id         string     `json:"id"`
	Links      ObjectLink `json:"links"`

	// Type Immutable value
	Type string `json:"type"`
}

// AttachmentSingle defines model for AttachmentSingle.
type AttachmentSingle struct {
	Data AttachmentRead `json:"data"`
}

// AttachmentStore defines model for AttachmentStore.
type AttachmentStore struct {
	// AttachableId ID of the model this attachment is linked to.
	AttachableId string `json:"attachable_id"`

	// AttachableType The object class to which the attachment must be linked.
	AttachableType AttachableType `json:"attachable_type"`
	Filename       string         `json:"filename"`
	Notes          *string        `json:"notes"`
	Title          *string        `json:"title,omitempty"`
}

// AttachmentUpdate defines model for AttachmentUpdate.
type AttachmentUpdate struct {
	Filename *string `json:"filename,omitempty"`
	Notes    *string `json:"notes"`
	Title    *string `json:"title,omitempty"`
}

// AutoBudgetPeriod Period for the auto budget
type AutoBudgetPeriod string

// AutoBudgetType The type of auto-budget that Firefly III must create.
type AutoBudgetType string

// AutocompleteAccount defines model for AutocompleteAccount.
type AutocompleteAccount struct {
	// CurrencyCode Currency code for the currency used by this account.
	CurrencyCode string `json:"currency_code"`

	// CurrencyDecimalPlaces Number of decimal places for the currency used by this account.
	CurrencyDecimalPlaces int32 `json:"currency_decimal_places"`

	// CurrencyId ID for the currency used by this account.
	CurrencyId string `json:"currency_id"`

	// CurrencyName Currency name for the currency used by this account.
	CurrencyName string `json:"currency_name"`

	// CurrencySymbol Currency symbol for the currency used by this account.
	CurrencySymbol string `json:"currency_symbol"`
	Id             string `json:"id"`

	// Name Name of the account found by an auto-complete search.
	Name string `json:"name"`

	// NameWithBalance Asset accounts and liabilities have a second field with the given date's account balance.
	NameWithBalance string `json:"name_with_balance"`

	// Type Account type of the account found by the auto-complete search.
	Type string `json:"type"`
}

// AutocompleteAccountArray defines model for AutocompleteAccountArray.
type AutocompleteAccountArray = []AutocompleteAccount

// AutocompleteBill defines model for AutocompleteBill.
type AutocompleteBill struct {
	// Active Is the bill active or not?
	Active *bool  `json:"active,omitempty"`
	Id     string `json:"id"`

	// Name Name of the bill found by an auto-complete search.
	Name string `json:"name"`
}

// AutocompleteBillArray defines model for AutocompleteBillArray.
type AutocompleteBillArray = []AutocompleteBill

// AutocompleteBudget defines model for AutocompleteBudget.
type AutocompleteBudget struct {
	Id string `json:"id"`

	// Name Name of the budget found by an auto-complete search.
	Name string `json:"name"`
}

// AutocompleteBudgetArray defines model for AutocompleteBudgetArray.
type AutocompleteBudgetArray = []AutocompleteBudget

// AutocompleteCategory defines model for AutocompleteCategory.
type AutocompleteCategory struct {
	Id string `json:"id"`

	// Name Name of the category found by an auto-complete search.
	Name string `json:"name"`
}

// AutocompleteCategoryArray defines model for AutocompleteCategoryArray.
type AutocompleteCategoryArray = []AutocompleteCategory

// AutocompleteCurrency defines model for AutocompleteCurrency.
type AutocompleteCurrency struct {
	// Code Currency code.
	Code          string `json:"code"`
	DecimalPlaces int32  `json:"decimal_places"`
	Id            string `json:"id"`

	// Name Currency name.
	Name   string `json:"name"`
	Symbol string `json:"symbol"`
}

// AutocompleteCurrencyArray defines model for AutocompleteCurrencyArray.
type AutocompleteCurrencyArray = []AutocompleteCurrency

// AutocompleteCurrencyCode defines model for AutocompleteCurrencyCode.
type AutocompleteCurrencyCode struct {
	// Code Currency code.
	Code          string `json:"code"`
	DecimalPlaces int32  `json:"decimal_places"`
	Id            string `json:"id"`

	// Name Currency name with the code between brackets.
	Name   string `json:"name"`
	Symbol string `json:"symbol"`
}

// AutocompleteCurrencyCodeArray defines model for AutocompleteCurrencyCodeArray.
type AutocompleteCurrencyCodeArray = []AutocompleteCurrencyCode

// AutocompleteObjectGroup defines model for AutocompleteObjectGroup.
type AutocompleteObjectGroup struct {
	Id string `json:"id"`

	// Name Title of the object group found by an auto-complete search.
	Name string `json:"name"`

	// Title Title of the object group found by an auto-complete search.
	Title string `json:"title"`
}

// AutocompleteObjectGroupArray defines model for AutocompleteObjectGroupArray.
type AutocompleteObjectGroupArray = []AutocompleteObjectGroup

// AutocompletePiggy defines model for AutocompletePiggy.
type AutocompletePiggy struct {
	// CurrencyCode Currency code for this piggy bank.
	CurrencyCode          *string `json:"currency_code,omitempty"`
	CurrencyDecimalPlaces *int32  `json:"currency_decimal_places,omitempty"`

	// CurrencyId Currency ID for this piggy bank.
	CurrencyId *string `json:"currency_id,omitempty"`

	// CurrencyName Currency name for the currency used by this account.
	CurrencyName   *string `json:"currency_name,omitempty"`
	CurrencySymbol *string `json:"currency_symbol,omitempty"`
	Id             string  `json:"id"`

	// Name Name of the piggy bank found by an auto-complete search.
	Name string `json:"name"`

	// ObjectGroupId The group ID of the group this object is part of. NULL if no group.
	ObjectGroupId *string `json:"object_group_id"`

	// ObjectGroupTitle The name of the group. NULL if no group.
	ObjectGroupTitle *string `json:"object_group_title"`
}

// AutocompletePiggyArray defines model for AutocompletePiggyArray.
type AutocompletePiggyArray = []AutocompletePiggy

// AutocompletePiggyBalance defines model for AutocompletePiggyBalance.
type AutocompletePiggyBalance struct {
	// CurrencyCode Currency code for this piggy bank.
	CurrencyCode          *string `json:"currency_code,omitempty"`
	CurrencyDecimalPlaces *int32  `json:"currency_decimal_places,omitempty"`

	// CurrencyId Currency ID for this piggy bank.
	CurrencyId     *string `json:"currency_id,omitempty"`
	CurrencySymbol *string `json:"currency_symbol,omitempty"`
	Id             string  `json:"id"`

	// Name Name of the piggy bank found by an auto-complete search.
	Name string `json:"name"`

	// NameWithBalance Name of the piggy bank found by an auto-complete search with the current balance formatted nicely.
	NameWithBalance *string `json:"name_with_balance,omitempty"`

	// ObjectGroupId The group ID of the group this object is part of. NULL if no group.
	ObjectGroupId *string `json:"object_group_id"`

	// ObjectGroupTitle The name of the group. NULL if no group.
	ObjectGroupTitle *string `json:"object_group_title"`
}

// AutocompletePiggyBalanceArray defines model for AutocompletePiggyBalanceArray.
type AutocompletePiggyBalanceArray = []AutocompletePiggyBalance

// AutocompleteRecurrence defines model for AutocompleteRecurrence.
type AutocompleteRecurrence struct {
	// Description Description of the recurrence found by auto-complete.
	Description *string `json:"description,omitempty"`
	Id          string  `json:"id"`

	// Name Name of the recurrence found by an auto-complete search.
	Name string `json:"name"`
}

// AutocompleteRecurrenceArray defines model for AutocompleteRecurrenceArray.
type AutocompleteRecurrenceArray = []AutocompleteRecurrence

// AutocompleteRule defines model for AutocompleteRule.
type AutocompleteRule struct {
	// Description Description of the rule found by auto-complete.
	Description *string `json:"description,omitempty"`
	Id          string  `json:"id"`

	// Name Name of the rule found by an auto-complete search.
	Name string `json:"name"`
}

// AutocompleteRuleArray defines model for AutocompleteRuleArray.
type AutocompleteRuleArray = []AutocompleteRule

// AutocompleteRuleGroup defines model for AutocompleteRuleGroup.
type AutocompleteRuleGroup struct {
	// Description Description of the rule group found by auto-complete.
	Description *string `json:"description,omitempty"`
	Id          string  `json:"id"`

	// Name Name of the rule group found by an auto-complete search.
	Name string `json:"name"`
}

// AutocompleteRuleGroupArray defines model for AutocompleteRuleGroupArray.
type AutocompleteRuleGroupArray = []AutocompleteRuleGroup

// AutocompleteTag defines model for AutocompleteTag.
type AutocompleteTag struct {
	Id string `json:"id"`

	// Name Name of the tag found by an auto-complete search.
	Name string `json:"name"`

	// Tag Name of the tag found by an auto-complete search.
	Tag string `json:"tag"`
}

// AutocompleteTagArray defines model for AutocompleteTagArray.
type AutocompleteTagArray = []AutocompleteTag

// AutocompleteTransaction defines model for AutocompleteTransaction.
type AutocompleteTransaction struct {
	// Description Transaction description
	Description string `json:"description"`

	// Id The ID of a transaction journal (basically a single split).
	Id string `json:"id"`

	// Name Transaction description
	Name string `json:"name"`

	// TransactionGroupId The ID of the underlying transaction group.
	TransactionGroupId *string `json:"transaction_group_id,omitempty"`
}

// AutocompleteTransactionArray defines model for AutocompleteTransactionArray.
type AutocompleteTransactionArray = []AutocompleteTransaction

// AutocompleteTransactionID defines model for AutocompleteTransactionID.
type AutocompleteTransactionID struct {
	// Description Transaction description with ID in the name.
	Description string `json:"description"`

	// Id The ID of a transaction journal (basically a single split).
	Id string `json:"id"`

	// Name Transaction description with ID in the name.
	Name string `json:"name"`

	// TransactionGroupId The ID of the underlying transaction group.
	TransactionGroupId *string `json:"transaction_group_id,omitempty"`
}

// AutocompleteTransactionIDArray defines model for AutocompleteTransactionIDArray.
type AutocompleteTransactionIDArray = []AutocompleteTransactionID

// AutocompleteTransactionType defines model for AutocompleteTransactionType.
type AutocompleteTransactionType struct {
	Id string `json:"id"`

	// Name Type of the object found by an auto-complete search.
	Name string `json:"name"`

	// Type Name of the object found by an auto-complete search.
	Type string `json:"type"`
}

// AutocompleteTransactionTypeArray defines model for AutocompleteTransactionTypeArray.
type AutocompleteTransactionTypeArray = []AutocompleteTransactionType

// AvailableBudget defines model for AvailableBudget.
type AvailableBudget struct {
	Amount    string     `json:"amount"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CurrencyCode Use either currency_id or currency_code.
	CurrencyCode          *string `json:"currency_code,omitempty"`
	CurrencyDecimalPlaces *int32  `json:"currency_decimal_places,omitempty"`

	// CurrencyId Use either currency_id or currency_code.
	CurrencyId     *string `json:"currency_id,omitempty"`
	CurrencySymbol *string `json:"currency_symbol,omitempty"`

	// End End date of the available budget.
	End                time.Time      `json:"end"`
	SpentInBudgets     *[]BudgetSpent `json:"spent_in_budgets,omitempty"`
	SpentOutsideBudget *[]BudgetSpent `json:"spent_outside_budget,omitempty"`

	// Start Start date of the available budget.
	Start     time.Time  `json:"start"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// AvailableBudgetArray defines model for AvailableBudgetArray.
type AvailableBudgetArray struct {
	Data []AvailableBudgetRead `json:"data"`
	Meta Meta                  `json:"meta"`
}

// AvailableBudgetRead defines model for AvailableBudgetRead.
type AvailableBudgetRead struct {
	Attributes AvailableBudget `json:"attributes"`
	Id         string          `json:"id"`

	// Type Immutable value
	Type string `json:"type"`
}

// AvailableBudgetSingle defines model for AvailableBudgetSingle.
type AvailableBudgetSingle struct {
	Data AvailableBudgetRead `json:"data"`
}

// BadRequestResponse defines model for BadRequestResponse.
type BadRequestResponse struct {
	Exception *string `json:"exception,omitempty"`
	Message   *string `json:"message,omitempty"`
}

// BasicSummary defines model for BasicSummary.
type BasicSummary map[string]BasicSummaryEntry

// BasicSummaryEntry defines model for BasicSummaryEntry.
type BasicSummaryEntry struct {
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyDecimalPlaces Number of decimals for the associated currency.
	CurrencyDecimalPlaces *int32 `json:"currency_decimal_places,omitempty"`

	// CurrencyId The currency ID of the associated currency.
	CurrencyId     *string `json:"currency_id,omitempty"`
	CurrencySymbol *string `json:"currency_symbol,omitempty"`

	// Key This is a reference to the type of info shared, not influenced by translations or user preferences. The EUR value is a reference to the currency code. Possibilities are: balance-in-ABC, spent-in-ABC, earned-in-ABC, bills-paid-in-ABC, bills-unpaid-in-ABC, left-to-spend-in-ABC and net-worth-in-ABC.
	Key *string `json:"key,omitempty"`

	// LocalIcon Reference to a font-awesome icon without the fa- part.
	LocalIcon *string `json:"local_icon,omitempty"`

	// MonetaryValue The amount as a float.
	MonetaryValue *float64 `json:"monetary_value,omitempty"`

	// SubTitle A short explanation of the amounts origin. Already formatted according to the locale of the user or translated, if relevant.
	SubTitle *string `json:"sub_title,omitempty"`

	// Title A translated title for the information shared.
	Title *string `json:"title,omitempty"`

	// ValueParsed The amount formatted according to the users locale
	ValueParsed *string `json:"value_parsed,omitempty"`
}

// Bill defines model for Bill.
type Bill struct {
	// Active If the bill is active.
	Active    *bool      `json:"active,omitempty"`
	AmountMax string     `json:"amount_max"`
	AmountMin string     `json:"amount_min"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CurrencyCode Use either currency_id or currency_code
	CurrencyCode          *string `json:"currency_code,omitempty"`
	CurrencyDecimalPlaces *int32  `json:"currency_decimal_places,omitempty"`

	// CurrencyId Use either currency_id or currency_code
	CurrencyId     *string   `json:"currency_id,omitempty"`
	CurrencySymbol *string   `json:"currency_symbol,omitempty"`
	Date           time.Time `json:"date"`

	// EndDate The date after which this bill is no longer valid or applicable
	EndDate *time.Time `json:"end_date"`

	// ExtensionDate The date before which the bill must be renewed (or cancelled)
	ExtensionDate *time.Time `json:"extension_date"`
	Name          string     `json:"name"`

	// NextExpectedMatch When the bill is expected to be due.
	NextExpectedMatch *time.Time `json:"next_expected_match"`

	// NextExpectedMatchDiff Formatted (locally) when the bill is due.
	NextExpectedMatchDiff *string `json:"next_expected_match_diff"`
	Notes                 *string `json:"notes"`

	// ObjectGroupId The group ID of the group this object is part of. NULL if no group.
	ObjectGroupId *string `json:"object_group_id"`

	// ObjectGroupOrder The order of the group. At least 1, for the highest sorting.
	ObjectGroupOrder *int32 `json:"object_group_order"`

	// ObjectGroupTitle The name of the group. NULL if no group.
	ObjectGroupTitle *string `json:"object_group_title"`

	// Order Order of the bill.
	Order *int32 `json:"order,omitempty"`

	// PaidDates Array of past transactions when the bill was paid.
	PaidDates *[]struct {
		// Date Date the bill was paid.
		Date *time.Time `json:"date,omitempty"`

		// TransactionGroupId Transaction group ID of the paid bill.
		TransactionGroupId *string `json:"transaction_group_id,omitempty"`

		// TransactionJournalId Transaction journal ID of the paid bill.
		TransactionJournalId *string `json:"transaction_journal_id,omitempty"`
	} `json:"paid_dates,omitempty"`

	// PayDates Array of future dates when the bill is expected to be paid. Autogenerated.
	PayDates *[]time.Time `json:"pay_dates,omitempty"`

	// RepeatFreq How often the bill must be paid.
	RepeatFreq BillRepeatFrequency `json:"repeat_freq"`

	// Skip How often the bill must be skipped. 1 means a bi-monthly bill.
	Skip      *int32     `json:"skip,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// BillArray defines model for BillArray.
type BillArray struct {
	Data []BillRead `json:"data"`
	Meta Meta       `json:"meta"`
}

// BillRead defines model for BillRead.
type BillRead struct {
	Attributes Bill   `json:"attributes"`
	Id         string `json:"id"`

	// Type Immutable value
	Type string `json:"type"`
}

// BillRepeatFrequency How often the bill must be paid.
type BillRepeatFrequency string

// BillSingle defines model for BillSingle.
type BillSingle struct {
	Data BillRead `json:"data"`
}

// BillStore defines model for BillStore.
type BillStore struct {
	// Active If the bill is active.
	Active    *bool  `json:"active,omitempty"`
	AmountMax string `json:"amount_max"`
	AmountMin string `json:"amount_min"`

	// CurrencyCode Use either currency_id or currency_code
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyId Use either currency_id or currency_code
	CurrencyId *string   `json:"currency_id,omitempty"`
	Date       time.Time `json:"date"`

	// EndDate The date after which this bill is no longer valid or applicable
	EndDate *time.Time `json:"end_date,omitempty"`

	// ExtensionDate The date before which the bill must be renewed (or cancelled)
	ExtensionDate *time.Time `json:"extension_date,omitempty"`
	Name          string     `json:"name"`
	Notes         *string    `json:"notes"`

	// ObjectGroupId The group ID of the group this object is part of. NULL if no group.
	ObjectGroupId *string `json:"object_group_id"`

	// ObjectGroupTitle The name of the group. NULL if no group.
	ObjectGroupTitle *string `json:"object_group_title"`

	// RepeatFreq How often the bill must be paid.
	RepeatFreq BillRepeatFrequency `json:"repeat_freq"`

	// Skip How often the bill must be skipped. 1 means a bi-monthly bill.
	Skip *int32 `json:"skip,omitempty"`
}

// BillUpdate defines model for BillUpdate.
type BillUpdate struct {
	// Active If the bill is active.
	Active    *bool   `json:"active,omitempty"`
	AmountMax *string `json:"amount_max,omitempty"`
	AmountMin *string `json:"amount_min,omitempty"`

	// CurrencyCode Use either currency_id or currency_code
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyId Use either currency_id or currency_code
	CurrencyId *string    `json:"currency_id,omitempty"`
	Date       *time.Time `json:"date,omitempty"`

	// EndDate The date after which this bill is no longer valid or applicable
	EndDate *time.Time `json:"end_date,omitempty"`

	// ExtensionDate The date before which the bill must be renewed (or cancelled)
	ExtensionDate *time.Time `json:"extension_date,omitempty"`
	Name          string     `json:"name"`
	Notes         *string    `json:"notes"`

	// ObjectGroupId The group ID of the group this object is part of. NULL if no group.
	ObjectGroupId *string `json:"object_group_id"`

	// ObjectGroupTitle The name of the group. NULL if no group.
	ObjectGroupTitle *string `json:"object_group_title"`

	// RepeatFreq How often the bill must be paid.
	RepeatFreq *BillRepeatFrequency `json:"repeat_freq,omitempty"`

	// Skip How often the bill must be skipped. 1 means a bi-monthly bill.
	Skip *int32 `json:"skip,omitempty"`
}

// Budget defines model for Budget.
type Budget struct {
	Active           *bool   `json:"active,omitempty"`
	AutoBudgetAmount *string `json:"auto_budget_amount"`

	// AutoBudgetCurrencyCode Use either currency_id or currency_code. Defaults to the user's default currency.
	AutoBudgetCurrencyCode *string `json:"auto_budget_currency_code"`

	// AutoBudgetCurrencyId Use either currency_id or currency_code. Defaults to the user's default currency.
	AutoBudgetCurrencyId *string `json:"auto_budget_currency_id"`

	// AutoBudgetPeriod Period for the auto budget
	AutoBudgetPeriod *AutoBudgetPeriod `json:"auto_budget_period"`

	// AutoBudgetType The type of auto-budget that Firefly III must create.
	AutoBudgetType *AutoBudgetType `json:"auto_budget_type"`
	CreatedAt      *time.Time      `json:"created_at,omitempty"`
	Name           string          `json:"name"`
	Notes          *string         `json:"notes"`
	Order          *int32          `json:"order,omitempty"`

	// Spent Information on how much was spent in this budget. Is only filled in when the start and end date are submitted.
	Spent     *[]BudgetSpent `json:"spent,omitempty"`
	UpdatedAt *time.Time     `json:"updated_at,omitempty"`
}

// BudgetArray defines model for BudgetArray.
type BudgetArray struct {
	Data []BudgetRead `json:"data"`
	Meta Meta         `json:"meta"`
}

// BudgetLimit defines model for BudgetLimit.
type BudgetLimit struct {
	Amount string `json:"amount"`

	// BudgetId The budget ID of the associated budget.
	BudgetId  *string    `json:"budget_id,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CurrencyCode Use either currency_id or currency_code. Defaults to the user's default currency.
	CurrencyCode          *string `json:"currency_code,omitempty"`
	CurrencyDecimalPlaces *int32  `json:"currency_decimal_places,omitempty"`

	// CurrencyId Use either currency_id or currency_code. Defaults to the user's default currency.
	CurrencyId     *string `json:"currency_id,omitempty"`
	CurrencyName   *string `json:"currency_name,omitempty"`
	CurrencySymbol *string `json:"currency_symbol,omitempty"`

	// End End date of the budget limit.
	End time.Time `json:"end"`

	// Period Period of the budget limit. Only used when auto-generated by auto-budget.
	Period *string `json:"period"`
	Spent  *string `json:"spent"`

	// Start Start date of the budget limit.
	Start     time.Time  `json:"start"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// BudgetLimitArray defines model for BudgetLimitArray.
type BudgetLimitArray struct {
	Data []BudgetLimitRead `json:"data"`
	Meta Meta              `json:"meta"`
}

// BudgetLimitRead defines model for BudgetLimitRead.
type BudgetLimitRead struct {
	Attributes BudgetLimit `json:"attributes"`
	Id         string      `json:"id"`

	// Type Immutable value
	Type string `json:"type"`
}

// BudgetLimitSingle defines model for BudgetLimitSingle.
type BudgetLimitSingle struct {
	Data BudgetLimitRead `json:"data"`
}

// BudgetLimitStore defines model for BudgetLimitStore.
type BudgetLimitStore struct {
	Amount string `json:"amount"`

	// BudgetId The budget ID of the associated budget.
	BudgetId *string `json:"budget_id,omitempty"`

	// CurrencyCode Use either currency_id or currency_code. Defaults to the user's default currency.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyId Use either currency_id or currency_code. Defaults to the user's default currency.
	CurrencyId *string `json:"currency_id,omitempty"`

	// End End date of the budget limit.
	End openapi_types.Date `json:"end"`

	// Period Period of the budget limit. Only used when auto-generated by auto-budget.
	Period *string `json:"period"`

	// Start Start date of the budget limit.
	Start openapi_types.Date `json:"start"`
}

// BudgetRead defines model for BudgetRead.
type BudgetRead struct {
	Attributes Budget `json:"attributes"`
	Id         string `json:"id"`

	// Type Immutable value
	Type string `json:"type"`
}

// BudgetSingle defines model for BudgetSingle.
type BudgetSingle struct {
	Data BudgetRead `json:"data"`
}

// BudgetSpent defines model for BudgetSpent.
type BudgetSpent struct {
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyDecimalPlaces Number of decimals supported by the currency
	CurrencyDecimalPlaces *int32  `json:"currency_decimal_places,omitempty"`
	CurrencyId            *string `json:"currency_id,omitempty"`
	CurrencySymbol        *string `json:"currency_symbol,omitempty"`

	// Sum The amount spent.
	Sum *string `json:"sum,omitempty"`
}

// BudgetStore defines model for BudgetStore.
type BudgetStore struct {
	Active           *bool   `json:"active,omitempty"`
	AutoBudgetAmount *string `json:"auto_budget_amount"`

	// AutoBudgetCurrencyCode Use either currency_id or currency_code. Defaults to the user's default currency.
	AutoBudgetCurrencyCode *string `json:"auto_budget_currency_code"`

	// AutoBudgetCurrencyId Use either currency_id or currency_code. Defaults to the user's default currency.
	AutoBudgetCurrencyId *string `json:"auto_budget_currency_id"`

	// AutoBudgetPeriod Period for the auto budget
	AutoBudgetPeriod *AutoBudgetPeriod `json:"auto_budget_period"`

	// AutoBudgetType The type of auto-budget that Firefly III must create.
	AutoBudgetType *AutoBudgetType `json:"auto_budget_type"`
	Name           string          `json:"name"`
	Notes          *string         `json:"notes"`
	Order          *int32          `json:"order,omitempty"`
}

// BudgetUpdate defines model for BudgetUpdate.
type BudgetUpdate struct {
	Active           *bool   `json:"active,omitempty"`
	AutoBudgetAmount *string `json:"auto_budget_amount"`

	// AutoBudgetCurrencyCode Use either currency_id or currency_code. Defaults to the user's default currency.
	AutoBudgetCurrencyCode *string `json:"auto_budget_currency_code"`

	// AutoBudgetCurrencyId Use either currency_id or currency_code. Defaults to the user's default currency.
	AutoBudgetCurrencyId *string `json:"auto_budget_currency_id"`

	// AutoBudgetPeriod Period for the auto budget
	AutoBudgetPeriod *AutoBudgetPeriod `json:"auto_budget_period"`

	// AutoBudgetType The type of auto-budget that Firefly III must create.
	AutoBudgetType *AutoBudgetType `json:"auto_budget_type"`
	Name           string          `json:"name"`
	Notes          *string         `json:"notes"`
	Order          *int32          `json:"order,omitempty"`
}

// Category defines model for Category.
type Category struct {
	CreatedAt *time.Time        `json:"created_at,omitempty"`
	Earned    *[]CategoryEarned `json:"earned,omitempty"`
	Name      string            `json:"name"`
	Notes     *string           `json:"notes"`
	Spent     *[]CategorySpent  `json:"spent,omitempty"`
	UpdatedAt *time.Time        `json:"updated_at,omitempty"`
}

// CategoryArray defines model for CategoryArray.
type CategoryArray struct {
	Data []CategoryRead `json:"data"`
	Meta Meta           `json:"meta"`
}

// CategoryEarned defines model for CategoryEarned.
type CategoryEarned struct {
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyDecimalPlaces Number of decimals supported by the currency
	CurrencyDecimalPlaces *int32  `json:"currency_decimal_places,omitempty"`
	CurrencyId            *string `json:"currency_id,omitempty"`
	CurrencySymbol        *string `json:"currency_symbol,omitempty"`

	// Sum The amount earned.
	Sum *string `json:"sum,omitempty"`
}

// CategoryRead defines model for CategoryRead.
type CategoryRead struct {
	Attributes Category `json:"attributes"`
	Id         string   `json:"id"`

	// Type Immutable value
	Type string `json:"type"`
}

// CategorySingle defines model for CategorySingle.
type CategorySingle struct {
	Data CategoryRead `json:"data"`
}

// CategorySpent defines model for CategorySpent.
type CategorySpent struct {
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyDecimalPlaces Number of decimals supported by the currency
	CurrencyDecimalPlaces *int32  `json:"currency_decimal_places,omitempty"`
	CurrencyId            *string `json:"currency_id,omitempty"`
	CurrencySymbol        *string `json:"currency_symbol,omitempty"`

	// Sum The amount spent.
	Sum *string `json:"sum,omitempty"`
}

// CategoryUpdate defines model for CategoryUpdate.
type CategoryUpdate struct {
	Name  string  `json:"name"`
	Notes *string `json:"notes"`
}

// ChartDataPoint defines model for ChartDataPoint.
type ChartDataPoint struct {
	// Key The key is the label of the value, so for example: '2018-01-01' => 13 or 'Groceries' => -123.
	Key *string `json:"key,omitempty"`
}

// ChartDataSet defines model for ChartDataSet.
type ChartDataSet struct {
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyDecimalPlaces Number of decimals for the currency associated to the data in the entries.
	CurrencyDecimalPlaces *int32 `json:"currency_decimal_places,omitempty"`

	// CurrencyId The currency ID of the currency associated to the data in the entries.
	CurrencyId     *string    `json:"currency_id,omitempty"`
	CurrencySymbol *string    `json:"currency_symbol,omitempty"`
	EndDate        *time.Time `json:"end_date,omitempty"`

	// Entries The actual entries for this data set. They 'key' value is the label for the data point. The value is the actual (numerical) value.
	Entries *map[string]interface{} `json:"entries,omitempty"`

	// Label This is the title of the current set. It can refer to an account, a budget or another object (by name).
	Label     *string    `json:"label,omitempty"`
	StartDate *time.Time `json:"start_date,omitempty"`

	// Type Indicated the type of chart that is expected to be rendered. You can safely ignore this if you want.
	Type *string `json:"type,omitempty"`

	// YAxisID Used to indicate the Y axis for this data set. Is usually between 0 and 1 (left and right side of the chart).
	YAxisID *int32 `json:"yAxisID,omitempty"`
}

// ChartLine defines model for ChartLine.
type ChartLine = []ChartDataSet

// ConfigValueFilter Title of the configuration value.
type ConfigValueFilter string

// ConfigValueUpdateFilter defines model for ConfigValueUpdateFilter.
type ConfigValueUpdateFilter string

// Configuration defines model for Configuration.
type Configuration struct {
	// Editable If this config variable can be edited by the user
	Editable bool `json:"editable"`

	// Title Title of the configuration value.
	Title ConfigValueFilter   `json:"title"`
	Value PolymorphicProperty `json:"value"`
}

// ConfigurationArray defines model for ConfigurationArray.
type ConfigurationArray = []Configuration

// ConfigurationSingle defines model for ConfigurationSingle.
type ConfigurationSingle struct {
	Data Configuration `json:"data"`
}

// ConfigurationUpdate defines model for ConfigurationUpdate.
type ConfigurationUpdate struct {
	Value PolymorphicProperty `json:"value"`
}

// CreditCardTypeProperty Mandatory when the account_role is ccAsset. Can only be monthlyFull or null.
type CreditCardTypeProperty string

// CronResult defines model for CronResult.
type CronResult struct {
	AutoBudgets           *CronResultRow `json:"auto_budgets,omitempty"`
	RecurringTransactions *CronResultRow `json:"recurring_transactions,omitempty"`
	Telemetry             *CronResultRow `json:"telemetry,omitempty"`
}

// CronResultRow defines model for CronResultRow.
type CronResultRow struct {
	// JobErrored If the cron job ran into some kind of an error, this value will be true.
	JobErrored *bool `json:"job_errored"`

	// JobFired This value tells you if this specific cron job actually fired. It may not fire. Some cron jobs
	// only fire every 24 hours, for example.
	JobFired *bool `json:"job_fired"`

	// JobSucceeded This value tells you if this specific cron job actually did something. The job may fire but not
	// change anything.
	JobSucceeded *bool `json:"job_succeeded"`

	// Message If the cron job ran into some kind of an error, this value will be the error message. The success message
	// if the job actually ran OK.
	Message *string `json:"message"`
}

// Currency defines model for Currency.
type Currency struct {
	Code      string     `json:"code"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DecimalPlaces Supports 0-16 decimals.
	DecimalPlaces *int32 `json:"decimal_places,omitempty"`

	// Default Make this currency the default currency.
	Default *bool `json:"default,omitempty"`

	// Enabled Defaults to true
	Enabled   *bool      `json:"enabled,omitempty"`
	Name      string     `json:"name"`
	Symbol    string     `json:"symbol"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// CurrencyArray defines model for CurrencyArray.
type CurrencyArray struct {
	Data  []CurrencyRead `json:"data"`
	Links PageLink       `json:"links"`
	Meta  Meta           `json:"meta"`
}

// CurrencyRead defines model for CurrencyRead.
type CurrencyRead struct {
	Attributes Currency `json:"attributes"`
	Id         string   `json:"id"`

	// Type Immutable value
	Type string `json:"type"`
}

// CurrencySingle defines model for CurrencySingle.
type CurrencySingle struct {
	Data CurrencyRead `json:"data"`
}

// CurrencyStore defines model for CurrencyStore.
type CurrencyStore struct {
	Code string `json:"code"`

	// DecimalPlaces Supports 0-16 decimals.
	DecimalPlaces *int32 `json:"decimal_places,omitempty"`

	// Default Make this currency the default currency. You can set this value to FALSE, in which case nothing will change to the default currency. If you set it to TRUE, the current default currency will no longer be the default currency.
	Default *bool `json:"default,omitempty"`

	// Enabled Defaults to true
	Enabled *bool  `json:"enabled,omitempty"`
	Name    string `json:"name"`
	Symbol  string `json:"symbol"`
}

// CurrencyUpdate defines model for CurrencyUpdate.
type CurrencyUpdate struct {
	// Code The currency code
	Code *string `json:"code,omitempty"`

	// DecimalPlaces How many decimals to use when displaying this currency. Between 0 and 16.
	DecimalPlaces *int32 `json:"decimal_places,omitempty"`

	// Default If the currency must be the default for the user. You can only submit TRUE. Submitting FALSE will not drop this currency as the default currency, because then the system would be without one.
	Default *CurrencyUpdateDefault `json:"default,omitempty"`

	// Enabled If the currency is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Name The currency name
	Name *string `json:"name,omitempty"`

	// Symbol The currency symbol
	Symbol *string `json:"symbol,omitempty"`
}

// CurrencyUpdateDefault If the currency must be the default for the user. You can only submit TRUE. Submitting FALSE will not drop this currency as the default currency, because then the system would be without one.
type CurrencyUpdateDefault bool

// DataDestroyObject defines model for DataDestroyObject.
type DataDestroyObject string

// ExportFileFilter defines model for ExportFileFilter.
type ExportFileFilter string

// InsightGroup defines model for InsightGroup.
type InsightGroup = []InsightGroupEntry

// InsightGroupEntry defines model for InsightGroupEntry.
type InsightGroupEntry struct {
	// CurrencyCode The currency code of the expenses listed for this account.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyId The currency ID of the expenses listed for this account.
	CurrencyId *string `json:"currency_id,omitempty"`

	// Difference The amount spent or earned between start date and end date, a number defined as a string, for this object and all asset accounts.
	Difference *string `json:"difference,omitempty"`

	// DifferenceFloat The amount spent or earned between start date and end date, a number as a float, for this object and all asset accounts. May have rounding errors.
	DifferenceFloat *float64 `json:"difference_float,omitempty"`

	// Id This ID is a reference to the original object.
	Id *string `json:"id,omitempty"`

	// Name This is the name of the object.
	Name *string `json:"name,omitempty"`
}

// InsightTotal defines model for InsightTotal.
type InsightTotal = []InsightTotalEntry

// InsightTotalEntry defines model for InsightTotalEntry.
type InsightTotalEntry struct {
	// CurrencyCode The currency code of the expenses listed for this expense account.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyId The currency ID of the expenses listed for this expense account.
	CurrencyId *string `json:"currency_id,omitempty"`

	// Difference The amount spent between start date and end date, defined as a string, for this expense account and all asset accounts.
	Difference *string `json:"difference,omitempty"`

	// DifferenceFloat The amount spent between start date and end date, defined as a string, for this expense account and all asset accounts. This number is a float (double) and may have rounding errors.
	DifferenceFloat *float64 `json:"difference_float,omitempty"`
}

// InsightTransfer defines model for InsightTransfer.
type InsightTransfer = []InsightTransferEntry

// InsightTransferEntry defines model for InsightTransferEntry.
type InsightTransferEntry struct {
	// CurrencyCode The currency code of the expenses listed for this account.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyId The currency ID of the expenses listed for this account.
	CurrencyId *string `json:"currency_id,omitempty"`

	// Difference The total amount transferred between start date and end date, a number defined as a string, for this asset account.
	Difference *string `json:"difference,omitempty"`

	// DifferenceFloat The total amount transferred between start date and end date, a number as a float, for this asset account. May have rounding errors.
	DifferenceFloat *float64 `json:"difference_float,omitempty"`

	// Id This ID is a reference to the original object.
	Id *string `json:"id,omitempty"`

	// In The total amount transferred TO this account between start date and end date, a number defined as a string, for this asset account.
	In *string `json:"in,omitempty"`

	// InFloat The total amount transferred FROM this account between start date and end date, a number as a float, for this asset account. May have rounding errors.
	InFloat *float64 `json:"in_float,omitempty"`

	// Name This is the name of the object.
	Name *string `json:"name,omitempty"`

	// Out The total amount transferred FROM this account between start date and end date, a number defined as a string, for this asset account.
	Out *string `json:"out,omitempty"`

	// OutFloat The total amount transferred TO this account between start date and end date, a number as a float, for this asset account. May have rounding errors.
	OutFloat *float64 `json:"out_float,omitempty"`
}

// InterestPeriodProperty Mandatory when type is liability. Period over which the interest is calculated.
type InterestPeriodProperty string

// InternalExceptionResponse defines model for InternalExceptionResponse.
type InternalExceptionResponse struct {
	Exception *string `json:"exception,omitempty"`
	Message   *string `json:"message,omitempty"`
}

// LiabilityDirectionProperty 'credit' indicates somebody owes you the liability. 'debit' Indicates you owe this debt yourself. Works only for liabiltiies.
type LiabilityDirectionProperty string

// LiabilityTypeProperty Mandatory when type is liability. Specifies the exact type.
type LiabilityTypeProperty string

// LinkType defines model for LinkType.
type LinkType struct {
	Editable *bool  `json:"editable,omitempty"`
	Inward   string `json:"inward"`
	Name     string `json:"name"`
	Outward  string `json:"outward"`
}

// LinkTypeArray defines model for LinkTypeArray.
type LinkTypeArray struct {
	Data  []LinkTypeRead `json:"data"`
	Links PageLink       `json:"links"`
	Meta  Meta           `json:"meta"`
}

// LinkTypeRead defines model for LinkTypeRead.
type LinkTypeRead struct {
	Attributes LinkType   `json:"attributes"`
	Id         string     `json:"id"`
	Links      ObjectLink `json:"links"`

	// Type Immutable value
	Type string `json:"type"`
}

// LinkTypeSingle defines model for LinkTypeSingle.
type LinkTypeSingle struct {
	Data LinkTypeRead `json:"data"`
}

// LinkTypeUpdate defines model for LinkTypeUpdate.
type LinkTypeUpdate struct {
	Inward  *string `json:"inward,omitempty"`
	Name    *string `json:"name,omitempty"`
	Outward *string `json:"outward,omitempty"`
}

// Meta defines model for Meta.
type Meta struct {
	Pagination *struct {
		Count       *int `json:"count,omitempty"`
		CurrentPage *int `json:"current_page,omitempty"`
		PerPage     *int `json:"per_page,omitempty"`
		Total       *int `json:"total,omitempty"`
		TotalPages  *int `json:"total_pages,omitempty"`
	} `json:"pagination,omitempty"`
}

// NotFoundResponse defines model for NotFoundResponse.
type NotFoundResponse struct {
	Exception *string `json:"exception,omitempty"`
	Message   *string `json:"message,omitempty"`
}

// ObjectGroup defines model for ObjectGroup.
type ObjectGroup struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Order Order of the object group
	Order     int32      `json:"order"`
	Title     string     `json:"title"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ObjectGroupArray defines model for ObjectGroupArray.
type ObjectGroupArray struct {
	Data []ObjectGroupRead `json:"data"`
	Meta Meta              `json:"meta"`
}

// ObjectGroupRead defines model for ObjectGroupRead.
type ObjectGroupRead struct {
	Attributes ObjectGroup `json:"attributes"`
	Id         string      `json:"id"`

	// Type Immutable value
	Type string `json:"type"`
}

// ObjectGroupSingle defines model for ObjectGroupSingle.
type ObjectGroupSingle struct {
	Data ObjectGroupRead `json:"data"`
}

// ObjectGroupUpdate defines model for ObjectGroupUpdate.
type ObjectGroupUpdate struct {
	// Order Order of the object group
	Order *int32 `json:"order,omitempty"`
	Title string `json:"title"`
}

// ObjectLink defines model for ObjectLink.
type ObjectLink struct {
	N0 *struct {
		Rel *string `json:"rel,omitempty"`
		Uri *string `json:"uri,omitempty"`
	} `json:"0,omitempty"`
	Self *string `json:"self,omitempty"`
}

// PageLink defines model for PageLink.
type PageLink struct {
	First *string `json:"first,omitempty"`
	Last  *string `json:"last,omitempty"`
	Next  *string `json:"next"`
	Prev  *string `json:"prev"`
	Self  *string `json:"self,omitempty"`
}

// PiggyBank defines model for PiggyBank.
type PiggyBank struct {
	// AccountId The ID of the asset account this piggy bank is connected to.
	AccountId string `json:"account_id"`

	// AccountName The name of the asset account this piggy bank is connected to.
	AccountName  *string    `json:"account_name,omitempty"`
	Active       *bool      `json:"active,omitempty"`
	CreatedAt    *time.Time `json:"created_at,omitempty"`
	CurrencyCode *string    `json:"currency_code,omitempty"`

	// CurrencyDecimalPlaces Number of decimals supported by the currency
	CurrencyDecimalPlaces *int32  `json:"currency_decimal_places,omitempty"`
	CurrencyId            *string `json:"currency_id,omitempty"`
	CurrencySymbol        *string `json:"currency_symbol,omitempty"`
	CurrentAmount         *string `json:"current_amount,omitempty"`
	LeftToSave            *string `json:"left_to_save"`
	Name                  string  `json:"name"`
	Notes                 *string `json:"notes"`

	// ObjectGroupId The group ID of the group this object is part of. NULL if no group.
	ObjectGroupId *string `json:"object_group_id"`

	// ObjectGroupOrder The order of the group. At least 1, for the highest sorting.
	ObjectGroupOrder *int32 `json:"object_group_order"`

	// ObjectGroupTitle The name of the group. NULL if no group.
	ObjectGroupTitle *string  `json:"object_group_title"`
	Order            *int32   `json:"order,omitempty"`
	Percentage       *float32 `json:"percentage"`
	SavePerMonth     *string  `json:"save_per_month"`

	// StartDate The date you started with this piggy bank.
	StartDate    *openapi_types.Date `json:"start_date,omitempty"`
	TargetAmount *string             `json:"target_amount"`

	// TargetDate The date you intend to finish saving money.
	TargetDate *openapi_types.Date `json:"target_date"`
	UpdatedAt  *time.Time          `json:"updated_at,omitempty"`
}

// PiggyBankArray defines model for PiggyBankArray.
type PiggyBankArray struct {
	Data  []PiggyBankRead `json:"data"`
	Links PageLink        `json:"links"`
	Meta  Meta            `json:"meta"`
}

// PiggyBankEvent defines model for PiggyBankEvent.
type PiggyBankEvent struct {
	Amount                *string    `json:"amount,omitempty"`
	CreatedAt             *time.Time `json:"created_at,omitempty"`
	CurrencyCode          *string    `json:"currency_code,omitempty"`
	CurrencyDecimalPlaces *int32     `json:"currency_decimal_places,omitempty"`
	CurrencyId            *string    `json:"currency_id,omitempty"`
	CurrencySymbol        *string    `json:"currency_symbol,omitempty"`

	// TransactionGroupId The transaction group associated with the event.
	TransactionGroupId *string `json:"transaction_group_id"`

	// TransactionJournalId The journal associated with the event.
	TransactionJournalId *string    `json:"transaction_journal_id"`
	UpdatedAt            *time.Time `json:"updated_at,omitempty"`
}

// PiggyBankEventArray defines model for PiggyBankEventArray.
type PiggyBankEventArray struct {
	Data  []PiggyBankEventRead `json:"data"`
	Links PageLink             `json:"links"`
	Meta  Meta                 `json:"meta"`
}

// PiggyBankEventRead defines model for PiggyBankEventRead.
type PiggyBankEventRead struct {
	Attributes PiggyBankEvent `json:"attributes"`
	Id         string         `json:"id"`
	Links      ObjectLink     `json:"links"`

	// Type Immutable value
	Type string `json:"type"`
}

// PiggyBankRead defines model for PiggyBankRead.
type PiggyBankRead struct {
	Attributes PiggyBank  `json:"attributes"`
	Id         string     `json:"id"`
	Links      ObjectLink `json:"links"`

	// Type Immutable value
	Type string `json:"type"`
}

// PiggyBankSingle defines model for PiggyBankSingle.
type PiggyBankSingle struct {
	Data PiggyBankRead `json:"data"`
}

// PiggyBankStore defines model for PiggyBankStore.
type PiggyBankStore struct {
	// AccountId The ID of the asset account this piggy bank is connected to.
	AccountId     string  `json:"account_id"`
	Active        *bool   `json:"active,omitempty"`
	CurrentAmount *string `json:"current_amount,omitempty"`
	Name          string  `json:"name"`
	Notes         *string `json:"notes"`

	// ObjectGroupId The group ID of the group this object is part of. NULL if no group.
	ObjectGroupId *string `json:"object_group_id"`

	// ObjectGroupTitle The name of the group. NULL if no group.
	ObjectGroupTitle *string `json:"object_group_title"`
	Order            *int32  `json:"order,omitempty"`

	// StartDate The date you started with this piggy bank.
	StartDate    *openapi_types.Date `json:"start_date,omitempty"`
	TargetAmount *string             `json:"target_amount"`

	// TargetDate The date you intend to finish saving money.
	TargetDate *openapi_types.Date `json:"target_date"`
}

// PiggyBankUpdate defines model for PiggyBankUpdate.
type PiggyBankUpdate struct {
	// AccountId The ID of the asset account this piggy bank is connected to.
	AccountId     *string `json:"account_id,omitempty"`
	Active        *bool   `json:"active,omitempty"`
	CurrencyCode  *string `json:"currency_code,omitempty"`
	CurrencyId    *string `json:"currency_id,omitempty"`
	CurrentAmount *string `json:"current_amount,omitempty"`
	Name          *string `json:"name,omitempty"`
	Notes         *string `json:"notes"`

	// ObjectGroupId The group ID of the group this object is part of. NULL if no group.
	ObjectGroupId *string `json:"object_group_id"`

	// ObjectGroupTitle The name of the group. NULL if no group.
	ObjectGroupTitle *string `json:"object_group_title"`
	Order            *int32  `json:"order,omitempty"`

	// StartDate The date you started with this piggy bank.
	StartDate    *openapi_types.Date `json:"start_date,omitempty"`
	TargetAmount *string             `json:"target_amount"`

	// TargetDate The date you intend to finish saving money.
	TargetDate *openapi_types.Date `json:"target_date"`
}

// PolymorphicProperty defines model for PolymorphicProperty.
type PolymorphicProperty struct {
	union json.RawMessage
}

// PolymorphicProperty0 defines model for .
type PolymorphicProperty0 = bool

// PolymorphicProperty1 defines model for .
type PolymorphicProperty1 = string

// PolymorphicProperty2 defines model for .
type PolymorphicProperty2 = map[string]interface{}

// PolymorphicProperty3 defines model for .
type PolymorphicProperty3 = []StringArrayItem

// Preference defines model for Preference.
type Preference struct {
	CreatedAt *time.Time          `json:"created_at,omitempty"`
	Data      PolymorphicProperty `json:"data"`
	Name      string              `json:"name"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
}

// PreferenceArray defines model for PreferenceArray.
type PreferenceArray struct {
	Data  []PreferenceRead `json:"data"`
	Links PageLink         `json:"links"`
	Meta  Meta             `json:"meta"`
}

// PreferenceRead defines model for PreferenceRead.
type PreferenceRead struct {
	Attributes Preference `json:"attributes"`
	Id         string     `json:"id"`

	// Type Immutable value
	Type string `json:"type"`
}

// PreferenceSingle defines model for PreferenceSingle.
type PreferenceSingle struct {
	Data PreferenceRead `json:"data"`
}

// PreferenceUpdate defines model for PreferenceUpdate.
type PreferenceUpdate struct {
	Data PolymorphicProperty `json:"data"`
}

// Recurrence defines model for Recurrence.
type Recurrence struct {
	// Active If the recurrence is even active.
	Active *bool `json:"active,omitempty"`

	// ApplyRules Whether or not to fire the rules after the creation of a transaction.
	ApplyRules *bool      `json:"apply_rules,omitempty"`
	CreatedAt  *time.Time `json:"created_at,omitempty"`

	// Description Not to be confused with the description of the actual transaction(s) being created.
	Description *string `json:"description,omitempty"`

	// FirstDate First time the recurring transaction will fire. Must be after today.
	FirstDate *openapi_types.Date `json:"first_date,omitempty"`

	// LatestDate Last time the recurring transaction has fired.
	LatestDate *openapi_types.Date `json:"latest_date"`
	Notes      *string             `json:"notes"`

	// NrOfRepetitions Max number of created transactions. Use either this field or repeat_until.
	NrOfRepetitions *int32 `json:"nr_of_repetitions"`

	// RepeatUntil Date until the recurring transaction can fire. Use either this field or repetitions.
	RepeatUntil  *openapi_types.Date        `json:"repeat_until"`
	Repetitions  *[]RecurrenceRepetition    `json:"repetitions,omitempty"`
	Title        *string                    `json:"title,omitempty"`
	Transactions *[]RecurrenceTransaction   `json:"transactions,omitempty"`
	Type         *RecurrenceTransactionType `json:"type,omitempty"`
	UpdatedAt    *time.Time                 `json:"updated_at,omitempty"`
}

// RecurrenceArray defines model for RecurrenceArray.
type RecurrenceArray struct {
	Data  []RecurrenceRead `json:"data"`
	Links PageLink         `json:"links"`
	Meta  Meta             `json:"meta"`
}

// RecurrenceRead defines model for RecurrenceRead.
type RecurrenceRead struct {
	Attributes Recurrence `json:"attributes"`
	Id         string     `json:"id"`
	Links      ObjectLink `json:"links"`

	// Type Immutable value
	Type string `json:"type"`
}

// RecurrenceRepetition defines model for RecurrenceRepetition.
type RecurrenceRepetition struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Description Auto-generated repetition description.
	Description *string `json:"description,omitempty"`
	Id          *string `json:"id,omitempty"`

	// Moment Information that defined the type of repetition.
	// - For 'daily', this is empty.
	// - For 'weekly', it is day of the week between 1 and 7 (Monday - Sunday).
	// - For 'ndom', it is '1,2' or '4,5' or something else, where the first number is the week in the month, and the second number is the day in the week (between 1 and 7). '2,3' means: the 2nd Wednesday of the month
	// - For 'monthly' it is the day of the month (1 - 31)
	// - For yearly, it is a full date, ie '2018-09-17'. The year you use does not matter.
	Moment string `json:"moment"`

	// Occurrences Array of future dates when the repetition will apply to. Auto generated.
	Occurrences *[]time.Time `json:"occurrences,omitempty"`

	// Skip How many occurrences to skip. 0 means skip nothing. 1 means every other.
	Skip *int32 `json:"skip,omitempty"`

	// Type The type of the repetition. ndom means: the n-th weekday of the month, where you can also specify which day of the week.
	Type      RecurrenceRepetitionType `json:"type"`
	UpdatedAt *time.Time               `json:"updated_at,omitempty"`

	// Weekend How to respond when the recurring transaction falls in the weekend. Possible values:
	// 1. Do nothing, just create it
	// 2. Create no transaction.
	// 3. Skip to the previous Friday.
	// 4. Skip to the next Monday.
	Weekend *int32 `json:"weekend,omitempty"`
}

// RecurrenceRepetitionStore defines model for RecurrenceRepetitionStore.
type RecurrenceRepetitionStore struct {
	// Moment Information that defined the type of repetition.
	// - For 'daily', this is empty.
	// - For 'weekly', it is day of the week between 1 and 7 (Monday - Sunday).
	// - For 'ndom', it is '1,2' or '4,5' or something else, where the first number is the week in the month, and the second number is the day in the week (between 1 and 7). '2,3' means: the 2nd Wednesday of the month
	// - For 'monthly' it is the day of the month (1 - 31)
	// - For yearly, it is a full date, ie '2018-09-17'. The year you use does not matter.
	Moment string `json:"moment"`

	// Skip How many occurrences to skip. 0 means skip nothing. 1 means every other.
	Skip *int32 `json:"skip,omitempty"`

	// Type The type of the repetition. ndom means: the n-th weekday of the month, where you can also specify which day of the week.
	Type RecurrenceRepetitionType `json:"type"`

	// Weekend How to respond when the recurring transaction falls in the weekend. Possible values:
	// 1. Do nothing, just create it
	// 2. Create no transaction.
	// 3. Skip to the previous Friday.
	// 4. Skip to the next Monday.
	Weekend *int32 `json:"weekend,omitempty"`
}

// RecurrenceRepetitionType The type of the repetition. ndom means: the n-th weekday of the month, where you can also specify which day of the week.
type RecurrenceRepetitionType string

// RecurrenceRepetitionUpdate defines model for RecurrenceRepetitionUpdate.
type RecurrenceRepetitionUpdate struct {
	// Moment Information that defined the type of repetition.
	// - For 'daily', this is empty.
	// - For 'weekly', it is day of the week between 1 and 7 (Monday - Sunday).
	// - For 'ndom', it is '1,2' or '4,5' or something else, where the first number is the week in the month, and the second number is the day in the week (between 1 and 7). '2,3' means: the 2nd Wednesday of the month
	// - For 'monthly' it is the day of the month (1 - 31)
	// - For yearly, it is a full date, ie '2018-09-17'. The year you use does not matter.
	Moment *string `json:"moment,omitempty"`

	// Skip How many occurrences to skip. 0 means skip nothing. 1 means every other.
	Skip *int32 `json:"skip,omitempty"`

	// Type The type of the repetition. ndom means: the n-th weekday of the month, where you can also specify which day of the week.
	Type *RecurrenceRepetitionType `json:"type,omitempty"`

	// Weekend How to respond when the recurring transaction falls in the weekend. Possible values:
	// 1. Do nothing, just create it
	// 2. Create no transaction.
	// 3. Skip to the previous Friday.
	// 4. Skip to the next Monday.
	Weekend *int32 `json:"weekend,omitempty"`
}

// RecurrenceSingle defines model for RecurrenceSingle.
type RecurrenceSingle struct {
	Data RecurrenceRead `json:"data"`
}

// RecurrenceStore defines model for RecurrenceStore.
type RecurrenceStore struct {
	// Active If the recurrence is even active.
	Active *bool `json:"active,omitempty"`

	// ApplyRules Whether or not to fire the rules after the creation of a transaction.
	ApplyRules *bool `json:"apply_rules,omitempty"`

	// Description Not to be confused with the description of the actual transaction(s) being created.
	Description *string `json:"description,omitempty"`

	// FirstDate First time the recurring transaction will fire. Must be after today.
	FirstDate openapi_types.Date `json:"first_date"`
	Notes     *string            `json:"notes"`

	// NrOfRepetitions Max number of created transactions. Use either this field or repeat_until.
	NrOfRepetitions *int32 `json:"nr_of_repetitions"`

	// RepeatUntil Date until the recurring transaction can fire. Use either this field or repetitions.
	RepeatUntil  *openapi_types.Date          `json:"repeat_until"`
	Repetitions  []RecurrenceRepetitionStore  `json:"repetitions"`
	Title        string                       `json:"title"`
	Transactions []RecurrenceTransactionStore `json:"transactions"`
	Type         RecurrenceTransactionType    `json:"type"`
}

// RecurrenceTransaction defines model for RecurrenceTransaction.
type RecurrenceTransaction struct {
	// Amount Amount of the transaction.
	Amount string `json:"amount"`

	// BillId Optional. Use either this or the bill_name
	BillId *string `json:"bill_id"`

	// BillName Optional. Use either this or the bill_id
	BillName *string `json:"bill_name"`

	// BudgetId The budget ID for this transaction.
	BudgetId *string `json:"budget_id,omitempty"`

	// BudgetName The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored.
	BudgetName *string `json:"budget_name"`

	// CategoryId Category ID for this transaction.
	CategoryId *string `json:"category_id,omitempty"`

	// CategoryName Category name for this transaction.
	CategoryName *string `json:"category_name,omitempty"`

	// CurrencyCode Submit either a currency_id or a currency_code.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyDecimalPlaces Number of decimals in the currency
	CurrencyDecimalPlaces *int32 `json:"currency_decimal_places,omitempty"`

	// CurrencyId Submit either a currency_id or a currency_code.
	CurrencyId      *string `json:"currency_id,omitempty"`
	CurrencySymbol  *string `json:"currency_symbol,omitempty"`
	Description     string  `json:"description"`
	DestinationIban *string `json:"destination_iban"`

	// DestinationId ID of the destination account. Submit either this or destination_name.
	DestinationId *string `json:"destination_id,omitempty"`

	// DestinationName Name of the destination account. Submit either this or destination_id.
	DestinationName *string              `json:"destination_name,omitempty"`
	DestinationType *AccountTypeProperty `json:"destination_type,omitempty"`

	// ForeignAmount Foreign amount of the transaction.
	ForeignAmount *string `json:"foreign_amount"`

	// ForeignCurrencyCode Submit either a foreign_currency_id or a foreign_currency_code, or neither.
	ForeignCurrencyCode *string `json:"foreign_currency_code"`

	// ForeignCurrencyDecimalPlaces Number of decimals in the currency
	ForeignCurrencyDecimalPlaces *int32 `json:"foreign_currency_decimal_places"`

	// ForeignCurrencyId Submit either a foreign_currency_id or a foreign_currency_code, or neither.
	ForeignCurrencyId     *string `json:"foreign_currency_id"`
	ForeignCurrencySymbol *string `json:"foreign_currency_symbol"`
	Id                    *string `json:"id,omitempty"`

	// PiggyBankId Optional. Use either this or the piggy_bank_name
	PiggyBankId *string `json:"piggy_bank_id"`

	// PiggyBankName Optional. Use either this or the piggy_bank_id
	PiggyBankName *string `json:"piggy_bank_name"`
	SourceIban    *string `json:"source_iban"`

	// SourceId ID of the source account. Submit either this or source_name.
	SourceId *string `json:"source_id,omitempty"`

	// SourceName Name of the source account. Submit either this or source_id.
	SourceName *string              `json:"source_name,omitempty"`
	SourceType *AccountTypeProperty `json:"source_type,omitempty"`

	// Tags Array of tags.
	Tags *[]string `json:"tags"`
}

// RecurrenceTransactionStore defines model for RecurrenceTransactionStore.
type RecurrenceTransactionStore struct {
	// Amount Amount of the transaction.
	Amount string `json:"amount"`

	// BillId Optional.
	BillId *string `json:"bill_id"`

	// BudgetId The budget ID for this transaction.
	BudgetId *string `json:"budget_id,omitempty"`

	// CategoryId Category ID for this transaction.
	CategoryId *string `json:"category_id,omitempty"`

	// CurrencyCode Submit either a currency_id or a currency_code.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyId Submit either a currency_id or a currency_code.
	CurrencyId  *string `json:"currency_id,omitempty"`
	Description string  `json:"description"`

	// DestinationId ID of the destination account.
	DestinationId string `json:"destination_id"`

	// ForeignAmount Foreign amount of the transaction.
	ForeignAmount *string `json:"foreign_amount"`

	// ForeignCurrencyCode Submit either a foreign_currency_id or a foreign_currency_code, or neither.
	ForeignCurrencyCode *string `json:"foreign_currency_code"`

	// ForeignCurrencyId Submit either a foreign_currency_id or a foreign_currency_code, or neither.
	ForeignCurrencyId *string `json:"foreign_currency_id"`

	// PiggyBankId Optional.
	PiggyBankId *string `json:"piggy_bank_id"`

	// SourceId ID of the source account.
	SourceId string `json:"source_id"`

	// Tags Array of tags.
	Tags *[]string `json:"tags"`
}

// RecurrenceTransactionType defines model for RecurrenceTransactionType.
type RecurrenceTransactionType string

// RecurrenceTransactionUpdate defines model for RecurrenceTransactionUpdate.
type RecurrenceTransactionUpdate struct {
	// Amount Amount of the transaction.
	Amount *string `json:"amount,omitempty"`

	// BillId Optional.
	BillId *string `json:"bill_id"`

	// BudgetId The budget ID for this transaction.
	BudgetId *string `json:"budget_id,omitempty"`

	// CategoryId Category ID for this transaction.
	CategoryId *string `json:"category_id,omitempty"`

	// CurrencyCode Submit either a currency_id or a currency_code.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CurrencyId Submit either a currency_id or a currency_code.
	CurrencyId  *string `json:"currency_id,omitempty"`
	Description *string `json:"description,omitempty"`

	// DestinationId ID of the destination account. Submit either this or destination_name.
	DestinationId *string `json:"destination_id,omitempty"`

	// ForeignAmount Foreign amount of the transaction.
	ForeignAmount *string `json:"foreign_amount"`

	// ForeignCurrencyId Submit either a foreign_currency_id or a foreign_currency_code, or neither.
	ForeignCurrencyId *string `json:"foreign_currency_id"`
	Id                string  `json:"id"`
	PiggyBankId       *string `json:"piggy_bank_id"`

	// SourceId ID of the source account. Submit either this or source_name.
	SourceId *string `json:"source_id,omitempty"`

	// Tags Array of tags.
	Tags *[]string `json:"tags"`
}

// RecurrenceUpdate defines model for RecurrenceUpdate.
type RecurrenceUpdate struct {
	// Active If the recurrence is even active.
	Active *bool `json:"active,omitempty"`

	// ApplyRules Whether or not to fire the rules after the creation of a transaction.
	ApplyRules *bool `json:"apply_rules,omitempty"`

	// Description Not to be confused with the description of the actual transaction(s) being created.
	Description *string `json:"description,omitempty"`

	// FirstDate First time the recurring transaction will fire.
	FirstDate *openapi_types.Date `json:"first_date,omitempty"`
	Notes     *string             `json:"notes"`

	// NrOfRepetitions Max number of created transactions. Use either this field or repeat_until.
	NrOfRepetitions *int32 `json:"nr_of_repetitions"`

	// RepeatUntil Date until the recurring transaction can fire. After that date, it's basically inactive. Use either this field or repetitions.
	RepeatUntil  *openapi_types.Date            `json:"repeat_until"`
	Repetitions  *[]RecurrenceRepetitionUpdate  `json:"repetitions,omitempty"`
	Title        *string                        `json:"title,omitempty"`
	Transactions *[]RecurrenceTransactionUpdate `json:"transactions,omitempty"`
}

// Rule defines model for Rule.
type Rule struct {
	Actions []RuleAction `json:"actions"`

	// Active Whether or not the rule is even active. Default is true.
	Active      *bool      `json:"active,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Description *string    `json:"description,omitempty"`
	Order       *int32     `json:"order,omitempty"`

	// RuleGroupId ID of the rule group under which the rule must be stored. Either this field or rule_group_title is mandatory.
	RuleGroupId string `json:"rule_group_id"`

	// RuleGroupTitle Title of the rule group under which the rule must be stored. Either this field or rule_group_id is mandatory.
	RuleGroupTitle *string `json:"rule_group_title,omitempty"`

	// StopProcessing If this value is true and the rule is triggered, other rules  after this one in the group will be skipped. Default value is false.
	StopProcessing *bool `json:"stop_processing,omitempty"`

	// Strict If the rule is set to be strict, ALL triggers must hit in order for the rule to fire. Otherwise, just one is enough. Default value is true.
	Strict *bool  `json:"strict,omitempty"`
	Title  string `json:"title"`

	// Trigger Which action is necessary for the rule to fire? Use either store-journal or update-journal.
	Trigger   RuleTriggerType `json:"trigger"`
	Triggers  []RuleTrigger   `json:"triggers"`
	UpdatedAt *time.Time      `json:"updated_at,omitempty"`
}

// RuleAction defines model for RuleAction.
type RuleAction struct {
	// Active If the action is active. Defaults to true.
	Active    *bool      `json:"active,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Id        *string    `json:"id,omitempty"`

	// Order Order of the action
	Order *int32 `json:"order,omitempty"`

	// StopProcessing When true, other actions will not be fired after this action has fired. Defaults to false.
	StopProcessing *bool `json:"stop_processing,omitempty"`

	// Type The type of thing this action will do. A limited set is possible.
	Type      RuleActionKeyword `json:"type"`
	UpdatedAt *time.Time        `json:"updated_at,omitempty"`

	// Value The accompanying value the action will set, change or update. Can be empty, but for some types this value is mandatory.
	Value *string `json:"value"`
}

// RuleActionKeyword The type of thing this action will do. A limited set is possible.
type RuleActionKeyword string

// RuleActionStore defines model for RuleActionStore.
type RuleActionStore struct {
	// Active If the action is active. Defaults to true.
	Active *bool `json:"active,omitempty"`

	// Order Order of the action
	Order *int32 `json:"order,omitempty"`

	// StopProcessing When true, other actions will not be fired after this action has fired. Defaults to false.
	StopProcessing *bool `json:"stop_processing,omitempty"`

	// Type The type of thing this action will do. A limited set is possible.
	Type RuleActionKeyword `json:"type"`

	// Value The accompanying value the action will set, change or update. Can be empty, but for some types this value is mandatory.
	Value *string `json:"value"`
}

// RuleActionUpdate defines model for RuleActionUpdate.
type RuleActionUpdate struct {
	// Active If the action is active.
	Active *bool `json:"active,omitempty"`

	// Order Order of the action
	Order *int32 `json:"order,omitempty"`

	// StopProcessing When true, other actions will not be fired after this action has fired.
	StopProcessing *bool `json:"stop_processing,omitempty"`

	// Type The type of thing this action will do. A limited set is possible.
	Type *RuleActionKeyword `json:"type,omitempty"`

	// Value The accompanying value the action will set, change or update. Can be empty, but for some types this value is mandatory.
	Value *string `json:"value"`
}

// RuleArray defines model for RuleArray.
type RuleArray struct {
	Data  []RuleRead `json:"data"`
	Links PageLink   `json:"links"`
	Meta  Meta       `json:"meta"`
}

// RuleGroup defines model for RuleGroup.
type RuleGroup struct {
	Active      *bool      `json:"active,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Description *string    `json:"description"`
	Order       *int32     `json:"order,omitempty"`
	Title       string     `json:"title"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
}

// RuleGroupArray defines model for RuleGroupArray.
type RuleGroupArray struct {
	Data  []RuleGroupRead `json:"data"`
	Links PageLink        `json:"links"`
	Meta  Meta            `json:"meta"`
}

// RuleGroupRead defines model for RuleGroupRead.
type RuleGroupRead struct {
	Attributes RuleGroup  `json:"attributes"`
	Id         string     `json:"id"`
	Links      ObjectLink `json:"links"`

	// Type Immutable value
	Type string `json:"type"`
}

// RuleGroupSingle defines model for RuleGroupSingle.
type RuleGroupSingle struct {
	Data RuleGroupRead `json:"data"`
}

// RuleGroupStore defines model for RuleGroupStore.
type RuleGroupStore struct {
	Active      *bool   `json:"active,omitempty"`
	Description *string `json:"description"`
	Order       *int32  `json:"order,omitempty"`
	Title       string  `json:"title"`
}

// RuleGroupUpdate defines model for RuleGroupUpdate.
type RuleGroupUpdate struct {
	Active      *bool   `json:"active,omitempty"`
	Description *string `json:"description"`
	Order       *int32  `json:"order,omitempty"`
	Title       *string `json:"title,omitempty"`
}

// RuleRead defines model for RuleRead.
type RuleRead struct {
	Attributes Rule       `json:"attributes"`
	Id         string     `json:"id"`
	Links      ObjectLink `json:"links"`

	// Type Immutable value
	Type string `json:"type"`
}

// RuleSingle defines model for RuleSingle.
type RuleSingle struct {
	Data RuleRead `json:"data"`
}

// RuleStore defines model for RuleStore.
type RuleStore struct {
	Actions []RuleActionStore `json:"actions"`

	// Active Whether or not the rule is even active. Default is true.
	Active      *bool   `json:"active,omitempty"`
	Description *string `json:"description,omitempty"`
	Order       *int32  `json:"order,omitempty"`

	// RuleGroupId ID of the rule group under which the rule must be stored. Either this field or rule_group_title is mandatory.
	RuleGroupId string `json:"rule_group_id"`

	// RuleGroupTitle Title of the rule group under which the rule must be stored. Either this field or rule_group_id is mandatory.
	RuleGroupTitle *string `json:"rule_group_title,omitempty"`

	// StopProcessing If this value is true and the rule is triggered, other rules  after this one in the group will be skipped. Default value is false.
	StopProcessing *bool `json:"stop_processing,omitempty"`

	// Strict If the rule is set to be strict, ALL triggers must hit in order for the rule to fire. Otherwise, just one is enough. Default value is true.
	Strict *bool  `json:"strict,omitempty"`
	Title  string `json:"title"`

	// Trigger Which action is necessary for the rule to fire? Use either store-journal or update-journal.
	Trigger  RuleTriggerType    `json:"trigger"`
	Triggers []RuleTriggerStore `json:"triggers"`
}

// RuleTrigger defines model for RuleTrigger.
type RuleTrigger struct {
	// Active If the trigger is active. Defaults to true.
	Active    *bool      `json:"active,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Id        *string    `json:"id,omitempty"`

	// Order Order of the trigger
	Order *int32 `json:"order,omitempty"`

	// Prohibited If 'prohibited' is true, this rule trigger will be negated. 'Description is' will become 'Description is NOT' etc.
	Prohibited *bool `json:"prohibited,omitempty"`

	// StopProcessing When true, other triggers will not be checked if this trigger was triggered. Defaults to false.
	StopProcessing *bool `json:"stop_processing,omitempty"`

	// Type The type of thing this trigger responds to. A limited set is possible
	Type      RuleTriggerKeyword `json:"type"`
	UpdatedAt *time.Time         `json:"updated_at,omitempty"`

	// Value The accompanying value the trigger responds to. This value is often mandatory, but this depends on the trigger.
	Value string `json:"value"`
}

// RuleTriggerKeyword The type of thing this trigger responds to. A limited set is possible
type RuleTriggerKeyword string

// RuleTriggerStore defines model for RuleTriggerStore.
type RuleTriggerStore struct {
	// Active If the trigger is active. Defaults to true.
	Active *bool `json:"active,omitempty"`

	// Order Order of the trigger
	Order *int32 `json:"order,omitempty"`

	// Prohibited If 'prohibited' is true, this rule trigger will be negated. 'Description is' will become 'Description is NOT' etc.
	Prohibited *bool `json:"prohibited,omitempty"`

	// StopProcessing When true, other triggers will not be checked if this trigger was triggered. Defaults to false.
	StopProcessing *bool `json:"stop_processing,omitempty"`

	// Type The type of thing this trigger responds to. A limited set is possible
	Type RuleTriggerKeyword `json:"type"`

	// Value The accompanying value the trigger responds to. This value is often mandatory, but this depends on the trigger.
	Value string `json:"value"`
}

// RuleTriggerType Which action is necessary for the rule to fire? Use either store-journal or update-journal.
type RuleTriggerType string

// RuleTriggerUpdate defines model for RuleTriggerUpdate.
type RuleTriggerUpdate struct {
	// Active If the trigger is active.
	Active *bool `json:"active,omitempty"`

	// Order Order of the trigger
	Order *int32 `json:"order,omitempty"`

	// StopProcessing When true, other triggers will not be checked if this trigger was triggered.
	StopProcessing *bool `json:"stop_processing,omitempty"`

	// Type The type of thing this trigger responds to. A limited set is possible
	Type *RuleTriggerKeyword `json:"type,omitempty"`

	// Value The accompanying value the trigger responds to. This value is often mandatory, but this depends on the trigger. If the rule trigger is something like 'has any tag', submit the string 'true'.
	Value *string `json:"value,omitempty"`
}

// RuleUpdate defines model for RuleUpdate.
type RuleUpdate struct {
	Actions *[]RuleActionUpdate `json:"actions,omitempty"`

	// Active Whether or not the rule is even active. Default is true.
	Active      *bool   `json:"active,omitempty"`
	Description *string `json:"description,omitempty"`
	Order       *int32  `json:"order,omitempty"`

	// RuleGroupId ID of the rule group under which the rule must be stored. Either this field or rule_group_title is mandatory.
	RuleGroupId *string `json:"rule_group_id,omitempty"`

	// StopProcessing If this value is true and the rule is triggered, other rules  after this one in the group will be skipped. Default value is false.
	StopProcessing *bool `json:"stop_processing,omitempty"`

	// Strict If the rule is set to be strict, ALL triggers must hit in order for the rule to fire. Otherwise, just one is enough. Default value is true.
	Strict *bool   `json:"strict,omitempty"`
	Title  *string `json:"title,omitempty"`

	// Trigger Which action is necessary for the rule to fire? Use either store-journal or update-journal.
	Trigger  *RuleTriggerType     `json:"trigger,omitempty"`
	Triggers *[]RuleTriggerUpdate `json:"triggers,omitempty"`
}

// ShortAccountTypeProperty Can only be one one these account types. import, initial-balance and reconciliation cannot be set manually.
type ShortAccountTypeProperty string

// StringArrayItem The actual preference content.
type StringArrayItem = string

// SystemInfo defines model for SystemInfo.
type SystemInfo struct {
	Data *struct {
		// ApiVersion Same value as the version field.
		ApiVersion *string `json:"api_version,omitempty"`
		Driver     *string `json:"driver,omitempty"`
		Os         *string `json:"os,omitempty"`
		PhpVersion *string `json:"php_version,omitempty"`
		Version    *string `json:"version,omitempty"`
	} `json:"data,omitempty"`
}

// TagArray defines model for TagArray.
type TagArray struct {
	Data  []TagRead `json:"data"`
	Links PageLink  `json:"links"`
	Meta  Meta      `json:"meta"`
}

// TagModel defines model for TagModel.
type TagModel struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Date The date to which the tag is applicable.
	Date        *openapi_types.Date `json:"date"`
	Description *string             `json:"description"`

	// Latitude Latitude of the tag's location, if applicable. Can be used to draw a map.
	Latitude *float64 `json:"latitude"`

	// Longitude Latitude of the tag's location, if applicable. Can be used to draw a map.
	Longitude *float64 `json:"longitude"`

	// Tag The tag
	Tag       string     `json:"tag"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// ZoomLevel Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
	ZoomLevel *int32 `json:"zoom_level"`
}

// TagModelStore defines model for TagModelStore.
type TagModelStore struct {
	// Date The date to which the tag is applicable.
	Date        *openapi_types.Date `json:"date"`
	Description *string             `json:"description"`

	// Latitude Latitude of the tag's location, if applicable. Can be used to draw a map.
	Latitude *float64 `json:"latitude"`

	// Longitude Latitude of the tag's location, if applicable. Can be used to draw a map.
	Longitude *float64 `json:"longitude"`

	// Tag The tag
	Tag string `json:"tag"`

	// ZoomLevel Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
	ZoomLevel *int32 `json:"zoom_level"`
}

// TagModelUpdate defines model for TagModelUpdate.
type TagModelUpdate struct {
	// Date The date to which the tag is applicable.
	Date        *openapi_types.Date `json:"date"`
	Description *string             `json:"description"`

	// Latitude Latitude of the tag's location, if applicable. Can be used to draw a map.
	Latitude *float64 `json:"latitude"`

	// Longitude Latitude of the tag's location, if applicable. Can be used to draw a map.
	Longitude *float64 `json:"longitude"`

	// Tag The tag
	Tag *string `json:"tag,omitempty"`

	// ZoomLevel Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
	ZoomLevel *int32 `json:"zoom_level"`
}

// TagRead defines model for TagRead.
type TagRead struct {
	Attributes TagModel   `json:"attributes"`
	Id         string     `json:"id"`
	Links      ObjectLink `json:"links"`

	// Type Immutable value
	Type string `json:"type"`
}

// TagSingle defines model for TagSingle.
type TagSingle struct {
	Data TagRead `json:"data"`
}

// Transaction defines model for Transaction.
type Transaction struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// GroupTitle Title of the transaction if it has been split in more than one piece. Empty otherwise.
	GroupTitle   *string            `json:"group_title"`
	Transactions []TransactionSplit `json:"transactions"`
	UpdatedAt    *time.Time         `json:"updated_at,omitempty"`

	// User User ID
	User *string `json:"user,omitempty"`
}

// TransactionArray defines model for TransactionArray.
type TransactionArray struct {
	Data  []TransactionRead `json:"data"`
	Links PageLink          `json:"links"`
	Meta  Meta              `json:"meta"`
}

// TransactionLink defines model for TransactionLink.
type TransactionLink struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// InwardId The inward transaction transaction_journal_id for the link. This becomes the 'is paid by' transaction of the set.
	InwardId string `json:"inward_id"`

	// LinkTypeId The link type ID to use. You can also use the link_type_name field.
	LinkTypeId *string `json:"link_type_id,omitempty"`

	// LinkTypeName The link type name to use. You can also use the link_type_id field.
	LinkTypeName *string `json:"link_type_name,omitempty"`

	// Notes Optional. Some notes.
	Notes *string `json:"notes"`

	// OutwardId The outward transaction transaction_journal_id for the link. This becomes the 'pays for' transaction of the set.
	OutwardId string     `json:"outward_id"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// TransactionLinkArray defines model for TransactionLinkArray.
type TransactionLinkArray struct {
	Data  []TransactionLinkRead `json:"data"`
	Links PageLink              `json:"links"`
	Meta  Meta                  `json:"meta"`
}

// TransactionLinkRead defines model for TransactionLinkRead.
type TransactionLinkRead struct {
	Attributes TransactionLink `json:"attributes"`
	Id         string          `json:"id"`
	Links      ObjectLink      `json:"links"`

	// Type Immutable value
	Type string `json:"type"`
}

// TransactionLinkSingle defines model for TransactionLinkSingle.
type TransactionLinkSingle struct {
	Data TransactionLinkRead `json:"data"`
}

// TransactionLinkStore defines model for TransactionLinkStore.
type TransactionLinkStore struct {
	// InwardId The inward transaction transaction_journal_id for the link. This becomes the 'is paid by' transaction of the set.
	InwardId string `json:"inward_id"`

	// LinkTypeId The link type ID to use. You can also use the link_type_name field.
	LinkTypeId *string `json:"link_type_id,omitempty"`

	// LinkTypeName The link type name to use. You can also use the link_type_id field.
	LinkTypeName *string `json:"link_type_name,omitempty"`

	// Notes Optional. Some notes.
	Notes *string `json:"notes"`

	// OutwardId The outward transaction transaction_journal_id for the link. This becomes the 'pays for' transaction of the set.
	OutwardId string `json:"outward_id"`
}

// TransactionLinkUpdate defines model for TransactionLinkUpdate.
type TransactionLinkUpdate struct {
	// InwardId The inward transaction transaction_journal_id for the link. This becomes the 'is paid by' transaction of the set.
	InwardId *string `json:"inward_id,omitempty"`

	// LinkTypeId The link type ID to use. Use this field OR use the link_type_name field.
	LinkTypeId *string `json:"link_type_id,omitempty"`

	// LinkTypeName The link type name to use. Use this field OR use the link_type_id field.
	LinkTypeName *string `json:"link_type_name,omitempty"`

	// Notes Optional. Some notes. If you submit an empty string the current notes will be removed
	Notes *string `json:"notes"`

	// OutwardId The outward transaction transaction_journal_id for the link. This becomes the 'pays for' transaction of the set.
	OutwardId *string `json:"outward_id,omitempty"`
}

// TransactionRead defines model for TransactionRead.
type TransactionRead struct {
	Attributes Transaction `json:"attributes"`
	Id         string      `json:"id"`
	Links      ObjectLink  `json:"links"`

	// Type Immutable value
	Type string `json:"type"`
}

// TransactionSingle defines model for TransactionSingle.
type TransactionSingle struct {
	Data TransactionRead `json:"data"`
}

// TransactionSplit defines model for TransactionSplit.
type TransactionSplit struct {
	// Amount Amount of the transaction.
	Amount string `json:"amount"`

	// BillId Optional. Use either this or the bill_name
	BillId *string `json:"bill_id"`

	// BillName Optional. Use either this or the bill_id
	BillName *string    `json:"bill_name"`
	BookDate *time.Time `json:"book_date"`

	// BudgetId The budget ID for this transaction.
	BudgetId *string `json:"budget_id"`

	// BudgetName The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored.
	BudgetName *string `json:"budget_name"`

	// BunqPaymentId Internal ID of bunq transaction. DEPRECATED
	BunqPaymentId *string `json:"bunq_payment_id"`

	// CategoryId The category ID for this transaction.
	CategoryId *string `json:"category_id"`

	// CategoryName The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name.
	CategoryName *string `json:"category_name"`

	// CurrencyCode Currency code. Default is the source account's currency, or the user's default currency. Can be used instead of currency_id.
	CurrencyCode *string `json:"currency_code"`

	// CurrencyDecimalPlaces Number of decimals used in this currency.
	CurrencyDecimalPlaces *int32 `json:"currency_decimal_places,omitempty"`

	// CurrencyId Currency ID. Default is the source account's currency, or the user's default currency. Can be used instead of currency_code.
	CurrencyId     *string `json:"currency_id"`
	CurrencyName   *string `json:"currency_name,omitempty"`
	CurrencySymbol *string `json:"currency_symbol,omitempty"`

	// Date Date of the transaction
	Date time.Time `json:"date"`

	// Description Description of the transaction.
	Description     string  `json:"description"`
	DestinationIban *string `json:"destination_iban"`

	// DestinationId ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account.
	DestinationId *string `json:"destination_id"`

	// DestinationName Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough.
	DestinationName *string              `json:"destination_name"`
	DestinationType *AccountTypeProperty `json:"destination_type,omitempty"`
	DueDate         *time.Time           `json:"due_date"`

	// ExternalId Reference to external ID in other systems.
	ExternalId *string `json:"external_id"`

	// ExternalUrl External, custom URL for this transaction.
	ExternalUrl *string `json:"external_url"`

	// ForeignAmount The amount in a foreign currency.
	ForeignAmount *string `json:"foreign_amount"`

	// ForeignCurrencyCode Currency code of the foreign currency. Default is NULL. Can be used instead of the foreign_currency_id, but this or the ID is required when submitting a foreign amount.
	ForeignCurrencyCode *string `json:"foreign_currency_code"`

	// ForeignCurrencyDecimalPlaces Number of decimals in the currency
	ForeignCurrencyDecimalPlaces *int32 `json:"foreign_currency_decimal_places"`

	// ForeignCurrencyId Currency ID of the foreign currency. Default is null. Is required when you submit a foreign amount.
	ForeignCurrencyId     *string `json:"foreign_currency_id"`
	ForeignCurrencySymbol *string `json:"foreign_currency_symbol"`

	// HasAttachments If the transaction has attachments.
	HasAttachments *bool `json:"has_attachments,omitempty"`

	// ImportHashV2 Hash value of original import transaction (for duplicate detection).
	ImportHashV2 *string    `json:"import_hash_v2"`
	InterestDate *time.Time `json:"interest_date"`

	// InternalReference Reference to internal reference of other systems.
	InternalReference *string    `json:"internal_reference"`
	InvoiceDate       *time.Time `json:"invoice_date"`

	// Latitude Latitude of the transaction's location, if applicable. Can be used to draw a map.
	Latitude *float64 `json:"latitude"`

	// Longitude Latitude of the transaction's location, if applicable. Can be used to draw a map.
	Longitude *float64 `json:"longitude"`
	Notes     *string  `json:"notes"`

	// Order Order of this entry in the list of transactions.
	Order *int32 `json:"order"`

	// OriginalSource System generated identifier for original creator of transaction.
	OriginalSource *string    `json:"original_source"`
	PaymentDate    *time.Time `json:"payment_date"`
	ProcessDate    *time.Time `json:"process_date"`

	// Reconciled If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user.
	Reconciled *bool `json:"reconciled,omitempty"`

	// RecurrenceCount The # of the current transaction created under this recurrence.
	RecurrenceCount *int32 `json:"recurrence_count"`

	// RecurrenceId Reference to recurrence that made the transaction.
	RecurrenceId *string `json:"recurrence_id"`

	// RecurrenceTotal Total number of transactions expected to be created by this recurrence repetition. Will be 0 if infinite.
	RecurrenceTotal *int32 `json:"recurrence_total"`

	// SepaBatchId SEPA Batch ID
	SepaBatchId *string `json:"sepa_batch_id"`

	// SepaCc SEPA Clearing Code
	SepaCc *string `json:"sepa_cc"`

	// SepaCi SEPA Creditor Identifier
	SepaCi *string `json:"sepa_ci"`

	// SepaCountry SEPA Country
	SepaCountry *string `json:"sepa_country"`

	// SepaCtId SEPA end-to-end Identifier
	SepaCtId *string `json:"sepa_ct_id"`

	// SepaCtOp SEPA Opposing Account Identifier
	SepaCtOp *string `json:"sepa_ct_op"`

	// SepaDb SEPA mandate identifier
	SepaDb *string `json:"sepa_db"`

	// SepaEp SEPA External Purpose indicator
	SepaEp     *string `json:"sepa_ep"`
	SourceIban *string `json:"source_iban"`

	// SourceId ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account.
	SourceId *string `json:"source_id"`

	// SourceName Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name.
	SourceName *string              `json:"source_name"`
	SourceType *AccountTypeProperty `json:"source_type,omitempty"`

	// Tags Array of tags.
	Tags *[]string `json:"tags"`

	// TransactionJournalId ID of the underlying transaction journal. Each transaction consists of a transaction group (see the top ID) and one or more journals
	// making up the splits of the transaction.
	TransactionJournalId *string                 `json:"transaction_journal_id,omitempty"`
	Type                 TransactionTypeProperty `json:"type"`

	// User User ID
	User *string `json:"user,omitempty"`

	// ZoomLevel Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
	ZoomLevel *int32 `json:"zoom_level"`
}

// TransactionSplitStore defines model for TransactionSplitStore.
type TransactionSplitStore struct {
	// Amount Amount of the transaction.
	Amount string `json:"amount"`

	// BillId Optional. Use either this or the bill_name
	BillId *string `json:"bill_id"`

	// BillName Optional. Use either this or the bill_id
	BillName *string    `json:"bill_name"`
	BookDate *time.Time `json:"book_date"`

	// BudgetId The budget ID for this transaction.
	BudgetId *string `json:"budget_id"`

	// BudgetName The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored.
	BudgetName *string `json:"budget_name"`

	// BunqPaymentId Internal ID of bunq transaction. Field is no longer used but still works.
	BunqPaymentId *string `json:"bunq_payment_id"`

	// CategoryId The category ID for this transaction.
	CategoryId *string `json:"category_id"`

	// CategoryName The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name.
	CategoryName *string `json:"category_name"`

	// CurrencyCode Currency code. Default is the source account's currency, or the user's default currency. The value you submit may be overruled by the source or destination account.
	CurrencyCode *string `json:"currency_code"`

	// CurrencyId Currency ID. Default is the source account's currency, or the user's default currency. The value you submit may be overruled by the source or destination account.
	CurrencyId *string `json:"currency_id"`

	// Date Date of the transaction
	Date time.Time `json:"date"`

	// Description Description of the transaction.
	Description string `json:"description"`

	// DestinationId ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account.
	DestinationId *string `json:"destination_id"`

	// DestinationName Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough.
	DestinationName *string    `json:"destination_name"`
	DueDate         *time.Time `json:"due_date"`

	// ExternalId Reference to external ID in other systems.
	ExternalId *string `json:"external_id"`

	// ExternalUrl External, custom URL for this transaction.
	ExternalUrl *string `json:"external_url"`

	// ForeignAmount The amount in a foreign currency.
	ForeignAmount *string `json:"foreign_amount"`

	// ForeignCurrencyCode Currency code of the foreign currency. Default is NULL. Can be used instead of the foreign_currency_id, but this or the ID is required when submitting a foreign amount.
	ForeignCurrencyCode *string `json:"foreign_currency_code"`

	// ForeignCurrencyId Currency ID of the foreign currency. Default is null. Is required when you submit a foreign amount.
	ForeignCurrencyId *string    `json:"foreign_currency_id"`
	InterestDate      *time.Time `json:"interest_date"`

	// InternalReference Reference to internal reference of other systems.
	InternalReference *string    `json:"internal_reference"`
	InvoiceDate       *time.Time `json:"invoice_date"`
	Notes             *string    `json:"notes"`

	// Order Order of this entry in the list of transactions.
	Order       *int32     `json:"order"`
	PaymentDate *time.Time `json:"payment_date"`

	// PiggyBankId Optional. Use either this or the piggy_bank_name
	PiggyBankId *int32 `json:"piggy_bank_id"`

	// PiggyBankName Optional. Use either this or the piggy_bank_id
	PiggyBankName *string    `json:"piggy_bank_name"`
	ProcessDate   *time.Time `json:"process_date"`

	// Reconciled If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user.
	Reconciled *bool `json:"reconciled,omitempty"`

	// SepaBatchId SEPA Batch ID
	SepaBatchId *string `json:"sepa_batch_id"`

	// SepaCc SEPA Clearing Code
	SepaCc *string `json:"sepa_cc"`

	// SepaCi SEPA Creditor Identifier
	SepaCi *string `json:"sepa_ci"`

	// SepaCountry SEPA Country
	SepaCountry *string `json:"sepa_country"`

	// SepaCtId SEPA end-to-end Identifier
	SepaCtId *string `json:"sepa_ct_id"`

	// SepaCtOp SEPA Opposing Account Identifier
	SepaCtOp *string `json:"sepa_ct_op"`

	// SepaDb SEPA mandate identifier
	SepaDb *string `json:"sepa_db"`

	// SepaEp SEPA External Purpose indicator
	SepaEp *string `json:"sepa_ep"`

	// SourceId ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account.
	SourceId *string `json:"source_id"`

	// SourceName Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name.
	SourceName *string `json:"source_name"`

	// Tags Array of tags.
	Tags *[]string               `json:"tags"`
	Type TransactionTypeProperty `json:"type"`
}

// TransactionSplitUpdate defines model for TransactionSplitUpdate.
type TransactionSplitUpdate struct {
	// Amount Amount of the transaction.
	Amount *string `json:"amount,omitempty"`

	// BillId Optional. Use either this or the bill_name
	BillId *string `json:"bill_id"`

	// BillName Optional. Use either this or the bill_id
	BillName *string    `json:"bill_name"`
	BookDate *time.Time `json:"book_date"`

	// BudgetId The budget ID for this transaction.
	BudgetId *string `json:"budget_id"`

	// BudgetName The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored.
	BudgetName *string `json:"budget_name"`

	// BunqPaymentId Internal ID of bunq transaction.
	BunqPaymentId *string `json:"bunq_payment_id"`

	// CategoryId The category ID for this transaction.
	CategoryId *string `json:"category_id"`

	// CategoryName The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name.
	CategoryName *string `json:"category_name"`

	// CurrencyCode Currency code. Default is the source account's currency, or the user's default currency. Can be used instead of currency_id.
	CurrencyCode *string `json:"currency_code"`

	// CurrencyDecimalPlaces Number of decimals used in this currency.
	CurrencyDecimalPlaces *int32 `json:"currency_decimal_places,omitempty"`

	// CurrencyId Currency ID. Default is the source account's currency, or the user's default currency. Can be used instead of currency_code.
	CurrencyId     *string `json:"currency_id"`
	CurrencyName   *string `json:"currency_name,omitempty"`
	CurrencySymbol *string `json:"currency_symbol,omitempty"`

	// Date Date of the transaction
	Date *time.Time `json:"date,omitempty"`

	// Description Description of the transaction.
	Description     *string `json:"description,omitempty"`
	DestinationIban *string `json:"destination_iban"`

	// DestinationId ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account.
	DestinationId *string `json:"destination_id"`

	// DestinationName Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough.
	DestinationName *string    `json:"destination_name"`
	DueDate         *time.Time `json:"due_date"`

	// ExternalId Reference to external ID in other systems.
	ExternalId *string `json:"external_id"`

	// ExternalUrl External, custom URL for this transaction.
	ExternalUrl *string `json:"external_url"`

	// ForeignAmount The amount in a foreign currency.
	ForeignAmount *string `json:"foreign_amount"`

	// ForeignCurrencyCode Currency code of the foreign currency. Default is NULL. Can be used instead of the foreign_currency_id, but this or the ID is required when submitting a foreign amount.
	ForeignCurrencyCode *string `json:"foreign_currency_code"`

	// ForeignCurrencyDecimalPlaces Number of decimals in the currency
	ForeignCurrencyDecimalPlaces *int32 `json:"foreign_currency_decimal_places"`

	// ForeignCurrencyId Currency ID of the foreign currency. Default is null. Is required when you submit a foreign amount.
	ForeignCurrencyId     *string    `json:"foreign_currency_id"`
	ForeignCurrencySymbol *string    `json:"foreign_currency_symbol"`
	InterestDate          *time.Time `json:"interest_date"`

	// InternalReference Reference to internal reference of other systems.
	InternalReference *string    `json:"internal_reference"`
	InvoiceDate       *time.Time `json:"invoice_date"`
	Notes             *string    `json:"notes"`

	// Order Order of this entry in the list of transactions.
	Order       *int32     `json:"order"`
	PaymentDate *time.Time `json:"payment_date"`
	ProcessDate *time.Time `json:"process_date"`

	// Reconciled If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user.
	Reconciled *bool `json:"reconciled,omitempty"`

	// SepaBatchId SEPA Batch ID
	SepaBatchId *string `json:"sepa_batch_id"`

	// SepaCc SEPA Clearing Code
	SepaCc *string `json:"sepa_cc"`

	// SepaCi SEPA Creditor Identifier
	SepaCi *string `json:"sepa_ci"`

	// SepaCountry SEPA Country
	SepaCountry *string `json:"sepa_country"`

	// SepaCtId SEPA end-to-end Identifier
	SepaCtId *string `json:"sepa_ct_id"`

	// SepaCtOp SEPA Opposing Account Identifier
	SepaCtOp *string `json:"sepa_ct_op"`

	// SepaDb SEPA mandate identifier
	SepaDb *string `json:"sepa_db"`

	// SepaEp SEPA External Purpose indicator
	SepaEp     *string `json:"sepa_ep"`
	SourceIban *string `json:"source_iban"`

	// SourceId ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account.
	SourceId *string `json:"source_id"`

	// SourceName Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name.
	SourceName *string `json:"source_name"`

	// Tags Array of tags.
	Tags *[]string `json:"tags"`

	// TransactionJournalId Transaction journal ID of current transaction (split).
	TransactionJournalId *string                  `json:"transaction_journal_id,omitempty"`
	Type                 *TransactionTypeProperty `json:"type,omitempty"`
}

// TransactionStore defines model for TransactionStore.
type TransactionStore struct {
	// ApplyRules Whether or not to apply rules when submitting transaction.
	ApplyRules *bool `json:"apply_rules,omitempty"`

	// ErrorIfDuplicateHash Break if the submitted transaction exists already.
	ErrorIfDuplicateHash *bool `json:"error_if_duplicate_hash,omitempty"`

	// FireWebhooks Whether or not to fire the webhooks that are related to this event.
	FireWebhooks *bool `json:"fire_webhooks,omitempty"`

	// GroupTitle Title of the transaction if it has been split in more than one piece. Empty otherwise.
	GroupTitle   *string                 `json:"group_title"`
	Transactions []TransactionSplitStore `json:"transactions"`
}

// TransactionTypeFilter defines model for TransactionTypeFilter.
type TransactionTypeFilter string

// TransactionTypeProperty defines model for TransactionTypeProperty.
type TransactionTypeProperty string

// TransactionUpdate defines model for TransactionUpdate.
type TransactionUpdate struct {
	// ApplyRules Whether or not to apply rules when submitting transaction.
	ApplyRules *bool `json:"apply_rules,omitempty"`

	// FireWebhooks Whether or not to fire the webhooks that are related to this event.
	FireWebhooks *bool `json:"fire_webhooks,omitempty"`

	// GroupTitle Title of the transaction if it has been split in more than one piece. Empty otherwise.
	GroupTitle   *string                   `json:"group_title"`
	Transactions *[]TransactionSplitUpdate `json:"transactions,omitempty"`
}

// UnauthenticatedResponse defines model for UnauthenticatedResponse.
type UnauthenticatedResponse struct {
	Exception *string `json:"exception,omitempty"`
	Message   *string `json:"message,omitempty"`
}

// User defines model for User.
type User struct {
	// Blocked Boolean to indicate if the user is blocked.
	Blocked *bool `json:"blocked,omitempty"`

	// BlockedCode If you say the user must be blocked, this will be the reason code.
	BlockedCode *UserBlockedCodeProperty `json:"blocked_code"`
	CreatedAt   *time.Time               `json:"created_at,omitempty"`

	// Email The new users email address.
	Email openapi_types.Email `json:"email"`

	// Role Role for the user. Can be empty or omitted.
	Role      *UserRoleProperty `json:"role"`
	UpdatedAt *time.Time        `json:"updated_at,omitempty"`
}

// UserArray defines model for UserArray.
type UserArray struct {
	Data  []UserRead `json:"data"`
	Links PageLink   `json:"links"`
	Meta  Meta       `json:"meta"`
}

// UserBlockedCodeProperty If you say the user must be blocked, this will be the reason code.
type UserBlockedCodeProperty string

// UserRead defines model for UserRead.
type UserRead struct {
	Attributes User       `json:"attributes"`
	Id         string     `json:"id"`
	Links      ObjectLink `json:"links"`

	// Type Immutable value
	Type string `json:"type"`
}

// UserRoleProperty Role for the user. Can be empty or omitted.
type UserRoleProperty string

// UserSingle defines model for UserSingle.
type UserSingle struct {
	Data UserRead `json:"data"`
}

// ValidationErrorResponse defines model for ValidationErrorResponse.
type ValidationErrorResponse struct {
	Errors *struct {
		Blocked     *[]string `json:"blocked,omitempty"`
		BlockedCode *[]string `json:"blocked_code,omitempty"`
		Date        *[]string `json:"date,omitempty"`
		Email       *[]string `json:"email,omitempty"`
		End         *[]string `json:"end,omitempty"`
		Iban        *[]string `json:"iban,omitempty"`
		Name        *[]string `json:"name,omitempty"`
		Role        *[]string `json:"role,omitempty"`
		Start       *[]string `json:"start,omitempty"`
		Type        *[]string `json:"type,omitempty"`
	} `json:"errors,omitempty"`
	Message *string `json:"message,omitempty"`
}

// Webhook defines model for Webhook.
type Webhook struct {
	// Active Boolean to indicate if the webhook is active
	Active    *bool      `json:"active,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Delivery Format of the delivered response.
	Delivery WebhookDelivery `json:"delivery"`

	// Response Indicator for what Firefly III will deliver to the webhook URL.
	Response WebhookResponse `json:"response"`

	// Secret A 24-character secret for the webhook. It's generated by Firefly III when saving a new webhook. If you submit a new secret through the PUT endpoint it will generate a new secret for the selected webhook, a new secret bearing no relation to whatever you just submitted.
	Secret *string `json:"secret,omitempty"`

	// Title A title for the webhook for easy recognition.
	Title string `json:"title"`

	// Trigger The trigger for the webhook.
	Trigger   WebhookTrigger `json:"trigger"`
	UpdatedAt *time.Time     `json:"updated_at,omitempty"`

	// Url The URL of the webhook. Has to start with `https`.
	Url string `json:"url"`
}

// WebhookArray defines model for WebhookArray.
type WebhookArray struct {
	Data  []WebhookRead `json:"data"`
	Links PageLink      `json:"links"`
	Meta  Meta          `json:"meta"`
}

// WebhookAttempt defines model for WebhookAttempt.
type WebhookAttempt struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Logs Internal log for this attempt. May contain sensitive user data.
	Logs *string `json:"logs"`

	// Response Webhook receiver response for this attempt, if any. May contain sensitive user data.
	Response *string `json:"response"`

	// StatusCode The HTTP status code of the error, if any.
	StatusCode *int32     `json:"status_code"`
	UpdatedAt  *time.Time `json:"updated_at,omitempty"`

	// WebhookMessageId The ID of the webhook message this attempt belongs to.
	WebhookMessageId *string `json:"webhook_message_id,omitempty"`
}

// WebhookAttemptArray defines model for WebhookAttemptArray.
type WebhookAttemptArray struct {
	Data []WebhookAttemptRead `json:"data"`
	Meta Meta                 `json:"meta"`
}

// WebhookAttemptRead defines model for WebhookAttemptRead.
type WebhookAttemptRead struct {
	Attributes WebhookAttempt `json:"attributes"`
	Id         string         `json:"id"`

	// Type Immutable value
	Type string `json:"type"`
}

// WebhookAttemptSingle defines model for WebhookAttemptSingle.
type WebhookAttemptSingle struct {
	Data WebhookAttemptRead `json:"data"`
}

// WebhookDelivery Format of the delivered response.
type WebhookDelivery string

// WebhookMessage defines model for WebhookMessage.
type WebhookMessage struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Errored If this message has errored out.
	Errored *bool `json:"errored,omitempty"`

	// Message The actual message that is sent or will be sent as JSON string.
	Message *string `json:"message"`

	// Sent If this message is sent yet.
	Sent      *bool      `json:"sent,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Uuid Long UUID string for identification of this webhook message.
	Uuid *string `json:"uuid,omitempty"`

	// WebhookId The ID of the webhook this message belongs to.
	WebhookId *string `json:"webhook_id,omitempty"`
}

// WebhookMessageArray defines model for WebhookMessageArray.
type WebhookMessageArray struct {
	Data []WebhookMessageRead `json:"data"`
	Meta Meta                 `json:"meta"`
}

// WebhookMessageRead defines model for WebhookMessageRead.
type WebhookMessageRead struct {
	Attributes WebhookMessage `json:"attributes"`
	Id         string         `json:"id"`

	// Type Immutable value
	Type string `json:"type"`
}

// WebhookMessageSingle defines model for WebhookMessageSingle.
type WebhookMessageSingle struct {
	Data WebhookMessageRead `json:"data"`
}

// WebhookRead defines model for WebhookRead.
type WebhookRead struct {
	Attributes Webhook    `json:"attributes"`
	Id         string     `json:"id"`
	Links      ObjectLink `json:"links"`

	// Type Immutable value
	Type string `json:"type"`
}

// WebhookResponse Indicator for what Firefly III will deliver to the webhook URL.
type WebhookResponse string

// WebhookSingle defines model for WebhookSingle.
type WebhookSingle struct {
	Data WebhookRead `json:"data"`
}

// WebhookStore defines model for WebhookStore.
type WebhookStore struct {
	// Active Boolean to indicate if the webhook is active
	Active *bool `json:"active,omitempty"`

	// Delivery Format of the delivered response.
	Delivery WebhookDelivery `json:"delivery"`

	// Response Indicator for what Firefly III will deliver to the webhook URL.
	Response WebhookResponse `json:"response"`

	// Title A title for the webhook for easy recognition.
	Title string `json:"title"`

	// Trigger The trigger for the webhook.
	Trigger WebhookTrigger `json:"trigger"`

	// Url The URL of the webhook. Has to start with `https`.
	Url string `json:"url"`
}

// WebhookTrigger The trigger for the webhook.
type WebhookTrigger string

// WebhookUpdate defines model for WebhookUpdate.
type WebhookUpdate struct {
	// Active Boolean to indicate if the webhook is active
	Active *bool `json:"active,omitempty"`

	// Delivery Format of the delivered response.
	Delivery *WebhookDelivery `json:"delivery,omitempty"`

	// Response Indicator for what Firefly III will deliver to the webhook URL.
	Response *WebhookResponse `json:"response,omitempty"`

	// Secret A 24-character secret for the webhook. It's generated by Firefly III when saving a new webhook. If you submit a new secret through the PUT endpoint it will generate a new secret for the selected webhook, a new secret bearing no relation to whatever you just submitted.
	Secret *string `json:"secret,omitempty"`

	// Title A title for the webhook for easy recognition.
	Title *string `json:"title,omitempty"`

	// Trigger The trigger for the webhook.
	Trigger *WebhookTrigger `json:"trigger,omitempty"`

	// Url The URL of the webhook. Has to start with `https`.
	Url *string `json:"url,omitempty"`
}

// GetAboutParams defines parameters for GetAbout.
type GetAboutParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetCurrentUserParams defines parameters for GetCurrentUser.
type GetCurrentUserParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListAccountParams defines parameters for ListAccount.
type ListAccountParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Date A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account's balance on that day.
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// Type Optional filter on the account type(s) returned
	Type *AccountTypeFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreAccountParams defines parameters for StoreAccount.
type StoreAccountParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteAccountParams defines parameters for DeleteAccount.
type DeleteAccountParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetAccountParams defines parameters for GetAccount.
type GetAccountParams struct {
	// Date A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account's balance on that day.
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateAccountParams defines parameters for UpdateAccount.
type UpdateAccountParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListAttachmentByAccountParams defines parameters for ListAttachmentByAccount.
type ListAttachmentByAccountParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListPiggyBankByAccountParams defines parameters for ListPiggyBankByAccount.
type ListPiggyBankByAccountParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListTransactionByAccountParams defines parameters for ListTransactionByAccount.
type ListTransactionByAccountParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Start A date formatted YYYY-MM-DD.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// Type Optional filter on the transaction type(s) returned.
	Type *TransactionTypeFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListAttachmentParams defines parameters for ListAttachment.
type ListAttachmentParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreAttachmentParams defines parameters for StoreAttachment.
type StoreAttachmentParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteAttachmentParams defines parameters for DeleteAttachment.
type DeleteAttachmentParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetAttachmentParams defines parameters for GetAttachment.
type GetAttachmentParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateAttachmentParams defines parameters for UpdateAttachment.
type UpdateAttachmentParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DownloadAttachmentParams defines parameters for DownloadAttachment.
type DownloadAttachmentParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UploadAttachmentParams defines parameters for UploadAttachment.
type UploadAttachmentParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetAccountsACParams defines parameters for GetAccountsAC.
type GetAccountsACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Date If the account is an asset account or a liability, the autocomplete will also return the balance of the account on this date.
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// Types Optional filter on the account type(s) used in the autocomplete.
	Types *[]AccountTypeFilter `form:"types,omitempty" json:"types,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetBillsACParams defines parameters for GetBillsAC.
type GetBillsACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetBudgetsACParams defines parameters for GetBudgetsAC.
type GetBudgetsACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetCategoriesACParams defines parameters for GetCategoriesAC.
type GetCategoriesACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetCurrenciesACParams defines parameters for GetCurrenciesAC.
type GetCurrenciesACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetCurrenciesCodeACParams defines parameters for GetCurrenciesCodeAC.
type GetCurrenciesCodeACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetObjectGroupsACParams defines parameters for GetObjectGroupsAC.
type GetObjectGroupsACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetPiggiesACParams defines parameters for GetPiggiesAC.
type GetPiggiesACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetPiggiesBalanceACParams defines parameters for GetPiggiesBalanceAC.
type GetPiggiesBalanceACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetRecurringACParams defines parameters for GetRecurringAC.
type GetRecurringACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetRuleGroupsACParams defines parameters for GetRuleGroupsAC.
type GetRuleGroupsACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetRulesACParams defines parameters for GetRulesAC.
type GetRulesACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetTagACParams defines parameters for GetTagAC.
type GetTagACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetTransactionTypesACParams defines parameters for GetTransactionTypesAC.
type GetTransactionTypesACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetTransactionsACParams defines parameters for GetTransactionsAC.
type GetTransactionsACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetTransactionsIDACParams defines parameters for GetTransactionsIDAC.
type GetTransactionsIDACParams struct {
	// Query The autocomplete search query.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit The number of items returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListAvailableBudgetParams defines parameters for ListAvailableBudget.
type ListAvailableBudgetParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Start A date formatted YYYY-MM-DD.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetAvailableBudgetParams defines parameters for GetAvailableBudget.
type GetAvailableBudgetParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListBillParams defines parameters for ListBill.
type ListBillParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Start A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreBillParams defines parameters for StoreBill.
type StoreBillParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteBillParams defines parameters for DeleteBill.
type DeleteBillParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetBillParams defines parameters for GetBill.
type GetBillParams struct {
	// Start A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateBillParams defines parameters for UpdateBill.
type UpdateBillParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListAttachmentByBillParams defines parameters for ListAttachmentByBill.
type ListAttachmentByBillParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListRuleByBillParams defines parameters for ListRuleByBill.
type ListRuleByBillParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListTransactionByBillParams defines parameters for ListTransactionByBill.
type ListTransactionByBillParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Start A date formatted YYYY-MM-DD.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// Type Optional filter on the transaction type(s) returned
	Type *TransactionTypeFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListBudgetLimitParams defines parameters for ListBudgetLimit.
type ListBudgetLimitParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListBudgetParams defines parameters for ListBudget.
type ListBudgetParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Start A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreBudgetParams defines parameters for StoreBudget.
type StoreBudgetParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteBudgetParams defines parameters for DeleteBudget.
type DeleteBudgetParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetBudgetParams defines parameters for GetBudget.
type GetBudgetParams struct {
	// Start A date formatted YYYY-MM-DD, to get info on how much the user has spent.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD, to get info on how much the user has spent.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateBudgetParams defines parameters for UpdateBudget.
type UpdateBudgetParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListAttachmentByBudgetParams defines parameters for ListAttachmentByBudget.
type ListAttachmentByBudgetParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListBudgetLimitByBudgetParams defines parameters for ListBudgetLimitByBudget.
type ListBudgetLimitByBudgetParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreBudgetLimitParams defines parameters for StoreBudgetLimit.
type StoreBudgetLimitParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteBudgetLimitParams defines parameters for DeleteBudgetLimit.
type DeleteBudgetLimitParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetBudgetLimitParams defines parameters for GetBudgetLimit.
type GetBudgetLimitParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateBudgetLimitParams defines parameters for UpdateBudgetLimit.
type UpdateBudgetLimitParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListTransactionByBudgetLimitParams defines parameters for ListTransactionByBudgetLimit.
type ListTransactionByBudgetLimitParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Type Optional filter on the transaction type(s) returned
	Type *TransactionTypeFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListTransactionByBudgetParams defines parameters for ListTransactionByBudget.
type ListTransactionByBudgetParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Start A date formatted YYYY-MM-DD.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// Type Optional filter on the transaction type(s) returned
	Type *TransactionTypeFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListCategoryParams defines parameters for ListCategory.
type ListCategoryParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreCategoryParams defines parameters for StoreCategory.
type StoreCategoryParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteCategoryParams defines parameters for DeleteCategory.
type DeleteCategoryParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetCategoryParams defines parameters for GetCategory.
type GetCategoryParams struct {
	// Start A date formatted YYYY-MM-DD, to show spent and earned info.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD, to show spent and earned info.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateCategoryParams defines parameters for UpdateCategory.
type UpdateCategoryParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListAttachmentByCategoryParams defines parameters for ListAttachmentByCategory.
type ListAttachmentByCategoryParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListTransactionByCategoryParams defines parameters for ListTransactionByCategory.
type ListTransactionByCategoryParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Start A date formatted YYYY-MM-DD, to limit the result list.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD, to limit the result list.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// Type Optional filter on the transaction type(s) returned
	Type *TransactionTypeFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetChartAccountOverviewParams defines parameters for GetChartAccountOverview.
type GetChartAccountOverviewParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetConfigurationParams defines parameters for GetConfiguration.
type GetConfigurationParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetSingleConfigurationParams defines parameters for GetSingleConfiguration.
type GetSingleConfigurationParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// SetConfigurationParams defines parameters for SetConfiguration.
type SetConfigurationParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetCronParams defines parameters for GetCron.
type GetCronParams struct {
	// Date A date formatted YYYY-MM-DD. This can be used to make the cron job pretend it's running
	// on another day.
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// Force Forces the cron job to fire, regardless of whether it has fired before. This may result
	// in double transactions or weird budgets, so be careful.
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListCurrencyParams defines parameters for ListCurrency.
type ListCurrencyParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreCurrencyParams defines parameters for StoreCurrency.
type StoreCurrencyParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetDefaultCurrencyParams defines parameters for GetDefaultCurrency.
type GetDefaultCurrencyParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteCurrencyParams defines parameters for DeleteCurrency.
type DeleteCurrencyParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetCurrencyParams defines parameters for GetCurrency.
type GetCurrencyParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateCurrencyParams defines parameters for UpdateCurrency.
type UpdateCurrencyParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListAccountByCurrencyParams defines parameters for ListAccountByCurrency.
type ListAccountByCurrencyParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Date A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account's balance on that day.
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// Type Optional filter on the account type(s) returned
	Type *AccountTypeFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListAvailableBudgetByCurrencyParams defines parameters for ListAvailableBudgetByCurrency.
type ListAvailableBudgetByCurrencyParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListBillByCurrencyParams defines parameters for ListBillByCurrency.
type ListBillByCurrencyParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListBudgetLimitByCurrencyParams defines parameters for ListBudgetLimitByCurrency.
type ListBudgetLimitByCurrencyParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Start Start date for the budget limit list.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End End date for the budget limit list.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DefaultCurrencyParams defines parameters for DefaultCurrency.
type DefaultCurrencyParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DisableCurrencyParams defines parameters for DisableCurrency.
type DisableCurrencyParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// EnableCurrencyParams defines parameters for EnableCurrency.
type EnableCurrencyParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListRecurrenceByCurrencyParams defines parameters for ListRecurrenceByCurrency.
type ListRecurrenceByCurrencyParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListRuleByCurrencyParams defines parameters for ListRuleByCurrency.
type ListRuleByCurrencyParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListTransactionByCurrencyParams defines parameters for ListTransactionByCurrency.
type ListTransactionByCurrencyParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Start A date formatted YYYY-MM-DD, to limit the list of transactions.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD, to limit the list of transactions.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// Type Optional filter on the transaction type(s) returned
	Type *TransactionTypeFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// BulkUpdateTransactionsParams defines parameters for BulkUpdateTransactions.
type BulkUpdateTransactionsParams struct {
	// Query The JSON query.
	Query json.RawMessage `form:"query" json:"query"`
}

// DestroyDataParams defines parameters for DestroyData.
type DestroyDataParams struct {
	// Objects The type of data that you wish to destroy. You can only use one at a time.
	Objects DataDestroyObject `form:"objects" json:"objects"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ExportAccountsParams defines parameters for ExportAccounts.
type ExportAccountsParams struct {
	// Type The file type the export file (CSV is currently the only option).
	Type *ExportFileFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ExportBillsParams defines parameters for ExportBills.
type ExportBillsParams struct {
	// Type The file type the export file (CSV is currently the only option).
	Type *ExportFileFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ExportBudgetsParams defines parameters for ExportBudgets.
type ExportBudgetsParams struct {
	// Type The file type the export file (CSV is currently the only option).
	Type *ExportFileFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ExportCategoriesParams defines parameters for ExportCategories.
type ExportCategoriesParams struct {
	// Type The file type the export file (CSV is currently the only option).
	Type *ExportFileFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ExportPiggiesParams defines parameters for ExportPiggies.
type ExportPiggiesParams struct {
	// Type The file type the export file (CSV is currently the only option).
	Type *ExportFileFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ExportRecurringParams defines parameters for ExportRecurring.
type ExportRecurringParams struct {
	// Type The file type the export file (CSV is currently the only option).
	Type *ExportFileFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ExportRulesParams defines parameters for ExportRules.
type ExportRulesParams struct {
	// Type The file type the export file (CSV is currently the only option).
	Type *ExportFileFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ExportTagsParams defines parameters for ExportTags.
type ExportTagsParams struct {
	// Type The file type the export file (CSV is currently the only option).
	Type *ExportFileFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ExportTransactionsParams defines parameters for ExportTransactions.
type ExportTransactionsParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts Limit the export of transactions to these accounts only. Only asset accounts will be accepted. Other types will be silently dropped.
	Accounts *string `form:"accounts,omitempty" json:"accounts,omitempty"`

	// Type The file type the export file (CSV is currently the only option).
	Type *ExportFileFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// PurgeDataParams defines parameters for PurgeData.
type PurgeDataParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightExpenseAssetParams defines parameters for InsightExpenseAsset.
type InsightExpenseAssetParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightExpenseBillParams defines parameters for InsightExpenseBill.
type InsightExpenseBillParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Bills The bills to be included in the results.
	Bills *[]int64 `form:"bills[],omitempty" json:"bills[],omitempty"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightExpenseBudgetParams defines parameters for InsightExpenseBudget.
type InsightExpenseBudgetParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Budgets The budgets to be included in the results.
	Budgets *[]int64 `form:"budgets[],omitempty" json:"budgets[],omitempty"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightExpenseCategoryParams defines parameters for InsightExpenseCategory.
type InsightExpenseCategoryParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Categories The categories to be included in the results.
	Categories *[]int64 `form:"categories[],omitempty" json:"categories[],omitempty"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightExpenseExpenseParams defines parameters for InsightExpenseExpense.
type InsightExpenseExpenseParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you add the accounts ID's of expense accounts, only those accounts
	// are included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
	// asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID's.
	// Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightExpenseNoBillParams defines parameters for InsightExpenseNoBill.
type InsightExpenseNoBillParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightExpenseNoBudgetParams defines parameters for InsightExpenseNoBudget.
type InsightExpenseNoBudgetParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightExpenseNoCategoryParams defines parameters for InsightExpenseNoCategory.
type InsightExpenseNoCategoryParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightExpenseNoTagParams defines parameters for InsightExpenseNoTag.
type InsightExpenseNoTagParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightExpenseTagParams defines parameters for InsightExpenseTag.
type InsightExpenseTagParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Tags The tags to be included in the results.
	Tags *[]int64 `form:"tags[],omitempty" json:"tags[],omitempty"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightExpenseTotalParams defines parameters for InsightExpenseTotal.
type InsightExpenseTotalParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only withdrawals from those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightIncomeAssetParams defines parameters for InsightIncomeAsset.
type InsightIncomeAssetParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only deposits to those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightIncomeCategoryParams defines parameters for InsightIncomeCategory.
type InsightIncomeCategoryParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Categories The categories to be included in the results.
	Categories *[]int64 `form:"categories[],omitempty" json:"categories[],omitempty"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only deposits to those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightIncomeNoCategoryParams defines parameters for InsightIncomeNoCategory.
type InsightIncomeNoCategoryParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only deposits to those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightIncomeNoTagParams defines parameters for InsightIncomeNoTag.
type InsightIncomeNoTagParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only deposits to those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightIncomeRevenueParams defines parameters for InsightIncomeRevenue.
type InsightIncomeRevenueParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you add the accounts ID's of revenue accounts, only those accounts
	// are included in the results. If you include ID's of asset accounts or liabilities, only deposits to those
	// asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID's.
	// Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightIncomeTagParams defines parameters for InsightIncomeTag.
type InsightIncomeTagParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Tags The tags to be included in the results.
	Tags *[]int64 `form:"tags[],omitempty" json:"tags[],omitempty"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only deposits to those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightIncomeTotalParams defines parameters for InsightIncomeTotal.
type InsightIncomeTotalParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only deposits to those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightTransfersParams defines parameters for InsightTransfers.
type InsightTransfersParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only transfers between those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightTransferCategoryParams defines parameters for InsightTransferCategory.
type InsightTransferCategoryParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Categories The categories to be included in the results.
	Categories *[]int64 `form:"categories[],omitempty" json:"categories[],omitempty"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only transfers between those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightTransferNoCategoryParams defines parameters for InsightTransferNoCategory.
type InsightTransferNoCategoryParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only transfers between those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightTransferNoTagParams defines parameters for InsightTransferNoTag.
type InsightTransferNoTagParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only transfers from those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightTransferTagParams defines parameters for InsightTransferTag.
type InsightTransferTagParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Tags The tags to be included in the results.
	Tags *[]int64 `form:"tags[],omitempty" json:"tags[],omitempty"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only transfers between those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// InsightTransferTotalParams defines parameters for InsightTransferTotal.
type InsightTransferTotalParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// Accounts The accounts to be included in the results. If you include ID's of asset accounts or liabilities, only transfers between those
	// asset accounts / liabilities will be included. Other account ID's will be ignored.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListLinkTypeParams defines parameters for ListLinkType.
type ListLinkTypeParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreLinkTypeParams defines parameters for StoreLinkType.
type StoreLinkTypeParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteLinkTypeParams defines parameters for DeleteLinkType.
type DeleteLinkTypeParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetLinkTypeParams defines parameters for GetLinkType.
type GetLinkTypeParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateLinkTypeParams defines parameters for UpdateLinkType.
type UpdateLinkTypeParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListTransactionByLinkTypeParams defines parameters for ListTransactionByLinkType.
type ListTransactionByLinkTypeParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Start A date formatted YYYY-MM-DD, to limit the results.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD, to limit the results.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// Type Optional filter on the transaction type(s) returned.
	Type *TransactionTypeFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListObjectGroupsParams defines parameters for ListObjectGroups.
type ListObjectGroupsParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteObjectGroupParams defines parameters for DeleteObjectGroup.
type DeleteObjectGroupParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetObjectGroupParams defines parameters for GetObjectGroup.
type GetObjectGroupParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateObjectGroupParams defines parameters for UpdateObjectGroup.
type UpdateObjectGroupParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListBillByObjectGroupParams defines parameters for ListBillByObjectGroup.
type ListBillByObjectGroupParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListPiggyBankByObjectGroupParams defines parameters for ListPiggyBankByObjectGroup.
type ListPiggyBankByObjectGroupParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListPiggyBankParams defines parameters for ListPiggyBank.
type ListPiggyBankParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StorePiggyBankParams defines parameters for StorePiggyBank.
type StorePiggyBankParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeletePiggyBankParams defines parameters for DeletePiggyBank.
type DeletePiggyBankParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetPiggyBankParams defines parameters for GetPiggyBank.
type GetPiggyBankParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdatePiggyBankParams defines parameters for UpdatePiggyBank.
type UpdatePiggyBankParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListAttachmentByPiggyBankParams defines parameters for ListAttachmentByPiggyBank.
type ListAttachmentByPiggyBankParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListEventByPiggyBankParams defines parameters for ListEventByPiggyBank.
type ListEventByPiggyBankParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListPreferenceParams defines parameters for ListPreference.
type ListPreferenceParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StorePreferenceParams defines parameters for StorePreference.
type StorePreferenceParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetPreferenceParams defines parameters for GetPreference.
type GetPreferenceParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdatePreferenceParams defines parameters for UpdatePreference.
type UpdatePreferenceParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListRecurrenceParams defines parameters for ListRecurrence.
type ListRecurrenceParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreRecurrenceParams defines parameters for StoreRecurrence.
type StoreRecurrenceParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteRecurrenceParams defines parameters for DeleteRecurrence.
type DeleteRecurrenceParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetRecurrenceParams defines parameters for GetRecurrence.
type GetRecurrenceParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateRecurrenceParams defines parameters for UpdateRecurrence.
type UpdateRecurrenceParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListTransactionByRecurrenceParams defines parameters for ListTransactionByRecurrence.
type ListTransactionByRecurrenceParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Start A date formatted YYYY-MM-DD. Both the start and end date must be present.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD. Both the start and end date must be present.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// Type Optional filter on the transaction type(s) returned
	Type *TransactionTypeFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListRuleGroupParams defines parameters for ListRuleGroup.
type ListRuleGroupParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreRuleGroupParams defines parameters for StoreRuleGroup.
type StoreRuleGroupParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteRuleGroupParams defines parameters for DeleteRuleGroup.
type DeleteRuleGroupParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetRuleGroupParams defines parameters for GetRuleGroup.
type GetRuleGroupParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateRuleGroupParams defines parameters for UpdateRuleGroup.
type UpdateRuleGroupParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListRuleByGroupParams defines parameters for ListRuleByGroup.
type ListRuleByGroupParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// TestRuleGroupParams defines parameters for TestRuleGroup.
type TestRuleGroupParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Start A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// SearchLimit Maximum number of transactions Firefly III will try. Don't set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200.
	SearchLimit *int `form:"search_limit,omitempty" json:"search_limit,omitempty"`

	// TriggeredLimit Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don't go above the user's page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow.
	TriggeredLimit *int `form:"triggered_limit,omitempty" json:"triggered_limit,omitempty"`

	// Accounts Limit the testing of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// FireRuleGroupParams defines parameters for FireRuleGroup.
type FireRuleGroupParams struct {
	// Start A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// Accounts Limit the triggering of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListRuleParams defines parameters for ListRule.
type ListRuleParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreRuleParams defines parameters for StoreRule.
type StoreRuleParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteRuleParams defines parameters for DeleteRule.
type DeleteRuleParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetRuleParams defines parameters for GetRule.
type GetRuleParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateRuleParams defines parameters for UpdateRule.
type UpdateRuleParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// TestRuleParams defines parameters for TestRule.
type TestRuleParams struct {
	// Start A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// Accounts Limit the testing of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// FireRuleParams defines parameters for FireRule.
type FireRuleParams struct {
	// Start A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the start date is not present, it will be set to one year ago. If you use this field, both the start date and the end date must be present.
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the end date is not present, it will be set to today. If you use this field, both the start date and the end date must be present.
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// Accounts Limit the triggering of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped.
	Accounts *[]int64 `form:"accounts[],omitempty" json:"accounts[],omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// SearchAccountsParams defines parameters for SearchAccounts.
type SearchAccountsParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Query The query you wish to search for.
	Query string `form:"query" json:"query"`

	// Type The type of accounts you wish to limit the search to.
	Type *AccountTypeFilter `form:"type,omitempty" json:"type,omitempty"`

	// Field The account field(s) you want to search in.
	Field AccountSearchFieldFilter `form:"field" json:"field"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// SearchTransactionsParams defines parameters for SearchTransactions.
type SearchTransactionsParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Query The query you wish to search for.
	Query string `form:"query" json:"query"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetBasicSummaryParams defines parameters for GetBasicSummary.
type GetBasicSummaryParams struct {
	// Start A date formatted YYYY-MM-DD.
	Start openapi_types.Date `form:"start" json:"start"`

	// End A date formatted YYYY-MM-DD.
	End openapi_types.Date `form:"end" json:"end"`

	// CurrencyCode A currency code like EUR or USD, to filter the result.
	CurrencyCode *string `form:"currency_code,omitempty" json:"currency_code,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListTagParams defines parameters for ListTag.
type ListTagParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreTagParams defines parameters for StoreTag.
type StoreTagParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteTagParams defines parameters for DeleteTag.
type DeleteTagParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetTagParams defines parameters for GetTag.
type GetTagParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateTagParams defines parameters for UpdateTag.
type UpdateTagParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListAttachmentByTagParams defines parameters for ListAttachmentByTag.
type ListAttachmentByTagParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListTransactionByTagParams defines parameters for ListTransactionByTag.
type ListTransactionByTagParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Start A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive).
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive).
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// Type Optional filter on the transaction type(s) returned.
	Type *TransactionTypeFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteTransactionJournalParams defines parameters for DeleteTransactionJournal.
type DeleteTransactionJournalParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetTransactionByJournalParams defines parameters for GetTransactionByJournal.
type GetTransactionByJournalParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListLinksByJournalParams defines parameters for ListLinksByJournal.
type ListLinksByJournalParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListTransactionLinkParams defines parameters for ListTransactionLink.
type ListTransactionLinkParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreTransactionLinkParams defines parameters for StoreTransactionLink.
type StoreTransactionLinkParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteTransactionLinkParams defines parameters for DeleteTransactionLink.
type DeleteTransactionLinkParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetTransactionLinkParams defines parameters for GetTransactionLink.
type GetTransactionLinkParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateTransactionLinkParams defines parameters for UpdateTransactionLink.
type UpdateTransactionLinkParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListTransactionParams defines parameters for ListTransaction.
type ListTransactionParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Start A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive).
	Start *openapi_types.Date `form:"start,omitempty" json:"start,omitempty"`

	// End A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive).
	End *openapi_types.Date `form:"end,omitempty" json:"end,omitempty"`

	// Type Optional filter on the transaction type(s) returned.
	Type *TransactionTypeFilter `form:"type,omitempty" json:"type,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreTransactionParams defines parameters for StoreTransaction.
type StoreTransactionParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteTransactionParams defines parameters for DeleteTransaction.
type DeleteTransactionParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetTransactionParams defines parameters for GetTransaction.
type GetTransactionParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateTransactionParams defines parameters for UpdateTransaction.
type UpdateTransactionParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListAttachmentByTransactionParams defines parameters for ListAttachmentByTransaction.
type ListAttachmentByTransactionParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListEventByTransactionParams defines parameters for ListEventByTransaction.
type ListEventByTransactionParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListUserParams defines parameters for ListUser.
type ListUserParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreUserParams defines parameters for StoreUser.
type StoreUserParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteUserParams defines parameters for DeleteUser.
type DeleteUserParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetUserParams defines parameters for GetUser.
type GetUserParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateUserParams defines parameters for UpdateUser.
type UpdateUserParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// ListWebhookParams defines parameters for ListWebhook.
type ListWebhookParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreWebhookParams defines parameters for StoreWebhook.
type StoreWebhookParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteWebhookParams defines parameters for DeleteWebhook.
type DeleteWebhookParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetWebhookParams defines parameters for GetWebhook.
type GetWebhookParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// UpdateWebhookParams defines parameters for UpdateWebhook.
type UpdateWebhookParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetWebhookMessagesParams defines parameters for GetWebhookMessages.
type GetWebhookMessagesParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteWebhookMessageParams defines parameters for DeleteWebhookMessage.
type DeleteWebhookMessageParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetSingleWebhookMessageParams defines parameters for GetSingleWebhookMessage.
type GetSingleWebhookMessageParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetWebhookMessageAttemptsParams defines parameters for GetWebhookMessageAttempts.
type GetWebhookMessageAttemptsParams struct {
	// Limit Number of items per page. The default pagination is per 50 items.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page Page number. The default pagination is per 50 items.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// DeleteWebhookMessageAttemptParams defines parameters for DeleteWebhookMessageAttempt.
type DeleteWebhookMessageAttemptParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// GetSingleWebhookMessageAttemptParams defines parameters for GetSingleWebhookMessageAttempt.
type GetSingleWebhookMessageAttemptParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// SubmitWebookParams defines parameters for SubmitWebook.
type SubmitWebookParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// TriggerTransactionWebhookParams defines parameters for TriggerTransactionWebhook.
type TriggerTransactionWebhookParams struct {
	// XTraceId Unique identifier associated with this request.
	XTraceId *openapi_types.UUID `json:"X-Trace-Id,omitempty"`
}

// StoreAccountJSONRequestBody defines body for StoreAccount for application/json ContentType.
type StoreAccountJSONRequestBody = AccountStore

// StoreAccountFormdataRequestBody defines body for StoreAccount for application/x-www-form-urlencoded ContentType.
type StoreAccountFormdataRequestBody = AccountStore

// UpdateAccountJSONRequestBody defines body for UpdateAccount for application/json ContentType.
type UpdateAccountJSONRequestBody = AccountUpdate

// UpdateAccountFormdataRequestBody defines body for UpdateAccount for application/x-www-form-urlencoded ContentType.
type UpdateAccountFormdataRequestBody = AccountUpdate

// StoreAttachmentJSONRequestBody defines body for StoreAttachment for application/json ContentType.
type StoreAttachmentJSONRequestBody = AttachmentStore

// StoreAttachmentFormdataRequestBody defines body for StoreAttachment for application/x-www-form-urlencoded ContentType.
type StoreAttachmentFormdataRequestBody = AttachmentStore

// UpdateAttachmentJSONRequestBody defines body for UpdateAttachment for application/json ContentType.
type UpdateAttachmentJSONRequestBody = AttachmentUpdate

// UpdateAttachmentFormdataRequestBody defines body for UpdateAttachment for application/x-www-form-urlencoded ContentType.
type UpdateAttachmentFormdataRequestBody = AttachmentUpdate

// StoreBillJSONRequestBody defines body for StoreBill for application/json ContentType.
type StoreBillJSONRequestBody = BillStore

// StoreBillFormdataRequestBody defines body for StoreBill for application/x-www-form-urlencoded ContentType.
type StoreBillFormdataRequestBody = BillStore

// UpdateBillJSONRequestBody defines body for UpdateBill for application/json ContentType.
type UpdateBillJSONRequestBody = BillUpdate

// UpdateBillFormdataRequestBody defines body for UpdateBill for application/x-www-form-urlencoded ContentType.
type UpdateBillFormdataRequestBody = BillUpdate

// StoreBudgetJSONRequestBody defines body for StoreBudget for application/json ContentType.
type StoreBudgetJSONRequestBody = BudgetStore

// StoreBudgetFormdataRequestBody defines body for StoreBudget for application/x-www-form-urlencoded ContentType.
type StoreBudgetFormdataRequestBody = BudgetStore

// UpdateBudgetJSONRequestBody defines body for UpdateBudget for application/json ContentType.
type UpdateBudgetJSONRequestBody = BudgetUpdate

// UpdateBudgetFormdataRequestBody defines body for UpdateBudget for application/x-www-form-urlencoded ContentType.
type UpdateBudgetFormdataRequestBody = BudgetUpdate

// StoreBudgetLimitJSONRequestBody defines body for StoreBudgetLimit for application/json ContentType.
type StoreBudgetLimitJSONRequestBody = BudgetLimitStore

// StoreBudgetLimitFormdataRequestBody defines body for StoreBudgetLimit for application/x-www-form-urlencoded ContentType.
type StoreBudgetLimitFormdataRequestBody = BudgetLimitStore

// UpdateBudgetLimitJSONRequestBody defines body for UpdateBudgetLimit for application/json ContentType.
type UpdateBudgetLimitJSONRequestBody = BudgetLimit

// UpdateBudgetLimitFormdataRequestBody defines body for UpdateBudgetLimit for application/x-www-form-urlencoded ContentType.
type UpdateBudgetLimitFormdataRequestBody = BudgetLimit

// StoreCategoryJSONRequestBody defines body for StoreCategory for application/json ContentType.
type StoreCategoryJSONRequestBody = Category

// StoreCategoryFormdataRequestBody defines body for StoreCategory for application/x-www-form-urlencoded ContentType.
type StoreCategoryFormdataRequestBody = Category

// UpdateCategoryJSONRequestBody defines body for UpdateCategory for application/json ContentType.
type UpdateCategoryJSONRequestBody = CategoryUpdate

// UpdateCategoryFormdataRequestBody defines body for UpdateCategory for application/x-www-form-urlencoded ContentType.
type UpdateCategoryFormdataRequestBody = CategoryUpdate

// SetConfigurationJSONRequestBody defines body for SetConfiguration for application/json ContentType.
type SetConfigurationJSONRequestBody = ConfigurationUpdate

// SetConfigurationFormdataRequestBody defines body for SetConfiguration for application/x-www-form-urlencoded ContentType.
type SetConfigurationFormdataRequestBody = ConfigurationUpdate

// StoreCurrencyJSONRequestBody defines body for StoreCurrency for application/json ContentType.
type StoreCurrencyJSONRequestBody = CurrencyStore

// StoreCurrencyFormdataRequestBody defines body for StoreCurrency for application/x-www-form-urlencoded ContentType.
type StoreCurrencyFormdataRequestBody = CurrencyStore

// UpdateCurrencyApplicationVndAPIPlusJSONRequestBody defines body for UpdateCurrency for application/vnd.api+json ContentType.
type UpdateCurrencyApplicationVndAPIPlusJSONRequestBody = CurrencyUpdate

// UpdateCurrencyFormdataRequestBody defines body for UpdateCurrency for application/x-www-form-urlencoded ContentType.
type UpdateCurrencyFormdataRequestBody = CurrencyUpdate

// StoreLinkTypeJSONRequestBody defines body for StoreLinkType for application/json ContentType.
type StoreLinkTypeJSONRequestBody = LinkType

// StoreLinkTypeFormdataRequestBody defines body for StoreLinkType for application/x-www-form-urlencoded ContentType.
type StoreLinkTypeFormdataRequestBody = LinkType

// UpdateLinkTypeJSONRequestBody defines body for UpdateLinkType for application/json ContentType.
type UpdateLinkTypeJSONRequestBody = LinkTypeUpdate

// UpdateLinkTypeFormdataRequestBody defines body for UpdateLinkType for application/x-www-form-urlencoded ContentType.
type UpdateLinkTypeFormdataRequestBody = LinkTypeUpdate

// UpdateObjectGroupJSONRequestBody defines body for UpdateObjectGroup for application/json ContentType.
type UpdateObjectGroupJSONRequestBody = ObjectGroupUpdate

// UpdateObjectGroupFormdataRequestBody defines body for UpdateObjectGroup for application/x-www-form-urlencoded ContentType.
type UpdateObjectGroupFormdataRequestBody = ObjectGroupUpdate

// StorePiggyBankJSONRequestBody defines body for StorePiggyBank for application/json ContentType.
type StorePiggyBankJSONRequestBody = PiggyBankStore

// StorePiggyBankFormdataRequestBody defines body for StorePiggyBank for application/x-www-form-urlencoded ContentType.
type StorePiggyBankFormdataRequestBody = PiggyBankStore

// UpdatePiggyBankJSONRequestBody defines body for UpdatePiggyBank for application/json ContentType.
type UpdatePiggyBankJSONRequestBody = PiggyBankUpdate

// UpdatePiggyBankFormdataRequestBody defines body for UpdatePiggyBank for application/x-www-form-urlencoded ContentType.
type UpdatePiggyBankFormdataRequestBody = PiggyBankUpdate

// StorePreferenceJSONRequestBody defines body for StorePreference for application/json ContentType.
type StorePreferenceJSONRequestBody = Preference

// StorePreferenceFormdataRequestBody defines body for StorePreference for application/x-www-form-urlencoded ContentType.
type StorePreferenceFormdataRequestBody = Preference

// UpdatePreferenceJSONRequestBody defines body for UpdatePreference for application/json ContentType.
type UpdatePreferenceJSONRequestBody = PreferenceUpdate

// UpdatePreferenceFormdataRequestBody defines body for UpdatePreference for application/x-www-form-urlencoded ContentType.
type UpdatePreferenceFormdataRequestBody = PreferenceUpdate

// StoreRecurrenceJSONRequestBody defines body for StoreRecurrence for application/json ContentType.
type StoreRecurrenceJSONRequestBody = RecurrenceStore

// StoreRecurrenceFormdataRequestBody defines body for StoreRecurrence for application/x-www-form-urlencoded ContentType.
type StoreRecurrenceFormdataRequestBody = RecurrenceStore

// UpdateRecurrenceJSONRequestBody defines body for UpdateRecurrence for application/json ContentType.
type UpdateRecurrenceJSONRequestBody = RecurrenceUpdate

// UpdateRecurrenceFormdataRequestBody defines body for UpdateRecurrence for application/x-www-form-urlencoded ContentType.
type UpdateRecurrenceFormdataRequestBody = RecurrenceUpdate

// StoreRuleGroupJSONRequestBody defines body for StoreRuleGroup for application/json ContentType.
type StoreRuleGroupJSONRequestBody = RuleGroupStore

// StoreRuleGroupFormdataRequestBody defines body for StoreRuleGroup for application/x-www-form-urlencoded ContentType.
type StoreRuleGroupFormdataRequestBody = RuleGroupStore

// UpdateRuleGroupJSONRequestBody defines body for UpdateRuleGroup for application/json ContentType.
type UpdateRuleGroupJSONRequestBody = RuleGroupUpdate

// UpdateRuleGroupFormdataRequestBody defines body for UpdateRuleGroup for application/x-www-form-urlencoded ContentType.
type UpdateRuleGroupFormdataRequestBody = RuleGroupUpdate

// StoreRuleJSONRequestBody defines body for StoreRule for application/json ContentType.
type StoreRuleJSONRequestBody = RuleStore

// StoreRuleFormdataRequestBody defines body for StoreRule for application/x-www-form-urlencoded ContentType.
type StoreRuleFormdataRequestBody = RuleStore

// UpdateRuleJSONRequestBody defines body for UpdateRule for application/json ContentType.
type UpdateRuleJSONRequestBody = RuleUpdate

// UpdateRuleFormdataRequestBody defines body for UpdateRule for application/x-www-form-urlencoded ContentType.
type UpdateRuleFormdataRequestBody = RuleUpdate

// StoreTagJSONRequestBody defines body for StoreTag for application/json ContentType.
type StoreTagJSONRequestBody = TagModelStore

// StoreTagFormdataRequestBody defines body for StoreTag for application/x-www-form-urlencoded ContentType.
type StoreTagFormdataRequestBody = TagModelStore

// UpdateTagJSONRequestBody defines body for UpdateTag for application/json ContentType.
type UpdateTagJSONRequestBody = TagModelUpdate

// UpdateTagFormdataRequestBody defines body for UpdateTag for application/x-www-form-urlencoded ContentType.
type UpdateTagFormdataRequestBody = TagModelUpdate

// StoreTransactionLinkJSONRequestBody defines body for StoreTransactionLink for application/json ContentType.
type StoreTransactionLinkJSONRequestBody = TransactionLinkStore

// StoreTransactionLinkFormdataRequestBody defines body for StoreTransactionLink for application/x-www-form-urlencoded ContentType.
type StoreTransactionLinkFormdataRequestBody = TransactionLinkStore

// UpdateTransactionLinkJSONRequestBody defines body for UpdateTransactionLink for application/json ContentType.
type UpdateTransactionLinkJSONRequestBody = TransactionLinkUpdate

// UpdateTransactionLinkFormdataRequestBody defines body for UpdateTransactionLink for application/x-www-form-urlencoded ContentType.
type UpdateTransactionLinkFormdataRequestBody = TransactionLinkUpdate

// StoreTransactionJSONRequestBody defines body for StoreTransaction for application/json ContentType.
type StoreTransactionJSONRequestBody = TransactionStore

// StoreTransactionFormdataRequestBody defines body for StoreTransaction for application/x-www-form-urlencoded ContentType.
type StoreTransactionFormdataRequestBody = TransactionStore

// UpdateTransactionJSONRequestBody defines body for UpdateTransaction for application/json ContentType.
type UpdateTransactionJSONRequestBody = TransactionUpdate

// UpdateTransactionFormdataRequestBody defines body for UpdateTransaction for application/x-www-form-urlencoded ContentType.
type UpdateTransactionFormdataRequestBody = TransactionUpdate

// StoreUserJSONRequestBody defines body for StoreUser for application/json ContentType.
type StoreUserJSONRequestBody = User

// StoreUserFormdataRequestBody defines body for StoreUser for application/x-www-form-urlencoded ContentType.
type StoreUserFormdataRequestBody = User

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = User

// UpdateUserFormdataRequestBody defines body for UpdateUser for application/x-www-form-urlencoded ContentType.
type UpdateUserFormdataRequestBody = User

// StoreWebhookJSONRequestBody defines body for StoreWebhook for application/json ContentType.
type StoreWebhookJSONRequestBody = WebhookStore

// StoreWebhookFormdataRequestBody defines body for StoreWebhook for application/x-www-form-urlencoded ContentType.
type StoreWebhookFormdataRequestBody = WebhookStore

// UpdateWebhookJSONRequestBody defines body for UpdateWebhook for application/json ContentType.
type UpdateWebhookJSONRequestBody = WebhookUpdate

// UpdateWebhookFormdataRequestBody defines body for UpdateWebhook for application/x-www-form-urlencoded ContentType.
type UpdateWebhookFormdataRequestBody = WebhookUpdate

// AsPolymorphicProperty0 returns the union data inside the PolymorphicProperty as a PolymorphicProperty0
func (t PolymorphicProperty) AsPolymorphicProperty0() (PolymorphicProperty0, error) {
	var body PolymorphicProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolymorphicProperty0 overwrites any union data inside the PolymorphicProperty as the provided PolymorphicProperty0
func (t *PolymorphicProperty) FromPolymorphicProperty0(v PolymorphicProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolymorphicProperty0 performs a merge with any union data inside the PolymorphicProperty, using the provided PolymorphicProperty0
func (t *PolymorphicProperty) MergePolymorphicProperty0(v PolymorphicProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPolymorphicProperty1 returns the union data inside the PolymorphicProperty as a PolymorphicProperty1
func (t PolymorphicProperty) AsPolymorphicProperty1() (PolymorphicProperty1, error) {
	var body PolymorphicProperty1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolymorphicProperty1 overwrites any union data inside the PolymorphicProperty as the provided PolymorphicProperty1
func (t *PolymorphicProperty) FromPolymorphicProperty1(v PolymorphicProperty1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolymorphicProperty1 performs a merge with any union data inside the PolymorphicProperty, using the provided PolymorphicProperty1
func (t *PolymorphicProperty) MergePolymorphicProperty1(v PolymorphicProperty1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPolymorphicProperty2 returns the union data inside the PolymorphicProperty as a PolymorphicProperty2
func (t PolymorphicProperty) AsPolymorphicProperty2() (PolymorphicProperty2, error) {
	var body PolymorphicProperty2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolymorphicProperty2 overwrites any union data inside the PolymorphicProperty as the provided PolymorphicProperty2
func (t *PolymorphicProperty) FromPolymorphicProperty2(v PolymorphicProperty2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolymorphicProperty2 performs a merge with any union data inside the PolymorphicProperty, using the provided PolymorphicProperty2
func (t *PolymorphicProperty) MergePolymorphicProperty2(v PolymorphicProperty2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPolymorphicProperty3 returns the union data inside the PolymorphicProperty as a PolymorphicProperty3
func (t PolymorphicProperty) AsPolymorphicProperty3() (PolymorphicProperty3, error) {
	var body PolymorphicProperty3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolymorphicProperty3 overwrites any union data inside the PolymorphicProperty as the provided PolymorphicProperty3
func (t *PolymorphicProperty) FromPolymorphicProperty3(v PolymorphicProperty3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolymorphicProperty3 performs a merge with any union data inside the PolymorphicProperty, using the provided PolymorphicProperty3
func (t *PolymorphicProperty) MergePolymorphicProperty3(v PolymorphicProperty3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PolymorphicProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PolymorphicProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAbout request
	GetAbout(ctx context.Context, params *GetAboutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, params *GetCurrentUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAccount request
	ListAccount(ctx context.Context, params *ListAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreAccountWithBody request with any body
	StoreAccountWithBody(ctx context.Context, params *StoreAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreAccount(ctx context.Context, params *StoreAccountParams, body StoreAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreAccountWithFormdataBody(ctx context.Context, params *StoreAccountParams, body StoreAccountFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAccount request
	DeleteAccount(ctx context.Context, id string, params *DeleteAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccount request
	GetAccount(ctx context.Context, id string, params *GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccountWithBody request with any body
	UpdateAccountWithBody(ctx context.Context, id string, params *UpdateAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccount(ctx context.Context, id string, params *UpdateAccountParams, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccountWithFormdataBody(ctx context.Context, id string, params *UpdateAccountParams, body UpdateAccountFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttachmentByAccount request
	ListAttachmentByAccount(ctx context.Context, id string, params *ListAttachmentByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPiggyBankByAccount request
	ListPiggyBankByAccount(ctx context.Context, id string, params *ListPiggyBankByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactionByAccount request
	ListTransactionByAccount(ctx context.Context, id string, params *ListTransactionByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttachment request
	ListAttachment(ctx context.Context, params *ListAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreAttachmentWithBody request with any body
	StoreAttachmentWithBody(ctx context.Context, params *StoreAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreAttachment(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreAttachmentWithFormdataBody(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttachment request
	DeleteAttachment(ctx context.Context, id string, params *DeleteAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachment request
	GetAttachment(ctx context.Context, id string, params *GetAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAttachmentWithBody request with any body
	UpdateAttachmentWithBody(ctx context.Context, id string, params *UpdateAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAttachment(ctx context.Context, id string, params *UpdateAttachmentParams, body UpdateAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAttachmentWithFormdataBody(ctx context.Context, id string, params *UpdateAttachmentParams, body UpdateAttachmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadAttachment request
	DownloadAttachment(ctx context.Context, id string, params *DownloadAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadAttachmentWithBody request with any body
	UploadAttachmentWithBody(ctx context.Context, id string, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountsAC request
	GetAccountsAC(ctx context.Context, params *GetAccountsACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillsAC request
	GetBillsAC(ctx context.Context, params *GetBillsACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBudgetsAC request
	GetBudgetsAC(ctx context.Context, params *GetBudgetsACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategoriesAC request
	GetCategoriesAC(ctx context.Context, params *GetCategoriesACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrenciesAC request
	GetCurrenciesAC(ctx context.Context, params *GetCurrenciesACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrenciesCodeAC request
	GetCurrenciesCodeAC(ctx context.Context, params *GetCurrenciesCodeACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObjectGroupsAC request
	GetObjectGroupsAC(ctx context.Context, params *GetObjectGroupsACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPiggiesAC request
	GetPiggiesAC(ctx context.Context, params *GetPiggiesACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPiggiesBalanceAC request
	GetPiggiesBalanceAC(ctx context.Context, params *GetPiggiesBalanceACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecurringAC request
	GetRecurringAC(ctx context.Context, params *GetRecurringACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleGroupsAC request
	GetRuleGroupsAC(ctx context.Context, params *GetRuleGroupsACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRulesAC request
	GetRulesAC(ctx context.Context, params *GetRulesACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTagAC request
	GetTagAC(ctx context.Context, params *GetTagACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionTypesAC request
	GetTransactionTypesAC(ctx context.Context, params *GetTransactionTypesACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionsAC request
	GetTransactionsAC(ctx context.Context, params *GetTransactionsACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionsIDAC request
	GetTransactionsIDAC(ctx context.Context, params *GetTransactionsIDACParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableBudget request
	ListAvailableBudget(ctx context.Context, params *ListAvailableBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailableBudget request
	GetAvailableBudget(ctx context.Context, id string, params *GetAvailableBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBill request
	ListBill(ctx context.Context, params *ListBillParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreBillWithBody request with any body
	StoreBillWithBody(ctx context.Context, params *StoreBillParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreBill(ctx context.Context, params *StoreBillParams, body StoreBillJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreBillWithFormdataBody(ctx context.Context, params *StoreBillParams, body StoreBillFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBill request
	DeleteBill(ctx context.Context, id string, params *DeleteBillParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBill request
	GetBill(ctx context.Context, id string, params *GetBillParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBillWithBody request with any body
	UpdateBillWithBody(ctx context.Context, id string, params *UpdateBillParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBill(ctx context.Context, id string, params *UpdateBillParams, body UpdateBillJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBillWithFormdataBody(ctx context.Context, id string, params *UpdateBillParams, body UpdateBillFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttachmentByBill request
	ListAttachmentByBill(ctx context.Context, id string, params *ListAttachmentByBillParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRuleByBill request
	ListRuleByBill(ctx context.Context, id string, params *ListRuleByBillParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactionByBill request
	ListTransactionByBill(ctx context.Context, id string, params *ListTransactionByBillParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBudgetLimit request
	ListBudgetLimit(ctx context.Context, params *ListBudgetLimitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBudget request
	ListBudget(ctx context.Context, params *ListBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreBudgetWithBody request with any body
	StoreBudgetWithBody(ctx context.Context, params *StoreBudgetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreBudget(ctx context.Context, params *StoreBudgetParams, body StoreBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreBudgetWithFormdataBody(ctx context.Context, params *StoreBudgetParams, body StoreBudgetFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBudget request
	DeleteBudget(ctx context.Context, id string, params *DeleteBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBudget request
	GetBudget(ctx context.Context, id string, params *GetBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBudgetWithBody request with any body
	UpdateBudgetWithBody(ctx context.Context, id string, params *UpdateBudgetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBudget(ctx context.Context, id string, params *UpdateBudgetParams, body UpdateBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBudgetWithFormdataBody(ctx context.Context, id string, params *UpdateBudgetParams, body UpdateBudgetFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttachmentByBudget request
	ListAttachmentByBudget(ctx context.Context, id string, params *ListAttachmentByBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBudgetLimitByBudget request
	ListBudgetLimitByBudget(ctx context.Context, id string, params *ListBudgetLimitByBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreBudgetLimitWithBody request with any body
	StoreBudgetLimitWithBody(ctx context.Context, id string, params *StoreBudgetLimitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreBudgetLimit(ctx context.Context, id string, params *StoreBudgetLimitParams, body StoreBudgetLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreBudgetLimitWithFormdataBody(ctx context.Context, id string, params *StoreBudgetLimitParams, body StoreBudgetLimitFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBudgetLimit request
	DeleteBudgetLimit(ctx context.Context, id string, limitId string, params *DeleteBudgetLimitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBudgetLimit request
	GetBudgetLimit(ctx context.Context, id string, limitId int, params *GetBudgetLimitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBudgetLimitWithBody request with any body
	UpdateBudgetLimitWithBody(ctx context.Context, id string, limitId string, params *UpdateBudgetLimitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBudgetLimit(ctx context.Context, id string, limitId string, params *UpdateBudgetLimitParams, body UpdateBudgetLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBudgetLimitWithFormdataBody(ctx context.Context, id string, limitId string, params *UpdateBudgetLimitParams, body UpdateBudgetLimitFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactionByBudgetLimit request
	ListTransactionByBudgetLimit(ctx context.Context, id string, limitId string, params *ListTransactionByBudgetLimitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactionByBudget request
	ListTransactionByBudget(ctx context.Context, id string, params *ListTransactionByBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCategory request
	ListCategory(ctx context.Context, params *ListCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreCategoryWithBody request with any body
	StoreCategoryWithBody(ctx context.Context, params *StoreCategoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCategory(ctx context.Context, params *StoreCategoryParams, body StoreCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCategoryWithFormdataBody(ctx context.Context, params *StoreCategoryParams, body StoreCategoryFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCategory request
	DeleteCategory(ctx context.Context, id string, params *DeleteCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategory request
	GetCategory(ctx context.Context, id string, params *GetCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCategoryWithBody request with any body
	UpdateCategoryWithBody(ctx context.Context, id string, params *UpdateCategoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCategory(ctx context.Context, id string, params *UpdateCategoryParams, body UpdateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCategoryWithFormdataBody(ctx context.Context, id string, params *UpdateCategoryParams, body UpdateCategoryFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttachmentByCategory request
	ListAttachmentByCategory(ctx context.Context, id string, params *ListAttachmentByCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactionByCategory request
	ListTransactionByCategory(ctx context.Context, id string, params *ListTransactionByCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChartAccountOverview request
	GetChartAccountOverview(ctx context.Context, params *GetChartAccountOverviewParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfiguration request
	GetConfiguration(ctx context.Context, params *GetConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSingleConfiguration request
	GetSingleConfiguration(ctx context.Context, name ConfigValueFilter, params *GetSingleConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetConfigurationWithBody request with any body
	SetConfigurationWithBody(ctx context.Context, name ConfigValueUpdateFilter, params *SetConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetConfiguration(ctx context.Context, name ConfigValueUpdateFilter, params *SetConfigurationParams, body SetConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetConfigurationWithFormdataBody(ctx context.Context, name ConfigValueUpdateFilter, params *SetConfigurationParams, body SetConfigurationFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCron request
	GetCron(ctx context.Context, cliToken string, params *GetCronParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCurrency request
	ListCurrency(ctx context.Context, params *ListCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreCurrencyWithBody request with any body
	StoreCurrencyWithBody(ctx context.Context, params *StoreCurrencyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCurrency(ctx context.Context, params *StoreCurrencyParams, body StoreCurrencyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCurrencyWithFormdataBody(ctx context.Context, params *StoreCurrencyParams, body StoreCurrencyFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultCurrency request
	GetDefaultCurrency(ctx context.Context, params *GetDefaultCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCurrency request
	DeleteCurrency(ctx context.Context, code string, params *DeleteCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrency request
	GetCurrency(ctx context.Context, code string, params *GetCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCurrencyWithBody request with any body
	UpdateCurrencyWithBody(ctx context.Context, code string, params *UpdateCurrencyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCurrencyWithApplicationVndAPIPlusJSONBody(ctx context.Context, code string, params *UpdateCurrencyParams, body UpdateCurrencyApplicationVndAPIPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCurrencyWithFormdataBody(ctx context.Context, code string, params *UpdateCurrencyParams, body UpdateCurrencyFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAccountByCurrency request
	ListAccountByCurrency(ctx context.Context, code string, params *ListAccountByCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableBudgetByCurrency request
	ListAvailableBudgetByCurrency(ctx context.Context, code string, params *ListAvailableBudgetByCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBillByCurrency request
	ListBillByCurrency(ctx context.Context, code string, params *ListBillByCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBudgetLimitByCurrency request
	ListBudgetLimitByCurrency(ctx context.Context, code string, params *ListBudgetLimitByCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DefaultCurrency request
	DefaultCurrency(ctx context.Context, code string, params *DefaultCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableCurrency request
	DisableCurrency(ctx context.Context, code string, params *DisableCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableCurrency request
	EnableCurrency(ctx context.Context, code string, params *EnableCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRecurrenceByCurrency request
	ListRecurrenceByCurrency(ctx context.Context, code string, params *ListRecurrenceByCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRuleByCurrency request
	ListRuleByCurrency(ctx context.Context, code string, params *ListRuleByCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactionByCurrency request
	ListTransactionByCurrency(ctx context.Context, code string, params *ListTransactionByCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateTransactions request
	BulkUpdateTransactions(ctx context.Context, params *BulkUpdateTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DestroyData request
	DestroyData(ctx context.Context, params *DestroyDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportAccounts request
	ExportAccounts(ctx context.Context, params *ExportAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportBills request
	ExportBills(ctx context.Context, params *ExportBillsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportBudgets request
	ExportBudgets(ctx context.Context, params *ExportBudgetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportCategories request
	ExportCategories(ctx context.Context, params *ExportCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportPiggies request
	ExportPiggies(ctx context.Context, params *ExportPiggiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportRecurring request
	ExportRecurring(ctx context.Context, params *ExportRecurringParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportRules request
	ExportRules(ctx context.Context, params *ExportRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportTags request
	ExportTags(ctx context.Context, params *ExportTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportTransactions request
	ExportTransactions(ctx context.Context, params *ExportTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PurgeData request
	PurgeData(ctx context.Context, params *PurgeDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightExpenseAsset request
	InsightExpenseAsset(ctx context.Context, params *InsightExpenseAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightExpenseBill request
	InsightExpenseBill(ctx context.Context, params *InsightExpenseBillParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightExpenseBudget request
	InsightExpenseBudget(ctx context.Context, params *InsightExpenseBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightExpenseCategory request
	InsightExpenseCategory(ctx context.Context, params *InsightExpenseCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightExpenseExpense request
	InsightExpenseExpense(ctx context.Context, params *InsightExpenseExpenseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightExpenseNoBill request
	InsightExpenseNoBill(ctx context.Context, params *InsightExpenseNoBillParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightExpenseNoBudget request
	InsightExpenseNoBudget(ctx context.Context, params *InsightExpenseNoBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightExpenseNoCategory request
	InsightExpenseNoCategory(ctx context.Context, params *InsightExpenseNoCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightExpenseNoTag request
	InsightExpenseNoTag(ctx context.Context, params *InsightExpenseNoTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightExpenseTag request
	InsightExpenseTag(ctx context.Context, params *InsightExpenseTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightExpenseTotal request
	InsightExpenseTotal(ctx context.Context, params *InsightExpenseTotalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightIncomeAsset request
	InsightIncomeAsset(ctx context.Context, params *InsightIncomeAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightIncomeCategory request
	InsightIncomeCategory(ctx context.Context, params *InsightIncomeCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightIncomeNoCategory request
	InsightIncomeNoCategory(ctx context.Context, params *InsightIncomeNoCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightIncomeNoTag request
	InsightIncomeNoTag(ctx context.Context, params *InsightIncomeNoTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightIncomeRevenue request
	InsightIncomeRevenue(ctx context.Context, params *InsightIncomeRevenueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightIncomeTag request
	InsightIncomeTag(ctx context.Context, params *InsightIncomeTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightIncomeTotal request
	InsightIncomeTotal(ctx context.Context, params *InsightIncomeTotalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightTransfers request
	InsightTransfers(ctx context.Context, params *InsightTransfersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightTransferCategory request
	InsightTransferCategory(ctx context.Context, params *InsightTransferCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightTransferNoCategory request
	InsightTransferNoCategory(ctx context.Context, params *InsightTransferNoCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightTransferNoTag request
	InsightTransferNoTag(ctx context.Context, params *InsightTransferNoTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightTransferTag request
	InsightTransferTag(ctx context.Context, params *InsightTransferTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InsightTransferTotal request
	InsightTransferTotal(ctx context.Context, params *InsightTransferTotalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLinkType request
	ListLinkType(ctx context.Context, params *ListLinkTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreLinkTypeWithBody request with any body
	StoreLinkTypeWithBody(ctx context.Context, params *StoreLinkTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreLinkType(ctx context.Context, params *StoreLinkTypeParams, body StoreLinkTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreLinkTypeWithFormdataBody(ctx context.Context, params *StoreLinkTypeParams, body StoreLinkTypeFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLinkType request
	DeleteLinkType(ctx context.Context, id string, params *DeleteLinkTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLinkType request
	GetLinkType(ctx context.Context, id string, params *GetLinkTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLinkTypeWithBody request with any body
	UpdateLinkTypeWithBody(ctx context.Context, id string, params *UpdateLinkTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLinkType(ctx context.Context, id string, params *UpdateLinkTypeParams, body UpdateLinkTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLinkTypeWithFormdataBody(ctx context.Context, id string, params *UpdateLinkTypeParams, body UpdateLinkTypeFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactionByLinkType request
	ListTransactionByLinkType(ctx context.Context, id string, params *ListTransactionByLinkTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListObjectGroups request
	ListObjectGroups(ctx context.Context, params *ListObjectGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObjectGroup request
	DeleteObjectGroup(ctx context.Context, id string, params *DeleteObjectGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObjectGroup request
	GetObjectGroup(ctx context.Context, id string, params *GetObjectGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateObjectGroupWithBody request with any body
	UpdateObjectGroupWithBody(ctx context.Context, id string, params *UpdateObjectGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateObjectGroup(ctx context.Context, id string, params *UpdateObjectGroupParams, body UpdateObjectGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateObjectGroupWithFormdataBody(ctx context.Context, id string, params *UpdateObjectGroupParams, body UpdateObjectGroupFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBillByObjectGroup request
	ListBillByObjectGroup(ctx context.Context, id string, params *ListBillByObjectGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPiggyBankByObjectGroup request
	ListPiggyBankByObjectGroup(ctx context.Context, id string, params *ListPiggyBankByObjectGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPiggyBank request
	ListPiggyBank(ctx context.Context, params *ListPiggyBankParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StorePiggyBankWithBody request with any body
	StorePiggyBankWithBody(ctx context.Context, params *StorePiggyBankParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StorePiggyBank(ctx context.Context, params *StorePiggyBankParams, body StorePiggyBankJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StorePiggyBankWithFormdataBody(ctx context.Context, params *StorePiggyBankParams, body StorePiggyBankFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePiggyBank request
	DeletePiggyBank(ctx context.Context, id string, params *DeletePiggyBankParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPiggyBank request
	GetPiggyBank(ctx context.Context, id string, params *GetPiggyBankParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePiggyBankWithBody request with any body
	UpdatePiggyBankWithBody(ctx context.Context, id string, params *UpdatePiggyBankParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePiggyBank(ctx context.Context, id string, params *UpdatePiggyBankParams, body UpdatePiggyBankJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePiggyBankWithFormdataBody(ctx context.Context, id string, params *UpdatePiggyBankParams, body UpdatePiggyBankFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttachmentByPiggyBank request
	ListAttachmentByPiggyBank(ctx context.Context, id string, params *ListAttachmentByPiggyBankParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventByPiggyBank request
	ListEventByPiggyBank(ctx context.Context, id string, params *ListEventByPiggyBankParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPreference request
	ListPreference(ctx context.Context, params *ListPreferenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StorePreferenceWithBody request with any body
	StorePreferenceWithBody(ctx context.Context, params *StorePreferenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StorePreference(ctx context.Context, params *StorePreferenceParams, body StorePreferenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StorePreferenceWithFormdataBody(ctx context.Context, params *StorePreferenceParams, body StorePreferenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPreference request
	GetPreference(ctx context.Context, name string, params *GetPreferenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePreferenceWithBody request with any body
	UpdatePreferenceWithBody(ctx context.Context, name string, params *UpdatePreferenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePreference(ctx context.Context, name string, params *UpdatePreferenceParams, body UpdatePreferenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePreferenceWithFormdataBody(ctx context.Context, name string, params *UpdatePreferenceParams, body UpdatePreferenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRecurrence request
	ListRecurrence(ctx context.Context, params *ListRecurrenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreRecurrenceWithBody request with any body
	StoreRecurrenceWithBody(ctx context.Context, params *StoreRecurrenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreRecurrence(ctx context.Context, params *StoreRecurrenceParams, body StoreRecurrenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreRecurrenceWithFormdataBody(ctx context.Context, params *StoreRecurrenceParams, body StoreRecurrenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRecurrence request
	DeleteRecurrence(ctx context.Context, id string, params *DeleteRecurrenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecurrence request
	GetRecurrence(ctx context.Context, id string, params *GetRecurrenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRecurrenceWithBody request with any body
	UpdateRecurrenceWithBody(ctx context.Context, id string, params *UpdateRecurrenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRecurrence(ctx context.Context, id string, params *UpdateRecurrenceParams, body UpdateRecurrenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRecurrenceWithFormdataBody(ctx context.Context, id string, params *UpdateRecurrenceParams, body UpdateRecurrenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactionByRecurrence request
	ListTransactionByRecurrence(ctx context.Context, id string, params *ListTransactionByRecurrenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRuleGroup request
	ListRuleGroup(ctx context.Context, params *ListRuleGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreRuleGroupWithBody request with any body
	StoreRuleGroupWithBody(ctx context.Context, params *StoreRuleGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreRuleGroup(ctx context.Context, params *StoreRuleGroupParams, body StoreRuleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreRuleGroupWithFormdataBody(ctx context.Context, params *StoreRuleGroupParams, body StoreRuleGroupFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRuleGroup request
	DeleteRuleGroup(ctx context.Context, id string, params *DeleteRuleGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleGroup request
	GetRuleGroup(ctx context.Context, id string, params *GetRuleGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRuleGroupWithBody request with any body
	UpdateRuleGroupWithBody(ctx context.Context, id string, params *UpdateRuleGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRuleGroup(ctx context.Context, id string, params *UpdateRuleGroupParams, body UpdateRuleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRuleGroupWithFormdataBody(ctx context.Context, id string, params *UpdateRuleGroupParams, body UpdateRuleGroupFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRuleByGroup request
	ListRuleByGroup(ctx context.Context, id string, params *ListRuleByGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestRuleGroup request
	TestRuleGroup(ctx context.Context, id string, params *TestRuleGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FireRuleGroup request
	FireRuleGroup(ctx context.Context, id string, params *FireRuleGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRule request
	ListRule(ctx context.Context, params *ListRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreRuleWithBody request with any body
	StoreRuleWithBody(ctx context.Context, params *StoreRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreRule(ctx context.Context, params *StoreRuleParams, body StoreRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreRuleWithFormdataBody(ctx context.Context, params *StoreRuleParams, body StoreRuleFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRule request
	DeleteRule(ctx context.Context, id string, params *DeleteRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRule request
	GetRule(ctx context.Context, id string, params *GetRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRuleWithBody request with any body
	UpdateRuleWithBody(ctx context.Context, id string, params *UpdateRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRule(ctx context.Context, id string, params *UpdateRuleParams, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRuleWithFormdataBody(ctx context.Context, id string, params *UpdateRuleParams, body UpdateRuleFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestRule request
	TestRule(ctx context.Context, id string, params *TestRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FireRule request
	FireRule(ctx context.Context, id string, params *FireRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchAccounts request
	SearchAccounts(ctx context.Context, params *SearchAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchTransactions request
	SearchTransactions(ctx context.Context, params *SearchTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBasicSummary request
	GetBasicSummary(ctx context.Context, params *GetBasicSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTag request
	ListTag(ctx context.Context, params *ListTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreTagWithBody request with any body
	StoreTagWithBody(ctx context.Context, params *StoreTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreTag(ctx context.Context, params *StoreTagParams, body StoreTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreTagWithFormdataBody(ctx context.Context, params *StoreTagParams, body StoreTagFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTag request
	DeleteTag(ctx context.Context, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTag request
	GetTag(ctx context.Context, tag string, params *GetTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTagWithBody request with any body
	UpdateTagWithBody(ctx context.Context, tag string, params *UpdateTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTag(ctx context.Context, tag string, params *UpdateTagParams, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTagWithFormdataBody(ctx context.Context, tag string, params *UpdateTagParams, body UpdateTagFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttachmentByTag request
	ListAttachmentByTag(ctx context.Context, tag string, params *ListAttachmentByTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactionByTag request
	ListTransactionByTag(ctx context.Context, tag string, params *ListTransactionByTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTransactionJournal request
	DeleteTransactionJournal(ctx context.Context, id string, params *DeleteTransactionJournalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionByJournal request
	GetTransactionByJournal(ctx context.Context, id string, params *GetTransactionByJournalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLinksByJournal request
	ListLinksByJournal(ctx context.Context, id string, params *ListLinksByJournalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactionLink request
	ListTransactionLink(ctx context.Context, params *ListTransactionLinkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreTransactionLinkWithBody request with any body
	StoreTransactionLinkWithBody(ctx context.Context, params *StoreTransactionLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreTransactionLink(ctx context.Context, params *StoreTransactionLinkParams, body StoreTransactionLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreTransactionLinkWithFormdataBody(ctx context.Context, params *StoreTransactionLinkParams, body StoreTransactionLinkFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTransactionLink request
	DeleteTransactionLink(ctx context.Context, id string, params *DeleteTransactionLinkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionLink request
	GetTransactionLink(ctx context.Context, id string, params *GetTransactionLinkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTransactionLinkWithBody request with any body
	UpdateTransactionLinkWithBody(ctx context.Context, id string, params *UpdateTransactionLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTransactionLink(ctx context.Context, id string, params *UpdateTransactionLinkParams, body UpdateTransactionLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTransactionLinkWithFormdataBody(ctx context.Context, id string, params *UpdateTransactionLinkParams, body UpdateTransactionLinkFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransaction request
	ListTransaction(ctx context.Context, params *ListTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreTransactionWithBody request with any body
	StoreTransactionWithBody(ctx context.Context, params *StoreTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreTransaction(ctx context.Context, params *StoreTransactionParams, body StoreTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreTransactionWithFormdataBody(ctx context.Context, params *StoreTransactionParams, body StoreTransactionFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTransaction request
	DeleteTransaction(ctx context.Context, id string, params *DeleteTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransaction request
	GetTransaction(ctx context.Context, id string, params *GetTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTransactionWithBody request with any body
	UpdateTransactionWithBody(ctx context.Context, id string, params *UpdateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTransaction(ctx context.Context, id string, params *UpdateTransactionParams, body UpdateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTransactionWithFormdataBody(ctx context.Context, id string, params *UpdateTransactionParams, body UpdateTransactionFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttachmentByTransaction request
	ListAttachmentByTransaction(ctx context.Context, id string, params *ListAttachmentByTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventByTransaction request
	ListEventByTransaction(ctx context.Context, id string, params *ListEventByTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUser request
	ListUser(ctx context.Context, params *ListUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreUserWithBody request with any body
	StoreUserWithBody(ctx context.Context, params *StoreUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreUser(ctx context.Context, params *StoreUserParams, body StoreUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreUserWithFormdataBody(ctx context.Context, params *StoreUserParams, body StoreUserFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, id string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, id string, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, id string, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, id string, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserWithFormdataBody(ctx context.Context, id string, params *UpdateUserParams, body UpdateUserFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWebhook request
	ListWebhook(ctx context.Context, params *ListWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreWebhookWithBody request with any body
	StoreWebhookWithBody(ctx context.Context, params *StoreWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreWebhook(ctx context.Context, params *StoreWebhookParams, body StoreWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreWebhookWithFormdataBody(ctx context.Context, params *StoreWebhookParams, body StoreWebhookFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhook request
	DeleteWebhook(ctx context.Context, id string, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhook request
	GetWebhook(ctx context.Context, id string, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWebhookWithBody request with any body
	UpdateWebhookWithBody(ctx context.Context, id string, params *UpdateWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWebhook(ctx context.Context, id string, params *UpdateWebhookParams, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWebhookWithFormdataBody(ctx context.Context, id string, params *UpdateWebhookParams, body UpdateWebhookFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhookMessages request
	GetWebhookMessages(ctx context.Context, id string, params *GetWebhookMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhookMessage request
	DeleteWebhookMessage(ctx context.Context, id string, messageId int, params *DeleteWebhookMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSingleWebhookMessage request
	GetSingleWebhookMessage(ctx context.Context, id string, messageId int, params *GetSingleWebhookMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhookMessageAttempts request
	GetWebhookMessageAttempts(ctx context.Context, id string, messageId int, params *GetWebhookMessageAttemptsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhookMessageAttempt request
	DeleteWebhookMessageAttempt(ctx context.Context, id string, messageId int, attemptId int, params *DeleteWebhookMessageAttemptParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSingleWebhookMessageAttempt request
	GetSingleWebhookMessageAttempt(ctx context.Context, id string, messageId int, attemptId int, params *GetSingleWebhookMessageAttemptParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitWebook request
	SubmitWebook(ctx context.Context, id string, params *SubmitWebookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerTransactionWebhook request
	TriggerTransactionWebhook(ctx context.Context, id string, transactionId string, params *TriggerTransactionWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAbout(ctx context.Context, params *GetAboutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAboutRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context, params *GetCurrentUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAccount(ctx context.Context, params *ListAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreAccountWithBody(ctx context.Context, params *StoreAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreAccount(ctx context.Context, params *StoreAccountParams, body StoreAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreAccountWithFormdataBody(ctx context.Context, params *StoreAccountParams, body StoreAccountFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreAccountRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAccount(ctx context.Context, id string, params *DeleteAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccountRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccount(ctx context.Context, id string, params *GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccountWithBody(ctx context.Context, id string, params *UpdateAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccount(ctx context.Context, id string, params *UpdateAccountParams, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccountWithFormdataBody(ctx context.Context, id string, params *UpdateAccountParams, body UpdateAccountFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttachmentByAccount(ctx context.Context, id string, params *ListAttachmentByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttachmentByAccountRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPiggyBankByAccount(ctx context.Context, id string, params *ListPiggyBankByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPiggyBankByAccountRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactionByAccount(ctx context.Context, id string, params *ListTransactionByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionByAccountRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttachment(ctx context.Context, params *ListAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttachmentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreAttachmentWithBody(ctx context.Context, params *StoreAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreAttachmentRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreAttachment(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreAttachmentRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreAttachmentWithFormdataBody(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreAttachmentRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttachment(ctx context.Context, id string, params *DeleteAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttachmentRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachment(ctx context.Context, id string, params *GetAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttachmentWithBody(ctx context.Context, id string, params *UpdateAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttachmentRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttachment(ctx context.Context, id string, params *UpdateAttachmentParams, body UpdateAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttachmentRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttachmentWithFormdataBody(ctx context.Context, id string, params *UpdateAttachmentParams, body UpdateAttachmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttachmentRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadAttachment(ctx context.Context, id string, params *DownloadAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadAttachmentRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadAttachmentWithBody(ctx context.Context, id string, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadAttachmentRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountsAC(ctx context.Context, params *GetAccountsACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountsACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillsAC(ctx context.Context, params *GetBillsACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillsACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBudgetsAC(ctx context.Context, params *GetBudgetsACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBudgetsACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategoriesAC(ctx context.Context, params *GetCategoriesACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoriesACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrenciesAC(ctx context.Context, params *GetCurrenciesACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrenciesACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrenciesCodeAC(ctx context.Context, params *GetCurrenciesCodeACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrenciesCodeACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObjectGroupsAC(ctx context.Context, params *GetObjectGroupsACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectGroupsACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPiggiesAC(ctx context.Context, params *GetPiggiesACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPiggiesACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPiggiesBalanceAC(ctx context.Context, params *GetPiggiesBalanceACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPiggiesBalanceACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecurringAC(ctx context.Context, params *GetRecurringACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecurringACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleGroupsAC(ctx context.Context, params *GetRuleGroupsACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleGroupsACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRulesAC(ctx context.Context, params *GetRulesACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTagAC(ctx context.Context, params *GetTagACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionTypesAC(ctx context.Context, params *GetTransactionTypesACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionTypesACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionsAC(ctx context.Context, params *GetTransactionsACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionsIDAC(ctx context.Context, params *GetTransactionsIDACParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsIDACRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableBudget(ctx context.Context, params *ListAvailableBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableBudgetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvailableBudget(ctx context.Context, id string, params *GetAvailableBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailableBudgetRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBill(ctx context.Context, params *ListBillParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreBillWithBody(ctx context.Context, params *StoreBillParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreBillRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreBill(ctx context.Context, params *StoreBillParams, body StoreBillJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreBillRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreBillWithFormdataBody(ctx context.Context, params *StoreBillParams, body StoreBillFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreBillRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBill(ctx context.Context, id string, params *DeleteBillParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBillRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBill(ctx context.Context, id string, params *GetBillParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBillWithBody(ctx context.Context, id string, params *UpdateBillParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBillRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBill(ctx context.Context, id string, params *UpdateBillParams, body UpdateBillJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBillRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBillWithFormdataBody(ctx context.Context, id string, params *UpdateBillParams, body UpdateBillFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBillRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttachmentByBill(ctx context.Context, id string, params *ListAttachmentByBillParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttachmentByBillRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRuleByBill(ctx context.Context, id string, params *ListRuleByBillParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRuleByBillRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactionByBill(ctx context.Context, id string, params *ListTransactionByBillParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionByBillRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBudgetLimit(ctx context.Context, params *ListBudgetLimitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBudgetLimitRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBudget(ctx context.Context, params *ListBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBudgetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreBudgetWithBody(ctx context.Context, params *StoreBudgetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreBudgetRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreBudget(ctx context.Context, params *StoreBudgetParams, body StoreBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreBudgetRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreBudgetWithFormdataBody(ctx context.Context, params *StoreBudgetParams, body StoreBudgetFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreBudgetRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBudget(ctx context.Context, id string, params *DeleteBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBudgetRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBudget(ctx context.Context, id string, params *GetBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBudgetRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBudgetWithBody(ctx context.Context, id string, params *UpdateBudgetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBudgetRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBudget(ctx context.Context, id string, params *UpdateBudgetParams, body UpdateBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBudgetRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBudgetWithFormdataBody(ctx context.Context, id string, params *UpdateBudgetParams, body UpdateBudgetFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBudgetRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttachmentByBudget(ctx context.Context, id string, params *ListAttachmentByBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttachmentByBudgetRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBudgetLimitByBudget(ctx context.Context, id string, params *ListBudgetLimitByBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBudgetLimitByBudgetRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreBudgetLimitWithBody(ctx context.Context, id string, params *StoreBudgetLimitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreBudgetLimitRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreBudgetLimit(ctx context.Context, id string, params *StoreBudgetLimitParams, body StoreBudgetLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreBudgetLimitRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreBudgetLimitWithFormdataBody(ctx context.Context, id string, params *StoreBudgetLimitParams, body StoreBudgetLimitFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreBudgetLimitRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBudgetLimit(ctx context.Context, id string, limitId string, params *DeleteBudgetLimitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBudgetLimitRequest(c.Server, id, limitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBudgetLimit(ctx context.Context, id string, limitId int, params *GetBudgetLimitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBudgetLimitRequest(c.Server, id, limitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBudgetLimitWithBody(ctx context.Context, id string, limitId string, params *UpdateBudgetLimitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBudgetLimitRequestWithBody(c.Server, id, limitId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBudgetLimit(ctx context.Context, id string, limitId string, params *UpdateBudgetLimitParams, body UpdateBudgetLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBudgetLimitRequest(c.Server, id, limitId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBudgetLimitWithFormdataBody(ctx context.Context, id string, limitId string, params *UpdateBudgetLimitParams, body UpdateBudgetLimitFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBudgetLimitRequestWithFormdataBody(c.Server, id, limitId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactionByBudgetLimit(ctx context.Context, id string, limitId string, params *ListTransactionByBudgetLimitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionByBudgetLimitRequest(c.Server, id, limitId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactionByBudget(ctx context.Context, id string, params *ListTransactionByBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionByBudgetRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCategory(ctx context.Context, params *ListCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCategoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCategoryWithBody(ctx context.Context, params *StoreCategoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCategoryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCategory(ctx context.Context, params *StoreCategoryParams, body StoreCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCategoryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCategoryWithFormdataBody(ctx context.Context, params *StoreCategoryParams, body StoreCategoryFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCategoryRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCategory(ctx context.Context, id string, params *DeleteCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCategoryRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategory(ctx context.Context, id string, params *GetCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoryRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCategoryWithBody(ctx context.Context, id string, params *UpdateCategoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCategoryRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCategory(ctx context.Context, id string, params *UpdateCategoryParams, body UpdateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCategoryRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCategoryWithFormdataBody(ctx context.Context, id string, params *UpdateCategoryParams, body UpdateCategoryFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCategoryRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttachmentByCategory(ctx context.Context, id string, params *ListAttachmentByCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttachmentByCategoryRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactionByCategory(ctx context.Context, id string, params *ListTransactionByCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionByCategoryRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChartAccountOverview(ctx context.Context, params *GetChartAccountOverviewParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChartAccountOverviewRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfiguration(ctx context.Context, params *GetConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSingleConfiguration(ctx context.Context, name ConfigValueFilter, params *GetSingleConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSingleConfigurationRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetConfigurationWithBody(ctx context.Context, name ConfigValueUpdateFilter, params *SetConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetConfigurationRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetConfiguration(ctx context.Context, name ConfigValueUpdateFilter, params *SetConfigurationParams, body SetConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetConfigurationRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetConfigurationWithFormdataBody(ctx context.Context, name ConfigValueUpdateFilter, params *SetConfigurationParams, body SetConfigurationFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetConfigurationRequestWithFormdataBody(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCron(ctx context.Context, cliToken string, params *GetCronParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCronRequest(c.Server, cliToken, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCurrency(ctx context.Context, params *ListCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCurrencyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCurrencyWithBody(ctx context.Context, params *StoreCurrencyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCurrencyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCurrency(ctx context.Context, params *StoreCurrencyParams, body StoreCurrencyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCurrencyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCurrencyWithFormdataBody(ctx context.Context, params *StoreCurrencyParams, body StoreCurrencyFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCurrencyRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultCurrency(ctx context.Context, params *GetDefaultCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultCurrencyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCurrency(ctx context.Context, code string, params *DeleteCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCurrencyRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrency(ctx context.Context, code string, params *GetCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrencyRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCurrencyWithBody(ctx context.Context, code string, params *UpdateCurrencyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCurrencyRequestWithBody(c.Server, code, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCurrencyWithApplicationVndAPIPlusJSONBody(ctx context.Context, code string, params *UpdateCurrencyParams, body UpdateCurrencyApplicationVndAPIPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCurrencyRequestWithApplicationVndAPIPlusJSONBody(c.Server, code, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCurrencyWithFormdataBody(ctx context.Context, code string, params *UpdateCurrencyParams, body UpdateCurrencyFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCurrencyRequestWithFormdataBody(c.Server, code, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAccountByCurrency(ctx context.Context, code string, params *ListAccountByCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccountByCurrencyRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableBudgetByCurrency(ctx context.Context, code string, params *ListAvailableBudgetByCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableBudgetByCurrencyRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillByCurrency(ctx context.Context, code string, params *ListBillByCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillByCurrencyRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBudgetLimitByCurrency(ctx context.Context, code string, params *ListBudgetLimitByCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBudgetLimitByCurrencyRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DefaultCurrency(ctx context.Context, code string, params *DefaultCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDefaultCurrencyRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableCurrency(ctx context.Context, code string, params *DisableCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableCurrencyRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableCurrency(ctx context.Context, code string, params *EnableCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableCurrencyRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRecurrenceByCurrency(ctx context.Context, code string, params *ListRecurrenceByCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRecurrenceByCurrencyRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRuleByCurrency(ctx context.Context, code string, params *ListRuleByCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRuleByCurrencyRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactionByCurrency(ctx context.Context, code string, params *ListTransactionByCurrencyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionByCurrencyRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateTransactions(ctx context.Context, params *BulkUpdateTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DestroyData(ctx context.Context, params *DestroyDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroyDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportAccounts(ctx context.Context, params *ExportAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportBills(ctx context.Context, params *ExportBillsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportBillsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportBudgets(ctx context.Context, params *ExportBudgetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportBudgetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportCategories(ctx context.Context, params *ExportCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportPiggies(ctx context.Context, params *ExportPiggiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportPiggiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportRecurring(ctx context.Context, params *ExportRecurringParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportRecurringRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportRules(ctx context.Context, params *ExportRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportTags(ctx context.Context, params *ExportTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportTransactions(ctx context.Context, params *ExportTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgeData(ctx context.Context, params *PurgeDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgeDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightExpenseAsset(ctx context.Context, params *InsightExpenseAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightExpenseAssetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightExpenseBill(ctx context.Context, params *InsightExpenseBillParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightExpenseBillRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightExpenseBudget(ctx context.Context, params *InsightExpenseBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightExpenseBudgetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightExpenseCategory(ctx context.Context, params *InsightExpenseCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightExpenseCategoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightExpenseExpense(ctx context.Context, params *InsightExpenseExpenseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightExpenseExpenseRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightExpenseNoBill(ctx context.Context, params *InsightExpenseNoBillParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightExpenseNoBillRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightExpenseNoBudget(ctx context.Context, params *InsightExpenseNoBudgetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightExpenseNoBudgetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightExpenseNoCategory(ctx context.Context, params *InsightExpenseNoCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightExpenseNoCategoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightExpenseNoTag(ctx context.Context, params *InsightExpenseNoTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightExpenseNoTagRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightExpenseTag(ctx context.Context, params *InsightExpenseTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightExpenseTagRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightExpenseTotal(ctx context.Context, params *InsightExpenseTotalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightExpenseTotalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightIncomeAsset(ctx context.Context, params *InsightIncomeAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightIncomeAssetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightIncomeCategory(ctx context.Context, params *InsightIncomeCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightIncomeCategoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightIncomeNoCategory(ctx context.Context, params *InsightIncomeNoCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightIncomeNoCategoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightIncomeNoTag(ctx context.Context, params *InsightIncomeNoTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightIncomeNoTagRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightIncomeRevenue(ctx context.Context, params *InsightIncomeRevenueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightIncomeRevenueRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightIncomeTag(ctx context.Context, params *InsightIncomeTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightIncomeTagRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightIncomeTotal(ctx context.Context, params *InsightIncomeTotalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightIncomeTotalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightTransfers(ctx context.Context, params *InsightTransfersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightTransfersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightTransferCategory(ctx context.Context, params *InsightTransferCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightTransferCategoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightTransferNoCategory(ctx context.Context, params *InsightTransferNoCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightTransferNoCategoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightTransferNoTag(ctx context.Context, params *InsightTransferNoTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightTransferNoTagRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightTransferTag(ctx context.Context, params *InsightTransferTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightTransferTagRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InsightTransferTotal(ctx context.Context, params *InsightTransferTotalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInsightTransferTotalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLinkType(ctx context.Context, params *ListLinkTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLinkTypeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreLinkTypeWithBody(ctx context.Context, params *StoreLinkTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreLinkTypeRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreLinkType(ctx context.Context, params *StoreLinkTypeParams, body StoreLinkTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreLinkTypeRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreLinkTypeWithFormdataBody(ctx context.Context, params *StoreLinkTypeParams, body StoreLinkTypeFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreLinkTypeRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLinkType(ctx context.Context, id string, params *DeleteLinkTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLinkTypeRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLinkType(ctx context.Context, id string, params *GetLinkTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLinkTypeRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLinkTypeWithBody(ctx context.Context, id string, params *UpdateLinkTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLinkTypeRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLinkType(ctx context.Context, id string, params *UpdateLinkTypeParams, body UpdateLinkTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLinkTypeRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLinkTypeWithFormdataBody(ctx context.Context, id string, params *UpdateLinkTypeParams, body UpdateLinkTypeFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLinkTypeRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactionByLinkType(ctx context.Context, id string, params *ListTransactionByLinkTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionByLinkTypeRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListObjectGroups(ctx context.Context, params *ListObjectGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListObjectGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObjectGroup(ctx context.Context, id string, params *DeleteObjectGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObjectGroup(ctx context.Context, id string, params *GetObjectGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateObjectGroupWithBody(ctx context.Context, id string, params *UpdateObjectGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateObjectGroupRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateObjectGroup(ctx context.Context, id string, params *UpdateObjectGroupParams, body UpdateObjectGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateObjectGroupRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateObjectGroupWithFormdataBody(ctx context.Context, id string, params *UpdateObjectGroupParams, body UpdateObjectGroupFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateObjectGroupRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillByObjectGroup(ctx context.Context, id string, params *ListBillByObjectGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillByObjectGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPiggyBankByObjectGroup(ctx context.Context, id string, params *ListPiggyBankByObjectGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPiggyBankByObjectGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPiggyBank(ctx context.Context, params *ListPiggyBankParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPiggyBankRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorePiggyBankWithBody(ctx context.Context, params *StorePiggyBankParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorePiggyBankRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorePiggyBank(ctx context.Context, params *StorePiggyBankParams, body StorePiggyBankJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorePiggyBankRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorePiggyBankWithFormdataBody(ctx context.Context, params *StorePiggyBankParams, body StorePiggyBankFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorePiggyBankRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePiggyBank(ctx context.Context, id string, params *DeletePiggyBankParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePiggyBankRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPiggyBank(ctx context.Context, id string, params *GetPiggyBankParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPiggyBankRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePiggyBankWithBody(ctx context.Context, id string, params *UpdatePiggyBankParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePiggyBankRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePiggyBank(ctx context.Context, id string, params *UpdatePiggyBankParams, body UpdatePiggyBankJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePiggyBankRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePiggyBankWithFormdataBody(ctx context.Context, id string, params *UpdatePiggyBankParams, body UpdatePiggyBankFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePiggyBankRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttachmentByPiggyBank(ctx context.Context, id string, params *ListAttachmentByPiggyBankParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttachmentByPiggyBankRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventByPiggyBank(ctx context.Context, id string, params *ListEventByPiggyBankParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventByPiggyBankRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPreference(ctx context.Context, params *ListPreferenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPreferenceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorePreferenceWithBody(ctx context.Context, params *StorePreferenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorePreferenceRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorePreference(ctx context.Context, params *StorePreferenceParams, body StorePreferenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorePreferenceRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorePreferenceWithFormdataBody(ctx context.Context, params *StorePreferenceParams, body StorePreferenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorePreferenceRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPreference(ctx context.Context, name string, params *GetPreferenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPreferenceRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePreferenceWithBody(ctx context.Context, name string, params *UpdatePreferenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePreferenceRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePreference(ctx context.Context, name string, params *UpdatePreferenceParams, body UpdatePreferenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePreferenceRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePreferenceWithFormdataBody(ctx context.Context, name string, params *UpdatePreferenceParams, body UpdatePreferenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePreferenceRequestWithFormdataBody(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRecurrence(ctx context.Context, params *ListRecurrenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRecurrenceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreRecurrenceWithBody(ctx context.Context, params *StoreRecurrenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreRecurrenceRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreRecurrence(ctx context.Context, params *StoreRecurrenceParams, body StoreRecurrenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreRecurrenceRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreRecurrenceWithFormdataBody(ctx context.Context, params *StoreRecurrenceParams, body StoreRecurrenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreRecurrenceRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecurrence(ctx context.Context, id string, params *DeleteRecurrenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecurrenceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecurrence(ctx context.Context, id string, params *GetRecurrenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecurrenceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecurrenceWithBody(ctx context.Context, id string, params *UpdateRecurrenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecurrenceRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecurrence(ctx context.Context, id string, params *UpdateRecurrenceParams, body UpdateRecurrenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecurrenceRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecurrenceWithFormdataBody(ctx context.Context, id string, params *UpdateRecurrenceParams, body UpdateRecurrenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecurrenceRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactionByRecurrence(ctx context.Context, id string, params *ListTransactionByRecurrenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionByRecurrenceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRuleGroup(ctx context.Context, params *ListRuleGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRuleGroupRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreRuleGroupWithBody(ctx context.Context, params *StoreRuleGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreRuleGroupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreRuleGroup(ctx context.Context, params *StoreRuleGroupParams, body StoreRuleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreRuleGroupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreRuleGroupWithFormdataBody(ctx context.Context, params *StoreRuleGroupParams, body StoreRuleGroupFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreRuleGroupRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRuleGroup(ctx context.Context, id string, params *DeleteRuleGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuleGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleGroup(ctx context.Context, id string, params *GetRuleGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleGroupWithBody(ctx context.Context, id string, params *UpdateRuleGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleGroupRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleGroup(ctx context.Context, id string, params *UpdateRuleGroupParams, body UpdateRuleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleGroupRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleGroupWithFormdataBody(ctx context.Context, id string, params *UpdateRuleGroupParams, body UpdateRuleGroupFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleGroupRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRuleByGroup(ctx context.Context, id string, params *ListRuleByGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRuleByGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestRuleGroup(ctx context.Context, id string, params *TestRuleGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestRuleGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FireRuleGroup(ctx context.Context, id string, params *FireRuleGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFireRuleGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRule(ctx context.Context, params *ListRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRuleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreRuleWithBody(ctx context.Context, params *StoreRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreRuleRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreRule(ctx context.Context, params *StoreRuleParams, body StoreRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreRuleRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreRuleWithFormdataBody(ctx context.Context, params *StoreRuleParams, body StoreRuleFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreRuleRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRule(ctx context.Context, id string, params *DeleteRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRule(ctx context.Context, id string, params *GetRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleWithBody(ctx context.Context, id string, params *UpdateRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRule(ctx context.Context, id string, params *UpdateRuleParams, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleWithFormdataBody(ctx context.Context, id string, params *UpdateRuleParams, body UpdateRuleFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestRule(ctx context.Context, id string, params *TestRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestRuleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FireRule(ctx context.Context, id string, params *FireRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFireRuleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchAccounts(ctx context.Context, params *SearchAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTransactions(ctx context.Context, params *SearchTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBasicSummary(ctx context.Context, params *GetBasicSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBasicSummaryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTag(ctx context.Context, params *ListTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTagRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreTagWithBody(ctx context.Context, params *StoreTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreTagRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreTag(ctx context.Context, params *StoreTagParams, body StoreTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreTagRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreTagWithFormdataBody(ctx context.Context, params *StoreTagParams, body StoreTagFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreTagRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTag(ctx context.Context, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagRequest(c.Server, tag, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTag(ctx context.Context, tag string, params *GetTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagRequest(c.Server, tag, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTagWithBody(ctx context.Context, tag string, params *UpdateTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTagRequestWithBody(c.Server, tag, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTag(ctx context.Context, tag string, params *UpdateTagParams, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTagRequest(c.Server, tag, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTagWithFormdataBody(ctx context.Context, tag string, params *UpdateTagParams, body UpdateTagFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTagRequestWithFormdataBody(c.Server, tag, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttachmentByTag(ctx context.Context, tag string, params *ListAttachmentByTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttachmentByTagRequest(c.Server, tag, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactionByTag(ctx context.Context, tag string, params *ListTransactionByTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionByTagRequest(c.Server, tag, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTransactionJournal(ctx context.Context, id string, params *DeleteTransactionJournalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTransactionJournalRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionByJournal(ctx context.Context, id string, params *GetTransactionByJournalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionByJournalRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLinksByJournal(ctx context.Context, id string, params *ListLinksByJournalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLinksByJournalRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactionLink(ctx context.Context, params *ListTransactionLinkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionLinkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreTransactionLinkWithBody(ctx context.Context, params *StoreTransactionLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreTransactionLinkRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreTransactionLink(ctx context.Context, params *StoreTransactionLinkParams, body StoreTransactionLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreTransactionLinkRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreTransactionLinkWithFormdataBody(ctx context.Context, params *StoreTransactionLinkParams, body StoreTransactionLinkFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreTransactionLinkRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTransactionLink(ctx context.Context, id string, params *DeleteTransactionLinkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTransactionLinkRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionLink(ctx context.Context, id string, params *GetTransactionLinkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionLinkRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTransactionLinkWithBody(ctx context.Context, id string, params *UpdateTransactionLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTransactionLinkRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTransactionLink(ctx context.Context, id string, params *UpdateTransactionLinkParams, body UpdateTransactionLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTransactionLinkRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTransactionLinkWithFormdataBody(ctx context.Context, id string, params *UpdateTransactionLinkParams, body UpdateTransactionLinkFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTransactionLinkRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransaction(ctx context.Context, params *ListTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreTransactionWithBody(ctx context.Context, params *StoreTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreTransactionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreTransaction(ctx context.Context, params *StoreTransactionParams, body StoreTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreTransactionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreTransactionWithFormdataBody(ctx context.Context, params *StoreTransactionParams, body StoreTransactionFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreTransactionRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTransaction(ctx context.Context, id string, params *DeleteTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTransactionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransaction(ctx context.Context, id string, params *GetTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTransactionWithBody(ctx context.Context, id string, params *UpdateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTransactionRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTransaction(ctx context.Context, id string, params *UpdateTransactionParams, body UpdateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTransactionRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTransactionWithFormdataBody(ctx context.Context, id string, params *UpdateTransactionParams, body UpdateTransactionFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTransactionRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttachmentByTransaction(ctx context.Context, id string, params *ListAttachmentByTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttachmentByTransactionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventByTransaction(ctx context.Context, id string, params *ListEventByTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventByTransactionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUser(ctx context.Context, params *ListUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreUserWithBody(ctx context.Context, params *StoreUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreUser(ctx context.Context, params *StoreUserParams, body StoreUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreUserWithFormdataBody(ctx context.Context, params *StoreUserParams, body StoreUserFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreUserRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, id string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, id string, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, id string, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, id string, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithFormdataBody(ctx context.Context, id string, params *UpdateUserParams, body UpdateUserFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebhook(ctx context.Context, params *ListWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebhookRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreWebhookWithBody(ctx context.Context, params *StoreWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreWebhookRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreWebhook(ctx context.Context, params *StoreWebhookParams, body StoreWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreWebhookRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreWebhookWithFormdataBody(ctx context.Context, params *StoreWebhookParams, body StoreWebhookFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreWebhookRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhook(ctx context.Context, id string, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhook(ctx context.Context, id string, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhookWithBody(ctx context.Context, id string, params *UpdateWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhook(ctx context.Context, id string, params *UpdateWebhookParams, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhookWithFormdataBody(ctx context.Context, id string, params *UpdateWebhookParams, body UpdateWebhookFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookRequestWithFormdataBody(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhookMessages(ctx context.Context, id string, params *GetWebhookMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookMessagesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhookMessage(ctx context.Context, id string, messageId int, params *DeleteWebhookMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookMessageRequest(c.Server, id, messageId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSingleWebhookMessage(ctx context.Context, id string, messageId int, params *GetSingleWebhookMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSingleWebhookMessageRequest(c.Server, id, messageId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhookMessageAttempts(ctx context.Context, id string, messageId int, params *GetWebhookMessageAttemptsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookMessageAttemptsRequest(c.Server, id, messageId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhookMessageAttempt(ctx context.Context, id string, messageId int, attemptId int, params *DeleteWebhookMessageAttemptParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookMessageAttemptRequest(c.Server, id, messageId, attemptId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSingleWebhookMessageAttempt(ctx context.Context, id string, messageId int, attemptId int, params *GetSingleWebhookMessageAttemptParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSingleWebhookMessageAttemptRequest(c.Server, id, messageId, attemptId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitWebook(ctx context.Context, id string, params *SubmitWebookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitWebookRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerTransactionWebhook(ctx context.Context, id string, transactionId string, params *TriggerTransactionWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerTransactionWebhookRequest(c.Server, id, transactionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAboutRequest generates requests for GetAbout
func NewGetAboutRequest(server string, params *GetAboutParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/about")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string, params *GetCurrentUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/about/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListAccountRequest generates requests for ListAccount
func NewListAccountRequest(server string, params *ListAccountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreAccountRequest calls the generic StoreAccount builder with application/json body
func NewStoreAccountRequest(server string, params *StoreAccountParams, body StoreAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreAccountRequestWithFormdataBody calls the generic StoreAccount builder with application/x-www-form-urlencoded body
func NewStoreAccountRequestWithFormdataBody(server string, params *StoreAccountParams, body StoreAccountFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreAccountRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreAccountRequestWithBody generates requests for StoreAccount with any type of body
func NewStoreAccountRequestWithBody(server string, params *StoreAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAccountRequest generates requests for DeleteAccount
func NewDeleteAccountRequest(server string, id string, params *DeleteAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetAccountRequest generates requests for GetAccount
func NewGetAccountRequest(server string, id string, params *GetAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateAccountRequest calls the generic UpdateAccount builder with application/json body
func NewUpdateAccountRequest(server string, id string, params *UpdateAccountParams, body UpdateAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccountRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateAccountRequestWithFormdataBody calls the generic UpdateAccount builder with application/x-www-form-urlencoded body
func NewUpdateAccountRequestWithFormdataBody(server string, id string, params *UpdateAccountParams, body UpdateAccountFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateAccountRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateAccountRequestWithBody generates requests for UpdateAccount with any type of body
func NewUpdateAccountRequestWithBody(server string, id string, params *UpdateAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListAttachmentByAccountRequest generates requests for ListAttachmentByAccount
func NewListAttachmentByAccountRequest(server string, id string, params *ListAttachmentByAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListPiggyBankByAccountRequest generates requests for ListPiggyBankByAccount
func NewListPiggyBankByAccountRequest(server string, id string, params *ListPiggyBankByAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/piggy-banks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListTransactionByAccountRequest generates requests for ListTransactionByAccount
func NewListTransactionByAccountRequest(server string, id string, params *ListTransactionByAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/accounts/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListAttachmentRequest generates requests for ListAttachment
func NewListAttachmentRequest(server string, params *ListAttachmentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/attachments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreAttachmentRequest calls the generic StoreAttachment builder with application/json body
func NewStoreAttachmentRequest(server string, params *StoreAttachmentParams, body StoreAttachmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreAttachmentRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreAttachmentRequestWithFormdataBody calls the generic StoreAttachment builder with application/x-www-form-urlencoded body
func NewStoreAttachmentRequestWithFormdataBody(server string, params *StoreAttachmentParams, body StoreAttachmentFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreAttachmentRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreAttachmentRequestWithBody generates requests for StoreAttachment with any type of body
func NewStoreAttachmentRequestWithBody(server string, params *StoreAttachmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/attachments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAttachmentRequest generates requests for DeleteAttachment
func NewDeleteAttachmentRequest(server string, id string, params *DeleteAttachmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/attachments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetAttachmentRequest generates requests for GetAttachment
func NewGetAttachmentRequest(server string, id string, params *GetAttachmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/attachments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateAttachmentRequest calls the generic UpdateAttachment builder with application/json body
func NewUpdateAttachmentRequest(server string, id string, params *UpdateAttachmentParams, body UpdateAttachmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAttachmentRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateAttachmentRequestWithFormdataBody calls the generic UpdateAttachment builder with application/x-www-form-urlencoded body
func NewUpdateAttachmentRequestWithFormdataBody(server string, id string, params *UpdateAttachmentParams, body UpdateAttachmentFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateAttachmentRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateAttachmentRequestWithBody generates requests for UpdateAttachment with any type of body
func NewUpdateAttachmentRequestWithBody(server string, id string, params *UpdateAttachmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/attachments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDownloadAttachmentRequest generates requests for DownloadAttachment
func NewDownloadAttachmentRequest(server string, id string, params *DownloadAttachmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/attachments/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUploadAttachmentRequestWithBody generates requests for UploadAttachment with any type of body
func NewUploadAttachmentRequestWithBody(server string, id string, params *UploadAttachmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/attachments/%s/upload", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetAccountsACRequest generates requests for GetAccountsAC
func NewGetAccountsACRequest(server string, params *GetAccountsACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Types != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "types", runtime.ParamLocationQuery, *params.Types); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetBillsACRequest generates requests for GetBillsAC
func NewGetBillsACRequest(server string, params *GetBillsACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/bills")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetBudgetsACRequest generates requests for GetBudgetsAC
func NewGetBudgetsACRequest(server string, params *GetBudgetsACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/budgets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetCategoriesACRequest generates requests for GetCategoriesAC
func NewGetCategoriesACRequest(server string, params *GetCategoriesACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetCurrenciesACRequest generates requests for GetCurrenciesAC
func NewGetCurrenciesACRequest(server string, params *GetCurrenciesACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/currencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetCurrenciesCodeACRequest generates requests for GetCurrenciesCodeAC
func NewGetCurrenciesCodeACRequest(server string, params *GetCurrenciesCodeACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/currencies-with-code")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetObjectGroupsACRequest generates requests for GetObjectGroupsAC
func NewGetObjectGroupsACRequest(server string, params *GetObjectGroupsACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/object-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetPiggiesACRequest generates requests for GetPiggiesAC
func NewGetPiggiesACRequest(server string, params *GetPiggiesACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/piggy-banks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetPiggiesBalanceACRequest generates requests for GetPiggiesBalanceAC
func NewGetPiggiesBalanceACRequest(server string, params *GetPiggiesBalanceACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/piggy-banks-with-balance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetRecurringACRequest generates requests for GetRecurringAC
func NewGetRecurringACRequest(server string, params *GetRecurringACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/recurring")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetRuleGroupsACRequest generates requests for GetRuleGroupsAC
func NewGetRuleGroupsACRequest(server string, params *GetRuleGroupsACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/rule-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetRulesACRequest generates requests for GetRulesAC
func NewGetRulesACRequest(server string, params *GetRulesACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetTagACRequest generates requests for GetTagAC
func NewGetTagACRequest(server string, params *GetTagACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetTransactionTypesACRequest generates requests for GetTransactionTypesAC
func NewGetTransactionTypesACRequest(server string, params *GetTransactionTypesACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/transaction-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetTransactionsACRequest generates requests for GetTransactionsAC
func NewGetTransactionsACRequest(server string, params *GetTransactionsACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetTransactionsIDACRequest generates requests for GetTransactionsIDAC
func NewGetTransactionsIDACRequest(server string, params *GetTransactionsIDACParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete/transactions-with-id")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListAvailableBudgetRequest generates requests for ListAvailableBudget
func NewListAvailableBudgetRequest(server string, params *ListAvailableBudgetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/available-budgets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetAvailableBudgetRequest generates requests for GetAvailableBudget
func NewGetAvailableBudgetRequest(server string, id string, params *GetAvailableBudgetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/available-budgets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListBillRequest generates requests for ListBill
func NewListBillRequest(server string, params *ListBillParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bills")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreBillRequest calls the generic StoreBill builder with application/json body
func NewStoreBillRequest(server string, params *StoreBillParams, body StoreBillJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreBillRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreBillRequestWithFormdataBody calls the generic StoreBill builder with application/x-www-form-urlencoded body
func NewStoreBillRequestWithFormdataBody(server string, params *StoreBillParams, body StoreBillFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreBillRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreBillRequestWithBody generates requests for StoreBill with any type of body
func NewStoreBillRequestWithBody(server string, params *StoreBillParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bills")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteBillRequest generates requests for DeleteBill
func NewDeleteBillRequest(server string, id string, params *DeleteBillParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bills/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetBillRequest generates requests for GetBill
func NewGetBillRequest(server string, id string, params *GetBillParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bills/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateBillRequest calls the generic UpdateBill builder with application/json body
func NewUpdateBillRequest(server string, id string, params *UpdateBillParams, body UpdateBillJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBillRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateBillRequestWithFormdataBody calls the generic UpdateBill builder with application/x-www-form-urlencoded body
func NewUpdateBillRequestWithFormdataBody(server string, id string, params *UpdateBillParams, body UpdateBillFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateBillRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateBillRequestWithBody generates requests for UpdateBill with any type of body
func NewUpdateBillRequestWithBody(server string, id string, params *UpdateBillParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bills/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListAttachmentByBillRequest generates requests for ListAttachmentByBill
func NewListAttachmentByBillRequest(server string, id string, params *ListAttachmentByBillParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bills/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListRuleByBillRequest generates requests for ListRuleByBill
func NewListRuleByBillRequest(server string, id string, params *ListRuleByBillParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bills/%s/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListTransactionByBillRequest generates requests for ListTransactionByBill
func NewListTransactionByBillRequest(server string, id string, params *ListTransactionByBillParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/bills/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListBudgetLimitRequest generates requests for ListBudgetLimit
func NewListBudgetLimitRequest(server string, params *ListBudgetLimitParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/budget-limits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListBudgetRequest generates requests for ListBudget
func NewListBudgetRequest(server string, params *ListBudgetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/budgets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreBudgetRequest calls the generic StoreBudget builder with application/json body
func NewStoreBudgetRequest(server string, params *StoreBudgetParams, body StoreBudgetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreBudgetRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreBudgetRequestWithFormdataBody calls the generic StoreBudget builder with application/x-www-form-urlencoded body
func NewStoreBudgetRequestWithFormdataBody(server string, params *StoreBudgetParams, body StoreBudgetFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreBudgetRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreBudgetRequestWithBody generates requests for StoreBudget with any type of body
func NewStoreBudgetRequestWithBody(server string, params *StoreBudgetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/budgets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteBudgetRequest generates requests for DeleteBudget
func NewDeleteBudgetRequest(server string, id string, params *DeleteBudgetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/budgets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetBudgetRequest generates requests for GetBudget
func NewGetBudgetRequest(server string, id string, params *GetBudgetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/budgets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateBudgetRequest calls the generic UpdateBudget builder with application/json body
func NewUpdateBudgetRequest(server string, id string, params *UpdateBudgetParams, body UpdateBudgetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBudgetRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateBudgetRequestWithFormdataBody calls the generic UpdateBudget builder with application/x-www-form-urlencoded body
func NewUpdateBudgetRequestWithFormdataBody(server string, id string, params *UpdateBudgetParams, body UpdateBudgetFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateBudgetRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateBudgetRequestWithBody generates requests for UpdateBudget with any type of body
func NewUpdateBudgetRequestWithBody(server string, id string, params *UpdateBudgetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/budgets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListAttachmentByBudgetRequest generates requests for ListAttachmentByBudget
func NewListAttachmentByBudgetRequest(server string, id string, params *ListAttachmentByBudgetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/budgets/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListBudgetLimitByBudgetRequest generates requests for ListBudgetLimitByBudget
func NewListBudgetLimitByBudgetRequest(server string, id string, params *ListBudgetLimitByBudgetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/budgets/%s/limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreBudgetLimitRequest calls the generic StoreBudgetLimit builder with application/json body
func NewStoreBudgetLimitRequest(server string, id string, params *StoreBudgetLimitParams, body StoreBudgetLimitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreBudgetLimitRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewStoreBudgetLimitRequestWithFormdataBody calls the generic StoreBudgetLimit builder with application/x-www-form-urlencoded body
func NewStoreBudgetLimitRequestWithFormdataBody(server string, id string, params *StoreBudgetLimitParams, body StoreBudgetLimitFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreBudgetLimitRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreBudgetLimitRequestWithBody generates requests for StoreBudgetLimit with any type of body
func NewStoreBudgetLimitRequestWithBody(server string, id string, params *StoreBudgetLimitParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/budgets/%s/limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteBudgetLimitRequest generates requests for DeleteBudgetLimit
func NewDeleteBudgetLimitRequest(server string, id string, limitId string, params *DeleteBudgetLimitParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "limitId", runtime.ParamLocationPath, limitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/budgets/%s/limits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetBudgetLimitRequest generates requests for GetBudgetLimit
func NewGetBudgetLimitRequest(server string, id string, limitId int, params *GetBudgetLimitParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "limitId", runtime.ParamLocationPath, limitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/budgets/%s/limits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateBudgetLimitRequest calls the generic UpdateBudgetLimit builder with application/json body
func NewUpdateBudgetLimitRequest(server string, id string, limitId string, params *UpdateBudgetLimitParams, body UpdateBudgetLimitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBudgetLimitRequestWithBody(server, id, limitId, params, "application/json", bodyReader)
}

// NewUpdateBudgetLimitRequestWithFormdataBody calls the generic UpdateBudgetLimit builder with application/x-www-form-urlencoded body
func NewUpdateBudgetLimitRequestWithFormdataBody(server string, id string, limitId string, params *UpdateBudgetLimitParams, body UpdateBudgetLimitFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateBudgetLimitRequestWithBody(server, id, limitId, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateBudgetLimitRequestWithBody generates requests for UpdateBudgetLimit with any type of body
func NewUpdateBudgetLimitRequestWithBody(server string, id string, limitId string, params *UpdateBudgetLimitParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "limitId", runtime.ParamLocationPath, limitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/budgets/%s/limits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListTransactionByBudgetLimitRequest generates requests for ListTransactionByBudgetLimit
func NewListTransactionByBudgetLimitRequest(server string, id string, limitId string, params *ListTransactionByBudgetLimitParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "limitId", runtime.ParamLocationPath, limitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/budgets/%s/limits/%s/transactions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListTransactionByBudgetRequest generates requests for ListTransactionByBudget
func NewListTransactionByBudgetRequest(server string, id string, params *ListTransactionByBudgetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/budgets/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListCategoryRequest generates requests for ListCategory
func NewListCategoryRequest(server string, params *ListCategoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreCategoryRequest calls the generic StoreCategory builder with application/json body
func NewStoreCategoryRequest(server string, params *StoreCategoryParams, body StoreCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreCategoryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreCategoryRequestWithFormdataBody calls the generic StoreCategory builder with application/x-www-form-urlencoded body
func NewStoreCategoryRequestWithFormdataBody(server string, params *StoreCategoryParams, body StoreCategoryFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreCategoryRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreCategoryRequestWithBody generates requests for StoreCategory with any type of body
func NewStoreCategoryRequestWithBody(server string, params *StoreCategoryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteCategoryRequest generates requests for DeleteCategory
func NewDeleteCategoryRequest(server string, id string, params *DeleteCategoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetCategoryRequest generates requests for GetCategory
func NewGetCategoryRequest(server string, id string, params *GetCategoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateCategoryRequest calls the generic UpdateCategory builder with application/json body
func NewUpdateCategoryRequest(server string, id string, params *UpdateCategoryParams, body UpdateCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCategoryRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateCategoryRequestWithFormdataBody calls the generic UpdateCategory builder with application/x-www-form-urlencoded body
func NewUpdateCategoryRequestWithFormdataBody(server string, id string, params *UpdateCategoryParams, body UpdateCategoryFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateCategoryRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateCategoryRequestWithBody generates requests for UpdateCategory with any type of body
func NewUpdateCategoryRequestWithBody(server string, id string, params *UpdateCategoryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListAttachmentByCategoryRequest generates requests for ListAttachmentByCategory
func NewListAttachmentByCategoryRequest(server string, id string, params *ListAttachmentByCategoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/categories/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListTransactionByCategoryRequest generates requests for ListTransactionByCategory
func NewListTransactionByCategoryRequest(server string, id string, params *ListTransactionByCategoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/categories/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetChartAccountOverviewRequest generates requests for GetChartAccountOverview
func NewGetChartAccountOverviewRequest(server string, params *GetChartAccountOverviewParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/chart/account/overview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetConfigurationRequest generates requests for GetConfiguration
func NewGetConfigurationRequest(server string, params *GetConfigurationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetSingleConfigurationRequest generates requests for GetSingleConfiguration
func NewGetSingleConfigurationRequest(server string, name ConfigValueFilter, params *GetSingleConfigurationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/configuration/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewSetConfigurationRequest calls the generic SetConfiguration builder with application/json body
func NewSetConfigurationRequest(server string, name ConfigValueUpdateFilter, params *SetConfigurationParams, body SetConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetConfigurationRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewSetConfigurationRequestWithFormdataBody calls the generic SetConfiguration builder with application/x-www-form-urlencoded body
func NewSetConfigurationRequestWithFormdataBody(server string, name ConfigValueUpdateFilter, params *SetConfigurationParams, body SetConfigurationFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSetConfigurationRequestWithBody(server, name, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewSetConfigurationRequestWithBody generates requests for SetConfiguration with any type of body
func NewSetConfigurationRequestWithBody(server string, name ConfigValueUpdateFilter, params *SetConfigurationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/configuration/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetCronRequest generates requests for GetCron
func NewGetCronRequest(server string, cliToken string, params *GetCronParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cliToken", runtime.ParamLocationPath, cliToken)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/cron/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListCurrencyRequest generates requests for ListCurrency
func NewListCurrencyRequest(server string, params *ListCurrencyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreCurrencyRequest calls the generic StoreCurrency builder with application/json body
func NewStoreCurrencyRequest(server string, params *StoreCurrencyParams, body StoreCurrencyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreCurrencyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreCurrencyRequestWithFormdataBody calls the generic StoreCurrency builder with application/x-www-form-urlencoded body
func NewStoreCurrencyRequestWithFormdataBody(server string, params *StoreCurrencyParams, body StoreCurrencyFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreCurrencyRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreCurrencyRequestWithBody generates requests for StoreCurrency with any type of body
func NewStoreCurrencyRequestWithBody(server string, params *StoreCurrencyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetDefaultCurrencyRequest generates requests for GetDefaultCurrency
func NewGetDefaultCurrencyRequest(server string, params *GetDefaultCurrencyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies/default")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteCurrencyRequest generates requests for DeleteCurrency
func NewDeleteCurrencyRequest(server string, code string, params *DeleteCurrencyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetCurrencyRequest generates requests for GetCurrency
func NewGetCurrencyRequest(server string, code string, params *GetCurrencyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateCurrencyRequestWithApplicationVndAPIPlusJSONBody calls the generic UpdateCurrency builder with application/vnd.api+json body
func NewUpdateCurrencyRequestWithApplicationVndAPIPlusJSONBody(server string, code string, params *UpdateCurrencyParams, body UpdateCurrencyApplicationVndAPIPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCurrencyRequestWithBody(server, code, params, "application/vnd.api+json", bodyReader)
}

// NewUpdateCurrencyRequestWithFormdataBody calls the generic UpdateCurrency builder with application/x-www-form-urlencoded body
func NewUpdateCurrencyRequestWithFormdataBody(server string, code string, params *UpdateCurrencyParams, body UpdateCurrencyFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateCurrencyRequestWithBody(server, code, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateCurrencyRequestWithBody generates requests for UpdateCurrency with any type of body
func NewUpdateCurrencyRequestWithBody(server string, code string, params *UpdateCurrencyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListAccountByCurrencyRequest generates requests for ListAccountByCurrency
func NewListAccountByCurrencyRequest(server string, code string, params *ListAccountByCurrencyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies/%s/accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListAvailableBudgetByCurrencyRequest generates requests for ListAvailableBudgetByCurrency
func NewListAvailableBudgetByCurrencyRequest(server string, code string, params *ListAvailableBudgetByCurrencyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies/%s/available-budgets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListBillByCurrencyRequest generates requests for ListBillByCurrency
func NewListBillByCurrencyRequest(server string, code string, params *ListBillByCurrencyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies/%s/bills", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListBudgetLimitByCurrencyRequest generates requests for ListBudgetLimitByCurrency
func NewListBudgetLimitByCurrencyRequest(server string, code string, params *ListBudgetLimitByCurrencyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies/%s/budget_limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDefaultCurrencyRequest generates requests for DefaultCurrency
func NewDefaultCurrencyRequest(server string, code string, params *DefaultCurrencyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies/%s/default", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDisableCurrencyRequest generates requests for DisableCurrency
func NewDisableCurrencyRequest(server string, code string, params *DisableCurrencyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies/%s/disable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewEnableCurrencyRequest generates requests for EnableCurrency
func NewEnableCurrencyRequest(server string, code string, params *EnableCurrencyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies/%s/enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListRecurrenceByCurrencyRequest generates requests for ListRecurrenceByCurrency
func NewListRecurrenceByCurrencyRequest(server string, code string, params *ListRecurrenceByCurrencyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies/%s/recurrences", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListRuleByCurrencyRequest generates requests for ListRuleByCurrency
func NewListRuleByCurrencyRequest(server string, code string, params *ListRuleByCurrencyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies/%s/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListTransactionByCurrencyRequest generates requests for ListTransactionByCurrency
func NewListTransactionByCurrencyRequest(server string, code string, params *ListTransactionByCurrencyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/currencies/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewBulkUpdateTransactionsRequest generates requests for BulkUpdateTransactions
func NewBulkUpdateTransactionsRequest(server string, params *BulkUpdateTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/bulk/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDestroyDataRequest generates requests for DestroyData
func NewDestroyDataRequest(server string, params *DestroyDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/destroy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "objects", runtime.ParamLocationQuery, params.Objects); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewExportAccountsRequest generates requests for ExportAccounts
func NewExportAccountsRequest(server string, params *ExportAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/export/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewExportBillsRequest generates requests for ExportBills
func NewExportBillsRequest(server string, params *ExportBillsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/export/bills")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewExportBudgetsRequest generates requests for ExportBudgets
func NewExportBudgetsRequest(server string, params *ExportBudgetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/export/budgets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewExportCategoriesRequest generates requests for ExportCategories
func NewExportCategoriesRequest(server string, params *ExportCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/export/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewExportPiggiesRequest generates requests for ExportPiggies
func NewExportPiggiesRequest(server string, params *ExportPiggiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/export/piggy-banks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewExportRecurringRequest generates requests for ExportRecurring
func NewExportRecurringRequest(server string, params *ExportRecurringParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/export/recurring")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewExportRulesRequest generates requests for ExportRules
func NewExportRulesRequest(server string, params *ExportRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/export/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewExportTagsRequest generates requests for ExportTags
func NewExportTagsRequest(server string, params *ExportTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/export/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewExportTransactionsRequest generates requests for ExportTransactions
func NewExportTransactionsRequest(server string, params *ExportTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/export/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "accounts", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewPurgeDataRequest generates requests for PurgeData
func NewPurgeDataRequest(server string, params *PurgeDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/purge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightExpenseAssetRequest generates requests for InsightExpenseAsset
func NewInsightExpenseAssetRequest(server string, params *InsightExpenseAssetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/expense/asset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightExpenseBillRequest generates requests for InsightExpenseBill
func NewInsightExpenseBillRequest(server string, params *InsightExpenseBillParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/expense/bill")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Bills != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bills[]", runtime.ParamLocationQuery, *params.Bills); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightExpenseBudgetRequest generates requests for InsightExpenseBudget
func NewInsightExpenseBudgetRequest(server string, params *InsightExpenseBudgetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/expense/budget")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Budgets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "budgets[]", runtime.ParamLocationQuery, *params.Budgets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightExpenseCategoryRequest generates requests for InsightExpenseCategory
func NewInsightExpenseCategoryRequest(server string, params *InsightExpenseCategoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/expense/category")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Categories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories[]", runtime.ParamLocationQuery, *params.Categories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightExpenseExpenseRequest generates requests for InsightExpenseExpense
func NewInsightExpenseExpenseRequest(server string, params *InsightExpenseExpenseParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/expense/expense")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightExpenseNoBillRequest generates requests for InsightExpenseNoBill
func NewInsightExpenseNoBillRequest(server string, params *InsightExpenseNoBillParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/expense/no-bill")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightExpenseNoBudgetRequest generates requests for InsightExpenseNoBudget
func NewInsightExpenseNoBudgetRequest(server string, params *InsightExpenseNoBudgetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/expense/no-budget")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightExpenseNoCategoryRequest generates requests for InsightExpenseNoCategory
func NewInsightExpenseNoCategoryRequest(server string, params *InsightExpenseNoCategoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/expense/no-category")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightExpenseNoTagRequest generates requests for InsightExpenseNoTag
func NewInsightExpenseNoTagRequest(server string, params *InsightExpenseNoTagParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/expense/no-tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightExpenseTagRequest generates requests for InsightExpenseTag
func NewInsightExpenseTagRequest(server string, params *InsightExpenseTagParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/expense/tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags[]", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightExpenseTotalRequest generates requests for InsightExpenseTotal
func NewInsightExpenseTotalRequest(server string, params *InsightExpenseTotalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/expense/total")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightIncomeAssetRequest generates requests for InsightIncomeAsset
func NewInsightIncomeAssetRequest(server string, params *InsightIncomeAssetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/income/asset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightIncomeCategoryRequest generates requests for InsightIncomeCategory
func NewInsightIncomeCategoryRequest(server string, params *InsightIncomeCategoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/income/category")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Categories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories[]", runtime.ParamLocationQuery, *params.Categories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightIncomeNoCategoryRequest generates requests for InsightIncomeNoCategory
func NewInsightIncomeNoCategoryRequest(server string, params *InsightIncomeNoCategoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/income/no-category")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightIncomeNoTagRequest generates requests for InsightIncomeNoTag
func NewInsightIncomeNoTagRequest(server string, params *InsightIncomeNoTagParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/income/no-tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightIncomeRevenueRequest generates requests for InsightIncomeRevenue
func NewInsightIncomeRevenueRequest(server string, params *InsightIncomeRevenueParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/income/revenue")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightIncomeTagRequest generates requests for InsightIncomeTag
func NewInsightIncomeTagRequest(server string, params *InsightIncomeTagParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/income/tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags[]", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightIncomeTotalRequest generates requests for InsightIncomeTotal
func NewInsightIncomeTotalRequest(server string, params *InsightIncomeTotalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/income/total")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightTransfersRequest generates requests for InsightTransfers
func NewInsightTransfersRequest(server string, params *InsightTransfersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/transfer/asset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightTransferCategoryRequest generates requests for InsightTransferCategory
func NewInsightTransferCategoryRequest(server string, params *InsightTransferCategoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/transfer/category")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Categories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories[]", runtime.ParamLocationQuery, *params.Categories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightTransferNoCategoryRequest generates requests for InsightTransferNoCategory
func NewInsightTransferNoCategoryRequest(server string, params *InsightTransferNoCategoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/transfer/no-category")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightTransferNoTagRequest generates requests for InsightTransferNoTag
func NewInsightTransferNoTagRequest(server string, params *InsightTransferNoTagParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/transfer/no-tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightTransferTagRequest generates requests for InsightTransferTag
func NewInsightTransferTagRequest(server string, params *InsightTransferTagParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/transfer/tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags[]", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewInsightTransferTotalRequest generates requests for InsightTransferTotal
func NewInsightTransferTotalRequest(server string, params *InsightTransferTotalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/insight/transfer/total")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListLinkTypeRequest generates requests for ListLinkType
func NewListLinkTypeRequest(server string, params *ListLinkTypeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/link-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreLinkTypeRequest calls the generic StoreLinkType builder with application/json body
func NewStoreLinkTypeRequest(server string, params *StoreLinkTypeParams, body StoreLinkTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreLinkTypeRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreLinkTypeRequestWithFormdataBody calls the generic StoreLinkType builder with application/x-www-form-urlencoded body
func NewStoreLinkTypeRequestWithFormdataBody(server string, params *StoreLinkTypeParams, body StoreLinkTypeFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreLinkTypeRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreLinkTypeRequestWithBody generates requests for StoreLinkType with any type of body
func NewStoreLinkTypeRequestWithBody(server string, params *StoreLinkTypeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/link-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteLinkTypeRequest generates requests for DeleteLinkType
func NewDeleteLinkTypeRequest(server string, id string, params *DeleteLinkTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/link-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetLinkTypeRequest generates requests for GetLinkType
func NewGetLinkTypeRequest(server string, id string, params *GetLinkTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/link-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateLinkTypeRequest calls the generic UpdateLinkType builder with application/json body
func NewUpdateLinkTypeRequest(server string, id string, params *UpdateLinkTypeParams, body UpdateLinkTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLinkTypeRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateLinkTypeRequestWithFormdataBody calls the generic UpdateLinkType builder with application/x-www-form-urlencoded body
func NewUpdateLinkTypeRequestWithFormdataBody(server string, id string, params *UpdateLinkTypeParams, body UpdateLinkTypeFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateLinkTypeRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateLinkTypeRequestWithBody generates requests for UpdateLinkType with any type of body
func NewUpdateLinkTypeRequestWithBody(server string, id string, params *UpdateLinkTypeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/link-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListTransactionByLinkTypeRequest generates requests for ListTransactionByLinkType
func NewListTransactionByLinkTypeRequest(server string, id string, params *ListTransactionByLinkTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/link-types/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListObjectGroupsRequest generates requests for ListObjectGroups
func NewListObjectGroupsRequest(server string, params *ListObjectGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/object-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteObjectGroupRequest generates requests for DeleteObjectGroup
func NewDeleteObjectGroupRequest(server string, id string, params *DeleteObjectGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/object-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetObjectGroupRequest generates requests for GetObjectGroup
func NewGetObjectGroupRequest(server string, id string, params *GetObjectGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/object-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateObjectGroupRequest calls the generic UpdateObjectGroup builder with application/json body
func NewUpdateObjectGroupRequest(server string, id string, params *UpdateObjectGroupParams, body UpdateObjectGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateObjectGroupRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateObjectGroupRequestWithFormdataBody calls the generic UpdateObjectGroup builder with application/x-www-form-urlencoded body
func NewUpdateObjectGroupRequestWithFormdataBody(server string, id string, params *UpdateObjectGroupParams, body UpdateObjectGroupFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateObjectGroupRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateObjectGroupRequestWithBody generates requests for UpdateObjectGroup with any type of body
func NewUpdateObjectGroupRequestWithBody(server string, id string, params *UpdateObjectGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/object-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListBillByObjectGroupRequest generates requests for ListBillByObjectGroup
func NewListBillByObjectGroupRequest(server string, id string, params *ListBillByObjectGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/object-groups/%s/bills", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListPiggyBankByObjectGroupRequest generates requests for ListPiggyBankByObjectGroup
func NewListPiggyBankByObjectGroupRequest(server string, id string, params *ListPiggyBankByObjectGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/object-groups/%s/piggy-banks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListPiggyBankRequest generates requests for ListPiggyBank
func NewListPiggyBankRequest(server string, params *ListPiggyBankParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/piggy-banks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStorePiggyBankRequest calls the generic StorePiggyBank builder with application/json body
func NewStorePiggyBankRequest(server string, params *StorePiggyBankParams, body StorePiggyBankJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStorePiggyBankRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStorePiggyBankRequestWithFormdataBody calls the generic StorePiggyBank builder with application/x-www-form-urlencoded body
func NewStorePiggyBankRequestWithFormdataBody(server string, params *StorePiggyBankParams, body StorePiggyBankFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStorePiggyBankRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStorePiggyBankRequestWithBody generates requests for StorePiggyBank with any type of body
func NewStorePiggyBankRequestWithBody(server string, params *StorePiggyBankParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/piggy-banks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeletePiggyBankRequest generates requests for DeletePiggyBank
func NewDeletePiggyBankRequest(server string, id string, params *DeletePiggyBankParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/piggy-banks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetPiggyBankRequest generates requests for GetPiggyBank
func NewGetPiggyBankRequest(server string, id string, params *GetPiggyBankParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/piggy-banks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdatePiggyBankRequest calls the generic UpdatePiggyBank builder with application/json body
func NewUpdatePiggyBankRequest(server string, id string, params *UpdatePiggyBankParams, body UpdatePiggyBankJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePiggyBankRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdatePiggyBankRequestWithFormdataBody calls the generic UpdatePiggyBank builder with application/x-www-form-urlencoded body
func NewUpdatePiggyBankRequestWithFormdataBody(server string, id string, params *UpdatePiggyBankParams, body UpdatePiggyBankFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdatePiggyBankRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdatePiggyBankRequestWithBody generates requests for UpdatePiggyBank with any type of body
func NewUpdatePiggyBankRequestWithBody(server string, id string, params *UpdatePiggyBankParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/piggy-banks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListAttachmentByPiggyBankRequest generates requests for ListAttachmentByPiggyBank
func NewListAttachmentByPiggyBankRequest(server string, id string, params *ListAttachmentByPiggyBankParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/piggy-banks/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListEventByPiggyBankRequest generates requests for ListEventByPiggyBank
func NewListEventByPiggyBankRequest(server string, id string, params *ListEventByPiggyBankParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/piggy-banks/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListPreferenceRequest generates requests for ListPreference
func NewListPreferenceRequest(server string, params *ListPreferenceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/preferences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStorePreferenceRequest calls the generic StorePreference builder with application/json body
func NewStorePreferenceRequest(server string, params *StorePreferenceParams, body StorePreferenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStorePreferenceRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStorePreferenceRequestWithFormdataBody calls the generic StorePreference builder with application/x-www-form-urlencoded body
func NewStorePreferenceRequestWithFormdataBody(server string, params *StorePreferenceParams, body StorePreferenceFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStorePreferenceRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStorePreferenceRequestWithBody generates requests for StorePreference with any type of body
func NewStorePreferenceRequestWithBody(server string, params *StorePreferenceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/preferences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetPreferenceRequest generates requests for GetPreference
func NewGetPreferenceRequest(server string, name string, params *GetPreferenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/preferences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdatePreferenceRequest calls the generic UpdatePreference builder with application/json body
func NewUpdatePreferenceRequest(server string, name string, params *UpdatePreferenceParams, body UpdatePreferenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePreferenceRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewUpdatePreferenceRequestWithFormdataBody calls the generic UpdatePreference builder with application/x-www-form-urlencoded body
func NewUpdatePreferenceRequestWithFormdataBody(server string, name string, params *UpdatePreferenceParams, body UpdatePreferenceFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdatePreferenceRequestWithBody(server, name, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdatePreferenceRequestWithBody generates requests for UpdatePreference with any type of body
func NewUpdatePreferenceRequestWithBody(server string, name string, params *UpdatePreferenceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/preferences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListRecurrenceRequest generates requests for ListRecurrence
func NewListRecurrenceRequest(server string, params *ListRecurrenceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/recurrences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreRecurrenceRequest calls the generic StoreRecurrence builder with application/json body
func NewStoreRecurrenceRequest(server string, params *StoreRecurrenceParams, body StoreRecurrenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreRecurrenceRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreRecurrenceRequestWithFormdataBody calls the generic StoreRecurrence builder with application/x-www-form-urlencoded body
func NewStoreRecurrenceRequestWithFormdataBody(server string, params *StoreRecurrenceParams, body StoreRecurrenceFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreRecurrenceRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreRecurrenceRequestWithBody generates requests for StoreRecurrence with any type of body
func NewStoreRecurrenceRequestWithBody(server string, params *StoreRecurrenceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/recurrences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteRecurrenceRequest generates requests for DeleteRecurrence
func NewDeleteRecurrenceRequest(server string, id string, params *DeleteRecurrenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/recurrences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetRecurrenceRequest generates requests for GetRecurrence
func NewGetRecurrenceRequest(server string, id string, params *GetRecurrenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/recurrences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateRecurrenceRequest calls the generic UpdateRecurrence builder with application/json body
func NewUpdateRecurrenceRequest(server string, id string, params *UpdateRecurrenceParams, body UpdateRecurrenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRecurrenceRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateRecurrenceRequestWithFormdataBody calls the generic UpdateRecurrence builder with application/x-www-form-urlencoded body
func NewUpdateRecurrenceRequestWithFormdataBody(server string, id string, params *UpdateRecurrenceParams, body UpdateRecurrenceFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateRecurrenceRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateRecurrenceRequestWithBody generates requests for UpdateRecurrence with any type of body
func NewUpdateRecurrenceRequestWithBody(server string, id string, params *UpdateRecurrenceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/recurrences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListTransactionByRecurrenceRequest generates requests for ListTransactionByRecurrence
func NewListTransactionByRecurrenceRequest(server string, id string, params *ListTransactionByRecurrenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/recurrences/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListRuleGroupRequest generates requests for ListRuleGroup
func NewListRuleGroupRequest(server string, params *ListRuleGroupParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rule-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreRuleGroupRequest calls the generic StoreRuleGroup builder with application/json body
func NewStoreRuleGroupRequest(server string, params *StoreRuleGroupParams, body StoreRuleGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreRuleGroupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreRuleGroupRequestWithFormdataBody calls the generic StoreRuleGroup builder with application/x-www-form-urlencoded body
func NewStoreRuleGroupRequestWithFormdataBody(server string, params *StoreRuleGroupParams, body StoreRuleGroupFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreRuleGroupRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreRuleGroupRequestWithBody generates requests for StoreRuleGroup with any type of body
func NewStoreRuleGroupRequestWithBody(server string, params *StoreRuleGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rule-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteRuleGroupRequest generates requests for DeleteRuleGroup
func NewDeleteRuleGroupRequest(server string, id string, params *DeleteRuleGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rule-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetRuleGroupRequest generates requests for GetRuleGroup
func NewGetRuleGroupRequest(server string, id string, params *GetRuleGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rule-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateRuleGroupRequest calls the generic UpdateRuleGroup builder with application/json body
func NewUpdateRuleGroupRequest(server string, id string, params *UpdateRuleGroupParams, body UpdateRuleGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRuleGroupRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateRuleGroupRequestWithFormdataBody calls the generic UpdateRuleGroup builder with application/x-www-form-urlencoded body
func NewUpdateRuleGroupRequestWithFormdataBody(server string, id string, params *UpdateRuleGroupParams, body UpdateRuleGroupFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateRuleGroupRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateRuleGroupRequestWithBody generates requests for UpdateRuleGroup with any type of body
func NewUpdateRuleGroupRequestWithBody(server string, id string, params *UpdateRuleGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rule-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListRuleByGroupRequest generates requests for ListRuleByGroup
func NewListRuleByGroupRequest(server string, id string, params *ListRuleByGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rule-groups/%s/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewTestRuleGroupRequest generates requests for TestRuleGroup
func NewTestRuleGroupRequest(server string, id string, params *TestRuleGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rule-groups/%s/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_limit", runtime.ParamLocationQuery, *params.SearchLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TriggeredLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "triggered_limit", runtime.ParamLocationQuery, *params.TriggeredLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewFireRuleGroupRequest generates requests for FireRuleGroup
func NewFireRuleGroupRequest(server string, id string, params *FireRuleGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rule-groups/%s/trigger", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListRuleRequest generates requests for ListRule
func NewListRuleRequest(server string, params *ListRuleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreRuleRequest calls the generic StoreRule builder with application/json body
func NewStoreRuleRequest(server string, params *StoreRuleParams, body StoreRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreRuleRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreRuleRequestWithFormdataBody calls the generic StoreRule builder with application/x-www-form-urlencoded body
func NewStoreRuleRequestWithFormdataBody(server string, params *StoreRuleParams, body StoreRuleFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreRuleRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreRuleRequestWithBody generates requests for StoreRule with any type of body
func NewStoreRuleRequestWithBody(server string, params *StoreRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteRuleRequest generates requests for DeleteRule
func NewDeleteRuleRequest(server string, id string, params *DeleteRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetRuleRequest generates requests for GetRule
func NewGetRuleRequest(server string, id string, params *GetRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateRuleRequest calls the generic UpdateRule builder with application/json body
func NewUpdateRuleRequest(server string, id string, params *UpdateRuleParams, body UpdateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRuleRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateRuleRequestWithFormdataBody calls the generic UpdateRule builder with application/x-www-form-urlencoded body
func NewUpdateRuleRequestWithFormdataBody(server string, id string, params *UpdateRuleParams, body UpdateRuleFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateRuleRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateRuleRequestWithBody generates requests for UpdateRule with any type of body
func NewUpdateRuleRequestWithBody(server string, id string, params *UpdateRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewTestRuleRequest generates requests for TestRule
func NewTestRuleRequest(server string, id string, params *TestRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rules/%s/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewFireRuleRequest generates requests for FireRule
func NewFireRuleRequest(server string, id string, params *FireRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/rules/%s/trigger", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accounts[]", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewSearchAccountsRequest generates requests for SearchAccounts
func NewSearchAccountsRequest(server string, params *SearchAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/search/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "field", runtime.ParamLocationQuery, params.Field); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewSearchTransactionsRequest generates requests for SearchTransactions
func NewSearchTransactionsRequest(server string, params *SearchTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/search/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetBasicSummaryRequest generates requests for GetBasicSummary
func NewGetBasicSummaryRequest(server string, params *GetBasicSummaryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/summary/basic")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.CurrencyCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "currency_code", runtime.ParamLocationQuery, *params.CurrencyCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListTagRequest generates requests for ListTag
func NewListTagRequest(server string, params *ListTagParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreTagRequest calls the generic StoreTag builder with application/json body
func NewStoreTagRequest(server string, params *StoreTagParams, body StoreTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreTagRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreTagRequestWithFormdataBody calls the generic StoreTag builder with application/x-www-form-urlencoded body
func NewStoreTagRequestWithFormdataBody(server string, params *StoreTagParams, body StoreTagFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreTagRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreTagRequestWithBody generates requests for StoreTag with any type of body
func NewStoreTagRequestWithBody(server string, params *StoreTagParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteTagRequest generates requests for DeleteTag
func NewDeleteTagRequest(server string, tag string, params *DeleteTagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetTagRequest generates requests for GetTag
func NewGetTagRequest(server string, tag string, params *GetTagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateTagRequest calls the generic UpdateTag builder with application/json body
func NewUpdateTagRequest(server string, tag string, params *UpdateTagParams, body UpdateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTagRequestWithBody(server, tag, params, "application/json", bodyReader)
}

// NewUpdateTagRequestWithFormdataBody calls the generic UpdateTag builder with application/x-www-form-urlencoded body
func NewUpdateTagRequestWithFormdataBody(server string, tag string, params *UpdateTagParams, body UpdateTagFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateTagRequestWithBody(server, tag, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateTagRequestWithBody generates requests for UpdateTag with any type of body
func NewUpdateTagRequestWithBody(server string, tag string, params *UpdateTagParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListAttachmentByTagRequest generates requests for ListAttachmentByTag
func NewListAttachmentByTagRequest(server string, tag string, params *ListAttachmentByTagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tags/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListTransactionByTagRequest generates requests for ListTransactionByTag
func NewListTransactionByTagRequest(server string, tag string, params *ListTransactionByTagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tags/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteTransactionJournalRequest generates requests for DeleteTransactionJournal
func NewDeleteTransactionJournalRequest(server string, id string, params *DeleteTransactionJournalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transaction-journals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetTransactionByJournalRequest generates requests for GetTransactionByJournal
func NewGetTransactionByJournalRequest(server string, id string, params *GetTransactionByJournalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transaction-journals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListLinksByJournalRequest generates requests for ListLinksByJournal
func NewListLinksByJournalRequest(server string, id string, params *ListLinksByJournalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transaction-journals/%s/links", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListTransactionLinkRequest generates requests for ListTransactionLink
func NewListTransactionLinkRequest(server string, params *ListTransactionLinkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transaction-links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreTransactionLinkRequest calls the generic StoreTransactionLink builder with application/json body
func NewStoreTransactionLinkRequest(server string, params *StoreTransactionLinkParams, body StoreTransactionLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreTransactionLinkRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreTransactionLinkRequestWithFormdataBody calls the generic StoreTransactionLink builder with application/x-www-form-urlencoded body
func NewStoreTransactionLinkRequestWithFormdataBody(server string, params *StoreTransactionLinkParams, body StoreTransactionLinkFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreTransactionLinkRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreTransactionLinkRequestWithBody generates requests for StoreTransactionLink with any type of body
func NewStoreTransactionLinkRequestWithBody(server string, params *StoreTransactionLinkParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transaction-links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteTransactionLinkRequest generates requests for DeleteTransactionLink
func NewDeleteTransactionLinkRequest(server string, id string, params *DeleteTransactionLinkParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transaction-links/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetTransactionLinkRequest generates requests for GetTransactionLink
func NewGetTransactionLinkRequest(server string, id string, params *GetTransactionLinkParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transaction-links/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateTransactionLinkRequest calls the generic UpdateTransactionLink builder with application/json body
func NewUpdateTransactionLinkRequest(server string, id string, params *UpdateTransactionLinkParams, body UpdateTransactionLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTransactionLinkRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateTransactionLinkRequestWithFormdataBody calls the generic UpdateTransactionLink builder with application/x-www-form-urlencoded body
func NewUpdateTransactionLinkRequestWithFormdataBody(server string, id string, params *UpdateTransactionLinkParams, body UpdateTransactionLinkFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateTransactionLinkRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateTransactionLinkRequestWithBody generates requests for UpdateTransactionLink with any type of body
func NewUpdateTransactionLinkRequestWithBody(server string, id string, params *UpdateTransactionLinkParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transaction-links/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListTransactionRequest generates requests for ListTransaction
func NewListTransactionRequest(server string, params *ListTransactionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreTransactionRequest calls the generic StoreTransaction builder with application/json body
func NewStoreTransactionRequest(server string, params *StoreTransactionParams, body StoreTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreTransactionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreTransactionRequestWithFormdataBody calls the generic StoreTransaction builder with application/x-www-form-urlencoded body
func NewStoreTransactionRequestWithFormdataBody(server string, params *StoreTransactionParams, body StoreTransactionFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreTransactionRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreTransactionRequestWithBody generates requests for StoreTransaction with any type of body
func NewStoreTransactionRequestWithBody(server string, params *StoreTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteTransactionRequest generates requests for DeleteTransaction
func NewDeleteTransactionRequest(server string, id string, params *DeleteTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetTransactionRequest generates requests for GetTransaction
func NewGetTransactionRequest(server string, id string, params *GetTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateTransactionRequest calls the generic UpdateTransaction builder with application/json body
func NewUpdateTransactionRequest(server string, id string, params *UpdateTransactionParams, body UpdateTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTransactionRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateTransactionRequestWithFormdataBody calls the generic UpdateTransaction builder with application/x-www-form-urlencoded body
func NewUpdateTransactionRequestWithFormdataBody(server string, id string, params *UpdateTransactionParams, body UpdateTransactionFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateTransactionRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateTransactionRequestWithBody generates requests for UpdateTransaction with any type of body
func NewUpdateTransactionRequestWithBody(server string, id string, params *UpdateTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListAttachmentByTransactionRequest generates requests for ListAttachmentByTransaction
func NewListAttachmentByTransactionRequest(server string, id string, params *ListAttachmentByTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transactions/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListEventByTransactionRequest generates requests for ListEventByTransaction
func NewListEventByTransactionRequest(server string, id string, params *ListEventByTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/transactions/%s/piggy-bank-events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListUserRequest generates requests for ListUser
func NewListUserRequest(server string, params *ListUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreUserRequest calls the generic StoreUser builder with application/json body
func NewStoreUserRequest(server string, params *StoreUserParams, body StoreUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreUserRequestWithFormdataBody calls the generic StoreUser builder with application/x-www-form-urlencoded body
func NewStoreUserRequestWithFormdataBody(server string, params *StoreUserParams, body StoreUserFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreUserRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreUserRequestWithBody generates requests for StoreUser with any type of body
func NewStoreUserRequestWithBody(server string, params *StoreUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, id string, params *DeleteUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, id string, params *GetUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, id string, params *UpdateUserParams, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateUserRequestWithFormdataBody calls the generic UpdateUser builder with application/x-www-form-urlencoded body
func NewUpdateUserRequestWithFormdataBody(server string, id string, params *UpdateUserParams, body UpdateUserFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateUserRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, id string, params *UpdateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewListWebhookRequest generates requests for ListWebhook
func NewListWebhookRequest(server string, params *ListWebhookParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewStoreWebhookRequest calls the generic StoreWebhook builder with application/json body
func NewStoreWebhookRequest(server string, params *StoreWebhookParams, body StoreWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreWebhookRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStoreWebhookRequestWithFormdataBody calls the generic StoreWebhook builder with application/x-www-form-urlencoded body
func NewStoreWebhookRequestWithFormdataBody(server string, params *StoreWebhookParams, body StoreWebhookFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewStoreWebhookRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewStoreWebhookRequestWithBody generates requests for StoreWebhook with any type of body
func NewStoreWebhookRequestWithBody(server string, params *StoreWebhookParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteWebhookRequest generates requests for DeleteWebhook
func NewDeleteWebhookRequest(server string, id string, params *DeleteWebhookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetWebhookRequest generates requests for GetWebhook
func NewGetWebhookRequest(server string, id string, params *GetWebhookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateWebhookRequest calls the generic UpdateWebhook builder with application/json body
func NewUpdateWebhookRequest(server string, id string, params *UpdateWebhookParams, body UpdateWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWebhookRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateWebhookRequestWithFormdataBody calls the generic UpdateWebhook builder with application/x-www-form-urlencoded body
func NewUpdateWebhookRequestWithFormdataBody(server string, id string, params *UpdateWebhookParams, body UpdateWebhookFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateWebhookRequestWithBody(server, id, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateWebhookRequestWithBody generates requests for UpdateWebhook with any type of body
func NewUpdateWebhookRequestWithBody(server string, id string, params *UpdateWebhookParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetWebhookMessagesRequest generates requests for GetWebhookMessages
func NewGetWebhookMessagesRequest(server string, id string, params *GetWebhookMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s/messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteWebhookMessageRequest generates requests for DeleteWebhookMessage
func NewDeleteWebhookMessageRequest(server string, id string, messageId int, params *DeleteWebhookMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "messageId", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s/messages/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetSingleWebhookMessageRequest generates requests for GetSingleWebhookMessage
func NewGetSingleWebhookMessageRequest(server string, id string, messageId int, params *GetSingleWebhookMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "messageId", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s/messages/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetWebhookMessageAttemptsRequest generates requests for GetWebhookMessageAttempts
func NewGetWebhookMessageAttemptsRequest(server string, id string, messageId int, params *GetWebhookMessageAttemptsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "messageId", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s/messages/%s/attempts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteWebhookMessageAttemptRequest generates requests for DeleteWebhookMessageAttempt
func NewDeleteWebhookMessageAttemptRequest(server string, id string, messageId int, attemptId int, params *DeleteWebhookMessageAttemptParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "messageId", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "attemptId", runtime.ParamLocationPath, attemptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s/messages/%s/attempts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewGetSingleWebhookMessageAttemptRequest generates requests for GetSingleWebhookMessageAttempt
func NewGetSingleWebhookMessageAttemptRequest(server string, id string, messageId int, attemptId int, params *GetSingleWebhookMessageAttemptParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "messageId", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "attemptId", runtime.ParamLocationPath, attemptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s/messages/%s/attempts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewSubmitWebookRequest generates requests for SubmitWebook
func NewSubmitWebookRequest(server string, id string, params *SubmitWebookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s/submit", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

// NewTriggerTransactionWebhookRequest generates requests for TriggerTransactionWebhook
func NewTriggerTransactionWebhookRequest(server string, id string, transactionId string, params *TriggerTransactionWebhookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transactionId", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s/trigger-transaction/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XTraceId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Trace-Id", runtime.ParamLocationHeader, *params.XTraceId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Trace-Id", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAboutWithResponse request
	GetAboutWithResponse(ctx context.Context, params *GetAboutParams, reqEditors ...RequestEditorFn) (*GetAboutResponse, error)

	// GetCurrentUserWithResponse request
	GetCurrentUserWithResponse(ctx context.Context, params *GetCurrentUserParams, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)

	// ListAccountWithResponse request
	ListAccountWithResponse(ctx context.Context, params *ListAccountParams, reqEditors ...RequestEditorFn) (*ListAccountResponse, error)

	// StoreAccountWithBodyWithResponse request with any body
	StoreAccountWithBodyWithResponse(ctx context.Context, params *StoreAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreAccountResponse, error)

	StoreAccountWithResponse(ctx context.Context, params *StoreAccountParams, body StoreAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreAccountResponse, error)

	StoreAccountWithFormdataBodyWithResponse(ctx context.Context, params *StoreAccountParams, body StoreAccountFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreAccountResponse, error)

	// DeleteAccountWithResponse request
	DeleteAccountWithResponse(ctx context.Context, id string, params *DeleteAccountParams, reqEditors ...RequestEditorFn) (*DeleteAccountResponse, error)

	// GetAccountWithResponse request
	GetAccountWithResponse(ctx context.Context, id string, params *GetAccountParams, reqEditors ...RequestEditorFn) (*GetAccountResponse, error)

	// UpdateAccountWithBodyWithResponse request with any body
	UpdateAccountWithBodyWithResponse(ctx context.Context, id string, params *UpdateAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccountResponse, error)

	UpdateAccountWithResponse(ctx context.Context, id string, params *UpdateAccountParams, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountResponse, error)

	UpdateAccountWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateAccountParams, body UpdateAccountFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountResponse, error)

	// ListAttachmentByAccountWithResponse request
	ListAttachmentByAccountWithResponse(ctx context.Context, id string, params *ListAttachmentByAccountParams, reqEditors ...RequestEditorFn) (*ListAttachmentByAccountResponse, error)

	// ListPiggyBankByAccountWithResponse request
	ListPiggyBankByAccountWithResponse(ctx context.Context, id string, params *ListPiggyBankByAccountParams, reqEditors ...RequestEditorFn) (*ListPiggyBankByAccountResponse, error)

	// ListTransactionByAccountWithResponse request
	ListTransactionByAccountWithResponse(ctx context.Context, id string, params *ListTransactionByAccountParams, reqEditors ...RequestEditorFn) (*ListTransactionByAccountResponse, error)

	// ListAttachmentWithResponse request
	ListAttachmentWithResponse(ctx context.Context, params *ListAttachmentParams, reqEditors ...RequestEditorFn) (*ListAttachmentResponse, error)

	// StoreAttachmentWithBodyWithResponse request with any body
	StoreAttachmentWithBodyWithResponse(ctx context.Context, params *StoreAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreAttachmentResponse, error)

	StoreAttachmentWithResponse(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreAttachmentResponse, error)

	StoreAttachmentWithFormdataBodyWithResponse(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreAttachmentResponse, error)

	// DeleteAttachmentWithResponse request
	DeleteAttachmentWithResponse(ctx context.Context, id string, params *DeleteAttachmentParams, reqEditors ...RequestEditorFn) (*DeleteAttachmentResponse, error)

	// GetAttachmentWithResponse request
	GetAttachmentWithResponse(ctx context.Context, id string, params *GetAttachmentParams, reqEditors ...RequestEditorFn) (*GetAttachmentResponse, error)

	// UpdateAttachmentWithBodyWithResponse request with any body
	UpdateAttachmentWithBodyWithResponse(ctx context.Context, id string, params *UpdateAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttachmentResponse, error)

	UpdateAttachmentWithResponse(ctx context.Context, id string, params *UpdateAttachmentParams, body UpdateAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttachmentResponse, error)

	UpdateAttachmentWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateAttachmentParams, body UpdateAttachmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttachmentResponse, error)

	// DownloadAttachmentWithResponse request
	DownloadAttachmentWithResponse(ctx context.Context, id string, params *DownloadAttachmentParams, reqEditors ...RequestEditorFn) (*DownloadAttachmentResponse, error)

	// UploadAttachmentWithBodyWithResponse request with any body
	UploadAttachmentWithBodyWithResponse(ctx context.Context, id string, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAttachmentResponse, error)

	// GetAccountsACWithResponse request
	GetAccountsACWithResponse(ctx context.Context, params *GetAccountsACParams, reqEditors ...RequestEditorFn) (*GetAccountsACResponse, error)

	// GetBillsACWithResponse request
	GetBillsACWithResponse(ctx context.Context, params *GetBillsACParams, reqEditors ...RequestEditorFn) (*GetBillsACResponse, error)

	// GetBudgetsACWithResponse request
	GetBudgetsACWithResponse(ctx context.Context, params *GetBudgetsACParams, reqEditors ...RequestEditorFn) (*GetBudgetsACResponse, error)

	// GetCategoriesACWithResponse request
	GetCategoriesACWithResponse(ctx context.Context, params *GetCategoriesACParams, reqEditors ...RequestEditorFn) (*GetCategoriesACResponse, error)

	// GetCurrenciesACWithResponse request
	GetCurrenciesACWithResponse(ctx context.Context, params *GetCurrenciesACParams, reqEditors ...RequestEditorFn) (*GetCurrenciesACResponse, error)

	// GetCurrenciesCodeACWithResponse request
	GetCurrenciesCodeACWithResponse(ctx context.Context, params *GetCurrenciesCodeACParams, reqEditors ...RequestEditorFn) (*GetCurrenciesCodeACResponse, error)

	// GetObjectGroupsACWithResponse request
	GetObjectGroupsACWithResponse(ctx context.Context, params *GetObjectGroupsACParams, reqEditors ...RequestEditorFn) (*GetObjectGroupsACResponse, error)

	// GetPiggiesACWithResponse request
	GetPiggiesACWithResponse(ctx context.Context, params *GetPiggiesACParams, reqEditors ...RequestEditorFn) (*GetPiggiesACResponse, error)

	// GetPiggiesBalanceACWithResponse request
	GetPiggiesBalanceACWithResponse(ctx context.Context, params *GetPiggiesBalanceACParams, reqEditors ...RequestEditorFn) (*GetPiggiesBalanceACResponse, error)

	// GetRecurringACWithResponse request
	GetRecurringACWithResponse(ctx context.Context, params *GetRecurringACParams, reqEditors ...RequestEditorFn) (*GetRecurringACResponse, error)

	// GetRuleGroupsACWithResponse request
	GetRuleGroupsACWithResponse(ctx context.Context, params *GetRuleGroupsACParams, reqEditors ...RequestEditorFn) (*GetRuleGroupsACResponse, error)

	// GetRulesACWithResponse request
	GetRulesACWithResponse(ctx context.Context, params *GetRulesACParams, reqEditors ...RequestEditorFn) (*GetRulesACResponse, error)

	// GetTagACWithResponse request
	GetTagACWithResponse(ctx context.Context, params *GetTagACParams, reqEditors ...RequestEditorFn) (*GetTagACResponse, error)

	// GetTransactionTypesACWithResponse request
	GetTransactionTypesACWithResponse(ctx context.Context, params *GetTransactionTypesACParams, reqEditors ...RequestEditorFn) (*GetTransactionTypesACResponse, error)

	// GetTransactionsACWithResponse request
	GetTransactionsACWithResponse(ctx context.Context, params *GetTransactionsACParams, reqEditors ...RequestEditorFn) (*GetTransactionsACResponse, error)

	// GetTransactionsIDACWithResponse request
	GetTransactionsIDACWithResponse(ctx context.Context, params *GetTransactionsIDACParams, reqEditors ...RequestEditorFn) (*GetTransactionsIDACResponse, error)

	// ListAvailableBudgetWithResponse request
	ListAvailableBudgetWithResponse(ctx context.Context, params *ListAvailableBudgetParams, reqEditors ...RequestEditorFn) (*ListAvailableBudgetResponse, error)

	// GetAvailableBudgetWithResponse request
	GetAvailableBudgetWithResponse(ctx context.Context, id string, params *GetAvailableBudgetParams, reqEditors ...RequestEditorFn) (*GetAvailableBudgetResponse, error)

	// ListBillWithResponse request
	ListBillWithResponse(ctx context.Context, params *ListBillParams, reqEditors ...RequestEditorFn) (*ListBillResponse, error)

	// StoreBillWithBodyWithResponse request with any body
	StoreBillWithBodyWithResponse(ctx context.Context, params *StoreBillParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreBillResponse, error)

	StoreBillWithResponse(ctx context.Context, params *StoreBillParams, body StoreBillJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreBillResponse, error)

	StoreBillWithFormdataBodyWithResponse(ctx context.Context, params *StoreBillParams, body StoreBillFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreBillResponse, error)

	// DeleteBillWithResponse request
	DeleteBillWithResponse(ctx context.Context, id string, params *DeleteBillParams, reqEditors ...RequestEditorFn) (*DeleteBillResponse, error)

	// GetBillWithResponse request
	GetBillWithResponse(ctx context.Context, id string, params *GetBillParams, reqEditors ...RequestEditorFn) (*GetBillResponse, error)

	// UpdateBillWithBodyWithResponse request with any body
	UpdateBillWithBodyWithResponse(ctx context.Context, id string, params *UpdateBillParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBillResponse, error)

	UpdateBillWithResponse(ctx context.Context, id string, params *UpdateBillParams, body UpdateBillJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBillResponse, error)

	UpdateBillWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateBillParams, body UpdateBillFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateBillResponse, error)

	// ListAttachmentByBillWithResponse request
	ListAttachmentByBillWithResponse(ctx context.Context, id string, params *ListAttachmentByBillParams, reqEditors ...RequestEditorFn) (*ListAttachmentByBillResponse, error)

	// ListRuleByBillWithResponse request
	ListRuleByBillWithResponse(ctx context.Context, id string, params *ListRuleByBillParams, reqEditors ...RequestEditorFn) (*ListRuleByBillResponse, error)

	// ListTransactionByBillWithResponse request
	ListTransactionByBillWithResponse(ctx context.Context, id string, params *ListTransactionByBillParams, reqEditors ...RequestEditorFn) (*ListTransactionByBillResponse, error)

	// ListBudgetLimitWithResponse request
	ListBudgetLimitWithResponse(ctx context.Context, params *ListBudgetLimitParams, reqEditors ...RequestEditorFn) (*ListBudgetLimitResponse, error)

	// ListBudgetWithResponse request
	ListBudgetWithResponse(ctx context.Context, params *ListBudgetParams, reqEditors ...RequestEditorFn) (*ListBudgetResponse, error)

	// StoreBudgetWithBodyWithResponse request with any body
	StoreBudgetWithBodyWithResponse(ctx context.Context, params *StoreBudgetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreBudgetResponse, error)

	StoreBudgetWithResponse(ctx context.Context, params *StoreBudgetParams, body StoreBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreBudgetResponse, error)

	StoreBudgetWithFormdataBodyWithResponse(ctx context.Context, params *StoreBudgetParams, body StoreBudgetFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreBudgetResponse, error)

	// DeleteBudgetWithResponse request
	DeleteBudgetWithResponse(ctx context.Context, id string, params *DeleteBudgetParams, reqEditors ...RequestEditorFn) (*DeleteBudgetResponse, error)

	// GetBudgetWithResponse request
	GetBudgetWithResponse(ctx context.Context, id string, params *GetBudgetParams, reqEditors ...RequestEditorFn) (*GetBudgetResponse, error)

	// UpdateBudgetWithBodyWithResponse request with any body
	UpdateBudgetWithBodyWithResponse(ctx context.Context, id string, params *UpdateBudgetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBudgetResponse, error)

	UpdateBudgetWithResponse(ctx context.Context, id string, params *UpdateBudgetParams, body UpdateBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBudgetResponse, error)

	UpdateBudgetWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateBudgetParams, body UpdateBudgetFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateBudgetResponse, error)

	// ListAttachmentByBudgetWithResponse request
	ListAttachmentByBudgetWithResponse(ctx context.Context, id string, params *ListAttachmentByBudgetParams, reqEditors ...RequestEditorFn) (*ListAttachmentByBudgetResponse, error)

	// ListBudgetLimitByBudgetWithResponse request
	ListBudgetLimitByBudgetWithResponse(ctx context.Context, id string, params *ListBudgetLimitByBudgetParams, reqEditors ...RequestEditorFn) (*ListBudgetLimitByBudgetResponse, error)

	// StoreBudgetLimitWithBodyWithResponse request with any body
	StoreBudgetLimitWithBodyWithResponse(ctx context.Context, id string, params *StoreBudgetLimitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreBudgetLimitResponse, error)

	StoreBudgetLimitWithResponse(ctx context.Context, id string, params *StoreBudgetLimitParams, body StoreBudgetLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreBudgetLimitResponse, error)

	StoreBudgetLimitWithFormdataBodyWithResponse(ctx context.Context, id string, params *StoreBudgetLimitParams, body StoreBudgetLimitFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreBudgetLimitResponse, error)

	// DeleteBudgetLimitWithResponse request
	DeleteBudgetLimitWithResponse(ctx context.Context, id string, limitId string, params *DeleteBudgetLimitParams, reqEditors ...RequestEditorFn) (*DeleteBudgetLimitResponse, error)

	// GetBudgetLimitWithResponse request
	GetBudgetLimitWithResponse(ctx context.Context, id string, limitId int, params *GetBudgetLimitParams, reqEditors ...RequestEditorFn) (*GetBudgetLimitResponse, error)

	// UpdateBudgetLimitWithBodyWithResponse request with any body
	UpdateBudgetLimitWithBodyWithResponse(ctx context.Context, id string, limitId string, params *UpdateBudgetLimitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBudgetLimitResponse, error)

	UpdateBudgetLimitWithResponse(ctx context.Context, id string, limitId string, params *UpdateBudgetLimitParams, body UpdateBudgetLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBudgetLimitResponse, error)

	UpdateBudgetLimitWithFormdataBodyWithResponse(ctx context.Context, id string, limitId string, params *UpdateBudgetLimitParams, body UpdateBudgetLimitFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateBudgetLimitResponse, error)

	// ListTransactionByBudgetLimitWithResponse request
	ListTransactionByBudgetLimitWithResponse(ctx context.Context, id string, limitId string, params *ListTransactionByBudgetLimitParams, reqEditors ...RequestEditorFn) (*ListTransactionByBudgetLimitResponse, error)

	// ListTransactionByBudgetWithResponse request
	ListTransactionByBudgetWithResponse(ctx context.Context, id string, params *ListTransactionByBudgetParams, reqEditors ...RequestEditorFn) (*ListTransactionByBudgetResponse, error)

	// ListCategoryWithResponse request
	ListCategoryWithResponse(ctx context.Context, params *ListCategoryParams, reqEditors ...RequestEditorFn) (*ListCategoryResponse, error)

	// StoreCategoryWithBodyWithResponse request with any body
	StoreCategoryWithBodyWithResponse(ctx context.Context, params *StoreCategoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCategoryResponse, error)

	StoreCategoryWithResponse(ctx context.Context, params *StoreCategoryParams, body StoreCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCategoryResponse, error)

	StoreCategoryWithFormdataBodyWithResponse(ctx context.Context, params *StoreCategoryParams, body StoreCategoryFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreCategoryResponse, error)

	// DeleteCategoryWithResponse request
	DeleteCategoryWithResponse(ctx context.Context, id string, params *DeleteCategoryParams, reqEditors ...RequestEditorFn) (*DeleteCategoryResponse, error)

	// GetCategoryWithResponse request
	GetCategoryWithResponse(ctx context.Context, id string, params *GetCategoryParams, reqEditors ...RequestEditorFn) (*GetCategoryResponse, error)

	// UpdateCategoryWithBodyWithResponse request with any body
	UpdateCategoryWithBodyWithResponse(ctx context.Context, id string, params *UpdateCategoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCategoryResponse, error)

	UpdateCategoryWithResponse(ctx context.Context, id string, params *UpdateCategoryParams, body UpdateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCategoryResponse, error)

	UpdateCategoryWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateCategoryParams, body UpdateCategoryFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateCategoryResponse, error)

	// ListAttachmentByCategoryWithResponse request
	ListAttachmentByCategoryWithResponse(ctx context.Context, id string, params *ListAttachmentByCategoryParams, reqEditors ...RequestEditorFn) (*ListAttachmentByCategoryResponse, error)

	// ListTransactionByCategoryWithResponse request
	ListTransactionByCategoryWithResponse(ctx context.Context, id string, params *ListTransactionByCategoryParams, reqEditors ...RequestEditorFn) (*ListTransactionByCategoryResponse, error)

	// GetChartAccountOverviewWithResponse request
	GetChartAccountOverviewWithResponse(ctx context.Context, params *GetChartAccountOverviewParams, reqEditors ...RequestEditorFn) (*GetChartAccountOverviewResponse, error)

	// GetConfigurationWithResponse request
	GetConfigurationWithResponse(ctx context.Context, params *GetConfigurationParams, reqEditors ...RequestEditorFn) (*GetConfigurationResponse, error)

	// GetSingleConfigurationWithResponse request
	GetSingleConfigurationWithResponse(ctx context.Context, name ConfigValueFilter, params *GetSingleConfigurationParams, reqEditors ...RequestEditorFn) (*GetSingleConfigurationResponse, error)

	// SetConfigurationWithBodyWithResponse request with any body
	SetConfigurationWithBodyWithResponse(ctx context.Context, name ConfigValueUpdateFilter, params *SetConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetConfigurationResponse, error)

	SetConfigurationWithResponse(ctx context.Context, name ConfigValueUpdateFilter, params *SetConfigurationParams, body SetConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetConfigurationResponse, error)

	SetConfigurationWithFormdataBodyWithResponse(ctx context.Context, name ConfigValueUpdateFilter, params *SetConfigurationParams, body SetConfigurationFormdataRequestBody, reqEditors ...RequestEditorFn) (*SetConfigurationResponse, error)

	// GetCronWithResponse request
	GetCronWithResponse(ctx context.Context, cliToken string, params *GetCronParams, reqEditors ...RequestEditorFn) (*GetCronResponse, error)

	// ListCurrencyWithResponse request
	ListCurrencyWithResponse(ctx context.Context, params *ListCurrencyParams, reqEditors ...RequestEditorFn) (*ListCurrencyResponse, error)

	// StoreCurrencyWithBodyWithResponse request with any body
	StoreCurrencyWithBodyWithResponse(ctx context.Context, params *StoreCurrencyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCurrencyResponse, error)

	StoreCurrencyWithResponse(ctx context.Context, params *StoreCurrencyParams, body StoreCurrencyJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCurrencyResponse, error)

	StoreCurrencyWithFormdataBodyWithResponse(ctx context.Context, params *StoreCurrencyParams, body StoreCurrencyFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreCurrencyResponse, error)

	// GetDefaultCurrencyWithResponse request
	GetDefaultCurrencyWithResponse(ctx context.Context, params *GetDefaultCurrencyParams, reqEditors ...RequestEditorFn) (*GetDefaultCurrencyResponse, error)

	// DeleteCurrencyWithResponse request
	DeleteCurrencyWithResponse(ctx context.Context, code string, params *DeleteCurrencyParams, reqEditors ...RequestEditorFn) (*DeleteCurrencyResponse, error)

	// GetCurrencyWithResponse request
	GetCurrencyWithResponse(ctx context.Context, code string, params *GetCurrencyParams, reqEditors ...RequestEditorFn) (*GetCurrencyResponse, error)

	// UpdateCurrencyWithBodyWithResponse request with any body
	UpdateCurrencyWithBodyWithResponse(ctx context.Context, code string, params *UpdateCurrencyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCurrencyResponse, error)

	UpdateCurrencyWithApplicationVndAPIPlusJSONBodyWithResponse(ctx context.Context, code string, params *UpdateCurrencyParams, body UpdateCurrencyApplicationVndAPIPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCurrencyResponse, error)

	UpdateCurrencyWithFormdataBodyWithResponse(ctx context.Context, code string, params *UpdateCurrencyParams, body UpdateCurrencyFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateCurrencyResponse, error)

	// ListAccountByCurrencyWithResponse request
	ListAccountByCurrencyWithResponse(ctx context.Context, code string, params *ListAccountByCurrencyParams, reqEditors ...RequestEditorFn) (*ListAccountByCurrencyResponse, error)

	// ListAvailableBudgetByCurrencyWithResponse request
	ListAvailableBudgetByCurrencyWithResponse(ctx context.Context, code string, params *ListAvailableBudgetByCurrencyParams, reqEditors ...RequestEditorFn) (*ListAvailableBudgetByCurrencyResponse, error)

	// ListBillByCurrencyWithResponse request
	ListBillByCurrencyWithResponse(ctx context.Context, code string, params *ListBillByCurrencyParams, reqEditors ...RequestEditorFn) (*ListBillByCurrencyResponse, error)

	// ListBudgetLimitByCurrencyWithResponse request
	ListBudgetLimitByCurrencyWithResponse(ctx context.Context, code string, params *ListBudgetLimitByCurrencyParams, reqEditors ...RequestEditorFn) (*ListBudgetLimitByCurrencyResponse, error)

	// DefaultCurrencyWithResponse request
	DefaultCurrencyWithResponse(ctx context.Context, code string, params *DefaultCurrencyParams, reqEditors ...RequestEditorFn) (*DefaultCurrencyResponse, error)

	// DisableCurrencyWithResponse request
	DisableCurrencyWithResponse(ctx context.Context, code string, params *DisableCurrencyParams, reqEditors ...RequestEditorFn) (*DisableCurrencyResponse, error)

	// EnableCurrencyWithResponse request
	EnableCurrencyWithResponse(ctx context.Context, code string, params *EnableCurrencyParams, reqEditors ...RequestEditorFn) (*EnableCurrencyResponse, error)

	// ListRecurrenceByCurrencyWithResponse request
	ListRecurrenceByCurrencyWithResponse(ctx context.Context, code string, params *ListRecurrenceByCurrencyParams, reqEditors ...RequestEditorFn) (*ListRecurrenceByCurrencyResponse, error)

	// ListRuleByCurrencyWithResponse request
	ListRuleByCurrencyWithResponse(ctx context.Context, code string, params *ListRuleByCurrencyParams, reqEditors ...RequestEditorFn) (*ListRuleByCurrencyResponse, error)

	// ListTransactionByCurrencyWithResponse request
	ListTransactionByCurrencyWithResponse(ctx context.Context, code string, params *ListTransactionByCurrencyParams, reqEditors ...RequestEditorFn) (*ListTransactionByCurrencyResponse, error)

	// BulkUpdateTransactionsWithResponse request
	BulkUpdateTransactionsWithResponse(ctx context.Context, params *BulkUpdateTransactionsParams, reqEditors ...RequestEditorFn) (*BulkUpdateTransactionsResponse, error)

	// DestroyDataWithResponse request
	DestroyDataWithResponse(ctx context.Context, params *DestroyDataParams, reqEditors ...RequestEditorFn) (*DestroyDataResponse, error)

	// ExportAccountsWithResponse request
	ExportAccountsWithResponse(ctx context.Context, params *ExportAccountsParams, reqEditors ...RequestEditorFn) (*ExportAccountsResponse, error)

	// ExportBillsWithResponse request
	ExportBillsWithResponse(ctx context.Context, params *ExportBillsParams, reqEditors ...RequestEditorFn) (*ExportBillsResponse, error)

	// ExportBudgetsWithResponse request
	ExportBudgetsWithResponse(ctx context.Context, params *ExportBudgetsParams, reqEditors ...RequestEditorFn) (*ExportBudgetsResponse, error)

	// ExportCategoriesWithResponse request
	ExportCategoriesWithResponse(ctx context.Context, params *ExportCategoriesParams, reqEditors ...RequestEditorFn) (*ExportCategoriesResponse, error)

	// ExportPiggiesWithResponse request
	ExportPiggiesWithResponse(ctx context.Context, params *ExportPiggiesParams, reqEditors ...RequestEditorFn) (*ExportPiggiesResponse, error)

	// ExportRecurringWithResponse request
	ExportRecurringWithResponse(ctx context.Context, params *ExportRecurringParams, reqEditors ...RequestEditorFn) (*ExportRecurringResponse, error)

	// ExportRulesWithResponse request
	ExportRulesWithResponse(ctx context.Context, params *ExportRulesParams, reqEditors ...RequestEditorFn) (*ExportRulesResponse, error)

	// ExportTagsWithResponse request
	ExportTagsWithResponse(ctx context.Context, params *ExportTagsParams, reqEditors ...RequestEditorFn) (*ExportTagsResponse, error)

	// ExportTransactionsWithResponse request
	ExportTransactionsWithResponse(ctx context.Context, params *ExportTransactionsParams, reqEditors ...RequestEditorFn) (*ExportTransactionsResponse, error)

	// PurgeDataWithResponse request
	PurgeDataWithResponse(ctx context.Context, params *PurgeDataParams, reqEditors ...RequestEditorFn) (*PurgeDataResponse, error)

	// InsightExpenseAssetWithResponse request
	InsightExpenseAssetWithResponse(ctx context.Context, params *InsightExpenseAssetParams, reqEditors ...RequestEditorFn) (*InsightExpenseAssetResponse, error)

	// InsightExpenseBillWithResponse request
	InsightExpenseBillWithResponse(ctx context.Context, params *InsightExpenseBillParams, reqEditors ...RequestEditorFn) (*InsightExpenseBillResponse, error)

	// InsightExpenseBudgetWithResponse request
	InsightExpenseBudgetWithResponse(ctx context.Context, params *InsightExpenseBudgetParams, reqEditors ...RequestEditorFn) (*InsightExpenseBudgetResponse, error)

	// InsightExpenseCategoryWithResponse request
	InsightExpenseCategoryWithResponse(ctx context.Context, params *InsightExpenseCategoryParams, reqEditors ...RequestEditorFn) (*InsightExpenseCategoryResponse, error)

	// InsightExpenseExpenseWithResponse request
	InsightExpenseExpenseWithResponse(ctx context.Context, params *InsightExpenseExpenseParams, reqEditors ...RequestEditorFn) (*InsightExpenseExpenseResponse, error)

	// InsightExpenseNoBillWithResponse request
	InsightExpenseNoBillWithResponse(ctx context.Context, params *InsightExpenseNoBillParams, reqEditors ...RequestEditorFn) (*InsightExpenseNoBillResponse, error)

	// InsightExpenseNoBudgetWithResponse request
	InsightExpenseNoBudgetWithResponse(ctx context.Context, params *InsightExpenseNoBudgetParams, reqEditors ...RequestEditorFn) (*InsightExpenseNoBudgetResponse, error)

	// InsightExpenseNoCategoryWithResponse request
	InsightExpenseNoCategoryWithResponse(ctx context.Context, params *InsightExpenseNoCategoryParams, reqEditors ...RequestEditorFn) (*InsightExpenseNoCategoryResponse, error)

	// InsightExpenseNoTagWithResponse request
	InsightExpenseNoTagWithResponse(ctx context.Context, params *InsightExpenseNoTagParams, reqEditors ...RequestEditorFn) (*InsightExpenseNoTagResponse, error)

	// InsightExpenseTagWithResponse request
	InsightExpenseTagWithResponse(ctx context.Context, params *InsightExpenseTagParams, reqEditors ...RequestEditorFn) (*InsightExpenseTagResponse, error)

	// InsightExpenseTotalWithResponse request
	InsightExpenseTotalWithResponse(ctx context.Context, params *InsightExpenseTotalParams, reqEditors ...RequestEditorFn) (*InsightExpenseTotalResponse, error)

	// InsightIncomeAssetWithResponse request
	InsightIncomeAssetWithResponse(ctx context.Context, params *InsightIncomeAssetParams, reqEditors ...RequestEditorFn) (*InsightIncomeAssetResponse, error)

	// InsightIncomeCategoryWithResponse request
	InsightIncomeCategoryWithResponse(ctx context.Context, params *InsightIncomeCategoryParams, reqEditors ...RequestEditorFn) (*InsightIncomeCategoryResponse, error)

	// InsightIncomeNoCategoryWithResponse request
	InsightIncomeNoCategoryWithResponse(ctx context.Context, params *InsightIncomeNoCategoryParams, reqEditors ...RequestEditorFn) (*InsightIncomeNoCategoryResponse, error)

	// InsightIncomeNoTagWithResponse request
	InsightIncomeNoTagWithResponse(ctx context.Context, params *InsightIncomeNoTagParams, reqEditors ...RequestEditorFn) (*InsightIncomeNoTagResponse, error)

	// InsightIncomeRevenueWithResponse request
	InsightIncomeRevenueWithResponse(ctx context.Context, params *InsightIncomeRevenueParams, reqEditors ...RequestEditorFn) (*InsightIncomeRevenueResponse, error)

	// InsightIncomeTagWithResponse request
	InsightIncomeTagWithResponse(ctx context.Context, params *InsightIncomeTagParams, reqEditors ...RequestEditorFn) (*InsightIncomeTagResponse, error)

	// InsightIncomeTotalWithResponse request
	InsightIncomeTotalWithResponse(ctx context.Context, params *InsightIncomeTotalParams, reqEditors ...RequestEditorFn) (*InsightIncomeTotalResponse, error)

	// InsightTransfersWithResponse request
	InsightTransfersWithResponse(ctx context.Context, params *InsightTransfersParams, reqEditors ...RequestEditorFn) (*InsightTransfersResponse, error)

	// InsightTransferCategoryWithResponse request
	InsightTransferCategoryWithResponse(ctx context.Context, params *InsightTransferCategoryParams, reqEditors ...RequestEditorFn) (*InsightTransferCategoryResponse, error)

	// InsightTransferNoCategoryWithResponse request
	InsightTransferNoCategoryWithResponse(ctx context.Context, params *InsightTransferNoCategoryParams, reqEditors ...RequestEditorFn) (*InsightTransferNoCategoryResponse, error)

	// InsightTransferNoTagWithResponse request
	InsightTransferNoTagWithResponse(ctx context.Context, params *InsightTransferNoTagParams, reqEditors ...RequestEditorFn) (*InsightTransferNoTagResponse, error)

	// InsightTransferTagWithResponse request
	InsightTransferTagWithResponse(ctx context.Context, params *InsightTransferTagParams, reqEditors ...RequestEditorFn) (*InsightTransferTagResponse, error)

	// InsightTransferTotalWithResponse request
	InsightTransferTotalWithResponse(ctx context.Context, params *InsightTransferTotalParams, reqEditors ...RequestEditorFn) (*InsightTransferTotalResponse, error)

	// ListLinkTypeWithResponse request
	ListLinkTypeWithResponse(ctx context.Context, params *ListLinkTypeParams, reqEditors ...RequestEditorFn) (*ListLinkTypeResponse, error)

	// StoreLinkTypeWithBodyWithResponse request with any body
	StoreLinkTypeWithBodyWithResponse(ctx context.Context, params *StoreLinkTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreLinkTypeResponse, error)

	StoreLinkTypeWithResponse(ctx context.Context, params *StoreLinkTypeParams, body StoreLinkTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreLinkTypeResponse, error)

	StoreLinkTypeWithFormdataBodyWithResponse(ctx context.Context, params *StoreLinkTypeParams, body StoreLinkTypeFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreLinkTypeResponse, error)

	// DeleteLinkTypeWithResponse request
	DeleteLinkTypeWithResponse(ctx context.Context, id string, params *DeleteLinkTypeParams, reqEditors ...RequestEditorFn) (*DeleteLinkTypeResponse, error)

	// GetLinkTypeWithResponse request
	GetLinkTypeWithResponse(ctx context.Context, id string, params *GetLinkTypeParams, reqEditors ...RequestEditorFn) (*GetLinkTypeResponse, error)

	// UpdateLinkTypeWithBodyWithResponse request with any body
	UpdateLinkTypeWithBodyWithResponse(ctx context.Context, id string, params *UpdateLinkTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLinkTypeResponse, error)

	UpdateLinkTypeWithResponse(ctx context.Context, id string, params *UpdateLinkTypeParams, body UpdateLinkTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLinkTypeResponse, error)

	UpdateLinkTypeWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateLinkTypeParams, body UpdateLinkTypeFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateLinkTypeResponse, error)

	// ListTransactionByLinkTypeWithResponse request
	ListTransactionByLinkTypeWithResponse(ctx context.Context, id string, params *ListTransactionByLinkTypeParams, reqEditors ...RequestEditorFn) (*ListTransactionByLinkTypeResponse, error)

	// ListObjectGroupsWithResponse request
	ListObjectGroupsWithResponse(ctx context.Context, params *ListObjectGroupsParams, reqEditors ...RequestEditorFn) (*ListObjectGroupsResponse, error)

	// DeleteObjectGroupWithResponse request
	DeleteObjectGroupWithResponse(ctx context.Context, id string, params *DeleteObjectGroupParams, reqEditors ...RequestEditorFn) (*DeleteObjectGroupResponse, error)

	// GetObjectGroupWithResponse request
	GetObjectGroupWithResponse(ctx context.Context, id string, params *GetObjectGroupParams, reqEditors ...RequestEditorFn) (*GetObjectGroupResponse, error)

	// UpdateObjectGroupWithBodyWithResponse request with any body
	UpdateObjectGroupWithBodyWithResponse(ctx context.Context, id string, params *UpdateObjectGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateObjectGroupResponse, error)

	UpdateObjectGroupWithResponse(ctx context.Context, id string, params *UpdateObjectGroupParams, body UpdateObjectGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateObjectGroupResponse, error)

	UpdateObjectGroupWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateObjectGroupParams, body UpdateObjectGroupFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateObjectGroupResponse, error)

	// ListBillByObjectGroupWithResponse request
	ListBillByObjectGroupWithResponse(ctx context.Context, id string, params *ListBillByObjectGroupParams, reqEditors ...RequestEditorFn) (*ListBillByObjectGroupResponse, error)

	// ListPiggyBankByObjectGroupWithResponse request
	ListPiggyBankByObjectGroupWithResponse(ctx context.Context, id string, params *ListPiggyBankByObjectGroupParams, reqEditors ...RequestEditorFn) (*ListPiggyBankByObjectGroupResponse, error)

	// ListPiggyBankWithResponse request
	ListPiggyBankWithResponse(ctx context.Context, params *ListPiggyBankParams, reqEditors ...RequestEditorFn) (*ListPiggyBankResponse, error)

	// StorePiggyBankWithBodyWithResponse request with any body
	StorePiggyBankWithBodyWithResponse(ctx context.Context, params *StorePiggyBankParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StorePiggyBankResponse, error)

	StorePiggyBankWithResponse(ctx context.Context, params *StorePiggyBankParams, body StorePiggyBankJSONRequestBody, reqEditors ...RequestEditorFn) (*StorePiggyBankResponse, error)

	StorePiggyBankWithFormdataBodyWithResponse(ctx context.Context, params *StorePiggyBankParams, body StorePiggyBankFormdataRequestBody, reqEditors ...RequestEditorFn) (*StorePiggyBankResponse, error)

	// DeletePiggyBankWithResponse request
	DeletePiggyBankWithResponse(ctx context.Context, id string, params *DeletePiggyBankParams, reqEditors ...RequestEditorFn) (*DeletePiggyBankResponse, error)

	// GetPiggyBankWithResponse request
	GetPiggyBankWithResponse(ctx context.Context, id string, params *GetPiggyBankParams, reqEditors ...RequestEditorFn) (*GetPiggyBankResponse, error)

	// UpdatePiggyBankWithBodyWithResponse request with any body
	UpdatePiggyBankWithBodyWithResponse(ctx context.Context, id string, params *UpdatePiggyBankParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePiggyBankResponse, error)

	UpdatePiggyBankWithResponse(ctx context.Context, id string, params *UpdatePiggyBankParams, body UpdatePiggyBankJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePiggyBankResponse, error)

	UpdatePiggyBankWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdatePiggyBankParams, body UpdatePiggyBankFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdatePiggyBankResponse, error)

	// ListAttachmentByPiggyBankWithResponse request
	ListAttachmentByPiggyBankWithResponse(ctx context.Context, id string, params *ListAttachmentByPiggyBankParams, reqEditors ...RequestEditorFn) (*ListAttachmentByPiggyBankResponse, error)

	// ListEventByPiggyBankWithResponse request
	ListEventByPiggyBankWithResponse(ctx context.Context, id string, params *ListEventByPiggyBankParams, reqEditors ...RequestEditorFn) (*ListEventByPiggyBankResponse, error)

	// ListPreferenceWithResponse request
	ListPreferenceWithResponse(ctx context.Context, params *ListPreferenceParams, reqEditors ...RequestEditorFn) (*ListPreferenceResponse, error)

	// StorePreferenceWithBodyWithResponse request with any body
	StorePreferenceWithBodyWithResponse(ctx context.Context, params *StorePreferenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StorePreferenceResponse, error)

	StorePreferenceWithResponse(ctx context.Context, params *StorePreferenceParams, body StorePreferenceJSONRequestBody, reqEditors ...RequestEditorFn) (*StorePreferenceResponse, error)

	StorePreferenceWithFormdataBodyWithResponse(ctx context.Context, params *StorePreferenceParams, body StorePreferenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*StorePreferenceResponse, error)

	// GetPreferenceWithResponse request
	GetPreferenceWithResponse(ctx context.Context, name string, params *GetPreferenceParams, reqEditors ...RequestEditorFn) (*GetPreferenceResponse, error)

	// UpdatePreferenceWithBodyWithResponse request with any body
	UpdatePreferenceWithBodyWithResponse(ctx context.Context, name string, params *UpdatePreferenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePreferenceResponse, error)

	UpdatePreferenceWithResponse(ctx context.Context, name string, params *UpdatePreferenceParams, body UpdatePreferenceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePreferenceResponse, error)

	UpdatePreferenceWithFormdataBodyWithResponse(ctx context.Context, name string, params *UpdatePreferenceParams, body UpdatePreferenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdatePreferenceResponse, error)

	// ListRecurrenceWithResponse request
	ListRecurrenceWithResponse(ctx context.Context, params *ListRecurrenceParams, reqEditors ...RequestEditorFn) (*ListRecurrenceResponse, error)

	// StoreRecurrenceWithBodyWithResponse request with any body
	StoreRecurrenceWithBodyWithResponse(ctx context.Context, params *StoreRecurrenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreRecurrenceResponse, error)

	StoreRecurrenceWithResponse(ctx context.Context, params *StoreRecurrenceParams, body StoreRecurrenceJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreRecurrenceResponse, error)

	StoreRecurrenceWithFormdataBodyWithResponse(ctx context.Context, params *StoreRecurrenceParams, body StoreRecurrenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreRecurrenceResponse, error)

	// DeleteRecurrenceWithResponse request
	DeleteRecurrenceWithResponse(ctx context.Context, id string, params *DeleteRecurrenceParams, reqEditors ...RequestEditorFn) (*DeleteRecurrenceResponse, error)

	// GetRecurrenceWithResponse request
	GetRecurrenceWithResponse(ctx context.Context, id string, params *GetRecurrenceParams, reqEditors ...RequestEditorFn) (*GetRecurrenceResponse, error)

	// UpdateRecurrenceWithBodyWithResponse request with any body
	UpdateRecurrenceWithBodyWithResponse(ctx context.Context, id string, params *UpdateRecurrenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecurrenceResponse, error)

	UpdateRecurrenceWithResponse(ctx context.Context, id string, params *UpdateRecurrenceParams, body UpdateRecurrenceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecurrenceResponse, error)

	UpdateRecurrenceWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateRecurrenceParams, body UpdateRecurrenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecurrenceResponse, error)

	// ListTransactionByRecurrenceWithResponse request
	ListTransactionByRecurrenceWithResponse(ctx context.Context, id string, params *ListTransactionByRecurrenceParams, reqEditors ...RequestEditorFn) (*ListTransactionByRecurrenceResponse, error)

	// ListRuleGroupWithResponse request
	ListRuleGroupWithResponse(ctx context.Context, params *ListRuleGroupParams, reqEditors ...RequestEditorFn) (*ListRuleGroupResponse, error)

	// StoreRuleGroupWithBodyWithResponse request with any body
	StoreRuleGroupWithBodyWithResponse(ctx context.Context, params *StoreRuleGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreRuleGroupResponse, error)

	StoreRuleGroupWithResponse(ctx context.Context, params *StoreRuleGroupParams, body StoreRuleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreRuleGroupResponse, error)

	StoreRuleGroupWithFormdataBodyWithResponse(ctx context.Context, params *StoreRuleGroupParams, body StoreRuleGroupFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreRuleGroupResponse, error)

	// DeleteRuleGroupWithResponse request
	DeleteRuleGroupWithResponse(ctx context.Context, id string, params *DeleteRuleGroupParams, reqEditors ...RequestEditorFn) (*DeleteRuleGroupResponse, error)

	// GetRuleGroupWithResponse request
	GetRuleGroupWithResponse(ctx context.Context, id string, params *GetRuleGroupParams, reqEditors ...RequestEditorFn) (*GetRuleGroupResponse, error)

	// UpdateRuleGroupWithBodyWithResponse request with any body
	UpdateRuleGroupWithBodyWithResponse(ctx context.Context, id string, params *UpdateRuleGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleGroupResponse, error)

	UpdateRuleGroupWithResponse(ctx context.Context, id string, params *UpdateRuleGroupParams, body UpdateRuleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleGroupResponse, error)

	UpdateRuleGroupWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateRuleGroupParams, body UpdateRuleGroupFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleGroupResponse, error)

	// ListRuleByGroupWithResponse request
	ListRuleByGroupWithResponse(ctx context.Context, id string, params *ListRuleByGroupParams, reqEditors ...RequestEditorFn) (*ListRuleByGroupResponse, error)

	// TestRuleGroupWithResponse request
	TestRuleGroupWithResponse(ctx context.Context, id string, params *TestRuleGroupParams, reqEditors ...RequestEditorFn) (*TestRuleGroupResponse, error)

	// FireRuleGroupWithResponse request
	FireRuleGroupWithResponse(ctx context.Context, id string, params *FireRuleGroupParams, reqEditors ...RequestEditorFn) (*FireRuleGroupResponse, error)

	// ListRuleWithResponse request
	ListRuleWithResponse(ctx context.Context, params *ListRuleParams, reqEditors ...RequestEditorFn) (*ListRuleResponse, error)

	// StoreRuleWithBodyWithResponse request with any body
	StoreRuleWithBodyWithResponse(ctx context.Context, params *StoreRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreRuleResponse, error)

	StoreRuleWithResponse(ctx context.Context, params *StoreRuleParams, body StoreRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreRuleResponse, error)

	StoreRuleWithFormdataBodyWithResponse(ctx context.Context, params *StoreRuleParams, body StoreRuleFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreRuleResponse, error)

	// DeleteRuleWithResponse request
	DeleteRuleWithResponse(ctx context.Context, id string, params *DeleteRuleParams, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error)

	// GetRuleWithResponse request
	GetRuleWithResponse(ctx context.Context, id string, params *GetRuleParams, reqEditors ...RequestEditorFn) (*GetRuleResponse, error)

	// UpdateRuleWithBodyWithResponse request with any body
	UpdateRuleWithBodyWithResponse(ctx context.Context, id string, params *UpdateRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	UpdateRuleWithResponse(ctx context.Context, id string, params *UpdateRuleParams, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	UpdateRuleWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateRuleParams, body UpdateRuleFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	// TestRuleWithResponse request
	TestRuleWithResponse(ctx context.Context, id string, params *TestRuleParams, reqEditors ...RequestEditorFn) (*TestRuleResponse, error)

	// FireRuleWithResponse request
	FireRuleWithResponse(ctx context.Context, id string, params *FireRuleParams, reqEditors ...RequestEditorFn) (*FireRuleResponse, error)

	// SearchAccountsWithResponse request
	SearchAccountsWithResponse(ctx context.Context, params *SearchAccountsParams, reqEditors ...RequestEditorFn) (*SearchAccountsResponse, error)

	// SearchTransactionsWithResponse request
	SearchTransactionsWithResponse(ctx context.Context, params *SearchTransactionsParams, reqEditors ...RequestEditorFn) (*SearchTransactionsResponse, error)

	// GetBasicSummaryWithResponse request
	GetBasicSummaryWithResponse(ctx context.Context, params *GetBasicSummaryParams, reqEditors ...RequestEditorFn) (*GetBasicSummaryResponse, error)

	// ListTagWithResponse request
	ListTagWithResponse(ctx context.Context, params *ListTagParams, reqEditors ...RequestEditorFn) (*ListTagResponse, error)

	// StoreTagWithBodyWithResponse request with any body
	StoreTagWithBodyWithResponse(ctx context.Context, params *StoreTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreTagResponse, error)

	StoreTagWithResponse(ctx context.Context, params *StoreTagParams, body StoreTagJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreTagResponse, error)

	StoreTagWithFormdataBodyWithResponse(ctx context.Context, params *StoreTagParams, body StoreTagFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreTagResponse, error)

	// DeleteTagWithResponse request
	DeleteTagWithResponse(ctx context.Context, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error)

	// GetTagWithResponse request
	GetTagWithResponse(ctx context.Context, tag string, params *GetTagParams, reqEditors ...RequestEditorFn) (*GetTagResponse, error)

	// UpdateTagWithBodyWithResponse request with any body
	UpdateTagWithBodyWithResponse(ctx context.Context, tag string, params *UpdateTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error)

	UpdateTagWithResponse(ctx context.Context, tag string, params *UpdateTagParams, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error)

	UpdateTagWithFormdataBodyWithResponse(ctx context.Context, tag string, params *UpdateTagParams, body UpdateTagFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error)

	// ListAttachmentByTagWithResponse request
	ListAttachmentByTagWithResponse(ctx context.Context, tag string, params *ListAttachmentByTagParams, reqEditors ...RequestEditorFn) (*ListAttachmentByTagResponse, error)

	// ListTransactionByTagWithResponse request
	ListTransactionByTagWithResponse(ctx context.Context, tag string, params *ListTransactionByTagParams, reqEditors ...RequestEditorFn) (*ListTransactionByTagResponse, error)

	// DeleteTransactionJournalWithResponse request
	DeleteTransactionJournalWithResponse(ctx context.Context, id string, params *DeleteTransactionJournalParams, reqEditors ...RequestEditorFn) (*DeleteTransactionJournalResponse, error)

	// GetTransactionByJournalWithResponse request
	GetTransactionByJournalWithResponse(ctx context.Context, id string, params *GetTransactionByJournalParams, reqEditors ...RequestEditorFn) (*GetTransactionByJournalResponse, error)

	// ListLinksByJournalWithResponse request
	ListLinksByJournalWithResponse(ctx context.Context, id string, params *ListLinksByJournalParams, reqEditors ...RequestEditorFn) (*ListLinksByJournalResponse, error)

	// ListTransactionLinkWithResponse request
	ListTransactionLinkWithResponse(ctx context.Context, params *ListTransactionLinkParams, reqEditors ...RequestEditorFn) (*ListTransactionLinkResponse, error)

	// StoreTransactionLinkWithBodyWithResponse request with any body
	StoreTransactionLinkWithBodyWithResponse(ctx context.Context, params *StoreTransactionLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreTransactionLinkResponse, error)

	StoreTransactionLinkWithResponse(ctx context.Context, params *StoreTransactionLinkParams, body StoreTransactionLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreTransactionLinkResponse, error)

	StoreTransactionLinkWithFormdataBodyWithResponse(ctx context.Context, params *StoreTransactionLinkParams, body StoreTransactionLinkFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreTransactionLinkResponse, error)

	// DeleteTransactionLinkWithResponse request
	DeleteTransactionLinkWithResponse(ctx context.Context, id string, params *DeleteTransactionLinkParams, reqEditors ...RequestEditorFn) (*DeleteTransactionLinkResponse, error)

	// GetTransactionLinkWithResponse request
	GetTransactionLinkWithResponse(ctx context.Context, id string, params *GetTransactionLinkParams, reqEditors ...RequestEditorFn) (*GetTransactionLinkResponse, error)

	// UpdateTransactionLinkWithBodyWithResponse request with any body
	UpdateTransactionLinkWithBodyWithResponse(ctx context.Context, id string, params *UpdateTransactionLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTransactionLinkResponse, error)

	UpdateTransactionLinkWithResponse(ctx context.Context, id string, params *UpdateTransactionLinkParams, body UpdateTransactionLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionLinkResponse, error)

	UpdateTransactionLinkWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateTransactionLinkParams, body UpdateTransactionLinkFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionLinkResponse, error)

	// ListTransactionWithResponse request
	ListTransactionWithResponse(ctx context.Context, params *ListTransactionParams, reqEditors ...RequestEditorFn) (*ListTransactionResponse, error)

	// StoreTransactionWithBodyWithResponse request with any body
	StoreTransactionWithBodyWithResponse(ctx context.Context, params *StoreTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreTransactionResponse, error)

	StoreTransactionWithResponse(ctx context.Context, params *StoreTransactionParams, body StoreTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreTransactionResponse, error)

	StoreTransactionWithFormdataBodyWithResponse(ctx context.Context, params *StoreTransactionParams, body StoreTransactionFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreTransactionResponse, error)

	// DeleteTransactionWithResponse request
	DeleteTransactionWithResponse(ctx context.Context, id string, params *DeleteTransactionParams, reqEditors ...RequestEditorFn) (*DeleteTransactionResponse, error)

	// GetTransactionWithResponse request
	GetTransactionWithResponse(ctx context.Context, id string, params *GetTransactionParams, reqEditors ...RequestEditorFn) (*GetTransactionResponse, error)

	// UpdateTransactionWithBodyWithResponse request with any body
	UpdateTransactionWithBodyWithResponse(ctx context.Context, id string, params *UpdateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTransactionResponse, error)

	UpdateTransactionWithResponse(ctx context.Context, id string, params *UpdateTransactionParams, body UpdateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionResponse, error)

	UpdateTransactionWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateTransactionParams, body UpdateTransactionFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionResponse, error)

	// ListAttachmentByTransactionWithResponse request
	ListAttachmentByTransactionWithResponse(ctx context.Context, id string, params *ListAttachmentByTransactionParams, reqEditors ...RequestEditorFn) (*ListAttachmentByTransactionResponse, error)

	// ListEventByTransactionWithResponse request
	ListEventByTransactionWithResponse(ctx context.Context, id string, params *ListEventByTransactionParams, reqEditors ...RequestEditorFn) (*ListEventByTransactionResponse, error)

	// ListUserWithResponse request
	ListUserWithResponse(ctx context.Context, params *ListUserParams, reqEditors ...RequestEditorFn) (*ListUserResponse, error)

	// StoreUserWithBodyWithResponse request with any body
	StoreUserWithBodyWithResponse(ctx context.Context, params *StoreUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreUserResponse, error)

	StoreUserWithResponse(ctx context.Context, params *StoreUserParams, body StoreUserJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreUserResponse, error)

	StoreUserWithFormdataBodyWithResponse(ctx context.Context, params *StoreUserParams, body StoreUserFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, id string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, id string, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, id string, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, id string, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateUserParams, body UpdateUserFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// ListWebhookWithResponse request
	ListWebhookWithResponse(ctx context.Context, params *ListWebhookParams, reqEditors ...RequestEditorFn) (*ListWebhookResponse, error)

	// StoreWebhookWithBodyWithResponse request with any body
	StoreWebhookWithBodyWithResponse(ctx context.Context, params *StoreWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreWebhookResponse, error)

	StoreWebhookWithResponse(ctx context.Context, params *StoreWebhookParams, body StoreWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreWebhookResponse, error)

	StoreWebhookWithFormdataBodyWithResponse(ctx context.Context, params *StoreWebhookParams, body StoreWebhookFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreWebhookResponse, error)

	// DeleteWebhookWithResponse request
	DeleteWebhookWithResponse(ctx context.Context, id string, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error)

	// GetWebhookWithResponse request
	GetWebhookWithResponse(ctx context.Context, id string, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error)

	// UpdateWebhookWithBodyWithResponse request with any body
	UpdateWebhookWithBodyWithResponse(ctx context.Context, id string, params *UpdateWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error)

	UpdateWebhookWithResponse(ctx context.Context, id string, params *UpdateWebhookParams, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error)

	UpdateWebhookWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateWebhookParams, body UpdateWebhookFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error)

	// GetWebhookMessagesWithResponse request
	GetWebhookMessagesWithResponse(ctx context.Context, id string, params *GetWebhookMessagesParams, reqEditors ...RequestEditorFn) (*GetWebhookMessagesResponse, error)

	// DeleteWebhookMessageWithResponse request
	DeleteWebhookMessageWithResponse(ctx context.Context, id string, messageId int, params *DeleteWebhookMessageParams, reqEditors ...RequestEditorFn) (*DeleteWebhookMessageResponse, error)

	// GetSingleWebhookMessageWithResponse request
	GetSingleWebhookMessageWithResponse(ctx context.Context, id string, messageId int, params *GetSingleWebhookMessageParams, reqEditors ...RequestEditorFn) (*GetSingleWebhookMessageResponse, error)

	// GetWebhookMessageAttemptsWithResponse request
	GetWebhookMessageAttemptsWithResponse(ctx context.Context, id string, messageId int, params *GetWebhookMessageAttemptsParams, reqEditors ...RequestEditorFn) (*GetWebhookMessageAttemptsResponse, error)

	// DeleteWebhookMessageAttemptWithResponse request
	DeleteWebhookMessageAttemptWithResponse(ctx context.Context, id string, messageId int, attemptId int, params *DeleteWebhookMessageAttemptParams, reqEditors ...RequestEditorFn) (*DeleteWebhookMessageAttemptResponse, error)

	// GetSingleWebhookMessageAttemptWithResponse request
	GetSingleWebhookMessageAttemptWithResponse(ctx context.Context, id string, messageId int, attemptId int, params *GetSingleWebhookMessageAttemptParams, reqEditors ...RequestEditorFn) (*GetSingleWebhookMessageAttemptResponse, error)

	// SubmitWebookWithResponse request
	SubmitWebookWithResponse(ctx context.Context, id string, params *SubmitWebookParams, reqEditors ...RequestEditorFn) (*SubmitWebookResponse, error)

	// TriggerTransactionWebhookWithResponse request
	TriggerTransactionWebhookWithResponse(ctx context.Context, id string, transactionId string, params *TriggerTransactionWebhookParams, reqEditors ...RequestEditorFn) (*TriggerTransactionWebhookResponse, error)
}

type GetAboutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SystemInfo
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetAboutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAboutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *UserSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAccountResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AccountArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreAccountResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AccountSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AccountSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccountResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AccountSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttachmentByAccountResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AttachmentArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListAttachmentByAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttachmentByAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPiggyBankByAccountResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *PiggyBankArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListPiggyBankByAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPiggyBankByAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionByAccountResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListTransactionByAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionByAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttachmentResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AttachmentArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreAttachmentResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AttachmentSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AttachmentSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAttachmentResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AttachmentSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DownloadAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON422      *ValidationErrorResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UploadAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountsACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteAccountArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetAccountsACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountsACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillsACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteBillArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetBillsACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillsACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBudgetsACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteBudgetArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetBudgetsACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBudgetsACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoriesACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteCategoryArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetCategoriesACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoriesACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrenciesACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteCurrencyArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetCurrenciesACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrenciesACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrenciesCodeACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteCurrencyCodeArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetCurrenciesCodeACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrenciesCodeACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectGroupsACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteObjectGroupArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetObjectGroupsACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectGroupsACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPiggiesACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompletePiggyArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetPiggiesACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPiggiesACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPiggiesBalanceACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompletePiggyBalanceArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetPiggiesBalanceACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPiggiesBalanceACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecurringACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteRecurrenceArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetRecurringACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecurringACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleGroupsACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteRuleGroupArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetRuleGroupsACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleGroupsACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteRuleArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetRulesACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteTagArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetTagACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionTypesACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteTransactionTypeArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionTypesACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionTypesACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteTransactionArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionsACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsIDACResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteTransactionIDArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionsIDACResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsIDACResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableBudgetResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AvailableBudgetArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListAvailableBudgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableBudgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvailableBudgetResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AvailableBudgetSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetAvailableBudgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvailableBudgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBillResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BillArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListBillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreBillResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BillSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreBillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreBillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBillResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteBillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BillSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetBillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBillResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BillSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateBillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttachmentByBillResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AttachmentArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListAttachmentByBillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttachmentByBillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRuleByBillResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RuleArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListRuleByBillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRuleByBillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionByBillResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListTransactionByBillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionByBillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBudgetLimitResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BudgetLimitArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListBudgetLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBudgetLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBudgetResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BudgetArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListBudgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBudgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreBudgetResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BudgetSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreBudgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreBudgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBudgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteBudgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBudgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBudgetResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BudgetSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetBudgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBudgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBudgetResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BudgetSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateBudgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBudgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttachmentByBudgetResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AttachmentArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListAttachmentByBudgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttachmentByBudgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBudgetLimitByBudgetResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BudgetLimitArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListBudgetLimitByBudgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBudgetLimitByBudgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreBudgetLimitResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BudgetLimitSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreBudgetLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreBudgetLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBudgetLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteBudgetLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBudgetLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBudgetLimitResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BudgetLimitSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetBudgetLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBudgetLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBudgetLimitResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BudgetLimitSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateBudgetLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBudgetLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionByBudgetLimitResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListTransactionByBudgetLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionByBudgetLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionByBudgetResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListTransactionByBudgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionByBudgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCategoryResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *CategoryArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreCategoryResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *CategorySingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoryResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *CategorySingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCategoryResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *CategorySingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttachmentByCategoryResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AttachmentArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListAttachmentByCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttachmentByCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionByCategoryResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListTransactionByCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionByCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChartAccountOverviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChartLine
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetChartAccountOverviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChartAccountOverviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigurationArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSingleConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigurationSingle
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetSingleConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSingleConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigurationSingle
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON422      *ValidationErrorResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r SetConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCronResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CronResult
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetCronResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCronResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCurrencyResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *CurrencyArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreCurrencyResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *CurrencySingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultCurrencyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CurrencySingle
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetDefaultCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCurrencyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrencyResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *CurrencySingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCurrencyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CurrencySingle
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON422      *ValidationErrorResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAccountByCurrencyResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AccountArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListAccountByCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountByCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableBudgetByCurrencyResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AvailableBudgetArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListAvailableBudgetByCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableBudgetByCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBillByCurrencyResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BillArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListBillByCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBillByCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBudgetLimitByCurrencyResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BudgetLimitArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListBudgetLimitByCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBudgetLimitByCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DefaultCurrencyResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON204 *CurrencySingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DefaultCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DefaultCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableCurrencyResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON204 *CurrencySingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DisableCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableCurrencyResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON204 *CurrencySingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r EnableCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRecurrenceByCurrencyResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RecurrenceArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListRecurrenceByCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRecurrenceByCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRuleByCurrencyResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RuleArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListRuleByCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRuleByCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionByCurrencyResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListTransactionByCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionByCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r BulkUpdateTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DestroyDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DestroyDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DestroyDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ExportAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportBillsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ExportBillsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportBillsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportBudgetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ExportBudgetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportBudgetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ExportCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportPiggiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ExportPiggiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportPiggiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportRecurringResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ExportRecurringResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportRecurringResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ExportRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ExportTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ExportTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PurgeDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r PurgeDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PurgeDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightExpenseAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightGroup
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightExpenseAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightExpenseAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightExpenseBillResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightGroup
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightExpenseBillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightExpenseBillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightExpenseBudgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightGroup
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightExpenseBudgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightExpenseBudgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightExpenseCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightGroup
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightExpenseCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightExpenseCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightExpenseExpenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightGroup
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightExpenseExpenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightExpenseExpenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightExpenseNoBillResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightTotal
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightExpenseNoBillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightExpenseNoBillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightExpenseNoBudgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightTotal
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightExpenseNoBudgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightExpenseNoBudgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightExpenseNoCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightTotal
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightExpenseNoCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightExpenseNoCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightExpenseNoTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightTotal
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightExpenseNoTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightExpenseNoTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightExpenseTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightGroup
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightExpenseTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightExpenseTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightExpenseTotalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightTotal
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightExpenseTotalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightExpenseTotalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightIncomeAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightGroup
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightIncomeAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightIncomeAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightIncomeCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightGroup
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightIncomeCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightIncomeCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightIncomeNoCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightTotal
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightIncomeNoCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightIncomeNoCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightIncomeNoTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightTotal
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightIncomeNoTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightIncomeNoTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightIncomeRevenueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightGroup
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightIncomeRevenueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightIncomeRevenueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightIncomeTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightGroup
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightIncomeTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightIncomeTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightIncomeTotalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightTotal
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightIncomeTotalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightIncomeTotalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightTransfersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightTransfer
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightTransfersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightTransfersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightTransferCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightGroup
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightTransferCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightTransferCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightTransferNoCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightTotal
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightTransferNoCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightTransferNoCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightTransferNoTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightTotal
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightTransferNoTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightTransferNoTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightTransferTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightGroup
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightTransferTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightTransferTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InsightTransferTotalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightTotal
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r InsightTransferTotalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InsightTransferTotalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLinkTypeResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *LinkTypeArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListLinkTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLinkTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreLinkTypeResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *LinkTypeSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreLinkTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreLinkTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLinkTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteLinkTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLinkTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLinkTypeResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *LinkTypeSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetLinkTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLinkTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLinkTypeResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *LinkTypeSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateLinkTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLinkTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionByLinkTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionArray
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListTransactionByLinkTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionByLinkTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListObjectGroupsResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *ObjectGroupArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListObjectGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListObjectGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteObjectGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteObjectGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteObjectGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectGroupResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *ObjectGroupSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetObjectGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateObjectGroupResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *ObjectGroupSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateObjectGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateObjectGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBillByObjectGroupResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BillArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListBillByObjectGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBillByObjectGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPiggyBankByObjectGroupResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *PiggyBankArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListPiggyBankByObjectGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPiggyBankByObjectGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPiggyBankResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *PiggyBankArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListPiggyBankResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPiggyBankResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StorePiggyBankResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *PiggyBankSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StorePiggyBankResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StorePiggyBankResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePiggyBankResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeletePiggyBankResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePiggyBankResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPiggyBankResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *PiggyBankSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetPiggyBankResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPiggyBankResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePiggyBankResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *PiggyBankSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdatePiggyBankResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePiggyBankResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttachmentByPiggyBankResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AttachmentArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListAttachmentByPiggyBankResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttachmentByPiggyBankResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventByPiggyBankResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *PiggyBankEventArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListEventByPiggyBankResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventByPiggyBankResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPreferenceResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *PreferenceArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListPreferenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPreferenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StorePreferenceResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *PreferenceSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StorePreferenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StorePreferenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPreferenceResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *PreferenceSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetPreferenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPreferenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePreferenceResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *PreferenceSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdatePreferenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePreferenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRecurrenceResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RecurrenceArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListRecurrenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRecurrenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreRecurrenceResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RecurrenceSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreRecurrenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreRecurrenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRecurrenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteRecurrenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecurrenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecurrenceResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RecurrenceSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetRecurrenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecurrenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRecurrenceResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RecurrenceSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateRecurrenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRecurrenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionByRecurrenceResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListTransactionByRecurrenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionByRecurrenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRuleGroupResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RuleGroupArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListRuleGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRuleGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreRuleGroupResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RuleGroupSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreRuleGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreRuleGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuleGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteRuleGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuleGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleGroupResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RuleGroupSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetRuleGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRuleGroupResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RuleGroupSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateRuleGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRuleGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRuleByGroupResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RuleArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListRuleByGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRuleByGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestRuleGroupResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r TestRuleGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestRuleGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FireRuleGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r FireRuleGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FireRuleGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRuleResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RuleArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreRuleResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RuleSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RuleSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRuleResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *RuleSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestRuleResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r TestRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FireRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r FireRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FireRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchAccountsResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AccountArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r SearchAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchTransactionsResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r SearchTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBasicSummaryResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *BasicSummary
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetBasicSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBasicSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTagResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TagArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreTagResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TagSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TagSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTagResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TagSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttachmentByTagResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AttachmentArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListAttachmentByTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttachmentByTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionByTagResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListTransactionByTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionByTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTransactionJournalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteTransactionJournalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTransactionJournalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionByJournalResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionByJournalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionByJournalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLinksByJournalResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionLinkArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListLinksByJournalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLinksByJournalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionLinkResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionLinkArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListTransactionLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreTransactionLinkResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionLinkSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreTransactionLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreTransactionLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTransactionLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteTransactionLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTransactionLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionLinkResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionLinkSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTransactionLinkResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionLinkSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateTransactionLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTransactionLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreTransactionResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTransactionResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *TransactionSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttachmentByTransactionResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *AttachmentArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListAttachmentByTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttachmentByTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventByTransactionResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *PiggyBankEventArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListEventByTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventByTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *UserArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreUserResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *UserSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *UserSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *UserSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWebhookResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *WebhookArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r ListWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreWebhookResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *WebhookSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r StoreWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *WebhookSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWebhookResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *WebhookSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON422                  *ValidationErrorResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookMessagesResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *WebhookMessageArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetWebhookMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSingleWebhookMessageResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *WebhookMessageSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetSingleWebhookMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSingleWebhookMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookMessageAttemptsResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *WebhookAttemptArray
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetWebhookMessageAttemptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookMessageAttemptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookMessageAttemptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestResponse
	JSON401      *UnauthenticatedResponse
	JSON404      *NotFoundResponse
	JSON500      *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookMessageAttemptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookMessageAttemptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSingleWebhookMessageAttemptResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *WebhookAttemptSingle
	JSON400                  *BadRequestResponse
	JSON401                  *UnauthenticatedResponse
	JSON404                  *NotFoundResponse
	JSON500                  *InternalExceptionResponse
}

// Status returns HTTPResponse.Status
func (r GetSingleWebhookMessageAttemptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSingleWebhookMessageAttemptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitWebookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SubmitWebookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitWebookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerTransactionWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TriggerTransactionWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerTransactionWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAboutWithResponse request returning *GetAboutResponse
func (c *ClientWithResponses) GetAboutWithResponse(ctx context.Context, params *GetAboutParams, reqEditors ...RequestEditorFn) (*GetAboutResponse, error) {
	rsp, err := c.GetAbout(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAboutResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, params *GetCurrentUserParams, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// ListAccountWithResponse request returning *ListAccountResponse
func (c *ClientWithResponses) ListAccountWithResponse(ctx context.Context, params *ListAccountParams, reqEditors ...RequestEditorFn) (*ListAccountResponse, error) {
	rsp, err := c.ListAccount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccountResponse(rsp)
}

// StoreAccountWithBodyWithResponse request with arbitrary body returning *StoreAccountResponse
func (c *ClientWithResponses) StoreAccountWithBodyWithResponse(ctx context.Context, params *StoreAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreAccountResponse, error) {
	rsp, err := c.StoreAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreAccountResponse(rsp)
}

func (c *ClientWithResponses) StoreAccountWithResponse(ctx context.Context, params *StoreAccountParams, body StoreAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreAccountResponse, error) {
	rsp, err := c.StoreAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreAccountResponse(rsp)
}

func (c *ClientWithResponses) StoreAccountWithFormdataBodyWithResponse(ctx context.Context, params *StoreAccountParams, body StoreAccountFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreAccountResponse, error) {
	rsp, err := c.StoreAccountWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreAccountResponse(rsp)
}

// DeleteAccountWithResponse request returning *DeleteAccountResponse
func (c *ClientWithResponses) DeleteAccountWithResponse(ctx context.Context, id string, params *DeleteAccountParams, reqEditors ...RequestEditorFn) (*DeleteAccountResponse, error) {
	rsp, err := c.DeleteAccount(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccountResponse(rsp)
}

// GetAccountWithResponse request returning *GetAccountResponse
func (c *ClientWithResponses) GetAccountWithResponse(ctx context.Context, id string, params *GetAccountParams, reqEditors ...RequestEditorFn) (*GetAccountResponse, error) {
	rsp, err := c.GetAccount(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountResponse(rsp)
}

// UpdateAccountWithBodyWithResponse request with arbitrary body returning *UpdateAccountResponse
func (c *ClientWithResponses) UpdateAccountWithBodyWithResponse(ctx context.Context, id string, params *UpdateAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccountResponse, error) {
	rsp, err := c.UpdateAccountWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateAccountWithResponse(ctx context.Context, id string, params *UpdateAccountParams, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountResponse, error) {
	rsp, err := c.UpdateAccount(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateAccountWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateAccountParams, body UpdateAccountFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountResponse, error) {
	rsp, err := c.UpdateAccountWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountResponse(rsp)
}

// ListAttachmentByAccountWithResponse request returning *ListAttachmentByAccountResponse
func (c *ClientWithResponses) ListAttachmentByAccountWithResponse(ctx context.Context, id string, params *ListAttachmentByAccountParams, reqEditors ...RequestEditorFn) (*ListAttachmentByAccountResponse, error) {
	rsp, err := c.ListAttachmentByAccount(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttachmentByAccountResponse(rsp)
}

// ListPiggyBankByAccountWithResponse request returning *ListPiggyBankByAccountResponse
func (c *ClientWithResponses) ListPiggyBankByAccountWithResponse(ctx context.Context, id string, params *ListPiggyBankByAccountParams, reqEditors ...RequestEditorFn) (*ListPiggyBankByAccountResponse, error) {
	rsp, err := c.ListPiggyBankByAccount(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPiggyBankByAccountResponse(rsp)
}

// ListTransactionByAccountWithResponse request returning *ListTransactionByAccountResponse
func (c *ClientWithResponses) ListTransactionByAccountWithResponse(ctx context.Context, id string, params *ListTransactionByAccountParams, reqEditors ...RequestEditorFn) (*ListTransactionByAccountResponse, error) {
	rsp, err := c.ListTransactionByAccount(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionByAccountResponse(rsp)
}

// ListAttachmentWithResponse request returning *ListAttachmentResponse
func (c *ClientWithResponses) ListAttachmentWithResponse(ctx context.Context, params *ListAttachmentParams, reqEditors ...RequestEditorFn) (*ListAttachmentResponse, error) {
	rsp, err := c.ListAttachment(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttachmentResponse(rsp)
}

// StoreAttachmentWithBodyWithResponse request with arbitrary body returning *StoreAttachmentResponse
func (c *ClientWithResponses) StoreAttachmentWithBodyWithResponse(ctx context.Context, params *StoreAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreAttachmentResponse, error) {
	rsp, err := c.StoreAttachmentWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreAttachmentResponse(rsp)
}

func (c *ClientWithResponses) StoreAttachmentWithResponse(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreAttachmentResponse, error) {
	rsp, err := c.StoreAttachment(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreAttachmentResponse(rsp)
}

func (c *ClientWithResponses) StoreAttachmentWithFormdataBodyWithResponse(ctx context.Context, params *StoreAttachmentParams, body StoreAttachmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreAttachmentResponse, error) {
	rsp, err := c.StoreAttachmentWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreAttachmentResponse(rsp)
}

// DeleteAttachmentWithResponse request returning *DeleteAttachmentResponse
func (c *ClientWithResponses) DeleteAttachmentWithResponse(ctx context.Context, id string, params *DeleteAttachmentParams, reqEditors ...RequestEditorFn) (*DeleteAttachmentResponse, error) {
	rsp, err := c.DeleteAttachment(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttachmentResponse(rsp)
}

// GetAttachmentWithResponse request returning *GetAttachmentResponse
func (c *ClientWithResponses) GetAttachmentWithResponse(ctx context.Context, id string, params *GetAttachmentParams, reqEditors ...RequestEditorFn) (*GetAttachmentResponse, error) {
	rsp, err := c.GetAttachment(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentResponse(rsp)
}

// UpdateAttachmentWithBodyWithResponse request with arbitrary body returning *UpdateAttachmentResponse
func (c *ClientWithResponses) UpdateAttachmentWithBodyWithResponse(ctx context.Context, id string, params *UpdateAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttachmentResponse, error) {
	rsp, err := c.UpdateAttachmentWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttachmentResponse(rsp)
}

func (c *ClientWithResponses) UpdateAttachmentWithResponse(ctx context.Context, id string, params *UpdateAttachmentParams, body UpdateAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttachmentResponse, error) {
	rsp, err := c.UpdateAttachment(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttachmentResponse(rsp)
}

func (c *ClientWithResponses) UpdateAttachmentWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateAttachmentParams, body UpdateAttachmentFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttachmentResponse, error) {
	rsp, err := c.UpdateAttachmentWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttachmentResponse(rsp)
}

// DownloadAttachmentWithResponse request returning *DownloadAttachmentResponse
func (c *ClientWithResponses) DownloadAttachmentWithResponse(ctx context.Context, id string, params *DownloadAttachmentParams, reqEditors ...RequestEditorFn) (*DownloadAttachmentResponse, error) {
	rsp, err := c.DownloadAttachment(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadAttachmentResponse(rsp)
}

// UploadAttachmentWithBodyWithResponse request with arbitrary body returning *UploadAttachmentResponse
func (c *ClientWithResponses) UploadAttachmentWithBodyWithResponse(ctx context.Context, id string, params *UploadAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadAttachmentResponse, error) {
	rsp, err := c.UploadAttachmentWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadAttachmentResponse(rsp)
}

// GetAccountsACWithResponse request returning *GetAccountsACResponse
func (c *ClientWithResponses) GetAccountsACWithResponse(ctx context.Context, params *GetAccountsACParams, reqEditors ...RequestEditorFn) (*GetAccountsACResponse, error) {
	rsp, err := c.GetAccountsAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountsACResponse(rsp)
}

// GetBillsACWithResponse request returning *GetBillsACResponse
func (c *ClientWithResponses) GetBillsACWithResponse(ctx context.Context, params *GetBillsACParams, reqEditors ...RequestEditorFn) (*GetBillsACResponse, error) {
	rsp, err := c.GetBillsAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillsACResponse(rsp)
}

// GetBudgetsACWithResponse request returning *GetBudgetsACResponse
func (c *ClientWithResponses) GetBudgetsACWithResponse(ctx context.Context, params *GetBudgetsACParams, reqEditors ...RequestEditorFn) (*GetBudgetsACResponse, error) {
	rsp, err := c.GetBudgetsAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBudgetsACResponse(rsp)
}

// GetCategoriesACWithResponse request returning *GetCategoriesACResponse
func (c *ClientWithResponses) GetCategoriesACWithResponse(ctx context.Context, params *GetCategoriesACParams, reqEditors ...RequestEditorFn) (*GetCategoriesACResponse, error) {
	rsp, err := c.GetCategoriesAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoriesACResponse(rsp)
}

// GetCurrenciesACWithResponse request returning *GetCurrenciesACResponse
func (c *ClientWithResponses) GetCurrenciesACWithResponse(ctx context.Context, params *GetCurrenciesACParams, reqEditors ...RequestEditorFn) (*GetCurrenciesACResponse, error) {
	rsp, err := c.GetCurrenciesAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrenciesACResponse(rsp)
}

// GetCurrenciesCodeACWithResponse request returning *GetCurrenciesCodeACResponse
func (c *ClientWithResponses) GetCurrenciesCodeACWithResponse(ctx context.Context, params *GetCurrenciesCodeACParams, reqEditors ...RequestEditorFn) (*GetCurrenciesCodeACResponse, error) {
	rsp, err := c.GetCurrenciesCodeAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrenciesCodeACResponse(rsp)
}

// GetObjectGroupsACWithResponse request returning *GetObjectGroupsACResponse
func (c *ClientWithResponses) GetObjectGroupsACWithResponse(ctx context.Context, params *GetObjectGroupsACParams, reqEditors ...RequestEditorFn) (*GetObjectGroupsACResponse, error) {
	rsp, err := c.GetObjectGroupsAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectGroupsACResponse(rsp)
}

// GetPiggiesACWithResponse request returning *GetPiggiesACResponse
func (c *ClientWithResponses) GetPiggiesACWithResponse(ctx context.Context, params *GetPiggiesACParams, reqEditors ...RequestEditorFn) (*GetPiggiesACResponse, error) {
	rsp, err := c.GetPiggiesAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPiggiesACResponse(rsp)
}

// GetPiggiesBalanceACWithResponse request returning *GetPiggiesBalanceACResponse
func (c *ClientWithResponses) GetPiggiesBalanceACWithResponse(ctx context.Context, params *GetPiggiesBalanceACParams, reqEditors ...RequestEditorFn) (*GetPiggiesBalanceACResponse, error) {
	rsp, err := c.GetPiggiesBalanceAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPiggiesBalanceACResponse(rsp)
}

// GetRecurringACWithResponse request returning *GetRecurringACResponse
func (c *ClientWithResponses) GetRecurringACWithResponse(ctx context.Context, params *GetRecurringACParams, reqEditors ...RequestEditorFn) (*GetRecurringACResponse, error) {
	rsp, err := c.GetRecurringAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecurringACResponse(rsp)
}

// GetRuleGroupsACWithResponse request returning *GetRuleGroupsACResponse
func (c *ClientWithResponses) GetRuleGroupsACWithResponse(ctx context.Context, params *GetRuleGroupsACParams, reqEditors ...RequestEditorFn) (*GetRuleGroupsACResponse, error) {
	rsp, err := c.GetRuleGroupsAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleGroupsACResponse(rsp)
}

// GetRulesACWithResponse request returning *GetRulesACResponse
func (c *ClientWithResponses) GetRulesACWithResponse(ctx context.Context, params *GetRulesACParams, reqEditors ...RequestEditorFn) (*GetRulesACResponse, error) {
	rsp, err := c.GetRulesAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesACResponse(rsp)
}

// GetTagACWithResponse request returning *GetTagACResponse
func (c *ClientWithResponses) GetTagACWithResponse(ctx context.Context, params *GetTagACParams, reqEditors ...RequestEditorFn) (*GetTagACResponse, error) {
	rsp, err := c.GetTagAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagACResponse(rsp)
}

// GetTransactionTypesACWithResponse request returning *GetTransactionTypesACResponse
func (c *ClientWithResponses) GetTransactionTypesACWithResponse(ctx context.Context, params *GetTransactionTypesACParams, reqEditors ...RequestEditorFn) (*GetTransactionTypesACResponse, error) {
	rsp, err := c.GetTransactionTypesAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionTypesACResponse(rsp)
}

// GetTransactionsACWithResponse request returning *GetTransactionsACResponse
func (c *ClientWithResponses) GetTransactionsACWithResponse(ctx context.Context, params *GetTransactionsACParams, reqEditors ...RequestEditorFn) (*GetTransactionsACResponse, error) {
	rsp, err := c.GetTransactionsAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsACResponse(rsp)
}

// GetTransactionsIDACWithResponse request returning *GetTransactionsIDACResponse
func (c *ClientWithResponses) GetTransactionsIDACWithResponse(ctx context.Context, params *GetTransactionsIDACParams, reqEditors ...RequestEditorFn) (*GetTransactionsIDACResponse, error) {
	rsp, err := c.GetTransactionsIDAC(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsIDACResponse(rsp)
}

// ListAvailableBudgetWithResponse request returning *ListAvailableBudgetResponse
func (c *ClientWithResponses) ListAvailableBudgetWithResponse(ctx context.Context, params *ListAvailableBudgetParams, reqEditors ...RequestEditorFn) (*ListAvailableBudgetResponse, error) {
	rsp, err := c.ListAvailableBudget(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableBudgetResponse(rsp)
}

// GetAvailableBudgetWithResponse request returning *GetAvailableBudgetResponse
func (c *ClientWithResponses) GetAvailableBudgetWithResponse(ctx context.Context, id string, params *GetAvailableBudgetParams, reqEditors ...RequestEditorFn) (*GetAvailableBudgetResponse, error) {
	rsp, err := c.GetAvailableBudget(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvailableBudgetResponse(rsp)
}

// ListBillWithResponse request returning *ListBillResponse
func (c *ClientWithResponses) ListBillWithResponse(ctx context.Context, params *ListBillParams, reqEditors ...RequestEditorFn) (*ListBillResponse, error) {
	rsp, err := c.ListBill(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillResponse(rsp)
}

// StoreBillWithBodyWithResponse request with arbitrary body returning *StoreBillResponse
func (c *ClientWithResponses) StoreBillWithBodyWithResponse(ctx context.Context, params *StoreBillParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreBillResponse, error) {
	rsp, err := c.StoreBillWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreBillResponse(rsp)
}

func (c *ClientWithResponses) StoreBillWithResponse(ctx context.Context, params *StoreBillParams, body StoreBillJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreBillResponse, error) {
	rsp, err := c.StoreBill(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreBillResponse(rsp)
}

func (c *ClientWithResponses) StoreBillWithFormdataBodyWithResponse(ctx context.Context, params *StoreBillParams, body StoreBillFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreBillResponse, error) {
	rsp, err := c.StoreBillWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreBillResponse(rsp)
}

// DeleteBillWithResponse request returning *DeleteBillResponse
func (c *ClientWithResponses) DeleteBillWithResponse(ctx context.Context, id string, params *DeleteBillParams, reqEditors ...RequestEditorFn) (*DeleteBillResponse, error) {
	rsp, err := c.DeleteBill(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBillResponse(rsp)
}

// GetBillWithResponse request returning *GetBillResponse
func (c *ClientWithResponses) GetBillWithResponse(ctx context.Context, id string, params *GetBillParams, reqEditors ...RequestEditorFn) (*GetBillResponse, error) {
	rsp, err := c.GetBill(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillResponse(rsp)
}

// UpdateBillWithBodyWithResponse request with arbitrary body returning *UpdateBillResponse
func (c *ClientWithResponses) UpdateBillWithBodyWithResponse(ctx context.Context, id string, params *UpdateBillParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBillResponse, error) {
	rsp, err := c.UpdateBillWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBillResponse(rsp)
}

func (c *ClientWithResponses) UpdateBillWithResponse(ctx context.Context, id string, params *UpdateBillParams, body UpdateBillJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBillResponse, error) {
	rsp, err := c.UpdateBill(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBillResponse(rsp)
}

func (c *ClientWithResponses) UpdateBillWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateBillParams, body UpdateBillFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateBillResponse, error) {
	rsp, err := c.UpdateBillWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBillResponse(rsp)
}

// ListAttachmentByBillWithResponse request returning *ListAttachmentByBillResponse
func (c *ClientWithResponses) ListAttachmentByBillWithResponse(ctx context.Context, id string, params *ListAttachmentByBillParams, reqEditors ...RequestEditorFn) (*ListAttachmentByBillResponse, error) {
	rsp, err := c.ListAttachmentByBill(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttachmentByBillResponse(rsp)
}

// ListRuleByBillWithResponse request returning *ListRuleByBillResponse
func (c *ClientWithResponses) ListRuleByBillWithResponse(ctx context.Context, id string, params *ListRuleByBillParams, reqEditors ...RequestEditorFn) (*ListRuleByBillResponse, error) {
	rsp, err := c.ListRuleByBill(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRuleByBillResponse(rsp)
}

// ListTransactionByBillWithResponse request returning *ListTransactionByBillResponse
func (c *ClientWithResponses) ListTransactionByBillWithResponse(ctx context.Context, id string, params *ListTransactionByBillParams, reqEditors ...RequestEditorFn) (*ListTransactionByBillResponse, error) {
	rsp, err := c.ListTransactionByBill(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionByBillResponse(rsp)
}

// ListBudgetLimitWithResponse request returning *ListBudgetLimitResponse
func (c *ClientWithResponses) ListBudgetLimitWithResponse(ctx context.Context, params *ListBudgetLimitParams, reqEditors ...RequestEditorFn) (*ListBudgetLimitResponse, error) {
	rsp, err := c.ListBudgetLimit(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBudgetLimitResponse(rsp)
}

// ListBudgetWithResponse request returning *ListBudgetResponse
func (c *ClientWithResponses) ListBudgetWithResponse(ctx context.Context, params *ListBudgetParams, reqEditors ...RequestEditorFn) (*ListBudgetResponse, error) {
	rsp, err := c.ListBudget(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBudgetResponse(rsp)
}

// StoreBudgetWithBodyWithResponse request with arbitrary body returning *StoreBudgetResponse
func (c *ClientWithResponses) StoreBudgetWithBodyWithResponse(ctx context.Context, params *StoreBudgetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreBudgetResponse, error) {
	rsp, err := c.StoreBudgetWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreBudgetResponse(rsp)
}

func (c *ClientWithResponses) StoreBudgetWithResponse(ctx context.Context, params *StoreBudgetParams, body StoreBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreBudgetResponse, error) {
	rsp, err := c.StoreBudget(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreBudgetResponse(rsp)
}

func (c *ClientWithResponses) StoreBudgetWithFormdataBodyWithResponse(ctx context.Context, params *StoreBudgetParams, body StoreBudgetFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreBudgetResponse, error) {
	rsp, err := c.StoreBudgetWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreBudgetResponse(rsp)
}

// DeleteBudgetWithResponse request returning *DeleteBudgetResponse
func (c *ClientWithResponses) DeleteBudgetWithResponse(ctx context.Context, id string, params *DeleteBudgetParams, reqEditors ...RequestEditorFn) (*DeleteBudgetResponse, error) {
	rsp, err := c.DeleteBudget(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBudgetResponse(rsp)
}

// GetBudgetWithResponse request returning *GetBudgetResponse
func (c *ClientWithResponses) GetBudgetWithResponse(ctx context.Context, id string, params *GetBudgetParams, reqEditors ...RequestEditorFn) (*GetBudgetResponse, error) {
	rsp, err := c.GetBudget(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBudgetResponse(rsp)
}

// UpdateBudgetWithBodyWithResponse request with arbitrary body returning *UpdateBudgetResponse
func (c *ClientWithResponses) UpdateBudgetWithBodyWithResponse(ctx context.Context, id string, params *UpdateBudgetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBudgetResponse, error) {
	rsp, err := c.UpdateBudgetWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBudgetResponse(rsp)
}

func (c *ClientWithResponses) UpdateBudgetWithResponse(ctx context.Context, id string, params *UpdateBudgetParams, body UpdateBudgetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBudgetResponse, error) {
	rsp, err := c.UpdateBudget(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBudgetResponse(rsp)
}

func (c *ClientWithResponses) UpdateBudgetWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateBudgetParams, body UpdateBudgetFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateBudgetResponse, error) {
	rsp, err := c.UpdateBudgetWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBudgetResponse(rsp)
}

// ListAttachmentByBudgetWithResponse request returning *ListAttachmentByBudgetResponse
func (c *ClientWithResponses) ListAttachmentByBudgetWithResponse(ctx context.Context, id string, params *ListAttachmentByBudgetParams, reqEditors ...RequestEditorFn) (*ListAttachmentByBudgetResponse, error) {
	rsp, err := c.ListAttachmentByBudget(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttachmentByBudgetResponse(rsp)
}

// ListBudgetLimitByBudgetWithResponse request returning *ListBudgetLimitByBudgetResponse
func (c *ClientWithResponses) ListBudgetLimitByBudgetWithResponse(ctx context.Context, id string, params *ListBudgetLimitByBudgetParams, reqEditors ...RequestEditorFn) (*ListBudgetLimitByBudgetResponse, error) {
	rsp, err := c.ListBudgetLimitByBudget(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBudgetLimitByBudgetResponse(rsp)
}

// StoreBudgetLimitWithBodyWithResponse request with arbitrary body returning *StoreBudgetLimitResponse
func (c *ClientWithResponses) StoreBudgetLimitWithBodyWithResponse(ctx context.Context, id string, params *StoreBudgetLimitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreBudgetLimitResponse, error) {
	rsp, err := c.StoreBudgetLimitWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreBudgetLimitResponse(rsp)
}

func (c *ClientWithResponses) StoreBudgetLimitWithResponse(ctx context.Context, id string, params *StoreBudgetLimitParams, body StoreBudgetLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreBudgetLimitResponse, error) {
	rsp, err := c.StoreBudgetLimit(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreBudgetLimitResponse(rsp)
}

func (c *ClientWithResponses) StoreBudgetLimitWithFormdataBodyWithResponse(ctx context.Context, id string, params *StoreBudgetLimitParams, body StoreBudgetLimitFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreBudgetLimitResponse, error) {
	rsp, err := c.StoreBudgetLimitWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreBudgetLimitResponse(rsp)
}

// DeleteBudgetLimitWithResponse request returning *DeleteBudgetLimitResponse
func (c *ClientWithResponses) DeleteBudgetLimitWithResponse(ctx context.Context, id string, limitId string, params *DeleteBudgetLimitParams, reqEditors ...RequestEditorFn) (*DeleteBudgetLimitResponse, error) {
	rsp, err := c.DeleteBudgetLimit(ctx, id, limitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBudgetLimitResponse(rsp)
}

// GetBudgetLimitWithResponse request returning *GetBudgetLimitResponse
func (c *ClientWithResponses) GetBudgetLimitWithResponse(ctx context.Context, id string, limitId int, params *GetBudgetLimitParams, reqEditors ...RequestEditorFn) (*GetBudgetLimitResponse, error) {
	rsp, err := c.GetBudgetLimit(ctx, id, limitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBudgetLimitResponse(rsp)
}

// UpdateBudgetLimitWithBodyWithResponse request with arbitrary body returning *UpdateBudgetLimitResponse
func (c *ClientWithResponses) UpdateBudgetLimitWithBodyWithResponse(ctx context.Context, id string, limitId string, params *UpdateBudgetLimitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBudgetLimitResponse, error) {
	rsp, err := c.UpdateBudgetLimitWithBody(ctx, id, limitId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBudgetLimitResponse(rsp)
}

func (c *ClientWithResponses) UpdateBudgetLimitWithResponse(ctx context.Context, id string, limitId string, params *UpdateBudgetLimitParams, body UpdateBudgetLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBudgetLimitResponse, error) {
	rsp, err := c.UpdateBudgetLimit(ctx, id, limitId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBudgetLimitResponse(rsp)
}

func (c *ClientWithResponses) UpdateBudgetLimitWithFormdataBodyWithResponse(ctx context.Context, id string, limitId string, params *UpdateBudgetLimitParams, body UpdateBudgetLimitFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateBudgetLimitResponse, error) {
	rsp, err := c.UpdateBudgetLimitWithFormdataBody(ctx, id, limitId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBudgetLimitResponse(rsp)
}

// ListTransactionByBudgetLimitWithResponse request returning *ListTransactionByBudgetLimitResponse
func (c *ClientWithResponses) ListTransactionByBudgetLimitWithResponse(ctx context.Context, id string, limitId string, params *ListTransactionByBudgetLimitParams, reqEditors ...RequestEditorFn) (*ListTransactionByBudgetLimitResponse, error) {
	rsp, err := c.ListTransactionByBudgetLimit(ctx, id, limitId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionByBudgetLimitResponse(rsp)
}

// ListTransactionByBudgetWithResponse request returning *ListTransactionByBudgetResponse
func (c *ClientWithResponses) ListTransactionByBudgetWithResponse(ctx context.Context, id string, params *ListTransactionByBudgetParams, reqEditors ...RequestEditorFn) (*ListTransactionByBudgetResponse, error) {
	rsp, err := c.ListTransactionByBudget(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionByBudgetResponse(rsp)
}

// ListCategoryWithResponse request returning *ListCategoryResponse
func (c *ClientWithResponses) ListCategoryWithResponse(ctx context.Context, params *ListCategoryParams, reqEditors ...RequestEditorFn) (*ListCategoryResponse, error) {
	rsp, err := c.ListCategory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCategoryResponse(rsp)
}

// StoreCategoryWithBodyWithResponse request with arbitrary body returning *StoreCategoryResponse
func (c *ClientWithResponses) StoreCategoryWithBodyWithResponse(ctx context.Context, params *StoreCategoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCategoryResponse, error) {
	rsp, err := c.StoreCategoryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCategoryResponse(rsp)
}

func (c *ClientWithResponses) StoreCategoryWithResponse(ctx context.Context, params *StoreCategoryParams, body StoreCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCategoryResponse, error) {
	rsp, err := c.StoreCategory(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCategoryResponse(rsp)
}

func (c *ClientWithResponses) StoreCategoryWithFormdataBodyWithResponse(ctx context.Context, params *StoreCategoryParams, body StoreCategoryFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreCategoryResponse, error) {
	rsp, err := c.StoreCategoryWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCategoryResponse(rsp)
}

// DeleteCategoryWithResponse request returning *DeleteCategoryResponse
func (c *ClientWithResponses) DeleteCategoryWithResponse(ctx context.Context, id string, params *DeleteCategoryParams, reqEditors ...RequestEditorFn) (*DeleteCategoryResponse, error) {
	rsp, err := c.DeleteCategory(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCategoryResponse(rsp)
}

// GetCategoryWithResponse request returning *GetCategoryResponse
func (c *ClientWithResponses) GetCategoryWithResponse(ctx context.Context, id string, params *GetCategoryParams, reqEditors ...RequestEditorFn) (*GetCategoryResponse, error) {
	rsp, err := c.GetCategory(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoryResponse(rsp)
}

// UpdateCategoryWithBodyWithResponse request with arbitrary body returning *UpdateCategoryResponse
func (c *ClientWithResponses) UpdateCategoryWithBodyWithResponse(ctx context.Context, id string, params *UpdateCategoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCategoryResponse, error) {
	rsp, err := c.UpdateCategoryWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCategoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateCategoryWithResponse(ctx context.Context, id string, params *UpdateCategoryParams, body UpdateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCategoryResponse, error) {
	rsp, err := c.UpdateCategory(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCategoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateCategoryWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateCategoryParams, body UpdateCategoryFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateCategoryResponse, error) {
	rsp, err := c.UpdateCategoryWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCategoryResponse(rsp)
}

// ListAttachmentByCategoryWithResponse request returning *ListAttachmentByCategoryResponse
func (c *ClientWithResponses) ListAttachmentByCategoryWithResponse(ctx context.Context, id string, params *ListAttachmentByCategoryParams, reqEditors ...RequestEditorFn) (*ListAttachmentByCategoryResponse, error) {
	rsp, err := c.ListAttachmentByCategory(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttachmentByCategoryResponse(rsp)
}

// ListTransactionByCategoryWithResponse request returning *ListTransactionByCategoryResponse
func (c *ClientWithResponses) ListTransactionByCategoryWithResponse(ctx context.Context, id string, params *ListTransactionByCategoryParams, reqEditors ...RequestEditorFn) (*ListTransactionByCategoryResponse, error) {
	rsp, err := c.ListTransactionByCategory(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionByCategoryResponse(rsp)
}

// GetChartAccountOverviewWithResponse request returning *GetChartAccountOverviewResponse
func (c *ClientWithResponses) GetChartAccountOverviewWithResponse(ctx context.Context, params *GetChartAccountOverviewParams, reqEditors ...RequestEditorFn) (*GetChartAccountOverviewResponse, error) {
	rsp, err := c.GetChartAccountOverview(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChartAccountOverviewResponse(rsp)
}

// GetConfigurationWithResponse request returning *GetConfigurationResponse
func (c *ClientWithResponses) GetConfigurationWithResponse(ctx context.Context, params *GetConfigurationParams, reqEditors ...RequestEditorFn) (*GetConfigurationResponse, error) {
	rsp, err := c.GetConfiguration(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationResponse(rsp)
}

// GetSingleConfigurationWithResponse request returning *GetSingleConfigurationResponse
func (c *ClientWithResponses) GetSingleConfigurationWithResponse(ctx context.Context, name ConfigValueFilter, params *GetSingleConfigurationParams, reqEditors ...RequestEditorFn) (*GetSingleConfigurationResponse, error) {
	rsp, err := c.GetSingleConfiguration(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSingleConfigurationResponse(rsp)
}

// SetConfigurationWithBodyWithResponse request with arbitrary body returning *SetConfigurationResponse
func (c *ClientWithResponses) SetConfigurationWithBodyWithResponse(ctx context.Context, name ConfigValueUpdateFilter, params *SetConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetConfigurationResponse, error) {
	rsp, err := c.SetConfigurationWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetConfigurationResponse(rsp)
}

func (c *ClientWithResponses) SetConfigurationWithResponse(ctx context.Context, name ConfigValueUpdateFilter, params *SetConfigurationParams, body SetConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetConfigurationResponse, error) {
	rsp, err := c.SetConfiguration(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetConfigurationResponse(rsp)
}

func (c *ClientWithResponses) SetConfigurationWithFormdataBodyWithResponse(ctx context.Context, name ConfigValueUpdateFilter, params *SetConfigurationParams, body SetConfigurationFormdataRequestBody, reqEditors ...RequestEditorFn) (*SetConfigurationResponse, error) {
	rsp, err := c.SetConfigurationWithFormdataBody(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetConfigurationResponse(rsp)
}

// GetCronWithResponse request returning *GetCronResponse
func (c *ClientWithResponses) GetCronWithResponse(ctx context.Context, cliToken string, params *GetCronParams, reqEditors ...RequestEditorFn) (*GetCronResponse, error) {
	rsp, err := c.GetCron(ctx, cliToken, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCronResponse(rsp)
}

// ListCurrencyWithResponse request returning *ListCurrencyResponse
func (c *ClientWithResponses) ListCurrencyWithResponse(ctx context.Context, params *ListCurrencyParams, reqEditors ...RequestEditorFn) (*ListCurrencyResponse, error) {
	rsp, err := c.ListCurrency(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCurrencyResponse(rsp)
}

// StoreCurrencyWithBodyWithResponse request with arbitrary body returning *StoreCurrencyResponse
func (c *ClientWithResponses) StoreCurrencyWithBodyWithResponse(ctx context.Context, params *StoreCurrencyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCurrencyResponse, error) {
	rsp, err := c.StoreCurrencyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCurrencyResponse(rsp)
}

func (c *ClientWithResponses) StoreCurrencyWithResponse(ctx context.Context, params *StoreCurrencyParams, body StoreCurrencyJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCurrencyResponse, error) {
	rsp, err := c.StoreCurrency(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCurrencyResponse(rsp)
}

func (c *ClientWithResponses) StoreCurrencyWithFormdataBodyWithResponse(ctx context.Context, params *StoreCurrencyParams, body StoreCurrencyFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreCurrencyResponse, error) {
	rsp, err := c.StoreCurrencyWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCurrencyResponse(rsp)
}

// GetDefaultCurrencyWithResponse request returning *GetDefaultCurrencyResponse
func (c *ClientWithResponses) GetDefaultCurrencyWithResponse(ctx context.Context, params *GetDefaultCurrencyParams, reqEditors ...RequestEditorFn) (*GetDefaultCurrencyResponse, error) {
	rsp, err := c.GetDefaultCurrency(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultCurrencyResponse(rsp)
}

// DeleteCurrencyWithResponse request returning *DeleteCurrencyResponse
func (c *ClientWithResponses) DeleteCurrencyWithResponse(ctx context.Context, code string, params *DeleteCurrencyParams, reqEditors ...RequestEditorFn) (*DeleteCurrencyResponse, error) {
	rsp, err := c.DeleteCurrency(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCurrencyResponse(rsp)
}

// GetCurrencyWithResponse request returning *GetCurrencyResponse
func (c *ClientWithResponses) GetCurrencyWithResponse(ctx context.Context, code string, params *GetCurrencyParams, reqEditors ...RequestEditorFn) (*GetCurrencyResponse, error) {
	rsp, err := c.GetCurrency(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrencyResponse(rsp)
}

// UpdateCurrencyWithBodyWithResponse request with arbitrary body returning *UpdateCurrencyResponse
func (c *ClientWithResponses) UpdateCurrencyWithBodyWithResponse(ctx context.Context, code string, params *UpdateCurrencyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCurrencyResponse, error) {
	rsp, err := c.UpdateCurrencyWithBody(ctx, code, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCurrencyResponse(rsp)
}

func (c *ClientWithResponses) UpdateCurrencyWithApplicationVndAPIPlusJSONBodyWithResponse(ctx context.Context, code string, params *UpdateCurrencyParams, body UpdateCurrencyApplicationVndAPIPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCurrencyResponse, error) {
	rsp, err := c.UpdateCurrencyWithApplicationVndAPIPlusJSONBody(ctx, code, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCurrencyResponse(rsp)
}

func (c *ClientWithResponses) UpdateCurrencyWithFormdataBodyWithResponse(ctx context.Context, code string, params *UpdateCurrencyParams, body UpdateCurrencyFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateCurrencyResponse, error) {
	rsp, err := c.UpdateCurrencyWithFormdataBody(ctx, code, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCurrencyResponse(rsp)
}

// ListAccountByCurrencyWithResponse request returning *ListAccountByCurrencyResponse
func (c *ClientWithResponses) ListAccountByCurrencyWithResponse(ctx context.Context, code string, params *ListAccountByCurrencyParams, reqEditors ...RequestEditorFn) (*ListAccountByCurrencyResponse, error) {
	rsp, err := c.ListAccountByCurrency(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccountByCurrencyResponse(rsp)
}

// ListAvailableBudgetByCurrencyWithResponse request returning *ListAvailableBudgetByCurrencyResponse
func (c *ClientWithResponses) ListAvailableBudgetByCurrencyWithResponse(ctx context.Context, code string, params *ListAvailableBudgetByCurrencyParams, reqEditors ...RequestEditorFn) (*ListAvailableBudgetByCurrencyResponse, error) {
	rsp, err := c.ListAvailableBudgetByCurrency(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableBudgetByCurrencyResponse(rsp)
}

// ListBillByCurrencyWithResponse request returning *ListBillByCurrencyResponse
func (c *ClientWithResponses) ListBillByCurrencyWithResponse(ctx context.Context, code string, params *ListBillByCurrencyParams, reqEditors ...RequestEditorFn) (*ListBillByCurrencyResponse, error) {
	rsp, err := c.ListBillByCurrency(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillByCurrencyResponse(rsp)
}

// ListBudgetLimitByCurrencyWithResponse request returning *ListBudgetLimitByCurrencyResponse
func (c *ClientWithResponses) ListBudgetLimitByCurrencyWithResponse(ctx context.Context, code string, params *ListBudgetLimitByCurrencyParams, reqEditors ...RequestEditorFn) (*ListBudgetLimitByCurrencyResponse, error) {
	rsp, err := c.ListBudgetLimitByCurrency(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBudgetLimitByCurrencyResponse(rsp)
}

// DefaultCurrencyWithResponse request returning *DefaultCurrencyResponse
func (c *ClientWithResponses) DefaultCurrencyWithResponse(ctx context.Context, code string, params *DefaultCurrencyParams, reqEditors ...RequestEditorFn) (*DefaultCurrencyResponse, error) {
	rsp, err := c.DefaultCurrency(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDefaultCurrencyResponse(rsp)
}

// DisableCurrencyWithResponse request returning *DisableCurrencyResponse
func (c *ClientWithResponses) DisableCurrencyWithResponse(ctx context.Context, code string, params *DisableCurrencyParams, reqEditors ...RequestEditorFn) (*DisableCurrencyResponse, error) {
	rsp, err := c.DisableCurrency(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableCurrencyResponse(rsp)
}

// EnableCurrencyWithResponse request returning *EnableCurrencyResponse
func (c *ClientWithResponses) EnableCurrencyWithResponse(ctx context.Context, code string, params *EnableCurrencyParams, reqEditors ...RequestEditorFn) (*EnableCurrencyResponse, error) {
	rsp, err := c.EnableCurrency(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableCurrencyResponse(rsp)
}

// ListRecurrenceByCurrencyWithResponse request returning *ListRecurrenceByCurrencyResponse
func (c *ClientWithResponses) ListRecurrenceByCurrencyWithResponse(ctx context.Context, code string, params *ListRecurrenceByCurrencyParams, reqEditors ...RequestEditorFn) (*ListRecurrenceByCurrencyResponse, error) {
	rsp, err := c.ListRecurrenceByCurrency(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRecurrenceByCurrencyResponse(rsp)
}

// ListRuleByCurrencyWithResponse request returning *ListRuleByCurrencyResponse
func (c *ClientWithResponses) ListRuleByCurrencyWithResponse(ctx context.Context, code string, params *ListRuleByCurrencyParams, reqEditors ...RequestEditorFn) (*ListRuleByCurrencyResponse, error) {
	rsp, err := c.ListRuleByCurrency(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRuleByCurrencyResponse(rsp)
}

// ListTransactionByCurrencyWithResponse request returning *ListTransactionByCurrencyResponse
func (c *ClientWithResponses) ListTransactionByCurrencyWithResponse(ctx context.Context, code string, params *ListTransactionByCurrencyParams, reqEditors ...RequestEditorFn) (*ListTransactionByCurrencyResponse, error) {
	rsp, err := c.ListTransactionByCurrency(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionByCurrencyResponse(rsp)
}

// BulkUpdateTransactionsWithResponse request returning *BulkUpdateTransactionsResponse
func (c *ClientWithResponses) BulkUpdateTransactionsWithResponse(ctx context.Context, params *BulkUpdateTransactionsParams, reqEditors ...RequestEditorFn) (*BulkUpdateTransactionsResponse, error) {
	rsp, err := c.BulkUpdateTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateTransactionsResponse(rsp)
}

// DestroyDataWithResponse request returning *DestroyDataResponse
func (c *ClientWithResponses) DestroyDataWithResponse(ctx context.Context, params *DestroyDataParams, reqEditors ...RequestEditorFn) (*DestroyDataResponse, error) {
	rsp, err := c.DestroyData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDestroyDataResponse(rsp)
}

// ExportAccountsWithResponse request returning *ExportAccountsResponse
func (c *ClientWithResponses) ExportAccountsWithResponse(ctx context.Context, params *ExportAccountsParams, reqEditors ...RequestEditorFn) (*ExportAccountsResponse, error) {
	rsp, err := c.ExportAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportAccountsResponse(rsp)
}

// ExportBillsWithResponse request returning *ExportBillsResponse
func (c *ClientWithResponses) ExportBillsWithResponse(ctx context.Context, params *ExportBillsParams, reqEditors ...RequestEditorFn) (*ExportBillsResponse, error) {
	rsp, err := c.ExportBills(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportBillsResponse(rsp)
}

// ExportBudgetsWithResponse request returning *ExportBudgetsResponse
func (c *ClientWithResponses) ExportBudgetsWithResponse(ctx context.Context, params *ExportBudgetsParams, reqEditors ...RequestEditorFn) (*ExportBudgetsResponse, error) {
	rsp, err := c.ExportBudgets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportBudgetsResponse(rsp)
}

// ExportCategoriesWithResponse request returning *ExportCategoriesResponse
func (c *ClientWithResponses) ExportCategoriesWithResponse(ctx context.Context, params *ExportCategoriesParams, reqEditors ...RequestEditorFn) (*ExportCategoriesResponse, error) {
	rsp, err := c.ExportCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportCategoriesResponse(rsp)
}

// ExportPiggiesWithResponse request returning *ExportPiggiesResponse
func (c *ClientWithResponses) ExportPiggiesWithResponse(ctx context.Context, params *ExportPiggiesParams, reqEditors ...RequestEditorFn) (*ExportPiggiesResponse, error) {
	rsp, err := c.ExportPiggies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportPiggiesResponse(rsp)
}

// ExportRecurringWithResponse request returning *ExportRecurringResponse
func (c *ClientWithResponses) ExportRecurringWithResponse(ctx context.Context, params *ExportRecurringParams, reqEditors ...RequestEditorFn) (*ExportRecurringResponse, error) {
	rsp, err := c.ExportRecurring(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportRecurringResponse(rsp)
}

// ExportRulesWithResponse request returning *ExportRulesResponse
func (c *ClientWithResponses) ExportRulesWithResponse(ctx context.Context, params *ExportRulesParams, reqEditors ...RequestEditorFn) (*ExportRulesResponse, error) {
	rsp, err := c.ExportRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportRulesResponse(rsp)
}

// ExportTagsWithResponse request returning *ExportTagsResponse
func (c *ClientWithResponses) ExportTagsWithResponse(ctx context.Context, params *ExportTagsParams, reqEditors ...RequestEditorFn) (*ExportTagsResponse, error) {
	rsp, err := c.ExportTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportTagsResponse(rsp)
}

// ExportTransactionsWithResponse request returning *ExportTransactionsResponse
func (c *ClientWithResponses) ExportTransactionsWithResponse(ctx context.Context, params *ExportTransactionsParams, reqEditors ...RequestEditorFn) (*ExportTransactionsResponse, error) {
	rsp, err := c.ExportTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportTransactionsResponse(rsp)
}

// PurgeDataWithResponse request returning *PurgeDataResponse
func (c *ClientWithResponses) PurgeDataWithResponse(ctx context.Context, params *PurgeDataParams, reqEditors ...RequestEditorFn) (*PurgeDataResponse, error) {
	rsp, err := c.PurgeData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgeDataResponse(rsp)
}

// InsightExpenseAssetWithResponse request returning *InsightExpenseAssetResponse
func (c *ClientWithResponses) InsightExpenseAssetWithResponse(ctx context.Context, params *InsightExpenseAssetParams, reqEditors ...RequestEditorFn) (*InsightExpenseAssetResponse, error) {
	rsp, err := c.InsightExpenseAsset(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightExpenseAssetResponse(rsp)
}

// InsightExpenseBillWithResponse request returning *InsightExpenseBillResponse
func (c *ClientWithResponses) InsightExpenseBillWithResponse(ctx context.Context, params *InsightExpenseBillParams, reqEditors ...RequestEditorFn) (*InsightExpenseBillResponse, error) {
	rsp, err := c.InsightExpenseBill(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightExpenseBillResponse(rsp)
}

// InsightExpenseBudgetWithResponse request returning *InsightExpenseBudgetResponse
func (c *ClientWithResponses) InsightExpenseBudgetWithResponse(ctx context.Context, params *InsightExpenseBudgetParams, reqEditors ...RequestEditorFn) (*InsightExpenseBudgetResponse, error) {
	rsp, err := c.InsightExpenseBudget(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightExpenseBudgetResponse(rsp)
}

// InsightExpenseCategoryWithResponse request returning *InsightExpenseCategoryResponse
func (c *ClientWithResponses) InsightExpenseCategoryWithResponse(ctx context.Context, params *InsightExpenseCategoryParams, reqEditors ...RequestEditorFn) (*InsightExpenseCategoryResponse, error) {
	rsp, err := c.InsightExpenseCategory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightExpenseCategoryResponse(rsp)
}

// InsightExpenseExpenseWithResponse request returning *InsightExpenseExpenseResponse
func (c *ClientWithResponses) InsightExpenseExpenseWithResponse(ctx context.Context, params *InsightExpenseExpenseParams, reqEditors ...RequestEditorFn) (*InsightExpenseExpenseResponse, error) {
	rsp, err := c.InsightExpenseExpense(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightExpenseExpenseResponse(rsp)
}

// InsightExpenseNoBillWithResponse request returning *InsightExpenseNoBillResponse
func (c *ClientWithResponses) InsightExpenseNoBillWithResponse(ctx context.Context, params *InsightExpenseNoBillParams, reqEditors ...RequestEditorFn) (*InsightExpenseNoBillResponse, error) {
	rsp, err := c.InsightExpenseNoBill(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightExpenseNoBillResponse(rsp)
}

// InsightExpenseNoBudgetWithResponse request returning *InsightExpenseNoBudgetResponse
func (c *ClientWithResponses) InsightExpenseNoBudgetWithResponse(ctx context.Context, params *InsightExpenseNoBudgetParams, reqEditors ...RequestEditorFn) (*InsightExpenseNoBudgetResponse, error) {
	rsp, err := c.InsightExpenseNoBudget(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightExpenseNoBudgetResponse(rsp)
}

// InsightExpenseNoCategoryWithResponse request returning *InsightExpenseNoCategoryResponse
func (c *ClientWithResponses) InsightExpenseNoCategoryWithResponse(ctx context.Context, params *InsightExpenseNoCategoryParams, reqEditors ...RequestEditorFn) (*InsightExpenseNoCategoryResponse, error) {
	rsp, err := c.InsightExpenseNoCategory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightExpenseNoCategoryResponse(rsp)
}

// InsightExpenseNoTagWithResponse request returning *InsightExpenseNoTagResponse
func (c *ClientWithResponses) InsightExpenseNoTagWithResponse(ctx context.Context, params *InsightExpenseNoTagParams, reqEditors ...RequestEditorFn) (*InsightExpenseNoTagResponse, error) {
	rsp, err := c.InsightExpenseNoTag(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightExpenseNoTagResponse(rsp)
}

// InsightExpenseTagWithResponse request returning *InsightExpenseTagResponse
func (c *ClientWithResponses) InsightExpenseTagWithResponse(ctx context.Context, params *InsightExpenseTagParams, reqEditors ...RequestEditorFn) (*InsightExpenseTagResponse, error) {
	rsp, err := c.InsightExpenseTag(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightExpenseTagResponse(rsp)
}

// InsightExpenseTotalWithResponse request returning *InsightExpenseTotalResponse
func (c *ClientWithResponses) InsightExpenseTotalWithResponse(ctx context.Context, params *InsightExpenseTotalParams, reqEditors ...RequestEditorFn) (*InsightExpenseTotalResponse, error) {
	rsp, err := c.InsightExpenseTotal(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightExpenseTotalResponse(rsp)
}

// InsightIncomeAssetWithResponse request returning *InsightIncomeAssetResponse
func (c *ClientWithResponses) InsightIncomeAssetWithResponse(ctx context.Context, params *InsightIncomeAssetParams, reqEditors ...RequestEditorFn) (*InsightIncomeAssetResponse, error) {
	rsp, err := c.InsightIncomeAsset(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightIncomeAssetResponse(rsp)
}

// InsightIncomeCategoryWithResponse request returning *InsightIncomeCategoryResponse
func (c *ClientWithResponses) InsightIncomeCategoryWithResponse(ctx context.Context, params *InsightIncomeCategoryParams, reqEditors ...RequestEditorFn) (*InsightIncomeCategoryResponse, error) {
	rsp, err := c.InsightIncomeCategory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightIncomeCategoryResponse(rsp)
}

// InsightIncomeNoCategoryWithResponse request returning *InsightIncomeNoCategoryResponse
func (c *ClientWithResponses) InsightIncomeNoCategoryWithResponse(ctx context.Context, params *InsightIncomeNoCategoryParams, reqEditors ...RequestEditorFn) (*InsightIncomeNoCategoryResponse, error) {
	rsp, err := c.InsightIncomeNoCategory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightIncomeNoCategoryResponse(rsp)
}

// InsightIncomeNoTagWithResponse request returning *InsightIncomeNoTagResponse
func (c *ClientWithResponses) InsightIncomeNoTagWithResponse(ctx context.Context, params *InsightIncomeNoTagParams, reqEditors ...RequestEditorFn) (*InsightIncomeNoTagResponse, error) {
	rsp, err := c.InsightIncomeNoTag(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightIncomeNoTagResponse(rsp)
}

// InsightIncomeRevenueWithResponse request returning *InsightIncomeRevenueResponse
func (c *ClientWithResponses) InsightIncomeRevenueWithResponse(ctx context.Context, params *InsightIncomeRevenueParams, reqEditors ...RequestEditorFn) (*InsightIncomeRevenueResponse, error) {
	rsp, err := c.InsightIncomeRevenue(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightIncomeRevenueResponse(rsp)
}

// InsightIncomeTagWithResponse request returning *InsightIncomeTagResponse
func (c *ClientWithResponses) InsightIncomeTagWithResponse(ctx context.Context, params *InsightIncomeTagParams, reqEditors ...RequestEditorFn) (*InsightIncomeTagResponse, error) {
	rsp, err := c.InsightIncomeTag(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightIncomeTagResponse(rsp)
}

// InsightIncomeTotalWithResponse request returning *InsightIncomeTotalResponse
func (c *ClientWithResponses) InsightIncomeTotalWithResponse(ctx context.Context, params *InsightIncomeTotalParams, reqEditors ...RequestEditorFn) (*InsightIncomeTotalResponse, error) {
	rsp, err := c.InsightIncomeTotal(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightIncomeTotalResponse(rsp)
}

// InsightTransfersWithResponse request returning *InsightTransfersResponse
func (c *ClientWithResponses) InsightTransfersWithResponse(ctx context.Context, params *InsightTransfersParams, reqEditors ...RequestEditorFn) (*InsightTransfersResponse, error) {
	rsp, err := c.InsightTransfers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightTransfersResponse(rsp)
}

// InsightTransferCategoryWithResponse request returning *InsightTransferCategoryResponse
func (c *ClientWithResponses) InsightTransferCategoryWithResponse(ctx context.Context, params *InsightTransferCategoryParams, reqEditors ...RequestEditorFn) (*InsightTransferCategoryResponse, error) {
	rsp, err := c.InsightTransferCategory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightTransferCategoryResponse(rsp)
}

// InsightTransferNoCategoryWithResponse request returning *InsightTransferNoCategoryResponse
func (c *ClientWithResponses) InsightTransferNoCategoryWithResponse(ctx context.Context, params *InsightTransferNoCategoryParams, reqEditors ...RequestEditorFn) (*InsightTransferNoCategoryResponse, error) {
	rsp, err := c.InsightTransferNoCategory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightTransferNoCategoryResponse(rsp)
}

// InsightTransferNoTagWithResponse request returning *InsightTransferNoTagResponse
func (c *ClientWithResponses) InsightTransferNoTagWithResponse(ctx context.Context, params *InsightTransferNoTagParams, reqEditors ...RequestEditorFn) (*InsightTransferNoTagResponse, error) {
	rsp, err := c.InsightTransferNoTag(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightTransferNoTagResponse(rsp)
}

// InsightTransferTagWithResponse request returning *InsightTransferTagResponse
func (c *ClientWithResponses) InsightTransferTagWithResponse(ctx context.Context, params *InsightTransferTagParams, reqEditors ...RequestEditorFn) (*InsightTransferTagResponse, error) {
	rsp, err := c.InsightTransferTag(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightTransferTagResponse(rsp)
}

// InsightTransferTotalWithResponse request returning *InsightTransferTotalResponse
func (c *ClientWithResponses) InsightTransferTotalWithResponse(ctx context.Context, params *InsightTransferTotalParams, reqEditors ...RequestEditorFn) (*InsightTransferTotalResponse, error) {
	rsp, err := c.InsightTransferTotal(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInsightTransferTotalResponse(rsp)
}

// ListLinkTypeWithResponse request returning *ListLinkTypeResponse
func (c *ClientWithResponses) ListLinkTypeWithResponse(ctx context.Context, params *ListLinkTypeParams, reqEditors ...RequestEditorFn) (*ListLinkTypeResponse, error) {
	rsp, err := c.ListLinkType(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLinkTypeResponse(rsp)
}

// StoreLinkTypeWithBodyWithResponse request with arbitrary body returning *StoreLinkTypeResponse
func (c *ClientWithResponses) StoreLinkTypeWithBodyWithResponse(ctx context.Context, params *StoreLinkTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreLinkTypeResponse, error) {
	rsp, err := c.StoreLinkTypeWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreLinkTypeResponse(rsp)
}

func (c *ClientWithResponses) StoreLinkTypeWithResponse(ctx context.Context, params *StoreLinkTypeParams, body StoreLinkTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreLinkTypeResponse, error) {
	rsp, err := c.StoreLinkType(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreLinkTypeResponse(rsp)
}

func (c *ClientWithResponses) StoreLinkTypeWithFormdataBodyWithResponse(ctx context.Context, params *StoreLinkTypeParams, body StoreLinkTypeFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreLinkTypeResponse, error) {
	rsp, err := c.StoreLinkTypeWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreLinkTypeResponse(rsp)
}

// DeleteLinkTypeWithResponse request returning *DeleteLinkTypeResponse
func (c *ClientWithResponses) DeleteLinkTypeWithResponse(ctx context.Context, id string, params *DeleteLinkTypeParams, reqEditors ...RequestEditorFn) (*DeleteLinkTypeResponse, error) {
	rsp, err := c.DeleteLinkType(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLinkTypeResponse(rsp)
}

// GetLinkTypeWithResponse request returning *GetLinkTypeResponse
func (c *ClientWithResponses) GetLinkTypeWithResponse(ctx context.Context, id string, params *GetLinkTypeParams, reqEditors ...RequestEditorFn) (*GetLinkTypeResponse, error) {
	rsp, err := c.GetLinkType(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLinkTypeResponse(rsp)
}

// UpdateLinkTypeWithBodyWithResponse request with arbitrary body returning *UpdateLinkTypeResponse
func (c *ClientWithResponses) UpdateLinkTypeWithBodyWithResponse(ctx context.Context, id string, params *UpdateLinkTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLinkTypeResponse, error) {
	rsp, err := c.UpdateLinkTypeWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLinkTypeResponse(rsp)
}

func (c *ClientWithResponses) UpdateLinkTypeWithResponse(ctx context.Context, id string, params *UpdateLinkTypeParams, body UpdateLinkTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLinkTypeResponse, error) {
	rsp, err := c.UpdateLinkType(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLinkTypeResponse(rsp)
}

func (c *ClientWithResponses) UpdateLinkTypeWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateLinkTypeParams, body UpdateLinkTypeFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateLinkTypeResponse, error) {
	rsp, err := c.UpdateLinkTypeWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLinkTypeResponse(rsp)
}

// ListTransactionByLinkTypeWithResponse request returning *ListTransactionByLinkTypeResponse
func (c *ClientWithResponses) ListTransactionByLinkTypeWithResponse(ctx context.Context, id string, params *ListTransactionByLinkTypeParams, reqEditors ...RequestEditorFn) (*ListTransactionByLinkTypeResponse, error) {
	rsp, err := c.ListTransactionByLinkType(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionByLinkTypeResponse(rsp)
}

// ListObjectGroupsWithResponse request returning *ListObjectGroupsResponse
func (c *ClientWithResponses) ListObjectGroupsWithResponse(ctx context.Context, params *ListObjectGroupsParams, reqEditors ...RequestEditorFn) (*ListObjectGroupsResponse, error) {
	rsp, err := c.ListObjectGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListObjectGroupsResponse(rsp)
}

// DeleteObjectGroupWithResponse request returning *DeleteObjectGroupResponse
func (c *ClientWithResponses) DeleteObjectGroupWithResponse(ctx context.Context, id string, params *DeleteObjectGroupParams, reqEditors ...RequestEditorFn) (*DeleteObjectGroupResponse, error) {
	rsp, err := c.DeleteObjectGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectGroupResponse(rsp)
}

// GetObjectGroupWithResponse request returning *GetObjectGroupResponse
func (c *ClientWithResponses) GetObjectGroupWithResponse(ctx context.Context, id string, params *GetObjectGroupParams, reqEditors ...RequestEditorFn) (*GetObjectGroupResponse, error) {
	rsp, err := c.GetObjectGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectGroupResponse(rsp)
}

// UpdateObjectGroupWithBodyWithResponse request with arbitrary body returning *UpdateObjectGroupResponse
func (c *ClientWithResponses) UpdateObjectGroupWithBodyWithResponse(ctx context.Context, id string, params *UpdateObjectGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateObjectGroupResponse, error) {
	rsp, err := c.UpdateObjectGroupWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateObjectGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateObjectGroupWithResponse(ctx context.Context, id string, params *UpdateObjectGroupParams, body UpdateObjectGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateObjectGroupResponse, error) {
	rsp, err := c.UpdateObjectGroup(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateObjectGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateObjectGroupWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateObjectGroupParams, body UpdateObjectGroupFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateObjectGroupResponse, error) {
	rsp, err := c.UpdateObjectGroupWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateObjectGroupResponse(rsp)
}

// ListBillByObjectGroupWithResponse request returning *ListBillByObjectGroupResponse
func (c *ClientWithResponses) ListBillByObjectGroupWithResponse(ctx context.Context, id string, params *ListBillByObjectGroupParams, reqEditors ...RequestEditorFn) (*ListBillByObjectGroupResponse, error) {
	rsp, err := c.ListBillByObjectGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillByObjectGroupResponse(rsp)
}

// ListPiggyBankByObjectGroupWithResponse request returning *ListPiggyBankByObjectGroupResponse
func (c *ClientWithResponses) ListPiggyBankByObjectGroupWithResponse(ctx context.Context, id string, params *ListPiggyBankByObjectGroupParams, reqEditors ...RequestEditorFn) (*ListPiggyBankByObjectGroupResponse, error) {
	rsp, err := c.ListPiggyBankByObjectGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPiggyBankByObjectGroupResponse(rsp)
}

// ListPiggyBankWithResponse request returning *ListPiggyBankResponse
func (c *ClientWithResponses) ListPiggyBankWithResponse(ctx context.Context, params *ListPiggyBankParams, reqEditors ...RequestEditorFn) (*ListPiggyBankResponse, error) {
	rsp, err := c.ListPiggyBank(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPiggyBankResponse(rsp)
}

// StorePiggyBankWithBodyWithResponse request with arbitrary body returning *StorePiggyBankResponse
func (c *ClientWithResponses) StorePiggyBankWithBodyWithResponse(ctx context.Context, params *StorePiggyBankParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StorePiggyBankResponse, error) {
	rsp, err := c.StorePiggyBankWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorePiggyBankResponse(rsp)
}

func (c *ClientWithResponses) StorePiggyBankWithResponse(ctx context.Context, params *StorePiggyBankParams, body StorePiggyBankJSONRequestBody, reqEditors ...RequestEditorFn) (*StorePiggyBankResponse, error) {
	rsp, err := c.StorePiggyBank(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorePiggyBankResponse(rsp)
}

func (c *ClientWithResponses) StorePiggyBankWithFormdataBodyWithResponse(ctx context.Context, params *StorePiggyBankParams, body StorePiggyBankFormdataRequestBody, reqEditors ...RequestEditorFn) (*StorePiggyBankResponse, error) {
	rsp, err := c.StorePiggyBankWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorePiggyBankResponse(rsp)
}

// DeletePiggyBankWithResponse request returning *DeletePiggyBankResponse
func (c *ClientWithResponses) DeletePiggyBankWithResponse(ctx context.Context, id string, params *DeletePiggyBankParams, reqEditors ...RequestEditorFn) (*DeletePiggyBankResponse, error) {
	rsp, err := c.DeletePiggyBank(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePiggyBankResponse(rsp)
}

// GetPiggyBankWithResponse request returning *GetPiggyBankResponse
func (c *ClientWithResponses) GetPiggyBankWithResponse(ctx context.Context, id string, params *GetPiggyBankParams, reqEditors ...RequestEditorFn) (*GetPiggyBankResponse, error) {
	rsp, err := c.GetPiggyBank(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPiggyBankResponse(rsp)
}

// UpdatePiggyBankWithBodyWithResponse request with arbitrary body returning *UpdatePiggyBankResponse
func (c *ClientWithResponses) UpdatePiggyBankWithBodyWithResponse(ctx context.Context, id string, params *UpdatePiggyBankParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePiggyBankResponse, error) {
	rsp, err := c.UpdatePiggyBankWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePiggyBankResponse(rsp)
}

func (c *ClientWithResponses) UpdatePiggyBankWithResponse(ctx context.Context, id string, params *UpdatePiggyBankParams, body UpdatePiggyBankJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePiggyBankResponse, error) {
	rsp, err := c.UpdatePiggyBank(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePiggyBankResponse(rsp)
}

func (c *ClientWithResponses) UpdatePiggyBankWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdatePiggyBankParams, body UpdatePiggyBankFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdatePiggyBankResponse, error) {
	rsp, err := c.UpdatePiggyBankWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePiggyBankResponse(rsp)
}

// ListAttachmentByPiggyBankWithResponse request returning *ListAttachmentByPiggyBankResponse
func (c *ClientWithResponses) ListAttachmentByPiggyBankWithResponse(ctx context.Context, id string, params *ListAttachmentByPiggyBankParams, reqEditors ...RequestEditorFn) (*ListAttachmentByPiggyBankResponse, error) {
	rsp, err := c.ListAttachmentByPiggyBank(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttachmentByPiggyBankResponse(rsp)
}

// ListEventByPiggyBankWithResponse request returning *ListEventByPiggyBankResponse
func (c *ClientWithResponses) ListEventByPiggyBankWithResponse(ctx context.Context, id string, params *ListEventByPiggyBankParams, reqEditors ...RequestEditorFn) (*ListEventByPiggyBankResponse, error) {
	rsp, err := c.ListEventByPiggyBank(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventByPiggyBankResponse(rsp)
}

// ListPreferenceWithResponse request returning *ListPreferenceResponse
func (c *ClientWithResponses) ListPreferenceWithResponse(ctx context.Context, params *ListPreferenceParams, reqEditors ...RequestEditorFn) (*ListPreferenceResponse, error) {
	rsp, err := c.ListPreference(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPreferenceResponse(rsp)
}

// StorePreferenceWithBodyWithResponse request with arbitrary body returning *StorePreferenceResponse
func (c *ClientWithResponses) StorePreferenceWithBodyWithResponse(ctx context.Context, params *StorePreferenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StorePreferenceResponse, error) {
	rsp, err := c.StorePreferenceWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorePreferenceResponse(rsp)
}

func (c *ClientWithResponses) StorePreferenceWithResponse(ctx context.Context, params *StorePreferenceParams, body StorePreferenceJSONRequestBody, reqEditors ...RequestEditorFn) (*StorePreferenceResponse, error) {
	rsp, err := c.StorePreference(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorePreferenceResponse(rsp)
}

func (c *ClientWithResponses) StorePreferenceWithFormdataBodyWithResponse(ctx context.Context, params *StorePreferenceParams, body StorePreferenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*StorePreferenceResponse, error) {
	rsp, err := c.StorePreferenceWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorePreferenceResponse(rsp)
}

// GetPreferenceWithResponse request returning *GetPreferenceResponse
func (c *ClientWithResponses) GetPreferenceWithResponse(ctx context.Context, name string, params *GetPreferenceParams, reqEditors ...RequestEditorFn) (*GetPreferenceResponse, error) {
	rsp, err := c.GetPreference(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPreferenceResponse(rsp)
}

// UpdatePreferenceWithBodyWithResponse request with arbitrary body returning *UpdatePreferenceResponse
func (c *ClientWithResponses) UpdatePreferenceWithBodyWithResponse(ctx context.Context, name string, params *UpdatePreferenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePreferenceResponse, error) {
	rsp, err := c.UpdatePreferenceWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePreferenceResponse(rsp)
}

func (c *ClientWithResponses) UpdatePreferenceWithResponse(ctx context.Context, name string, params *UpdatePreferenceParams, body UpdatePreferenceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePreferenceResponse, error) {
	rsp, err := c.UpdatePreference(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePreferenceResponse(rsp)
}

func (c *ClientWithResponses) UpdatePreferenceWithFormdataBodyWithResponse(ctx context.Context, name string, params *UpdatePreferenceParams, body UpdatePreferenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdatePreferenceResponse, error) {
	rsp, err := c.UpdatePreferenceWithFormdataBody(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePreferenceResponse(rsp)
}

// ListRecurrenceWithResponse request returning *ListRecurrenceResponse
func (c *ClientWithResponses) ListRecurrenceWithResponse(ctx context.Context, params *ListRecurrenceParams, reqEditors ...RequestEditorFn) (*ListRecurrenceResponse, error) {
	rsp, err := c.ListRecurrence(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRecurrenceResponse(rsp)
}

// StoreRecurrenceWithBodyWithResponse request with arbitrary body returning *StoreRecurrenceResponse
func (c *ClientWithResponses) StoreRecurrenceWithBodyWithResponse(ctx context.Context, params *StoreRecurrenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreRecurrenceResponse, error) {
	rsp, err := c.StoreRecurrenceWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreRecurrenceResponse(rsp)
}

func (c *ClientWithResponses) StoreRecurrenceWithResponse(ctx context.Context, params *StoreRecurrenceParams, body StoreRecurrenceJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreRecurrenceResponse, error) {
	rsp, err := c.StoreRecurrence(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreRecurrenceResponse(rsp)
}

func (c *ClientWithResponses) StoreRecurrenceWithFormdataBodyWithResponse(ctx context.Context, params *StoreRecurrenceParams, body StoreRecurrenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreRecurrenceResponse, error) {
	rsp, err := c.StoreRecurrenceWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreRecurrenceResponse(rsp)
}

// DeleteRecurrenceWithResponse request returning *DeleteRecurrenceResponse
func (c *ClientWithResponses) DeleteRecurrenceWithResponse(ctx context.Context, id string, params *DeleteRecurrenceParams, reqEditors ...RequestEditorFn) (*DeleteRecurrenceResponse, error) {
	rsp, err := c.DeleteRecurrence(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecurrenceResponse(rsp)
}

// GetRecurrenceWithResponse request returning *GetRecurrenceResponse
func (c *ClientWithResponses) GetRecurrenceWithResponse(ctx context.Context, id string, params *GetRecurrenceParams, reqEditors ...RequestEditorFn) (*GetRecurrenceResponse, error) {
	rsp, err := c.GetRecurrence(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecurrenceResponse(rsp)
}

// UpdateRecurrenceWithBodyWithResponse request with arbitrary body returning *UpdateRecurrenceResponse
func (c *ClientWithResponses) UpdateRecurrenceWithBodyWithResponse(ctx context.Context, id string, params *UpdateRecurrenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecurrenceResponse, error) {
	rsp, err := c.UpdateRecurrenceWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecurrenceResponse(rsp)
}

func (c *ClientWithResponses) UpdateRecurrenceWithResponse(ctx context.Context, id string, params *UpdateRecurrenceParams, body UpdateRecurrenceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecurrenceResponse, error) {
	rsp, err := c.UpdateRecurrence(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecurrenceResponse(rsp)
}

func (c *ClientWithResponses) UpdateRecurrenceWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateRecurrenceParams, body UpdateRecurrenceFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecurrenceResponse, error) {
	rsp, err := c.UpdateRecurrenceWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecurrenceResponse(rsp)
}

// ListTransactionByRecurrenceWithResponse request returning *ListTransactionByRecurrenceResponse
func (c *ClientWithResponses) ListTransactionByRecurrenceWithResponse(ctx context.Context, id string, params *ListTransactionByRecurrenceParams, reqEditors ...RequestEditorFn) (*ListTransactionByRecurrenceResponse, error) {
	rsp, err := c.ListTransactionByRecurrence(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionByRecurrenceResponse(rsp)
}

// ListRuleGroupWithResponse request returning *ListRuleGroupResponse
func (c *ClientWithResponses) ListRuleGroupWithResponse(ctx context.Context, params *ListRuleGroupParams, reqEditors ...RequestEditorFn) (*ListRuleGroupResponse, error) {
	rsp, err := c.ListRuleGroup(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRuleGroupResponse(rsp)
}

// StoreRuleGroupWithBodyWithResponse request with arbitrary body returning *StoreRuleGroupResponse
func (c *ClientWithResponses) StoreRuleGroupWithBodyWithResponse(ctx context.Context, params *StoreRuleGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreRuleGroupResponse, error) {
	rsp, err := c.StoreRuleGroupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreRuleGroupResponse(rsp)
}

func (c *ClientWithResponses) StoreRuleGroupWithResponse(ctx context.Context, params *StoreRuleGroupParams, body StoreRuleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreRuleGroupResponse, error) {
	rsp, err := c.StoreRuleGroup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreRuleGroupResponse(rsp)
}

func (c *ClientWithResponses) StoreRuleGroupWithFormdataBodyWithResponse(ctx context.Context, params *StoreRuleGroupParams, body StoreRuleGroupFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreRuleGroupResponse, error) {
	rsp, err := c.StoreRuleGroupWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreRuleGroupResponse(rsp)
}

// DeleteRuleGroupWithResponse request returning *DeleteRuleGroupResponse
func (c *ClientWithResponses) DeleteRuleGroupWithResponse(ctx context.Context, id string, params *DeleteRuleGroupParams, reqEditors ...RequestEditorFn) (*DeleteRuleGroupResponse, error) {
	rsp, err := c.DeleteRuleGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuleGroupResponse(rsp)
}

// GetRuleGroupWithResponse request returning *GetRuleGroupResponse
func (c *ClientWithResponses) GetRuleGroupWithResponse(ctx context.Context, id string, params *GetRuleGroupParams, reqEditors ...RequestEditorFn) (*GetRuleGroupResponse, error) {
	rsp, err := c.GetRuleGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleGroupResponse(rsp)
}

// UpdateRuleGroupWithBodyWithResponse request with arbitrary body returning *UpdateRuleGroupResponse
func (c *ClientWithResponses) UpdateRuleGroupWithBodyWithResponse(ctx context.Context, id string, params *UpdateRuleGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleGroupResponse, error) {
	rsp, err := c.UpdateRuleGroupWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleGroupWithResponse(ctx context.Context, id string, params *UpdateRuleGroupParams, body UpdateRuleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleGroupResponse, error) {
	rsp, err := c.UpdateRuleGroup(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleGroupWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateRuleGroupParams, body UpdateRuleGroupFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleGroupResponse, error) {
	rsp, err := c.UpdateRuleGroupWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleGroupResponse(rsp)
}

// ListRuleByGroupWithResponse request returning *ListRuleByGroupResponse
func (c *ClientWithResponses) ListRuleByGroupWithResponse(ctx context.Context, id string, params *ListRuleByGroupParams, reqEditors ...RequestEditorFn) (*ListRuleByGroupResponse, error) {
	rsp, err := c.ListRuleByGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRuleByGroupResponse(rsp)
}

// TestRuleGroupWithResponse request returning *TestRuleGroupResponse
func (c *ClientWithResponses) TestRuleGroupWithResponse(ctx context.Context, id string, params *TestRuleGroupParams, reqEditors ...RequestEditorFn) (*TestRuleGroupResponse, error) {
	rsp, err := c.TestRuleGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestRuleGroupResponse(rsp)
}

// FireRuleGroupWithResponse request returning *FireRuleGroupResponse
func (c *ClientWithResponses) FireRuleGroupWithResponse(ctx context.Context, id string, params *FireRuleGroupParams, reqEditors ...RequestEditorFn) (*FireRuleGroupResponse, error) {
	rsp, err := c.FireRuleGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFireRuleGroupResponse(rsp)
}

// ListRuleWithResponse request returning *ListRuleResponse
func (c *ClientWithResponses) ListRuleWithResponse(ctx context.Context, params *ListRuleParams, reqEditors ...RequestEditorFn) (*ListRuleResponse, error) {
	rsp, err := c.ListRule(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRuleResponse(rsp)
}

// StoreRuleWithBodyWithResponse request with arbitrary body returning *StoreRuleResponse
func (c *ClientWithResponses) StoreRuleWithBodyWithResponse(ctx context.Context, params *StoreRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreRuleResponse, error) {
	rsp, err := c.StoreRuleWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreRuleResponse(rsp)
}

func (c *ClientWithResponses) StoreRuleWithResponse(ctx context.Context, params *StoreRuleParams, body StoreRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreRuleResponse, error) {
	rsp, err := c.StoreRule(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreRuleResponse(rsp)
}

func (c *ClientWithResponses) StoreRuleWithFormdataBodyWithResponse(ctx context.Context, params *StoreRuleParams, body StoreRuleFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreRuleResponse, error) {
	rsp, err := c.StoreRuleWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreRuleResponse(rsp)
}

// DeleteRuleWithResponse request returning *DeleteRuleResponse
func (c *ClientWithResponses) DeleteRuleWithResponse(ctx context.Context, id string, params *DeleteRuleParams, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error) {
	rsp, err := c.DeleteRule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuleResponse(rsp)
}

// GetRuleWithResponse request returning *GetRuleResponse
func (c *ClientWithResponses) GetRuleWithResponse(ctx context.Context, id string, params *GetRuleParams, reqEditors ...RequestEditorFn) (*GetRuleResponse, error) {
	rsp, err := c.GetRule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleResponse(rsp)
}

// UpdateRuleWithBodyWithResponse request with arbitrary body returning *UpdateRuleResponse
func (c *ClientWithResponses) UpdateRuleWithBodyWithResponse(ctx context.Context, id string, params *UpdateRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRuleWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleWithResponse(ctx context.Context, id string, params *UpdateRuleParams, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRule(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateRuleParams, body UpdateRuleFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRuleWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

// TestRuleWithResponse request returning *TestRuleResponse
func (c *ClientWithResponses) TestRuleWithResponse(ctx context.Context, id string, params *TestRuleParams, reqEditors ...RequestEditorFn) (*TestRuleResponse, error) {
	rsp, err := c.TestRule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestRuleResponse(rsp)
}

// FireRuleWithResponse request returning *FireRuleResponse
func (c *ClientWithResponses) FireRuleWithResponse(ctx context.Context, id string, params *FireRuleParams, reqEditors ...RequestEditorFn) (*FireRuleResponse, error) {
	rsp, err := c.FireRule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFireRuleResponse(rsp)
}

// SearchAccountsWithResponse request returning *SearchAccountsResponse
func (c *ClientWithResponses) SearchAccountsWithResponse(ctx context.Context, params *SearchAccountsParams, reqEditors ...RequestEditorFn) (*SearchAccountsResponse, error) {
	rsp, err := c.SearchAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchAccountsResponse(rsp)
}

// SearchTransactionsWithResponse request returning *SearchTransactionsResponse
func (c *ClientWithResponses) SearchTransactionsWithResponse(ctx context.Context, params *SearchTransactionsParams, reqEditors ...RequestEditorFn) (*SearchTransactionsResponse, error) {
	rsp, err := c.SearchTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTransactionsResponse(rsp)
}

// GetBasicSummaryWithResponse request returning *GetBasicSummaryResponse
func (c *ClientWithResponses) GetBasicSummaryWithResponse(ctx context.Context, params *GetBasicSummaryParams, reqEditors ...RequestEditorFn) (*GetBasicSummaryResponse, error) {
	rsp, err := c.GetBasicSummary(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBasicSummaryResponse(rsp)
}

// ListTagWithResponse request returning *ListTagResponse
func (c *ClientWithResponses) ListTagWithResponse(ctx context.Context, params *ListTagParams, reqEditors ...RequestEditorFn) (*ListTagResponse, error) {
	rsp, err := c.ListTag(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTagResponse(rsp)
}

// StoreTagWithBodyWithResponse request with arbitrary body returning *StoreTagResponse
func (c *ClientWithResponses) StoreTagWithBodyWithResponse(ctx context.Context, params *StoreTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreTagResponse, error) {
	rsp, err := c.StoreTagWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreTagResponse(rsp)
}

func (c *ClientWithResponses) StoreTagWithResponse(ctx context.Context, params *StoreTagParams, body StoreTagJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreTagResponse, error) {
	rsp, err := c.StoreTag(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreTagResponse(rsp)
}

func (c *ClientWithResponses) StoreTagWithFormdataBodyWithResponse(ctx context.Context, params *StoreTagParams, body StoreTagFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreTagResponse, error) {
	rsp, err := c.StoreTagWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreTagResponse(rsp)
}

// DeleteTagWithResponse request returning *DeleteTagResponse
func (c *ClientWithResponses) DeleteTagWithResponse(ctx context.Context, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error) {
	rsp, err := c.DeleteTag(ctx, tag, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagResponse(rsp)
}

// GetTagWithResponse request returning *GetTagResponse
func (c *ClientWithResponses) GetTagWithResponse(ctx context.Context, tag string, params *GetTagParams, reqEditors ...RequestEditorFn) (*GetTagResponse, error) {
	rsp, err := c.GetTag(ctx, tag, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagResponse(rsp)
}

// UpdateTagWithBodyWithResponse request with arbitrary body returning *UpdateTagResponse
func (c *ClientWithResponses) UpdateTagWithBodyWithResponse(ctx context.Context, tag string, params *UpdateTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error) {
	rsp, err := c.UpdateTagWithBody(ctx, tag, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTagResponse(rsp)
}

func (c *ClientWithResponses) UpdateTagWithResponse(ctx context.Context, tag string, params *UpdateTagParams, body UpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error) {
	rsp, err := c.UpdateTag(ctx, tag, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTagResponse(rsp)
}

func (c *ClientWithResponses) UpdateTagWithFormdataBodyWithResponse(ctx context.Context, tag string, params *UpdateTagParams, body UpdateTagFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateTagResponse, error) {
	rsp, err := c.UpdateTagWithFormdataBody(ctx, tag, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTagResponse(rsp)
}

// ListAttachmentByTagWithResponse request returning *ListAttachmentByTagResponse
func (c *ClientWithResponses) ListAttachmentByTagWithResponse(ctx context.Context, tag string, params *ListAttachmentByTagParams, reqEditors ...RequestEditorFn) (*ListAttachmentByTagResponse, error) {
	rsp, err := c.ListAttachmentByTag(ctx, tag, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttachmentByTagResponse(rsp)
}

// ListTransactionByTagWithResponse request returning *ListTransactionByTagResponse
func (c *ClientWithResponses) ListTransactionByTagWithResponse(ctx context.Context, tag string, params *ListTransactionByTagParams, reqEditors ...RequestEditorFn) (*ListTransactionByTagResponse, error) {
	rsp, err := c.ListTransactionByTag(ctx, tag, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionByTagResponse(rsp)
}

// DeleteTransactionJournalWithResponse request returning *DeleteTransactionJournalResponse
func (c *ClientWithResponses) DeleteTransactionJournalWithResponse(ctx context.Context, id string, params *DeleteTransactionJournalParams, reqEditors ...RequestEditorFn) (*DeleteTransactionJournalResponse, error) {
	rsp, err := c.DeleteTransactionJournal(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTransactionJournalResponse(rsp)
}

// GetTransactionByJournalWithResponse request returning *GetTransactionByJournalResponse
func (c *ClientWithResponses) GetTransactionByJournalWithResponse(ctx context.Context, id string, params *GetTransactionByJournalParams, reqEditors ...RequestEditorFn) (*GetTransactionByJournalResponse, error) {
	rsp, err := c.GetTransactionByJournal(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionByJournalResponse(rsp)
}

// ListLinksByJournalWithResponse request returning *ListLinksByJournalResponse
func (c *ClientWithResponses) ListLinksByJournalWithResponse(ctx context.Context, id string, params *ListLinksByJournalParams, reqEditors ...RequestEditorFn) (*ListLinksByJournalResponse, error) {
	rsp, err := c.ListLinksByJournal(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLinksByJournalResponse(rsp)
}

// ListTransactionLinkWithResponse request returning *ListTransactionLinkResponse
func (c *ClientWithResponses) ListTransactionLinkWithResponse(ctx context.Context, params *ListTransactionLinkParams, reqEditors ...RequestEditorFn) (*ListTransactionLinkResponse, error) {
	rsp, err := c.ListTransactionLink(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionLinkResponse(rsp)
}

// StoreTransactionLinkWithBodyWithResponse request with arbitrary body returning *StoreTransactionLinkResponse
func (c *ClientWithResponses) StoreTransactionLinkWithBodyWithResponse(ctx context.Context, params *StoreTransactionLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreTransactionLinkResponse, error) {
	rsp, err := c.StoreTransactionLinkWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreTransactionLinkResponse(rsp)
}

func (c *ClientWithResponses) StoreTransactionLinkWithResponse(ctx context.Context, params *StoreTransactionLinkParams, body StoreTransactionLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreTransactionLinkResponse, error) {
	rsp, err := c.StoreTransactionLink(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreTransactionLinkResponse(rsp)
}

func (c *ClientWithResponses) StoreTransactionLinkWithFormdataBodyWithResponse(ctx context.Context, params *StoreTransactionLinkParams, body StoreTransactionLinkFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreTransactionLinkResponse, error) {
	rsp, err := c.StoreTransactionLinkWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreTransactionLinkResponse(rsp)
}

// DeleteTransactionLinkWithResponse request returning *DeleteTransactionLinkResponse
func (c *ClientWithResponses) DeleteTransactionLinkWithResponse(ctx context.Context, id string, params *DeleteTransactionLinkParams, reqEditors ...RequestEditorFn) (*DeleteTransactionLinkResponse, error) {
	rsp, err := c.DeleteTransactionLink(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTransactionLinkResponse(rsp)
}

// GetTransactionLinkWithResponse request returning *GetTransactionLinkResponse
func (c *ClientWithResponses) GetTransactionLinkWithResponse(ctx context.Context, id string, params *GetTransactionLinkParams, reqEditors ...RequestEditorFn) (*GetTransactionLinkResponse, error) {
	rsp, err := c.GetTransactionLink(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionLinkResponse(rsp)
}

// UpdateTransactionLinkWithBodyWithResponse request with arbitrary body returning *UpdateTransactionLinkResponse
func (c *ClientWithResponses) UpdateTransactionLinkWithBodyWithResponse(ctx context.Context, id string, params *UpdateTransactionLinkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTransactionLinkResponse, error) {
	rsp, err := c.UpdateTransactionLinkWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransactionLinkResponse(rsp)
}

func (c *ClientWithResponses) UpdateTransactionLinkWithResponse(ctx context.Context, id string, params *UpdateTransactionLinkParams, body UpdateTransactionLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionLinkResponse, error) {
	rsp, err := c.UpdateTransactionLink(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransactionLinkResponse(rsp)
}

func (c *ClientWithResponses) UpdateTransactionLinkWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateTransactionLinkParams, body UpdateTransactionLinkFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionLinkResponse, error) {
	rsp, err := c.UpdateTransactionLinkWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransactionLinkResponse(rsp)
}

// ListTransactionWithResponse request returning *ListTransactionResponse
func (c *ClientWithResponses) ListTransactionWithResponse(ctx context.Context, params *ListTransactionParams, reqEditors ...RequestEditorFn) (*ListTransactionResponse, error) {
	rsp, err := c.ListTransaction(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionResponse(rsp)
}

// StoreTransactionWithBodyWithResponse request with arbitrary body returning *StoreTransactionResponse
func (c *ClientWithResponses) StoreTransactionWithBodyWithResponse(ctx context.Context, params *StoreTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreTransactionResponse, error) {
	rsp, err := c.StoreTransactionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreTransactionResponse(rsp)
}

func (c *ClientWithResponses) StoreTransactionWithResponse(ctx context.Context, params *StoreTransactionParams, body StoreTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreTransactionResponse, error) {
	rsp, err := c.StoreTransaction(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreTransactionResponse(rsp)
}

func (c *ClientWithResponses) StoreTransactionWithFormdataBodyWithResponse(ctx context.Context, params *StoreTransactionParams, body StoreTransactionFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreTransactionResponse, error) {
	rsp, err := c.StoreTransactionWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreTransactionResponse(rsp)
}

// DeleteTransactionWithResponse request returning *DeleteTransactionResponse
func (c *ClientWithResponses) DeleteTransactionWithResponse(ctx context.Context, id string, params *DeleteTransactionParams, reqEditors ...RequestEditorFn) (*DeleteTransactionResponse, error) {
	rsp, err := c.DeleteTransaction(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTransactionResponse(rsp)
}

// GetTransactionWithResponse request returning *GetTransactionResponse
func (c *ClientWithResponses) GetTransactionWithResponse(ctx context.Context, id string, params *GetTransactionParams, reqEditors ...RequestEditorFn) (*GetTransactionResponse, error) {
	rsp, err := c.GetTransaction(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionResponse(rsp)
}

// UpdateTransactionWithBodyWithResponse request with arbitrary body returning *UpdateTransactionResponse
func (c *ClientWithResponses) UpdateTransactionWithBodyWithResponse(ctx context.Context, id string, params *UpdateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTransactionResponse, error) {
	rsp, err := c.UpdateTransactionWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransactionResponse(rsp)
}

func (c *ClientWithResponses) UpdateTransactionWithResponse(ctx context.Context, id string, params *UpdateTransactionParams, body UpdateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionResponse, error) {
	rsp, err := c.UpdateTransaction(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransactionResponse(rsp)
}

func (c *ClientWithResponses) UpdateTransactionWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateTransactionParams, body UpdateTransactionFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionResponse, error) {
	rsp, err := c.UpdateTransactionWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransactionResponse(rsp)
}

// ListAttachmentByTransactionWithResponse request returning *ListAttachmentByTransactionResponse
func (c *ClientWithResponses) ListAttachmentByTransactionWithResponse(ctx context.Context, id string, params *ListAttachmentByTransactionParams, reqEditors ...RequestEditorFn) (*ListAttachmentByTransactionResponse, error) {
	rsp, err := c.ListAttachmentByTransaction(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttachmentByTransactionResponse(rsp)
}

// ListEventByTransactionWithResponse request returning *ListEventByTransactionResponse
func (c *ClientWithResponses) ListEventByTransactionWithResponse(ctx context.Context, id string, params *ListEventByTransactionParams, reqEditors ...RequestEditorFn) (*ListEventByTransactionResponse, error) {
	rsp, err := c.ListEventByTransaction(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventByTransactionResponse(rsp)
}

// ListUserWithResponse request returning *ListUserResponse
func (c *ClientWithResponses) ListUserWithResponse(ctx context.Context, params *ListUserParams, reqEditors ...RequestEditorFn) (*ListUserResponse, error) {
	rsp, err := c.ListUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserResponse(rsp)
}

// StoreUserWithBodyWithResponse request with arbitrary body returning *StoreUserResponse
func (c *ClientWithResponses) StoreUserWithBodyWithResponse(ctx context.Context, params *StoreUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreUserResponse, error) {
	rsp, err := c.StoreUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreUserResponse(rsp)
}

func (c *ClientWithResponses) StoreUserWithResponse(ctx context.Context, params *StoreUserParams, body StoreUserJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreUserResponse, error) {
	rsp, err := c.StoreUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreUserResponse(rsp)
}

func (c *ClientWithResponses) StoreUserWithFormdataBodyWithResponse(ctx context.Context, params *StoreUserParams, body StoreUserFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreUserResponse, error) {
	rsp, err := c.StoreUserWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, id string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, id string, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, id string, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, id string, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateUserParams, body UpdateUserFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// ListWebhookWithResponse request returning *ListWebhookResponse
func (c *ClientWithResponses) ListWebhookWithResponse(ctx context.Context, params *ListWebhookParams, reqEditors ...RequestEditorFn) (*ListWebhookResponse, error) {
	rsp, err := c.ListWebhook(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebhookResponse(rsp)
}

// StoreWebhookWithBodyWithResponse request with arbitrary body returning *StoreWebhookResponse
func (c *ClientWithResponses) StoreWebhookWithBodyWithResponse(ctx context.Context, params *StoreWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreWebhookResponse, error) {
	rsp, err := c.StoreWebhookWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreWebhookResponse(rsp)
}

func (c *ClientWithResponses) StoreWebhookWithResponse(ctx context.Context, params *StoreWebhookParams, body StoreWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreWebhookResponse, error) {
	rsp, err := c.StoreWebhook(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreWebhookResponse(rsp)
}

func (c *ClientWithResponses) StoreWebhookWithFormdataBodyWithResponse(ctx context.Context, params *StoreWebhookParams, body StoreWebhookFormdataRequestBody, reqEditors ...RequestEditorFn) (*StoreWebhookResponse, error) {
	rsp, err := c.StoreWebhookWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreWebhookResponse(rsp)
}

// DeleteWebhookWithResponse request returning *DeleteWebhookResponse
func (c *ClientWithResponses) DeleteWebhookWithResponse(ctx context.Context, id string, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error) {
	rsp, err := c.DeleteWebhook(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookResponse(rsp)
}

// GetWebhookWithResponse request returning *GetWebhookResponse
func (c *ClientWithResponses) GetWebhookWithResponse(ctx context.Context, id string, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error) {
	rsp, err := c.GetWebhook(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookResponse(rsp)
}

// UpdateWebhookWithBodyWithResponse request with arbitrary body returning *UpdateWebhookResponse
func (c *ClientWithResponses) UpdateWebhookWithBodyWithResponse(ctx context.Context, id string, params *UpdateWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error) {
	rsp, err := c.UpdateWebhookWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookResponse(rsp)
}

func (c *ClientWithResponses) UpdateWebhookWithResponse(ctx context.Context, id string, params *UpdateWebhookParams, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error) {
	rsp, err := c.UpdateWebhook(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookResponse(rsp)
}

func (c *ClientWithResponses) UpdateWebhookWithFormdataBodyWithResponse(ctx context.Context, id string, params *UpdateWebhookParams, body UpdateWebhookFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error) {
	rsp, err := c.UpdateWebhookWithFormdataBody(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookResponse(rsp)
}

// GetWebhookMessagesWithResponse request returning *GetWebhookMessagesResponse
func (c *ClientWithResponses) GetWebhookMessagesWithResponse(ctx context.Context, id string, params *GetWebhookMessagesParams, reqEditors ...RequestEditorFn) (*GetWebhookMessagesResponse, error) {
	rsp, err := c.GetWebhookMessages(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookMessagesResponse(rsp)
}

// DeleteWebhookMessageWithResponse request returning *DeleteWebhookMessageResponse
func (c *ClientWithResponses) DeleteWebhookMessageWithResponse(ctx context.Context, id string, messageId int, params *DeleteWebhookMessageParams, reqEditors ...RequestEditorFn) (*DeleteWebhookMessageResponse, error) {
	rsp, err := c.DeleteWebhookMessage(ctx, id, messageId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookMessageResponse(rsp)
}

// GetSingleWebhookMessageWithResponse request returning *GetSingleWebhookMessageResponse
func (c *ClientWithResponses) GetSingleWebhookMessageWithResponse(ctx context.Context, id string, messageId int, params *GetSingleWebhookMessageParams, reqEditors ...RequestEditorFn) (*GetSingleWebhookMessageResponse, error) {
	rsp, err := c.GetSingleWebhookMessage(ctx, id, messageId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSingleWebhookMessageResponse(rsp)
}

// GetWebhookMessageAttemptsWithResponse request returning *GetWebhookMessageAttemptsResponse
func (c *ClientWithResponses) GetWebhookMessageAttemptsWithResponse(ctx context.Context, id string, messageId int, params *GetWebhookMessageAttemptsParams, reqEditors ...RequestEditorFn) (*GetWebhookMessageAttemptsResponse, error) {
	rsp, err := c.GetWebhookMessageAttempts(ctx, id, messageId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookMessageAttemptsResponse(rsp)
}

// DeleteWebhookMessageAttemptWithResponse request returning *DeleteWebhookMessageAttemptResponse
func (c *ClientWithResponses) DeleteWebhookMessageAttemptWithResponse(ctx context.Context, id string, messageId int, attemptId int, params *DeleteWebhookMessageAttemptParams, reqEditors ...RequestEditorFn) (*DeleteWebhookMessageAttemptResponse, error) {
	rsp, err := c.DeleteWebhookMessageAttempt(ctx, id, messageId, attemptId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookMessageAttemptResponse(rsp)
}

// GetSingleWebhookMessageAttemptWithResponse request returning *GetSingleWebhookMessageAttemptResponse
func (c *ClientWithResponses) GetSingleWebhookMessageAttemptWithResponse(ctx context.Context, id string, messageId int, attemptId int, params *GetSingleWebhookMessageAttemptParams, reqEditors ...RequestEditorFn) (*GetSingleWebhookMessageAttemptResponse, error) {
	rsp, err := c.GetSingleWebhookMessageAttempt(ctx, id, messageId, attemptId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSingleWebhookMessageAttemptResponse(rsp)
}

// SubmitWebookWithResponse request returning *SubmitWebookResponse
func (c *ClientWithResponses) SubmitWebookWithResponse(ctx context.Context, id string, params *SubmitWebookParams, reqEditors ...RequestEditorFn) (*SubmitWebookResponse, error) {
	rsp, err := c.SubmitWebook(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitWebookResponse(rsp)
}

// TriggerTransactionWebhookWithResponse request returning *TriggerTransactionWebhookResponse
func (c *ClientWithResponses) TriggerTransactionWebhookWithResponse(ctx context.Context, id string, transactionId string, params *TriggerTransactionWebhookParams, reqEditors ...RequestEditorFn) (*TriggerTransactionWebhookResponse, error) {
	rsp, err := c.TriggerTransactionWebhook(ctx, id, transactionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerTransactionWebhookResponse(rsp)
}

// ParseGetAboutResponse parses an HTTP response from a GetAboutWithResponse call
func ParseGetAboutResponse(rsp *http.Response) (*GetAboutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAboutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SystemInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAccountResponse parses an HTTP response from a ListAccountWithResponse call
func ParseListAccountResponse(rsp *http.Response) (*ListAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreAccountResponse parses an HTTP response from a StoreAccountWithResponse call
func ParseStoreAccountResponse(rsp *http.Response) (*StoreAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAccountResponse parses an HTTP response from a DeleteAccountWithResponse call
func ParseDeleteAccountResponse(rsp *http.Response) (*DeleteAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAccountResponse parses an HTTP response from a GetAccountWithResponse call
func ParseGetAccountResponse(rsp *http.Response) (*GetAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAccountResponse parses an HTTP response from a UpdateAccountWithResponse call
func ParseUpdateAccountResponse(rsp *http.Response) (*UpdateAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttachmentByAccountResponse parses an HTTP response from a ListAttachmentByAccountWithResponse call
func ParseListAttachmentByAccountResponse(rsp *http.Response) (*ListAttachmentByAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttachmentByAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachmentArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPiggyBankByAccountResponse parses an HTTP response from a ListPiggyBankByAccountWithResponse call
func ParseListPiggyBankByAccountResponse(rsp *http.Response) (*ListPiggyBankByAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPiggyBankByAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PiggyBankArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTransactionByAccountResponse parses an HTTP response from a ListTransactionByAccountWithResponse call
func ParseListTransactionByAccountResponse(rsp *http.Response) (*ListTransactionByAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionByAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttachmentResponse parses an HTTP response from a ListAttachmentWithResponse call
func ParseListAttachmentResponse(rsp *http.Response) (*ListAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachmentArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreAttachmentResponse parses an HTTP response from a StoreAttachmentWithResponse call
func ParseStoreAttachmentResponse(rsp *http.Response) (*StoreAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachmentSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAttachmentResponse parses an HTTP response from a DeleteAttachmentWithResponse call
func ParseDeleteAttachmentResponse(rsp *http.Response) (*DeleteAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAttachmentResponse parses an HTTP response from a GetAttachmentWithResponse call
func ParseGetAttachmentResponse(rsp *http.Response) (*GetAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachmentSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAttachmentResponse parses an HTTP response from a UpdateAttachmentWithResponse call
func ParseUpdateAttachmentResponse(rsp *http.Response) (*UpdateAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachmentSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadAttachmentResponse parses an HTTP response from a DownloadAttachmentWithResponse call
func ParseDownloadAttachmentResponse(rsp *http.Response) (*DownloadAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadAttachmentResponse parses an HTTP response from a UploadAttachmentWithResponse call
func ParseUploadAttachmentResponse(rsp *http.Response) (*UploadAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAccountsACResponse parses an HTTP response from a GetAccountsACWithResponse call
func ParseGetAccountsACResponse(rsp *http.Response) (*GetAccountsACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountsACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteAccountArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBillsACResponse parses an HTTP response from a GetBillsACWithResponse call
func ParseGetBillsACResponse(rsp *http.Response) (*GetBillsACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillsACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteBillArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBudgetsACResponse parses an HTTP response from a GetBudgetsACWithResponse call
func ParseGetBudgetsACResponse(rsp *http.Response) (*GetBudgetsACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBudgetsACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteBudgetArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCategoriesACResponse parses an HTTP response from a GetCategoriesACWithResponse call
func ParseGetCategoriesACResponse(rsp *http.Response) (*GetCategoriesACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoriesACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteCategoryArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrenciesACResponse parses an HTTP response from a GetCurrenciesACWithResponse call
func ParseGetCurrenciesACResponse(rsp *http.Response) (*GetCurrenciesACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrenciesACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteCurrencyArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrenciesCodeACResponse parses an HTTP response from a GetCurrenciesCodeACWithResponse call
func ParseGetCurrenciesCodeACResponse(rsp *http.Response) (*GetCurrenciesCodeACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrenciesCodeACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteCurrencyCodeArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetObjectGroupsACResponse parses an HTTP response from a GetObjectGroupsACWithResponse call
func ParseGetObjectGroupsACResponse(rsp *http.Response) (*GetObjectGroupsACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetObjectGroupsACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteObjectGroupArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPiggiesACResponse parses an HTTP response from a GetPiggiesACWithResponse call
func ParseGetPiggiesACResponse(rsp *http.Response) (*GetPiggiesACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPiggiesACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompletePiggyArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPiggiesBalanceACResponse parses an HTTP response from a GetPiggiesBalanceACWithResponse call
func ParseGetPiggiesBalanceACResponse(rsp *http.Response) (*GetPiggiesBalanceACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPiggiesBalanceACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompletePiggyBalanceArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRecurringACResponse parses an HTTP response from a GetRecurringACWithResponse call
func ParseGetRecurringACResponse(rsp *http.Response) (*GetRecurringACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecurringACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteRecurrenceArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRuleGroupsACResponse parses an HTTP response from a GetRuleGroupsACWithResponse call
func ParseGetRuleGroupsACResponse(rsp *http.Response) (*GetRuleGroupsACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleGroupsACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteRuleGroupArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRulesACResponse parses an HTTP response from a GetRulesACWithResponse call
func ParseGetRulesACResponse(rsp *http.Response) (*GetRulesACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteRuleArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTagACResponse parses an HTTP response from a GetTagACWithResponse call
func ParseGetTagACResponse(rsp *http.Response) (*GetTagACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteTagArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTransactionTypesACResponse parses an HTTP response from a GetTransactionTypesACWithResponse call
func ParseGetTransactionTypesACResponse(rsp *http.Response) (*GetTransactionTypesACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionTypesACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteTransactionTypeArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTransactionsACResponse parses an HTTP response from a GetTransactionsACWithResponse call
func ParseGetTransactionsACResponse(rsp *http.Response) (*GetTransactionsACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteTransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTransactionsIDACResponse parses an HTTP response from a GetTransactionsIDACWithResponse call
func ParseGetTransactionsIDACResponse(rsp *http.Response) (*GetTransactionsIDACResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsIDACResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteTransactionIDArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAvailableBudgetResponse parses an HTTP response from a ListAvailableBudgetWithResponse call
func ParseListAvailableBudgetResponse(rsp *http.Response) (*ListAvailableBudgetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableBudgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AvailableBudgetArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAvailableBudgetResponse parses an HTTP response from a GetAvailableBudgetWithResponse call
func ParseGetAvailableBudgetResponse(rsp *http.Response) (*GetAvailableBudgetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvailableBudgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AvailableBudgetSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBillResponse parses an HTTP response from a ListBillWithResponse call
func ParseListBillResponse(rsp *http.Response) (*ListBillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreBillResponse parses an HTTP response from a StoreBillWithResponse call
func ParseStoreBillResponse(rsp *http.Response) (*StoreBillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreBillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBillResponse parses an HTTP response from a DeleteBillWithResponse call
func ParseDeleteBillResponse(rsp *http.Response) (*DeleteBillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBillResponse parses an HTTP response from a GetBillWithResponse call
func ParseGetBillResponse(rsp *http.Response) (*GetBillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateBillResponse parses an HTTP response from a UpdateBillWithResponse call
func ParseUpdateBillResponse(rsp *http.Response) (*UpdateBillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttachmentByBillResponse parses an HTTP response from a ListAttachmentByBillWithResponse call
func ParseListAttachmentByBillResponse(rsp *http.Response) (*ListAttachmentByBillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttachmentByBillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachmentArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRuleByBillResponse parses an HTTP response from a ListRuleByBillWithResponse call
func ParseListRuleByBillResponse(rsp *http.Response) (*ListRuleByBillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRuleByBillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTransactionByBillResponse parses an HTTP response from a ListTransactionByBillWithResponse call
func ParseListTransactionByBillResponse(rsp *http.Response) (*ListTransactionByBillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionByBillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBudgetLimitResponse parses an HTTP response from a ListBudgetLimitWithResponse call
func ParseListBudgetLimitResponse(rsp *http.Response) (*ListBudgetLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBudgetLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetLimitArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBudgetResponse parses an HTTP response from a ListBudgetWithResponse call
func ParseListBudgetResponse(rsp *http.Response) (*ListBudgetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBudgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreBudgetResponse parses an HTTP response from a StoreBudgetWithResponse call
func ParseStoreBudgetResponse(rsp *http.Response) (*StoreBudgetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreBudgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBudgetResponse parses an HTTP response from a DeleteBudgetWithResponse call
func ParseDeleteBudgetResponse(rsp *http.Response) (*DeleteBudgetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBudgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBudgetResponse parses an HTTP response from a GetBudgetWithResponse call
func ParseGetBudgetResponse(rsp *http.Response) (*GetBudgetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBudgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateBudgetResponse parses an HTTP response from a UpdateBudgetWithResponse call
func ParseUpdateBudgetResponse(rsp *http.Response) (*UpdateBudgetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBudgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttachmentByBudgetResponse parses an HTTP response from a ListAttachmentByBudgetWithResponse call
func ParseListAttachmentByBudgetResponse(rsp *http.Response) (*ListAttachmentByBudgetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttachmentByBudgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachmentArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBudgetLimitByBudgetResponse parses an HTTP response from a ListBudgetLimitByBudgetWithResponse call
func ParseListBudgetLimitByBudgetResponse(rsp *http.Response) (*ListBudgetLimitByBudgetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBudgetLimitByBudgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetLimitArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreBudgetLimitResponse parses an HTTP response from a StoreBudgetLimitWithResponse call
func ParseStoreBudgetLimitResponse(rsp *http.Response) (*StoreBudgetLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreBudgetLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetLimitSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBudgetLimitResponse parses an HTTP response from a DeleteBudgetLimitWithResponse call
func ParseDeleteBudgetLimitResponse(rsp *http.Response) (*DeleteBudgetLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBudgetLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBudgetLimitResponse parses an HTTP response from a GetBudgetLimitWithResponse call
func ParseGetBudgetLimitResponse(rsp *http.Response) (*GetBudgetLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBudgetLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetLimitSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateBudgetLimitResponse parses an HTTP response from a UpdateBudgetLimitWithResponse call
func ParseUpdateBudgetLimitResponse(rsp *http.Response) (*UpdateBudgetLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBudgetLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetLimitSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTransactionByBudgetLimitResponse parses an HTTP response from a ListTransactionByBudgetLimitWithResponse call
func ParseListTransactionByBudgetLimitResponse(rsp *http.Response) (*ListTransactionByBudgetLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionByBudgetLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTransactionByBudgetResponse parses an HTTP response from a ListTransactionByBudgetWithResponse call
func ParseListTransactionByBudgetResponse(rsp *http.Response) (*ListTransactionByBudgetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionByBudgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCategoryResponse parses an HTTP response from a ListCategoryWithResponse call
func ParseListCategoryResponse(rsp *http.Response) (*ListCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CategoryArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreCategoryResponse parses an HTTP response from a StoreCategoryWithResponse call
func ParseStoreCategoryResponse(rsp *http.Response) (*StoreCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CategorySingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCategoryResponse parses an HTTP response from a DeleteCategoryWithResponse call
func ParseDeleteCategoryResponse(rsp *http.Response) (*DeleteCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCategoryResponse parses an HTTP response from a GetCategoryWithResponse call
func ParseGetCategoryResponse(rsp *http.Response) (*GetCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CategorySingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCategoryResponse parses an HTTP response from a UpdateCategoryWithResponse call
func ParseUpdateCategoryResponse(rsp *http.Response) (*UpdateCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CategorySingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttachmentByCategoryResponse parses an HTTP response from a ListAttachmentByCategoryWithResponse call
func ParseListAttachmentByCategoryResponse(rsp *http.Response) (*ListAttachmentByCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttachmentByCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachmentArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTransactionByCategoryResponse parses an HTTP response from a ListTransactionByCategoryWithResponse call
func ParseListTransactionByCategoryResponse(rsp *http.Response) (*ListTransactionByCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionByCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetChartAccountOverviewResponse parses an HTTP response from a GetChartAccountOverviewWithResponse call
func ParseGetChartAccountOverviewResponse(rsp *http.Response) (*GetChartAccountOverviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChartAccountOverviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChartLine
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetConfigurationResponse parses an HTTP response from a GetConfigurationWithResponse call
func ParseGetConfigurationResponse(rsp *http.Response) (*GetConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigurationArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/x-www-form-urlencoded) unsupported

	}

	return response, nil
}

// ParseGetSingleConfigurationResponse parses an HTTP response from a GetSingleConfigurationWithResponse call
func ParseGetSingleConfigurationResponse(rsp *http.Response) (*GetSingleConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSingleConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigurationSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetConfigurationResponse parses an HTTP response from a SetConfigurationWithResponse call
func ParseSetConfigurationResponse(rsp *http.Response) (*SetConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigurationSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCronResponse parses an HTTP response from a GetCronWithResponse call
func ParseGetCronResponse(rsp *http.Response) (*GetCronResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCronResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CronResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCurrencyResponse parses an HTTP response from a ListCurrencyWithResponse call
func ParseListCurrencyResponse(rsp *http.Response) (*ListCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CurrencyArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreCurrencyResponse parses an HTTP response from a StoreCurrencyWithResponse call
func ParseStoreCurrencyResponse(rsp *http.Response) (*StoreCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CurrencySingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDefaultCurrencyResponse parses an HTTP response from a GetDefaultCurrencyWithResponse call
func ParseGetDefaultCurrencyResponse(rsp *http.Response) (*GetDefaultCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CurrencySingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCurrencyResponse parses an HTTP response from a DeleteCurrencyWithResponse call
func ParseDeleteCurrencyResponse(rsp *http.Response) (*DeleteCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrencyResponse parses an HTTP response from a GetCurrencyWithResponse call
func ParseGetCurrencyResponse(rsp *http.Response) (*GetCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CurrencySingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCurrencyResponse parses an HTTP response from a UpdateCurrencyWithResponse call
func ParseUpdateCurrencyResponse(rsp *http.Response) (*UpdateCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CurrencySingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAccountByCurrencyResponse parses an HTTP response from a ListAccountByCurrencyWithResponse call
func ParseListAccountByCurrencyResponse(rsp *http.Response) (*ListAccountByCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountByCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAvailableBudgetByCurrencyResponse parses an HTTP response from a ListAvailableBudgetByCurrencyWithResponse call
func ParseListAvailableBudgetByCurrencyResponse(rsp *http.Response) (*ListAvailableBudgetByCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableBudgetByCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AvailableBudgetArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBillByCurrencyResponse parses an HTTP response from a ListBillByCurrencyWithResponse call
func ParseListBillByCurrencyResponse(rsp *http.Response) (*ListBillByCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBillByCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBudgetLimitByCurrencyResponse parses an HTTP response from a ListBudgetLimitByCurrencyWithResponse call
func ParseListBudgetLimitByCurrencyResponse(rsp *http.Response) (*ListBudgetLimitByCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBudgetLimitByCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetLimitArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDefaultCurrencyResponse parses an HTTP response from a DefaultCurrencyWithResponse call
func ParseDefaultCurrencyResponse(rsp *http.Response) (*DefaultCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DefaultCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest CurrencySingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDisableCurrencyResponse parses an HTTP response from a DisableCurrencyWithResponse call
func ParseDisableCurrencyResponse(rsp *http.Response) (*DisableCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest CurrencySingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEnableCurrencyResponse parses an HTTP response from a EnableCurrencyWithResponse call
func ParseEnableCurrencyResponse(rsp *http.Response) (*EnableCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest CurrencySingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRecurrenceByCurrencyResponse parses an HTTP response from a ListRecurrenceByCurrencyWithResponse call
func ParseListRecurrenceByCurrencyResponse(rsp *http.Response) (*ListRecurrenceByCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRecurrenceByCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecurrenceArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRuleByCurrencyResponse parses an HTTP response from a ListRuleByCurrencyWithResponse call
func ParseListRuleByCurrencyResponse(rsp *http.Response) (*ListRuleByCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRuleByCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTransactionByCurrencyResponse parses an HTTP response from a ListTransactionByCurrencyWithResponse call
func ParseListTransactionByCurrencyResponse(rsp *http.Response) (*ListTransactionByCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionByCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBulkUpdateTransactionsResponse parses an HTTP response from a BulkUpdateTransactionsWithResponse call
func ParseBulkUpdateTransactionsResponse(rsp *http.Response) (*BulkUpdateTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDestroyDataResponse parses an HTTP response from a DestroyDataWithResponse call
func ParseDestroyDataResponse(rsp *http.Response) (*DestroyDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DestroyDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportAccountsResponse parses an HTTP response from a ExportAccountsWithResponse call
func ParseExportAccountsResponse(rsp *http.Response) (*ExportAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportBillsResponse parses an HTTP response from a ExportBillsWithResponse call
func ParseExportBillsResponse(rsp *http.Response) (*ExportBillsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportBillsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportBudgetsResponse parses an HTTP response from a ExportBudgetsWithResponse call
func ParseExportBudgetsResponse(rsp *http.Response) (*ExportBudgetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportBudgetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportCategoriesResponse parses an HTTP response from a ExportCategoriesWithResponse call
func ParseExportCategoriesResponse(rsp *http.Response) (*ExportCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportPiggiesResponse parses an HTTP response from a ExportPiggiesWithResponse call
func ParseExportPiggiesResponse(rsp *http.Response) (*ExportPiggiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportPiggiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportRecurringResponse parses an HTTP response from a ExportRecurringWithResponse call
func ParseExportRecurringResponse(rsp *http.Response) (*ExportRecurringResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportRecurringResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportRulesResponse parses an HTTP response from a ExportRulesWithResponse call
func ParseExportRulesResponse(rsp *http.Response) (*ExportRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportTagsResponse parses an HTTP response from a ExportTagsWithResponse call
func ParseExportTagsResponse(rsp *http.Response) (*ExportTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportTransactionsResponse parses an HTTP response from a ExportTransactionsWithResponse call
func ParseExportTransactionsResponse(rsp *http.Response) (*ExportTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePurgeDataResponse parses an HTTP response from a PurgeDataWithResponse call
func ParsePurgeDataResponse(rsp *http.Response) (*PurgeDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PurgeDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightExpenseAssetResponse parses an HTTP response from a InsightExpenseAssetWithResponse call
func ParseInsightExpenseAssetResponse(rsp *http.Response) (*InsightExpenseAssetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightExpenseAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightExpenseBillResponse parses an HTTP response from a InsightExpenseBillWithResponse call
func ParseInsightExpenseBillResponse(rsp *http.Response) (*InsightExpenseBillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightExpenseBillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightExpenseBudgetResponse parses an HTTP response from a InsightExpenseBudgetWithResponse call
func ParseInsightExpenseBudgetResponse(rsp *http.Response) (*InsightExpenseBudgetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightExpenseBudgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightExpenseCategoryResponse parses an HTTP response from a InsightExpenseCategoryWithResponse call
func ParseInsightExpenseCategoryResponse(rsp *http.Response) (*InsightExpenseCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightExpenseCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightExpenseExpenseResponse parses an HTTP response from a InsightExpenseExpenseWithResponse call
func ParseInsightExpenseExpenseResponse(rsp *http.Response) (*InsightExpenseExpenseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightExpenseExpenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightExpenseNoBillResponse parses an HTTP response from a InsightExpenseNoBillWithResponse call
func ParseInsightExpenseNoBillResponse(rsp *http.Response) (*InsightExpenseNoBillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightExpenseNoBillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightTotal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightExpenseNoBudgetResponse parses an HTTP response from a InsightExpenseNoBudgetWithResponse call
func ParseInsightExpenseNoBudgetResponse(rsp *http.Response) (*InsightExpenseNoBudgetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightExpenseNoBudgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightTotal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightExpenseNoCategoryResponse parses an HTTP response from a InsightExpenseNoCategoryWithResponse call
func ParseInsightExpenseNoCategoryResponse(rsp *http.Response) (*InsightExpenseNoCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightExpenseNoCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightTotal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightExpenseNoTagResponse parses an HTTP response from a InsightExpenseNoTagWithResponse call
func ParseInsightExpenseNoTagResponse(rsp *http.Response) (*InsightExpenseNoTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightExpenseNoTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightTotal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightExpenseTagResponse parses an HTTP response from a InsightExpenseTagWithResponse call
func ParseInsightExpenseTagResponse(rsp *http.Response) (*InsightExpenseTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightExpenseTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightExpenseTotalResponse parses an HTTP response from a InsightExpenseTotalWithResponse call
func ParseInsightExpenseTotalResponse(rsp *http.Response) (*InsightExpenseTotalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightExpenseTotalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightTotal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightIncomeAssetResponse parses an HTTP response from a InsightIncomeAssetWithResponse call
func ParseInsightIncomeAssetResponse(rsp *http.Response) (*InsightIncomeAssetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightIncomeAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightIncomeCategoryResponse parses an HTTP response from a InsightIncomeCategoryWithResponse call
func ParseInsightIncomeCategoryResponse(rsp *http.Response) (*InsightIncomeCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightIncomeCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightIncomeNoCategoryResponse parses an HTTP response from a InsightIncomeNoCategoryWithResponse call
func ParseInsightIncomeNoCategoryResponse(rsp *http.Response) (*InsightIncomeNoCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightIncomeNoCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightTotal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightIncomeNoTagResponse parses an HTTP response from a InsightIncomeNoTagWithResponse call
func ParseInsightIncomeNoTagResponse(rsp *http.Response) (*InsightIncomeNoTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightIncomeNoTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightTotal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightIncomeRevenueResponse parses an HTTP response from a InsightIncomeRevenueWithResponse call
func ParseInsightIncomeRevenueResponse(rsp *http.Response) (*InsightIncomeRevenueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightIncomeRevenueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightIncomeTagResponse parses an HTTP response from a InsightIncomeTagWithResponse call
func ParseInsightIncomeTagResponse(rsp *http.Response) (*InsightIncomeTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightIncomeTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightIncomeTotalResponse parses an HTTP response from a InsightIncomeTotalWithResponse call
func ParseInsightIncomeTotalResponse(rsp *http.Response) (*InsightIncomeTotalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightIncomeTotalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightTotal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightTransfersResponse parses an HTTP response from a InsightTransfersWithResponse call
func ParseInsightTransfersResponse(rsp *http.Response) (*InsightTransfersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightTransfersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightTransfer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightTransferCategoryResponse parses an HTTP response from a InsightTransferCategoryWithResponse call
func ParseInsightTransferCategoryResponse(rsp *http.Response) (*InsightTransferCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightTransferCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightTransferNoCategoryResponse parses an HTTP response from a InsightTransferNoCategoryWithResponse call
func ParseInsightTransferNoCategoryResponse(rsp *http.Response) (*InsightTransferNoCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightTransferNoCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightTotal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightTransferNoTagResponse parses an HTTP response from a InsightTransferNoTagWithResponse call
func ParseInsightTransferNoTagResponse(rsp *http.Response) (*InsightTransferNoTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightTransferNoTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightTotal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightTransferTagResponse parses an HTTP response from a InsightTransferTagWithResponse call
func ParseInsightTransferTagResponse(rsp *http.Response) (*InsightTransferTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightTransferTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInsightTransferTotalResponse parses an HTTP response from a InsightTransferTotalWithResponse call
func ParseInsightTransferTotalResponse(rsp *http.Response) (*InsightTransferTotalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InsightTransferTotalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightTotal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListLinkTypeResponse parses an HTTP response from a ListLinkTypeWithResponse call
func ParseListLinkTypeResponse(rsp *http.Response) (*ListLinkTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLinkTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkTypeArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreLinkTypeResponse parses an HTTP response from a StoreLinkTypeWithResponse call
func ParseStoreLinkTypeResponse(rsp *http.Response) (*StoreLinkTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreLinkTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkTypeSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLinkTypeResponse parses an HTTP response from a DeleteLinkTypeWithResponse call
func ParseDeleteLinkTypeResponse(rsp *http.Response) (*DeleteLinkTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLinkTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLinkTypeResponse parses an HTTP response from a GetLinkTypeWithResponse call
func ParseGetLinkTypeResponse(rsp *http.Response) (*GetLinkTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLinkTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkTypeSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateLinkTypeResponse parses an HTTP response from a UpdateLinkTypeWithResponse call
func ParseUpdateLinkTypeResponse(rsp *http.Response) (*UpdateLinkTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLinkTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkTypeSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTransactionByLinkTypeResponse parses an HTTP response from a ListTransactionByLinkTypeWithResponse call
func ParseListTransactionByLinkTypeResponse(rsp *http.Response) (*ListTransactionByLinkTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionByLinkTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListObjectGroupsResponse parses an HTTP response from a ListObjectGroupsWithResponse call
func ParseListObjectGroupsResponse(rsp *http.Response) (*ListObjectGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListObjectGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectGroupArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteObjectGroupResponse parses an HTTP response from a DeleteObjectGroupWithResponse call
func ParseDeleteObjectGroupResponse(rsp *http.Response) (*DeleteObjectGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteObjectGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetObjectGroupResponse parses an HTTP response from a GetObjectGroupWithResponse call
func ParseGetObjectGroupResponse(rsp *http.Response) (*GetObjectGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetObjectGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectGroupSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateObjectGroupResponse parses an HTTP response from a UpdateObjectGroupWithResponse call
func ParseUpdateObjectGroupResponse(rsp *http.Response) (*UpdateObjectGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateObjectGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectGroupSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBillByObjectGroupResponse parses an HTTP response from a ListBillByObjectGroupWithResponse call
func ParseListBillByObjectGroupResponse(rsp *http.Response) (*ListBillByObjectGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBillByObjectGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPiggyBankByObjectGroupResponse parses an HTTP response from a ListPiggyBankByObjectGroupWithResponse call
func ParseListPiggyBankByObjectGroupResponse(rsp *http.Response) (*ListPiggyBankByObjectGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPiggyBankByObjectGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PiggyBankArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPiggyBankResponse parses an HTTP response from a ListPiggyBankWithResponse call
func ParseListPiggyBankResponse(rsp *http.Response) (*ListPiggyBankResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPiggyBankResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PiggyBankArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStorePiggyBankResponse parses an HTTP response from a StorePiggyBankWithResponse call
func ParseStorePiggyBankResponse(rsp *http.Response) (*StorePiggyBankResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StorePiggyBankResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PiggyBankSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePiggyBankResponse parses an HTTP response from a DeletePiggyBankWithResponse call
func ParseDeletePiggyBankResponse(rsp *http.Response) (*DeletePiggyBankResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePiggyBankResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPiggyBankResponse parses an HTTP response from a GetPiggyBankWithResponse call
func ParseGetPiggyBankResponse(rsp *http.Response) (*GetPiggyBankResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPiggyBankResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PiggyBankSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdatePiggyBankResponse parses an HTTP response from a UpdatePiggyBankWithResponse call
func ParseUpdatePiggyBankResponse(rsp *http.Response) (*UpdatePiggyBankResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePiggyBankResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PiggyBankSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttachmentByPiggyBankResponse parses an HTTP response from a ListAttachmentByPiggyBankWithResponse call
func ParseListAttachmentByPiggyBankResponse(rsp *http.Response) (*ListAttachmentByPiggyBankResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttachmentByPiggyBankResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachmentArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEventByPiggyBankResponse parses an HTTP response from a ListEventByPiggyBankWithResponse call
func ParseListEventByPiggyBankResponse(rsp *http.Response) (*ListEventByPiggyBankResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventByPiggyBankResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PiggyBankEventArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPreferenceResponse parses an HTTP response from a ListPreferenceWithResponse call
func ParseListPreferenceResponse(rsp *http.Response) (*ListPreferenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPreferenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreferenceArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStorePreferenceResponse parses an HTTP response from a StorePreferenceWithResponse call
func ParseStorePreferenceResponse(rsp *http.Response) (*StorePreferenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StorePreferenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreferenceSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPreferenceResponse parses an HTTP response from a GetPreferenceWithResponse call
func ParseGetPreferenceResponse(rsp *http.Response) (*GetPreferenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPreferenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreferenceSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdatePreferenceResponse parses an HTTP response from a UpdatePreferenceWithResponse call
func ParseUpdatePreferenceResponse(rsp *http.Response) (*UpdatePreferenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePreferenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreferenceSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRecurrenceResponse parses an HTTP response from a ListRecurrenceWithResponse call
func ParseListRecurrenceResponse(rsp *http.Response) (*ListRecurrenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRecurrenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecurrenceArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreRecurrenceResponse parses an HTTP response from a StoreRecurrenceWithResponse call
func ParseStoreRecurrenceResponse(rsp *http.Response) (*StoreRecurrenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreRecurrenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecurrenceSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRecurrenceResponse parses an HTTP response from a DeleteRecurrenceWithResponse call
func ParseDeleteRecurrenceResponse(rsp *http.Response) (*DeleteRecurrenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRecurrenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRecurrenceResponse parses an HTTP response from a GetRecurrenceWithResponse call
func ParseGetRecurrenceResponse(rsp *http.Response) (*GetRecurrenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecurrenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecurrenceSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRecurrenceResponse parses an HTTP response from a UpdateRecurrenceWithResponse call
func ParseUpdateRecurrenceResponse(rsp *http.Response) (*UpdateRecurrenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRecurrenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecurrenceSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTransactionByRecurrenceResponse parses an HTTP response from a ListTransactionByRecurrenceWithResponse call
func ParseListTransactionByRecurrenceResponse(rsp *http.Response) (*ListTransactionByRecurrenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionByRecurrenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRuleGroupResponse parses an HTTP response from a ListRuleGroupWithResponse call
func ParseListRuleGroupResponse(rsp *http.Response) (*ListRuleGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRuleGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleGroupArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreRuleGroupResponse parses an HTTP response from a StoreRuleGroupWithResponse call
func ParseStoreRuleGroupResponse(rsp *http.Response) (*StoreRuleGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreRuleGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleGroupSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRuleGroupResponse parses an HTTP response from a DeleteRuleGroupWithResponse call
func ParseDeleteRuleGroupResponse(rsp *http.Response) (*DeleteRuleGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuleGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRuleGroupResponse parses an HTTP response from a GetRuleGroupWithResponse call
func ParseGetRuleGroupResponse(rsp *http.Response) (*GetRuleGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleGroupSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRuleGroupResponse parses an HTTP response from a UpdateRuleGroupWithResponse call
func ParseUpdateRuleGroupResponse(rsp *http.Response) (*UpdateRuleGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRuleGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleGroupSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRuleByGroupResponse parses an HTTP response from a ListRuleByGroupWithResponse call
func ParseListRuleByGroupResponse(rsp *http.Response) (*ListRuleByGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRuleByGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTestRuleGroupResponse parses an HTTP response from a TestRuleGroupWithResponse call
func ParseTestRuleGroupResponse(rsp *http.Response) (*TestRuleGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestRuleGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFireRuleGroupResponse parses an HTTP response from a FireRuleGroupWithResponse call
func ParseFireRuleGroupResponse(rsp *http.Response) (*FireRuleGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FireRuleGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRuleResponse parses an HTTP response from a ListRuleWithResponse call
func ParseListRuleResponse(rsp *http.Response) (*ListRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreRuleResponse parses an HTTP response from a StoreRuleWithResponse call
func ParseStoreRuleResponse(rsp *http.Response) (*StoreRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRuleResponse parses an HTTP response from a DeleteRuleWithResponse call
func ParseDeleteRuleResponse(rsp *http.Response) (*DeleteRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRuleResponse parses an HTTP response from a GetRuleWithResponse call
func ParseGetRuleResponse(rsp *http.Response) (*GetRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRuleResponse parses an HTTP response from a UpdateRuleWithResponse call
func ParseUpdateRuleResponse(rsp *http.Response) (*UpdateRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTestRuleResponse parses an HTTP response from a TestRuleWithResponse call
func ParseTestRuleResponse(rsp *http.Response) (*TestRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFireRuleResponse parses an HTTP response from a FireRuleWithResponse call
func ParseFireRuleResponse(rsp *http.Response) (*FireRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FireRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchAccountsResponse parses an HTTP response from a SearchAccountsWithResponse call
func ParseSearchAccountsResponse(rsp *http.Response) (*SearchAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchTransactionsResponse parses an HTTP response from a SearchTransactionsWithResponse call
func ParseSearchTransactionsResponse(rsp *http.Response) (*SearchTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBasicSummaryResponse parses an HTTP response from a GetBasicSummaryWithResponse call
func ParseGetBasicSummaryResponse(rsp *http.Response) (*GetBasicSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBasicSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BasicSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTagResponse parses an HTTP response from a ListTagWithResponse call
func ParseListTagResponse(rsp *http.Response) (*ListTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreTagResponse parses an HTTP response from a StoreTagWithResponse call
func ParseStoreTagResponse(rsp *http.Response) (*StoreTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTagResponse parses an HTTP response from a DeleteTagWithResponse call
func ParseDeleteTagResponse(rsp *http.Response) (*DeleteTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTagResponse parses an HTTP response from a GetTagWithResponse call
func ParseGetTagResponse(rsp *http.Response) (*GetTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateTagResponse parses an HTTP response from a UpdateTagWithResponse call
func ParseUpdateTagResponse(rsp *http.Response) (*UpdateTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttachmentByTagResponse parses an HTTP response from a ListAttachmentByTagWithResponse call
func ParseListAttachmentByTagResponse(rsp *http.Response) (*ListAttachmentByTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttachmentByTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachmentArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTransactionByTagResponse parses an HTTP response from a ListTransactionByTagWithResponse call
func ParseListTransactionByTagResponse(rsp *http.Response) (*ListTransactionByTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionByTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTransactionJournalResponse parses an HTTP response from a DeleteTransactionJournalWithResponse call
func ParseDeleteTransactionJournalResponse(rsp *http.Response) (*DeleteTransactionJournalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTransactionJournalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTransactionByJournalResponse parses an HTTP response from a GetTransactionByJournalWithResponse call
func ParseGetTransactionByJournalResponse(rsp *http.Response) (*GetTransactionByJournalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionByJournalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListLinksByJournalResponse parses an HTTP response from a ListLinksByJournalWithResponse call
func ParseListLinksByJournalResponse(rsp *http.Response) (*ListLinksByJournalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLinksByJournalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionLinkArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTransactionLinkResponse parses an HTTP response from a ListTransactionLinkWithResponse call
func ParseListTransactionLinkResponse(rsp *http.Response) (*ListTransactionLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionLinkArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreTransactionLinkResponse parses an HTTP response from a StoreTransactionLinkWithResponse call
func ParseStoreTransactionLinkResponse(rsp *http.Response) (*StoreTransactionLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreTransactionLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionLinkSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTransactionLinkResponse parses an HTTP response from a DeleteTransactionLinkWithResponse call
func ParseDeleteTransactionLinkResponse(rsp *http.Response) (*DeleteTransactionLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTransactionLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTransactionLinkResponse parses an HTTP response from a GetTransactionLinkWithResponse call
func ParseGetTransactionLinkResponse(rsp *http.Response) (*GetTransactionLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionLinkSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateTransactionLinkResponse parses an HTTP response from a UpdateTransactionLinkWithResponse call
func ParseUpdateTransactionLinkResponse(rsp *http.Response) (*UpdateTransactionLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTransactionLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionLinkSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTransactionResponse parses an HTTP response from a ListTransactionWithResponse call
func ParseListTransactionResponse(rsp *http.Response) (*ListTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreTransactionResponse parses an HTTP response from a StoreTransactionWithResponse call
func ParseStoreTransactionResponse(rsp *http.Response) (*StoreTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTransactionResponse parses an HTTP response from a DeleteTransactionWithResponse call
func ParseDeleteTransactionResponse(rsp *http.Response) (*DeleteTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTransactionResponse parses an HTTP response from a GetTransactionWithResponse call
func ParseGetTransactionResponse(rsp *http.Response) (*GetTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateTransactionResponse parses an HTTP response from a UpdateTransactionWithResponse call
func ParseUpdateTransactionResponse(rsp *http.Response) (*UpdateTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttachmentByTransactionResponse parses an HTTP response from a ListAttachmentByTransactionWithResponse call
func ParseListAttachmentByTransactionResponse(rsp *http.Response) (*ListAttachmentByTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttachmentByTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttachmentArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEventByTransactionResponse parses an HTTP response from a ListEventByTransactionWithResponse call
func ParseListEventByTransactionResponse(rsp *http.Response) (*ListEventByTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventByTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PiggyBankEventArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUserResponse parses an HTTP response from a ListUserWithResponse call
func ParseListUserResponse(rsp *http.Response) (*ListUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreUserResponse parses an HTTP response from a StoreUserWithResponse call
func ParseStoreUserResponse(rsp *http.Response) (*StoreUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListWebhookResponse parses an HTTP response from a ListWebhookWithResponse call
func ParseListWebhookResponse(rsp *http.Response) (*ListWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStoreWebhookResponse parses an HTTP response from a StoreWebhookWithResponse call
func ParseStoreWebhookResponse(rsp *http.Response) (*StoreWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookResponse parses an HTTP response from a DeleteWebhookWithResponse call
func ParseDeleteWebhookResponse(rsp *http.Response) (*DeleteWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWebhookResponse parses an HTTP response from a GetWebhookWithResponse call
func ParseGetWebhookResponse(rsp *http.Response) (*GetWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateWebhookResponse parses an HTTP response from a UpdateWebhookWithResponse call
func ParseUpdateWebhookResponse(rsp *http.Response) (*UpdateWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWebhookMessagesResponse parses an HTTP response from a GetWebhookMessagesWithResponse call
func ParseGetWebhookMessagesResponse(rsp *http.Response) (*GetWebhookMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookMessageArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookMessageResponse parses an HTTP response from a DeleteWebhookMessageWithResponse call
func ParseDeleteWebhookMessageResponse(rsp *http.Response) (*DeleteWebhookMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSingleWebhookMessageResponse parses an HTTP response from a GetSingleWebhookMessageWithResponse call
func ParseGetSingleWebhookMessageResponse(rsp *http.Response) (*GetSingleWebhookMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSingleWebhookMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookMessageSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWebhookMessageAttemptsResponse parses an HTTP response from a GetWebhookMessageAttemptsWithResponse call
func ParseGetWebhookMessageAttemptsResponse(rsp *http.Response) (*GetWebhookMessageAttemptsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookMessageAttemptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookAttemptArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookMessageAttemptResponse parses an HTTP response from a DeleteWebhookMessageAttemptWithResponse call
func ParseDeleteWebhookMessageAttemptResponse(rsp *http.Response) (*DeleteWebhookMessageAttemptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookMessageAttemptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSingleWebhookMessageAttemptResponse parses an HTTP response from a GetSingleWebhookMessageAttemptWithResponse call
func ParseGetSingleWebhookMessageAttemptResponse(rsp *http.Response) (*GetSingleWebhookMessageAttemptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSingleWebhookMessageAttemptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookAttemptSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthenticatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSubmitWebookResponse parses an HTTP response from a SubmitWebookWithResponse call
func ParseSubmitWebookResponse(rsp *http.Response) (*SubmitWebookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitWebookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTriggerTransactionWebhookResponse parses an HTTP response from a TriggerTransactionWebhookWithResponse call
func ParseTriggerTransactionWebhookResponse(rsp *http.Response) (*TriggerTransactionWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerTransactionWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
